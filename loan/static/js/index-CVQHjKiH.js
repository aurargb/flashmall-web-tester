const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["static/js/index-JfpGQrRU.js","static/js/RightPop.vue_vue_type_script_setup_true_lang-B1_7GVJX.js","static/js/index-Culc1QRb.js","static/css/RightPop-BwPNwCWm.css","static/css/index-CojbDFo-.css","static/js/erc20Contract-DFn00mXD.js","static/js/ApproveButton-Dic8X4Em.js","static/js/BackIcon-CdrC5To7.js","static/css/BackIcon-DBGACz16.css","static/css/index-_tswxGmM.css","static/js/index-BjalBOO6.js","static/js/MarketItem.vue_vue_type_script_setup_true_lang-CL575LZk.js","static/js/LoanMethodLabel.vue_vue_type_script_setup_true_lang-CaY1KaEz.js","static/js/useType-GHSO8guk.js","static/js/index.es-CLwpJEin.js","static/js/useLpData-C285s8xY.js","static/css/MarketItem-BRjwdrW9.css","static/js/index-Bbv1NXtA.js","static/css/index-BzrbYvYM.css","static/js/Empty.vue_vue_type_script_setup_true_lang-DHv6J42C.js","static/js/loan-DUx-0XpN.js","static/js/exchangeContract-CB3fZuma.js","static/css/index-DZtpxBR8.css","static/js/Detail-yNnxICEm.js","static/js/useLoan-BhqL0FVa.js","static/css/Detail-Dn0bSsH1.css","static/js/InvestmentRecord-Dogme5S8.js","static/js/RepaymentPlan.vue_vue_type_script_setup_true_lang-7R7pyOPb.js","static/js/index-CTBrWdf5.js","static/css/InvestmentRecord-BWTtaoIa.css","static/js/myPost-QSK2-HAv.js","static/css/myPost-urqXiraP.css","static/js/Index-9zVh3Eif.js","static/js/ReleaseLoan-O0z1Iw4B.js","static/js/NumberKeyBoardInput-BHPjsVku.js","static/css/NumberKeyBoardInput-GxsAHlj0.css","static/js/index-DzuQWI3K.js","static/css/index-CTWnX5A-.css","static/css/ReleaseLoan-DxxHhZ75.css","static/js/HistoryMatchmaking-DfmkIpX1.js","static/css/HistoryMatchmaking-BD8utuLh.css","static/js/index-BVoPSHCi.js","static/js/RepayItem.vue_vue_type_script_setup_true_lang-C23b9J81.js","static/css/index-CRddJXdw.css","static/js/earlyRepayment-fpOFMOlh.js","static/js/earlyDetail-clVF-J7k.js","static/js/LoanRecord-BdUs1nus.js","static/css/LoanRecord-BbL3oiI6.css","static/js/index-CKXk_4P5.js","static/css/index-7ZUFUMqE.css","static/js/index-B16lP2ce.js","static/css/index-DWu_lZFh.css"])))=>i.map(i=>d[i]);
var __defProp = Object.defineProperty;
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);
var __privateWrapper = (obj, member, setter, getter) => ({
  set _(value) {
    __privateSet(obj, member, value, setter);
  },
  get _() {
    return __privateGet(obj, member, getter);
  }
});
let ix, XW, o6, op, jW, y1, jn, JW, qW, m1, Co, lP, s6, ZW, oI, To, pn, cs, MW, Tr, Qs, NW, Xr, EC, xC, Ms, bo, tb, $i, c6, HW, yn, wC, FI, BW, Fn, D1, OW, Fd, RW, GW, CW, UW, TW, QW, wW, Yt, Kq, _y, qq, ah, L3, NC, Nd, EW, WW, jq, Sq, t5, vq, C1, KW, Jq, YK, qn, I1, a6, BC, ZC, PW, n3, FC, LW, Zv, U3, U1, HI, SW, yl, YI, Kc, rb, Wq, Eq, Hc, TI, zi, kW, Bc, VC, IW, vW, DW, Bd, Kb, _W, W1, F1, _d, q3, FW, OC, d3, HG, HS, Gn, Te, ar, Qr, ts, fi, n9, $W, xn, Hi, AW, Si, cS, it, Ze, xo, Tu, ks, YW, jc, zW, FN, k1;
let __tla = (async () => {
  var _e2, _e3, _t, _e4, _t2, _n2, _r2, _i2, _o2, _s2, _a2, _f2, _l2, _p2, _g2, _c2, _u2, _d2, _Ls_instances, h_fn, _e5, _t3, _n3, _r3, _i3, _o3, _e6, _t4, _n4, _oa_instances, r_fn, i_fn, o_fn, s_fn, a_fn, f_fn, _a3, _e7, _e8, _t5, _fm_instances, n_fn, _b2, _e9, _t6, _n5, _r4, _i4, _TE_instances, o_fn2, s_fn2, _c3, _e10, _t7, _n6, _r5, _d3, _e11, _e12, _e13, _e14, _t8, _n7, _r6, _i5, _o4, _s3, _a4, _f3, _l3, _p3, _g3, _c4, _u3, _d4, _h2, _y2, _li_instances, m_fn, _e15, _t9, _n8, _ii_instances, r_fn2, _f4, _e16, _t10, _qr_instances, n_fn2, _si_instances, e_fn, _g4, _Tm_instances, e_fn2, _h3, _e17, _t11, _n9, _r7, _gc_instances, i_fn2, o_fn3, _i6, _e18, _e19, _e20, _e21, _e22, _e23, _j2, _k2, _e24, _t12, _Uc_instances, n_fn3, _Uc_static, r_fn3, _e25, _t13, _e26, _t14, _n10, _e27, _t15, _n11, _r8, _rF_instances, i_fn3, _e28, _t16, _n12, _e29, _t17, _e30, _e31, _e32, _t18, _n13, _r9, _i7, _my_instances, o_fn4, _e33, _t19, _n14, _r10, _i8, _o5, _s4, _a5, _f5, _l4, _p4, _g5, _fF_instances, c_fn, u_fn, d_fn, h_fn2, y_fn, m_fn2, b_fn, _e34, _t20, _n15, _r11, _i9, _o6, _$4_instances, s_fn3, a_fn2, _e35, _e36, _t21, _n16, _r12, _i10, _o7, _s5, _EF_instances, a_fn3, _e37, _e38, _t22;
  (function() {
    const e = document.createElement("link").relList;
    if (e && e.supports && e.supports("modulepreload")) return;
    for (const i of document.querySelectorAll('link[rel="modulepreload"]')) r(i);
    new MutationObserver((i) => {
      for (const s of i) if (s.type === "childList") for (const o of s.addedNodes) o.tagName === "LINK" && o.rel === "modulepreload" && r(o);
    }).observe(document, {
      childList: true,
      subtree: true
    });
    function n(i) {
      const s = {};
      return i.integrity && (s.integrity = i.integrity), i.referrerPolicy && (s.referrerPolicy = i.referrerPolicy), i.crossOrigin === "use-credentials" ? s.credentials = "include" : i.crossOrigin === "anonymous" ? s.credentials = "omit" : s.credentials = "same-origin", s;
    }
    function r(i) {
      if (i.ep) return;
      i.ep = true;
      const s = n(i);
      fetch(i.href, s);
    }
  })();
  function d1(t) {
    const e = /* @__PURE__ */ Object.create(null);
    for (const n of t.split(",")) e[n] = 1;
    return (n) => n in e;
  }
  const bt = {}, _c = [], Ki = () => {
  }, s9 = () => false, vd = (t) => t.charCodeAt(0) === 111 && t.charCodeAt(1) === 110 && (t.charCodeAt(2) > 122 || t.charCodeAt(2) < 97), h1 = (t) => t.startsWith("onUpdate:"), Nn = Object.assign, p1 = (t, e) => {
    const n = t.indexOf(e);
    n > -1 && t.splice(n, 1);
  }, o9 = Object.prototype.hasOwnProperty, dt = (t, e) => o9.call(t, e), Be = Array.isArray, Rc = (t) => tf(t) === "[object Map]", Av = (t) => tf(t) === "[object Set]", a9 = (t) => tf(t) === "[object RegExp]", Ge = (t) => typeof t == "function", jt = (t) => typeof t == "string", Vs = (t) => typeof t == "symbol", zt = (t) => t !== null && typeof t == "object", wv = (t) => (zt(t) || Ge(t)) && Ge(t.then) && Ge(t.catch), vv = Object.prototype.toString, tf = (t) => vv.call(t), c9 = (t) => tf(t).slice(8, -1), Ev = (t) => tf(t) === "[object Object]", g1 = (t) => jt(t) && t !== "NaN" && t[0] !== "-" && "" + parseInt(t, 10) === t, ru = d1(",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"), Ed = (t) => {
    const e = /* @__PURE__ */ Object.create(null);
    return (n) => e[n] || (e[n] = t(n));
  }, l9 = /-(\w)/g, Wr = Ed((t) => t.replace(l9, (e, n) => n ? n.toUpperCase() : "")), u9 = /\B([A-Z])/g, Da = Ed((t) => t.replace(u9, "-$1").toLowerCase()), Sd = Ed((t) => t.charAt(0).toUpperCase() + t.slice(1)), Yh = Ed((t) => t ? `on${Sd(t)}` : ""), Eo = (t, e) => !Object.is(t, e), Nc = (t, ...e) => {
    for (let n = 0; n < t.length; n++) t[n](...e);
  }, Bg = (t, e, n, r = false) => {
    Object.defineProperty(t, e, {
      configurable: true,
      enumerable: false,
      writable: r,
      value: n
    });
  }, Mg = (t) => {
    const e = parseFloat(t);
    return isNaN(e) ? t : e;
  }, f9 = (t) => {
    const e = jt(t) ? Number(t) : NaN;
    return isNaN(e) ? t : e;
  };
  let ib;
  const Td = () => ib || (ib = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : typeof global < "u" ? global : {});
  m1 = function(t) {
    if (Be(t)) {
      const e = {};
      for (let n = 0; n < t.length; n++) {
        const r = t[n], i = jt(r) ? g9(r) : m1(r);
        if (i) for (const s in i) e[s] = i[s];
      }
      return e;
    } else if (jt(t) || zt(t)) return t;
  };
  const d9 = /;(?![^(]*\))/g, h9 = /:([^]+)/, p9 = /\/\*[^]*?\*\//g;
  function g9(t) {
    const e = {};
    return t.replace(p9, "").split(d9).forEach((n) => {
      if (n) {
        const r = n.split(h9);
        r.length > 1 && (e[r[0].trim()] = r[1].trim());
      }
    }), e;
  }
  y1 = function(t) {
    let e = "";
    if (jt(t)) e = t;
    else if (Be(t)) for (let n = 0; n < t.length; n++) {
      const r = y1(t[n]);
      r && (e += r + " ");
    }
    else if (zt(t)) for (const n in t) t[n] && (e += n + " ");
    return e.trim();
  };
  const m9 = "itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly", y9 = d1(m9);
  function Sv(t) {
    return !!t || t === "";
  }
  let Tv, Cv, Xh;
  Tv = (t) => !!(t && t.__v_isRef === true);
  Tu = (t) => jt(t) ? t : t == null ? "" : Be(t) || zt(t) && (t.toString === vv || !Ge(t.toString)) ? Tv(t) ? Tu(t.value) : JSON.stringify(t, Cv, 2) : String(t);
  Cv = (t, e) => Tv(e) ? Cv(t, e.value) : Rc(e) ? {
    [`Map(${e.size})`]: [
      ...e.entries()
    ].reduce((n, [r, i], s) => (n[Xh(r, s) + " =>"] = i, n), {})
  } : Av(e) ? {
    [`Set(${e.size})`]: [
      ...e.values()
    ].map((n) => Xh(n))
  } : Vs(e) ? Xh(e) : zt(e) && !Be(e) && !Ev(e) ? String(e) : e;
  Xh = (t, e = "") => {
    var n;
    return Vs(t) ? `Symbol(${(n = t.description) != null ? n : e})` : t;
  };
  let zn;
  class Iv {
    constructor(e = false) {
      this.detached = e, this._active = true, this._on = 0, this.effects = [], this.cleanups = [], this._isPaused = false, this.parent = zn, !e && zn && (this.index = (zn.scopes || (zn.scopes = [])).push(this) - 1);
    }
    get active() {
      return this._active;
    }
    pause() {
      if (this._active) {
        this._isPaused = true;
        let e, n;
        if (this.scopes) for (e = 0, n = this.scopes.length; e < n; e++) this.scopes[e].pause();
        for (e = 0, n = this.effects.length; e < n; e++) this.effects[e].pause();
      }
    }
    resume() {
      if (this._active && this._isPaused) {
        this._isPaused = false;
        let e, n;
        if (this.scopes) for (e = 0, n = this.scopes.length; e < n; e++) this.scopes[e].resume();
        for (e = 0, n = this.effects.length; e < n; e++) this.effects[e].resume();
      }
    }
    run(e) {
      if (this._active) {
        const n = zn;
        try {
          return zn = this, e();
        } finally {
          zn = n;
        }
      }
    }
    on() {
      ++this._on === 1 && (this.prevScope = zn, zn = this);
    }
    off() {
      this._on > 0 && --this._on === 0 && (zn = this.prevScope, this.prevScope = void 0);
    }
    stop(e) {
      if (this._active) {
        this._active = false;
        let n, r;
        for (n = 0, r = this.effects.length; n < r; n++) this.effects[n].stop();
        for (this.effects.length = 0, n = 0, r = this.cleanups.length; n < r; n++) this.cleanups[n]();
        if (this.cleanups.length = 0, this.scopes) {
          for (n = 0, r = this.scopes.length; n < r; n++) this.scopes[n].stop(true);
          this.scopes.length = 0;
        }
        if (!this.detached && this.parent && !e) {
          const i = this.parent.scopes.pop();
          i && i !== this && (this.parent.scopes[this.index] = i, i.index = this.index);
        }
        this.parent = void 0;
      }
    }
  }
  function b1(t) {
    return new Iv(t);
  }
  function Pv() {
    return zn;
  }
  function b9(t, e = false) {
    zn && zn.cleanups.push(t);
  }
  let At;
  const Zh = /* @__PURE__ */ new WeakSet();
  class _v {
    constructor(e) {
      this.fn = e, this.deps = void 0, this.depsTail = void 0, this.flags = 5, this.next = void 0, this.cleanup = void 0, this.scheduler = void 0, zn && zn.active && zn.effects.push(this);
    }
    pause() {
      this.flags |= 64;
    }
    resume() {
      this.flags & 64 && (this.flags &= -65, Zh.has(this) && (Zh.delete(this), this.trigger()));
    }
    notify() {
      this.flags & 2 && !(this.flags & 32) || this.flags & 8 || Nv(this);
    }
    run() {
      if (!(this.flags & 1)) return this.fn();
      this.flags |= 2, sb(this), Ov(this);
      const e = At, n = Ai;
      At = this, Ai = true;
      try {
        return this.fn();
      } finally {
        Bv(this), At = e, Ai = n, this.flags &= -3;
      }
    }
    stop() {
      if (this.flags & 1) {
        for (let e = this.deps; e; e = e.nextDep) w1(e);
        this.deps = this.depsTail = void 0, sb(this), this.onStop && this.onStop(), this.flags &= -2;
      }
    }
    trigger() {
      this.flags & 64 ? Zh.add(this) : this.scheduler ? this.scheduler() : this.runIfDirty();
    }
    runIfDirty() {
      kg(this) && this.run();
    }
    get dirty() {
      return kg(this);
    }
  }
  let Rv = 0, iu, su;
  function Nv(t, e = false) {
    if (t.flags |= 8, e) {
      t.next = su, su = t;
      return;
    }
    t.next = iu, iu = t;
  }
  function x1() {
    Rv++;
  }
  function A1() {
    if (--Rv > 0) return;
    if (su) {
      let e = su;
      for (su = void 0; e; ) {
        const n = e.next;
        e.next = void 0, e.flags &= -9, e = n;
      }
    }
    let t;
    for (; iu; ) {
      let e = iu;
      for (iu = void 0; e; ) {
        const n = e.next;
        if (e.next = void 0, e.flags &= -9, e.flags & 1) try {
          e.trigger();
        } catch (r) {
          t || (t = r);
        }
        e = n;
      }
    }
    if (t) throw t;
  }
  function Ov(t) {
    for (let e = t.deps; e; e = e.nextDep) e.version = -1, e.prevActiveLink = e.dep.activeLink, e.dep.activeLink = e;
  }
  function Bv(t) {
    let e, n = t.depsTail, r = n;
    for (; r; ) {
      const i = r.prevDep;
      r.version === -1 ? (r === n && (n = i), w1(r), x9(r)) : e = r, r.dep.activeLink = r.prevActiveLink, r.prevActiveLink = void 0, r = i;
    }
    t.deps = e, t.depsTail = n;
  }
  function kg(t) {
    for (let e = t.deps; e; e = e.nextDep) if (e.dep.version !== e.version || e.dep.computed && (Mv(e.dep.computed) || e.dep.version !== e.version)) return true;
    return !!t._dirty;
  }
  function Mv(t) {
    if (t.flags & 4 && !(t.flags & 16) || (t.flags &= -17, t.globalVersion === Cu) || (t.globalVersion = Cu, !t.isSSR && t.flags & 128 && (!t.deps && !t._dirty || !kg(t)))) return;
    t.flags |= 2;
    const e = t.dep, n = At, r = Ai;
    At = t, Ai = true;
    try {
      Ov(t);
      const i = t.fn(t._value);
      (e.version === 0 || Eo(i, t._value)) && (t.flags |= 128, t._value = i, e.version++);
    } catch (i) {
      throw e.version++, i;
    } finally {
      At = n, Ai = r, Bv(t), t.flags &= -3;
    }
  }
  function w1(t, e = false) {
    const { dep: n, prevSub: r, nextSub: i } = t;
    if (r && (r.nextSub = i, t.prevSub = void 0), i && (i.prevSub = r, t.nextSub = void 0), n.subs === t && (n.subs = r, !r && n.computed)) {
      n.computed.flags &= -5;
      for (let s = n.computed.deps; s; s = s.nextDep) w1(s, true);
    }
    !e && !--n.sc && n.map && n.map.delete(n.key);
  }
  function x9(t) {
    const { prevDep: e, nextDep: n } = t;
    e && (e.nextDep = n, t.prevDep = void 0), n && (n.prevDep = e, t.nextDep = void 0);
  }
  let Ai = true;
  const kv = [];
  function Ns() {
    kv.push(Ai), Ai = false;
  }
  function Os() {
    const t = kv.pop();
    Ai = t === void 0 ? true : t;
  }
  function sb(t) {
    const { cleanup: e } = t;
    if (t.cleanup = void 0, e) {
      const n = At;
      At = void 0;
      try {
        e();
      } finally {
        At = n;
      }
    }
  }
  let Cu = 0;
  class A9 {
    constructor(e, n) {
      this.sub = e, this.dep = n, this.version = n.version, this.nextDep = this.prevDep = this.nextSub = this.prevSub = this.prevActiveLink = void 0;
    }
  }
  class v1 {
    constructor(e) {
      this.computed = e, this.version = 0, this.activeLink = void 0, this.subs = void 0, this.map = void 0, this.key = void 0, this.sc = 0, this.__v_skip = true;
    }
    track(e) {
      if (!At || !Ai || At === this.computed) return;
      let n = this.activeLink;
      if (n === void 0 || n.sub !== At) n = this.activeLink = new A9(At, this), At.deps ? (n.prevDep = At.depsTail, At.depsTail.nextDep = n, At.depsTail = n) : At.deps = At.depsTail = n, Fv(n);
      else if (n.version === -1 && (n.version = this.version, n.nextDep)) {
        const r = n.nextDep;
        r.prevDep = n.prevDep, n.prevDep && (n.prevDep.nextDep = r), n.prevDep = At.depsTail, n.nextDep = void 0, At.depsTail.nextDep = n, At.depsTail = n, At.deps === n && (At.deps = r);
      }
      return n;
    }
    trigger(e) {
      this.version++, Cu++, this.notify(e);
    }
    notify(e) {
      x1();
      try {
        for (let n = this.subs; n; n = n.prevSub) n.sub.notify() && n.sub.dep.notify();
      } finally {
        A1();
      }
    }
  }
  function Fv(t) {
    if (t.dep.sc++, t.sub.flags & 4) {
      const e = t.dep.computed;
      if (e && !t.dep.subs) {
        e.flags |= 20;
        for (let r = e.deps; r; r = r.nextDep) Fv(r);
      }
      const n = t.dep.subs;
      n !== t && (t.prevSub = n, n && (n.nextSub = t)), t.dep.subs = t;
    }
  }
  const B0 = /* @__PURE__ */ new WeakMap(), ba = Symbol(""), Fg = Symbol(""), Iu = Symbol("");
  function Qn(t, e, n) {
    if (Ai && At) {
      let r = B0.get(t);
      r || B0.set(t, r = /* @__PURE__ */ new Map());
      let i = r.get(n);
      i || (r.set(n, i = new v1()), i.map = r, i.key = n), i.track();
    }
  }
  function Ss(t, e, n, r, i, s) {
    const o = B0.get(t);
    if (!o) {
      Cu++;
      return;
    }
    const a = (c) => {
      c && c.trigger();
    };
    if (x1(), e === "clear") o.forEach(a);
    else {
      const c = Be(t), l = c && g1(n);
      if (c && n === "length") {
        const u = Number(r);
        o.forEach((f, d) => {
          (d === "length" || d === Iu || !Vs(d) && d >= u) && a(f);
        });
      } else switch ((n !== void 0 || o.has(void 0)) && a(o.get(n)), l && a(o.get(Iu)), e) {
        case "add":
          c ? l && a(o.get("length")) : (a(o.get(ba)), Rc(t) && a(o.get(Fg)));
          break;
        case "delete":
          c || (a(o.get(ba)), Rc(t) && a(o.get(Fg)));
          break;
        case "set":
          Rc(t) && a(o.get(ba));
          break;
      }
    }
    A1();
  }
  function w9(t, e) {
    const n = B0.get(t);
    return n && n.get(e);
  }
  function Ka(t) {
    const e = at(t);
    return e === t ? e : (Qn(e, "iterate", Iu), jr(t) ? e : e.map(kn));
  }
  function Cd(t) {
    return Qn(t = at(t), "iterate", Iu), t;
  }
  const v9 = {
    __proto__: null,
    [Symbol.iterator]() {
      return $h(this, Symbol.iterator, kn);
    },
    concat(...t) {
      return Ka(this).concat(...t.map((e) => Be(e) ? Ka(e) : e));
    },
    entries() {
      return $h(this, "entries", (t) => (t[1] = kn(t[1]), t));
    },
    every(t, e) {
      return us(this, "every", t, e, void 0, arguments);
    },
    filter(t, e) {
      return us(this, "filter", t, e, (n) => n.map(kn), arguments);
    },
    find(t, e) {
      return us(this, "find", t, e, kn, arguments);
    },
    findIndex(t, e) {
      return us(this, "findIndex", t, e, void 0, arguments);
    },
    findLast(t, e) {
      return us(this, "findLast", t, e, kn, arguments);
    },
    findLastIndex(t, e) {
      return us(this, "findLastIndex", t, e, void 0, arguments);
    },
    forEach(t, e) {
      return us(this, "forEach", t, e, void 0, arguments);
    },
    includes(...t) {
      return ep(this, "includes", t);
    },
    indexOf(...t) {
      return ep(this, "indexOf", t);
    },
    join(t) {
      return Ka(this).join(t);
    },
    lastIndexOf(...t) {
      return ep(this, "lastIndexOf", t);
    },
    map(t, e) {
      return us(this, "map", t, e, void 0, arguments);
    },
    pop() {
      return Bl(this, "pop");
    },
    push(...t) {
      return Bl(this, "push", t);
    },
    reduce(t, ...e) {
      return ob(this, "reduce", t, e);
    },
    reduceRight(t, ...e) {
      return ob(this, "reduceRight", t, e);
    },
    shift() {
      return Bl(this, "shift");
    },
    some(t, e) {
      return us(this, "some", t, e, void 0, arguments);
    },
    splice(...t) {
      return Bl(this, "splice", t);
    },
    toReversed() {
      return Ka(this).toReversed();
    },
    toSorted(t) {
      return Ka(this).toSorted(t);
    },
    toSpliced(...t) {
      return Ka(this).toSpliced(...t);
    },
    unshift(...t) {
      return Bl(this, "unshift", t);
    },
    values() {
      return $h(this, "values", kn);
    }
  };
  function $h(t, e, n) {
    const r = Cd(t), i = r[e]();
    return r !== t && !jr(t) && (i._next = i.next, i.next = () => {
      const s = i._next();
      return s.value && (s.value = n(s.value)), s;
    }), i;
  }
  const E9 = Array.prototype;
  function us(t, e, n, r, i, s) {
    const o = Cd(t), a = o !== t && !jr(t), c = o[e];
    if (c !== E9[e]) {
      const f = c.apply(t, s);
      return a ? kn(f) : f;
    }
    let l = n;
    o !== t && (a ? l = function(f, d) {
      return n.call(this, kn(f), d, t);
    } : n.length > 2 && (l = function(f, d) {
      return n.call(this, f, d, t);
    }));
    const u = c.call(o, l, r);
    return a && i ? i(u) : u;
  }
  function ob(t, e, n, r) {
    const i = Cd(t);
    let s = n;
    return i !== t && (jr(t) ? n.length > 3 && (s = function(o, a, c) {
      return n.call(this, o, a, c, t);
    }) : s = function(o, a, c) {
      return n.call(this, o, kn(a), c, t);
    }), i[e](s, ...r);
  }
  function ep(t, e, n) {
    const r = at(t);
    Qn(r, "iterate", Iu);
    const i = r[e](...n);
    return (i === -1 || i === false) && T1(n[0]) ? (n[0] = at(n[0]), r[e](...n)) : i;
  }
  function Bl(t, e, n = []) {
    Ns(), x1();
    const r = at(t)[e].apply(t, n);
    return A1(), Os(), r;
  }
  const S9 = d1("__proto__,__v_isRef,__isVue"), Lv = new Set(Object.getOwnPropertyNames(Symbol).filter((t) => t !== "arguments" && t !== "caller").map((t) => Symbol[t]).filter(Vs));
  function T9(t) {
    Vs(t) || (t = String(t));
    const e = at(this);
    return Qn(e, "has", t), e.hasOwnProperty(t);
  }
  class Dv {
    constructor(e = false, n = false) {
      this._isReadonly = e, this._isShallow = n;
    }
    get(e, n, r) {
      if (n === "__v_skip") return e.__v_skip;
      const i = this._isReadonly, s = this._isShallow;
      if (n === "__v_isReactive") return !i;
      if (n === "__v_isReadonly") return i;
      if (n === "__v_isShallow") return s;
      if (n === "__v_raw") return r === (i ? s ? k9 : Vv : s ? Gv : Hv).get(e) || Object.getPrototypeOf(e) === Object.getPrototypeOf(r) ? e : void 0;
      const o = Be(e);
      if (!i) {
        let c;
        if (o && (c = v9[n])) return c;
        if (n === "hasOwnProperty") return T9;
      }
      const a = Reflect.get(e, n, Yt(e) ? e : r);
      return (Vs(n) ? Lv.has(n) : S9(n)) || (i || Qn(e, "get", n), s) ? a : Yt(a) ? o && g1(n) ? a : a.value : zt(a) ? i ? Qv(a) : $i(a) : a;
    }
  }
  class Uv extends Dv {
    constructor(e = false) {
      super(false, e);
    }
    set(e, n, r, i) {
      let s = e[n];
      if (!this._isShallow) {
        const c = _o(s);
        if (!jr(r) && !_o(r) && (s = at(s), r = at(r)), !Be(e) && Yt(s) && !Yt(r)) return c ? false : (s.value = r, true);
      }
      const o = Be(e) && g1(n) ? Number(n) < e.length : dt(e, n), a = Reflect.set(e, n, r, Yt(e) ? e : i);
      return e === at(i) && (o ? Eo(r, s) && Ss(e, "set", n, r) : Ss(e, "add", n, r)), a;
    }
    deleteProperty(e, n) {
      const r = dt(e, n);
      e[n];
      const i = Reflect.deleteProperty(e, n);
      return i && r && Ss(e, "delete", n, void 0), i;
    }
    has(e, n) {
      const r = Reflect.has(e, n);
      return (!Vs(n) || !Lv.has(n)) && Qn(e, "has", n), r;
    }
    ownKeys(e) {
      return Qn(e, "iterate", Be(e) ? "length" : ba), Reflect.ownKeys(e);
    }
  }
  class C9 extends Dv {
    constructor(e = false) {
      super(true, e);
    }
    set(e, n) {
      return true;
    }
    deleteProperty(e, n) {
      return true;
    }
  }
  const I9 = new Uv(), P9 = new C9(), _9 = new Uv(true);
  const Lg = (t) => t, _f = (t) => Reflect.getPrototypeOf(t);
  function R9(t, e, n) {
    return function(...r) {
      const i = this.__v_raw, s = at(i), o = Rc(s), a = t === "entries" || t === Symbol.iterator && o, c = t === "keys" && o, l = i[t](...r), u = n ? Lg : e ? M0 : kn;
      return !e && Qn(s, "iterate", c ? Fg : ba), {
        next() {
          const { value: f, done: d } = l.next();
          return d ? {
            value: f,
            done: d
          } : {
            value: a ? [
              u(f[0]),
              u(f[1])
            ] : u(f),
            done: d
          };
        },
        [Symbol.iterator]() {
          return this;
        }
      };
    };
  }
  function Rf(t) {
    return function(...e) {
      return t === "delete" ? false : t === "clear" ? void 0 : this;
    };
  }
  function N9(t, e) {
    const n = {
      get(i) {
        const s = this.__v_raw, o = at(s), a = at(i);
        t || (Eo(i, a) && Qn(o, "get", i), Qn(o, "get", a));
        const { has: c } = _f(o), l = e ? Lg : t ? M0 : kn;
        if (c.call(o, i)) return l(s.get(i));
        if (c.call(o, a)) return l(s.get(a));
        s !== o && s.get(i);
      },
      get size() {
        const i = this.__v_raw;
        return !t && Qn(at(i), "iterate", ba), Reflect.get(i, "size", i);
      },
      has(i) {
        const s = this.__v_raw, o = at(s), a = at(i);
        return t || (Eo(i, a) && Qn(o, "has", i), Qn(o, "has", a)), i === a ? s.has(i) : s.has(i) || s.has(a);
      },
      forEach(i, s) {
        const o = this, a = o.__v_raw, c = at(a), l = e ? Lg : t ? M0 : kn;
        return !t && Qn(c, "iterate", ba), a.forEach((u, f) => i.call(s, l(u), l(f), o));
      }
    };
    return Nn(n, t ? {
      add: Rf("add"),
      set: Rf("set"),
      delete: Rf("delete"),
      clear: Rf("clear")
    } : {
      add(i) {
        !e && !jr(i) && !_o(i) && (i = at(i));
        const s = at(this);
        return _f(s).has.call(s, i) || (s.add(i), Ss(s, "add", i, i)), this;
      },
      set(i, s) {
        !e && !jr(s) && !_o(s) && (s = at(s));
        const o = at(this), { has: a, get: c } = _f(o);
        let l = a.call(o, i);
        l || (i = at(i), l = a.call(o, i));
        const u = c.call(o, i);
        return o.set(i, s), l ? Eo(s, u) && Ss(o, "set", i, s) : Ss(o, "add", i, s), this;
      },
      delete(i) {
        const s = at(this), { has: o, get: a } = _f(s);
        let c = o.call(s, i);
        c || (i = at(i), c = o.call(s, i)), a && a.call(s, i);
        const l = s.delete(i);
        return c && Ss(s, "delete", i, void 0), l;
      },
      clear() {
        const i = at(this), s = i.size !== 0, o = i.clear();
        return s && Ss(i, "clear", void 0, void 0), o;
      }
    }), [
      "keys",
      "values",
      "entries",
      Symbol.iterator
    ].forEach((i) => {
      n[i] = R9(i, t, e);
    }), n;
  }
  function E1(t, e) {
    const n = N9(t, e);
    return (r, i, s) => i === "__v_isReactive" ? !t : i === "__v_isReadonly" ? t : i === "__v_raw" ? r : Reflect.get(dt(n, i) && i in r ? n : r, i, s);
  }
  const O9 = {
    get: E1(false, false)
  }, B9 = {
    get: E1(false, true)
  }, M9 = {
    get: E1(true, false)
  };
  const Hv = /* @__PURE__ */ new WeakMap(), Gv = /* @__PURE__ */ new WeakMap(), Vv = /* @__PURE__ */ new WeakMap(), k9 = /* @__PURE__ */ new WeakMap();
  function F9(t) {
    switch (t) {
      case "Object":
      case "Array":
        return 1;
      case "Map":
      case "Set":
      case "WeakMap":
      case "WeakSet":
        return 2;
      default:
        return 0;
    }
  }
  function L9(t) {
    return t.__v_skip || !Object.isExtensible(t) ? 0 : F9(c9(t));
  }
  $i = function(t) {
    return _o(t) ? t : S1(t, false, I9, O9, Hv);
  };
  function zv(t) {
    return S1(t, false, _9, B9, Gv);
  }
  function Qv(t) {
    return S1(t, true, P9, M9, Vv);
  }
  function S1(t, e, n, r, i) {
    if (!zt(t) || t.__v_raw && !(e && t.__v_isReactive)) return t;
    const s = L9(t);
    if (s === 0) return t;
    const o = i.get(t);
    if (o) return o;
    const a = new Proxy(t, s === 2 ? r : n);
    return i.set(t, a), a;
  }
  function So(t) {
    return _o(t) ? So(t.__v_raw) : !!(t && t.__v_isReactive);
  }
  function _o(t) {
    return !!(t && t.__v_isReadonly);
  }
  function jr(t) {
    return !!(t && t.__v_isShallow);
  }
  function T1(t) {
    return t ? !!t.__v_raw : false;
  }
  function at(t) {
    const e = t && t.__v_raw;
    return e ? at(e) : t;
  }
  C1 = function(t) {
    return !dt(t, "__v_skip") && Object.isExtensible(t) && Bg(t, "__v_skip", true), t;
  };
  const kn = (t) => zt(t) ? $i(t) : t, M0 = (t) => zt(t) ? Qv(t) : t;
  Yt = function(t) {
    return t ? t.__v_isRef === true : false;
  };
  Ze = function(t) {
    return jv(t, false);
  };
  I1 = function(t) {
    return jv(t, true);
  };
  function jv(t, e) {
    return Yt(t) ? t : new D9(t, e);
  }
  class D9 {
    constructor(e, n) {
      this.dep = new v1(), this.__v_isRef = true, this.__v_isShallow = false, this._rawValue = n ? e : at(e), this._value = n ? e : kn(e), this.__v_isShallow = n;
    }
    get value() {
      return this.dep.track(), this._value;
    }
    set value(e) {
      const n = this._rawValue, r = this.__v_isShallow || jr(e) || _o(e);
      e = r ? e : at(e), Eo(e, n) && (this._rawValue = e, this._value = r ? e : kn(e), this.dep.trigger());
    }
  }
  ar = function(t) {
    return Yt(t) ? t.value : t;
  };
  const U9 = {
    get: (t, e, n) => e === "__v_raw" ? t : ar(Reflect.get(t, e, n)),
    set: (t, e, n, r) => {
      const i = t[e];
      return Yt(i) && !Yt(n) ? (i.value = n, true) : Reflect.set(t, e, n, r);
    }
  };
  function Jv(t) {
    return So(t) ? t : new Proxy(t, U9);
  }
  function H9(t) {
    const e = Be(t) ? new Array(t.length) : {};
    for (const n in t) e[n] = V9(t, n);
    return e;
  }
  class G9 {
    constructor(e, n, r) {
      this._object = e, this._key = n, this._defaultValue = r, this.__v_isRef = true, this._value = void 0;
    }
    get value() {
      const e = this._object[this._key];
      return this._value = e === void 0 ? this._defaultValue : e;
    }
    set value(e) {
      this._object[this._key] = e;
    }
    get dep() {
      return w9(at(this._object), this._key);
    }
  }
  function V9(t, e, n) {
    const r = t[e];
    return Yt(r) ? r : new G9(t, e, n);
  }
  class z9 {
    constructor(e, n, r) {
      this.fn = e, this.setter = n, this._value = void 0, this.dep = new v1(this), this.__v_isRef = true, this.deps = void 0, this.depsTail = void 0, this.flags = 16, this.globalVersion = Cu - 1, this.next = void 0, this.effect = this, this.__v_isReadonly = !n, this.isSSR = r;
    }
    notify() {
      if (this.flags |= 16, !(this.flags & 8) && At !== this) return Nv(this, true), true;
    }
    get value() {
      const e = this.dep.track();
      return Mv(this), e && (e.version = this.dep.version), this._value;
    }
    set value(e) {
      this.setter && this.setter(e);
    }
  }
  function Q9(t, e, n = false) {
    let r, i;
    return Ge(t) ? r = t : (r = t.get, i = t.set), new z9(r, i, n);
  }
  const Nf = {}, k0 = /* @__PURE__ */ new WeakMap();
  let sa;
  function j9(t, e = false, n = sa) {
    if (n) {
      let r = k0.get(n);
      r || k0.set(n, r = []), r.push(t);
    }
  }
  function J9(t, e, n = bt) {
    const { immediate: r, deep: i, once: s, scheduler: o, augmentJob: a, call: c } = n, l = (M) => i ? M : jr(M) || i === false || i === 0 ? Ts(M, 1) : Ts(M);
    let u, f, d, m, y = false, x = false;
    if (Yt(t) ? (f = () => t.value, y = jr(t)) : So(t) ? (f = () => l(t), y = true) : Be(t) ? (x = true, y = t.some((M) => So(M) || jr(M)), f = () => t.map((M) => {
      if (Yt(M)) return M.value;
      if (So(M)) return l(M);
      if (Ge(M)) return c ? c(M, 2) : M();
    })) : Ge(t) ? e ? f = c ? () => c(t, 2) : t : f = () => {
      if (d) {
        Ns();
        try {
          d();
        } finally {
          Os();
        }
      }
      const M = sa;
      sa = u;
      try {
        return c ? c(t, 3, [
          m
        ]) : t(m);
      } finally {
        sa = M;
      }
    } : f = Ki, e && i) {
      const M = f, D = i === true ? 1 / 0 : i;
      f = () => Ts(M(), D);
    }
    const w = Pv(), R = () => {
      u.stop(), w && w.active && p1(w.effects, u);
    };
    if (s && e) {
      const M = e;
      e = (...D) => {
        M(...D), R();
      };
    }
    let O = x ? new Array(t.length).fill(Nf) : Nf;
    const B = (M) => {
      if (!(!(u.flags & 1) || !u.dirty && !M)) if (e) {
        const D = u.run();
        if (i || y || (x ? D.some((H, q) => Eo(H, O[q])) : Eo(D, O))) {
          d && d();
          const H = sa;
          sa = u;
          try {
            const q = [
              D,
              O === Nf ? void 0 : x && O[0] === Nf ? [] : O,
              m
            ];
            O = D, c ? c(e, 3, q) : e(...q);
          } finally {
            sa = H;
          }
        }
      } else u.run();
    };
    return a && a(B), u = new _v(f), u.scheduler = o ? () => o(B, false) : B, m = (M) => j9(M, false, u), d = u.onStop = () => {
      const M = k0.get(u);
      if (M) {
        if (c) c(M, 4);
        else for (const D of M) D();
        k0.delete(u);
      }
    }, e ? r ? B(true) : O = u.run() : o ? o(B.bind(null, true), true) : u.run(), R.pause = u.pause.bind(u), R.resume = u.resume.bind(u), R.stop = R, R;
  }
  function Ts(t, e = 1 / 0, n) {
    if (e <= 0 || !zt(t) || t.__v_skip || (n = n || /* @__PURE__ */ new Set(), n.has(t))) return t;
    if (n.add(t), e--, Yt(t)) Ts(t.value, e, n);
    else if (Be(t)) for (let r = 0; r < t.length; r++) Ts(t[r], e, n);
    else if (Av(t) || Rc(t)) t.forEach((r) => {
      Ts(r, e, n);
    });
    else if (Ev(t)) {
      for (const r in t) Ts(t[r], e, n);
      for (const r of Object.getOwnPropertySymbols(t)) Object.prototype.propertyIsEnumerable.call(t, r) && Ts(t[r], e, n);
    }
    return t;
  }
  function nf(t, e, n, r) {
    try {
      return r ? t(...r) : t();
    } catch (i) {
      Id(i, e, n);
    }
  }
  function wi(t, e, n, r) {
    if (Ge(t)) {
      const i = nf(t, e, n, r);
      return i && wv(i) && i.catch((s) => {
        Id(s, e, n);
      }), i;
    }
    if (Be(t)) {
      const i = [];
      for (let s = 0; s < t.length; s++) i.push(wi(t[s], e, n, r));
      return i;
    }
  }
  function Id(t, e, n, r = true) {
    const i = e ? e.vnode : null, { errorHandler: s, throwUnhandledErrorInProduction: o } = e && e.appContext.config || bt;
    if (e) {
      let a = e.parent;
      const c = e.proxy, l = `https://vuejs.org/error-reference/#runtime-${n}`;
      for (; a; ) {
        const u = a.ec;
        if (u) {
          for (let f = 0; f < u.length; f++) if (u[f](t, c, l) === false) return;
        }
        a = a.parent;
      }
      if (s) {
        Ns(), nf(s, null, 10, [
          t,
          c,
          l
        ]), Os();
        return;
      }
    }
    K9(t, n, i, r, o);
  }
  function K9(t, e, n, r = true, i = false) {
    if (i) throw t;
    console.error(t);
  }
  const er = [];
  let Bi = -1;
  const Oc = [];
  let fo = null, ac = 0;
  const Kv = Promise.resolve();
  let F0 = null;
  zi = function(t) {
    const e = F0 || Kv;
    return t ? e.then(this ? t.bind(this) : t) : e;
  };
  function W9(t) {
    let e = Bi + 1, n = er.length;
    for (; e < n; ) {
      const r = e + n >>> 1, i = er[r], s = Pu(i);
      s < t || s === t && i.flags & 2 ? e = r + 1 : n = r;
    }
    return e;
  }
  function P1(t) {
    if (!(t.flags & 1)) {
      const e = Pu(t), n = er[er.length - 1];
      !n || !(t.flags & 2) && e >= Pu(n) ? er.push(t) : er.splice(W9(e), 0, t), t.flags |= 1, Wv();
    }
  }
  function Wv() {
    F0 || (F0 = Kv.then(Yv));
  }
  function q9(t) {
    Be(t) ? Oc.push(...t) : fo && t.id === -1 ? fo.splice(ac + 1, 0, t) : t.flags & 1 || (Oc.push(t), t.flags |= 1), Wv();
  }
  function ab(t, e, n = Bi + 1) {
    for (; n < er.length; n++) {
      const r = er[n];
      if (r && r.flags & 2) {
        if (t && r.id !== t.uid) continue;
        er.splice(n, 1), n--, r.flags & 4 && (r.flags &= -2), r(), r.flags & 4 || (r.flags &= -2);
      }
    }
  }
  function qv(t) {
    if (Oc.length) {
      const e = [
        ...new Set(Oc)
      ].sort((n, r) => Pu(n) - Pu(r));
      if (Oc.length = 0, fo) {
        fo.push(...e);
        return;
      }
      for (fo = e, ac = 0; ac < fo.length; ac++) {
        const n = fo[ac];
        n.flags & 4 && (n.flags &= -2), n.flags & 8 || n(), n.flags &= -2;
      }
      fo = null, ac = 0;
    }
  }
  const Pu = (t) => t.id == null ? t.flags & 2 ? -1 : 1 / 0 : t.id;
  function Yv(t) {
    try {
      for (Bi = 0; Bi < er.length; Bi++) {
        const e = er[Bi];
        e && !(e.flags & 8) && (e.flags & 4 && (e.flags &= -2), nf(e, e.i, e.i ? 15 : 14), e.flags & 4 || (e.flags &= -2));
      }
    } finally {
      for (; Bi < er.length; Bi++) {
        const e = er[Bi];
        e && (e.flags &= -2);
      }
      Bi = -1, er.length = 0, qv(), F0 = null, (er.length || Oc.length) && Yv();
    }
  }
  let En = null, Xv = null;
  function L0(t) {
    const e = En;
    return En = t, Xv = t && t.type.__scopeId || null, e;
  }
  jc = function(t, e = En, n) {
    if (!e || t._n) return t;
    const r = (...i) => {
      r._d && Ab(-1);
      const s = L0(e);
      let o;
      try {
        o = t(...i);
      } finally {
        L0(s), r._d && Ab(1);
      }
      return o;
    };
    return r._n = true, r._c = true, r._d = true, r;
  };
  Zv = function(t, e) {
    if (En === null) return t;
    const n = Md(En), r = t.dirs || (t.dirs = []);
    for (let i = 0; i < e.length; i++) {
      let [s, o, a, c = bt] = e[i];
      s && (Ge(s) && (s = {
        mounted: s,
        updated: s
      }), s.deep && Ts(o), r.push({
        dir: s,
        instance: n,
        value: o,
        oldValue: void 0,
        arg: a,
        modifiers: c
      }));
    }
    return t;
  };
  function Yo(t, e, n, r) {
    const i = t.dirs, s = e && e.dirs;
    for (let o = 0; o < i.length; o++) {
      const a = i[o];
      s && (a.oldValue = s[o].value);
      let c = a.dir[r];
      c && (Ns(), wi(c, n, 8, [
        t.el,
        a,
        t,
        e
      ]), Os());
    }
  }
  const $v = Symbol("_vte"), e3 = (t) => t.__isTeleport, ou = (t) => t && (t.disabled || t.disabled === ""), cb = (t) => t && (t.defer || t.defer === ""), lb = (t) => typeof SVGElement < "u" && t instanceof SVGElement, ub = (t) => typeof MathMLElement == "function" && t instanceof MathMLElement, Dg = (t, e) => {
    const n = t && t.to;
    return jt(n) ? e ? e(n) : null : n;
  }, t3 = {
    name: "Teleport",
    __isTeleport: true,
    process(t, e, n, r, i, s, o, a, c, l) {
      const { mc: u, pc: f, pbc: d, o: { insert: m, querySelector: y, createText: x, createComment: w } } = l, R = ou(e.props);
      let { shapeFlag: O, children: B, dynamicChildren: M } = e;
      if (t == null) {
        const D = e.el = x(""), H = e.anchor = x("");
        m(D, n, r), m(H, n, r);
        const q = (P, L) => {
          O & 16 && (i && i.isCE && (i.ce._teleportTarget = P), u(B, P, L, i, s, o, a, c));
        }, S = () => {
          const P = e.target = Dg(e.props, y), L = r3(P, e, x, m);
          P && (o !== "svg" && lb(P) ? o = "svg" : o !== "mathml" && ub(P) && (o = "mathml"), R || (q(P, L), a0(e, false)));
        };
        R && (q(n, H), a0(e, true)), cb(e.props) ? (e.el.__isMounted = false, wn(() => {
          S(), delete e.el.__isMounted;
        }, s)) : S();
      } else {
        if (cb(e.props) && t.el.__isMounted === false) {
          wn(() => {
            t3.process(t, e, n, r, i, s, o, a, c, l);
          }, s);
          return;
        }
        e.el = t.el, e.targetStart = t.targetStart;
        const D = e.anchor = t.anchor, H = e.target = t.target, q = e.targetAnchor = t.targetAnchor, S = ou(t.props), P = S ? n : H, L = S ? D : q;
        if (o === "svg" || lb(H) ? o = "svg" : (o === "mathml" || ub(H)) && (o = "mathml"), M ? (d(t.dynamicChildren, M, P, i, s, o, a), O1(t, e, true)) : c || f(t, e, P, L, i, s, o, a, false), R) S ? e.props && t.props && e.props.to !== t.props.to && (e.props.to = t.props.to) : Of(e, n, D, l, 1);
        else if ((e.props && e.props.to) !== (t.props && t.props.to)) {
          const K = e.target = Dg(e.props, y);
          K && Of(e, K, null, l, 0);
        } else S && Of(e, H, q, l, 1);
        a0(e, R);
      }
    },
    remove(t, e, n, { um: r, o: { remove: i } }, s) {
      const { shapeFlag: o, children: a, anchor: c, targetStart: l, targetAnchor: u, target: f, props: d } = t;
      if (f && (i(l), i(u)), s && i(c), o & 16) {
        const m = s || !ou(d);
        for (let y = 0; y < a.length; y++) {
          const x = a[y];
          r(x, e, n, m, !!x.dynamicChildren);
        }
      }
    },
    move: Of,
    hydrate: Y9
  };
  function Of(t, e, n, { o: { insert: r }, m: i }, s = 2) {
    s === 0 && r(t.targetAnchor, e, n);
    const { el: o, anchor: a, shapeFlag: c, children: l, props: u } = t, f = s === 2;
    if (f && r(o, e, n), (!f || ou(u)) && c & 16) for (let d = 0; d < l.length; d++) i(l[d], e, n, 2);
    f && r(a, e, n);
  }
  function Y9(t, e, n, r, i, s, { o: { nextSibling: o, parentNode: a, querySelector: c, insert: l, createText: u } }, f) {
    const d = e.target = Dg(e.props, c);
    if (d) {
      const m = ou(e.props), y = d._lpa || d.firstChild;
      if (e.shapeFlag & 16) if (m) e.anchor = f(o(t), e, a(t), n, r, i, s), e.targetStart = y, e.targetAnchor = y && o(y);
      else {
        e.anchor = o(t);
        let x = y;
        for (; x; ) {
          if (x && x.nodeType === 8) {
            if (x.data === "teleport start anchor") e.targetStart = x;
            else if (x.data === "teleport anchor") {
              e.targetAnchor = x, d._lpa = e.targetAnchor && o(e.targetAnchor);
              break;
            }
          }
          x = o(x);
        }
        e.targetAnchor || r3(d, e, u, l), f(y && o(y), e, d, n, r, i, s);
      }
      a0(e, m);
    }
    return e.anchor && o(e.anchor);
  }
  n3 = t3;
  function a0(t, e) {
    const n = t.ctx;
    if (n && n.ut) {
      let r, i;
      for (e ? (r = t.el, i = t.anchor) : (r = t.targetStart, i = t.targetAnchor); r && r !== i; ) r.nodeType === 1 && r.setAttribute("data-v-owner", n.uid), r = r.nextSibling;
      n.ut();
    }
  }
  function r3(t, e, n, r) {
    const i = e.targetStart = n(""), s = e.targetAnchor = n("");
    return i[$v] = s, t && (r(i, t), r(s, t)), s;
  }
  const ho = Symbol("_leaveCb"), Bf = Symbol("_enterCb");
  function X9() {
    const t = {
      isMounted: false,
      isLeaving: false,
      isUnmounting: false,
      leavingVNodes: /* @__PURE__ */ new Map()
    };
    return Si(() => {
      t.isMounted = true;
    }), Nd(() => {
      t.isUnmounting = true;
    }), t;
  }
  const Nr = [
    Function,
    Array
  ], i3 = {
    mode: String,
    appear: Boolean,
    persisted: Boolean,
    onBeforeEnter: Nr,
    onEnter: Nr,
    onAfterEnter: Nr,
    onEnterCancelled: Nr,
    onBeforeLeave: Nr,
    onLeave: Nr,
    onAfterLeave: Nr,
    onLeaveCancelled: Nr,
    onBeforeAppear: Nr,
    onAppear: Nr,
    onAfterAppear: Nr,
    onAppearCancelled: Nr
  }, s3 = (t) => {
    const e = t.subTree;
    return e.component ? s3(e.component) : e;
  }, Z9 = {
    name: "BaseTransition",
    props: i3,
    setup(t, { slots: e }) {
      const n = xr(), r = X9();
      return () => {
        const i = e.default && c3(e.default(), true);
        if (!i || !i.length) return;
        const s = o3(i), o = at(t), { mode: a } = o;
        if (r.isLeaving) return tp(s);
        const c = fb(s);
        if (!c) return tp(s);
        let l = Ug(c, o, r, n, (f) => l = f);
        c.type !== Dn && Jc(c, l);
        let u = n.subTree && fb(n.subTree);
        if (u && u.type !== Dn && !mo(c, u) && s3(n).type !== Dn) {
          let f = Ug(u, o, r, n);
          if (Jc(u, f), a === "out-in" && c.type !== Dn) return r.isLeaving = true, f.afterLeave = () => {
            r.isLeaving = false, n.job.flags & 8 || n.update(), delete f.afterLeave, u = void 0;
          }, tp(s);
          a === "in-out" && c.type !== Dn ? f.delayLeave = (d, m, y) => {
            const x = a3(r, u);
            x[String(u.key)] = u, d[ho] = () => {
              m(), d[ho] = void 0, delete l.delayedLeave, u = void 0;
            }, l.delayedLeave = () => {
              y(), delete l.delayedLeave, u = void 0;
            };
          } : u = void 0;
        } else u && (u = void 0);
        return s;
      };
    }
  };
  function o3(t) {
    let e = t[0];
    if (t.length > 1) {
      for (const n of t) if (n.type !== Dn) {
        e = n;
        break;
      }
    }
    return e;
  }
  const $9 = Z9;
  function a3(t, e) {
    const { leavingVNodes: n } = t;
    let r = n.get(e.type);
    return r || (r = /* @__PURE__ */ Object.create(null), n.set(e.type, r)), r;
  }
  function Ug(t, e, n, r, i) {
    const { appear: s, mode: o, persisted: a = false, onBeforeEnter: c, onEnter: l, onAfterEnter: u, onEnterCancelled: f, onBeforeLeave: d, onLeave: m, onAfterLeave: y, onLeaveCancelled: x, onBeforeAppear: w, onAppear: R, onAfterAppear: O, onAppearCancelled: B } = e, M = String(t.key), D = a3(n, t), H = (P, L) => {
      P && wi(P, r, 9, L);
    }, q = (P, L) => {
      const K = L[1];
      H(P, L), Be(P) ? P.every((z) => z.length <= 1) && K() : P.length <= 1 && K();
    }, S = {
      mode: o,
      persisted: a,
      beforeEnter(P) {
        let L = c;
        if (!n.isMounted) if (s) L = w || c;
        else return;
        P[ho] && P[ho](true);
        const K = D[M];
        K && mo(t, K) && K.el[ho] && K.el[ho](), H(L, [
          P
        ]);
      },
      enter(P) {
        let L = l, K = u, z = f;
        if (!n.isMounted) if (s) L = R || l, K = O || u, z = B || f;
        else return;
        let I = false;
        const h = P[Bf] = (p) => {
          I || (I = true, p ? H(z, [
            P
          ]) : H(K, [
            P
          ]), S.delayedLeave && S.delayedLeave(), P[Bf] = void 0);
        };
        L ? q(L, [
          P,
          h
        ]) : h();
      },
      leave(P, L) {
        const K = String(t.key);
        if (P[Bf] && P[Bf](true), n.isUnmounting) return L();
        H(d, [
          P
        ]);
        let z = false;
        const I = P[ho] = (h) => {
          z || (z = true, L(), h ? H(x, [
            P
          ]) : H(y, [
            P
          ]), P[ho] = void 0, D[K] === t && delete D[K]);
        };
        D[K] = t, m ? q(m, [
          P,
          I
        ]) : I();
      },
      clone(P) {
        const L = Ug(P, e, n, r, i);
        return i && i(L), L;
      }
    };
    return S;
  }
  function tp(t) {
    if (Pd(t)) return t = Bs(t), t.children = null, t;
  }
  function fb(t) {
    if (!Pd(t)) return e3(t.type) && t.children ? o3(t.children) : t;
    if (t.component) return t.component.subTree;
    const { shapeFlag: e, children: n } = t;
    if (n) {
      if (e & 16) return n[0];
      if (e & 32 && Ge(n.default)) return n.default();
    }
  }
  function Jc(t, e) {
    t.shapeFlag & 6 && t.component ? (t.transition = e, Jc(t.component.subTree, e)) : t.shapeFlag & 128 ? (t.ssContent.transition = e.clone(t.ssContent), t.ssFallback.transition = e.clone(t.ssFallback)) : t.transition = e;
  }
  function c3(t, e = false, n) {
    let r = [], i = 0;
    for (let s = 0; s < t.length; s++) {
      let o = t[s];
      const a = n == null ? o.key : String(n) + String(o.key != null ? o.key : s);
      o.type === jn ? (o.patchFlag & 128 && i++, r = r.concat(c3(o.children, e, a))) : (e || o.type !== Dn) && r.push(a != null ? Bs(o, {
        key: a
      }) : o);
    }
    if (i > 1) for (let s = 0; s < r.length; s++) r[s].patchFlag = -2;
    return r;
  }
  Gn = function(t, e) {
    return Ge(t) ? Nn({
      name: t.name
    }, e, {
      setup: t
    }) : t;
  };
  function l3(t) {
    t.ids = [
      t.ids[0] + t.ids[2]++ + "-",
      0,
      0
    ];
  }
  function au(t, e, n, r, i = false) {
    if (Be(t)) {
      t.forEach((y, x) => au(y, e && (Be(e) ? e[x] : e), n, r, i));
      return;
    }
    if (xa(r) && !i) {
      r.shapeFlag & 512 && r.type.__asyncResolved && r.component.subTree.component && au(t, e, n, r.component.subTree);
      return;
    }
    const s = r.shapeFlag & 4 ? Md(r.component) : r.el, o = i ? null : s, { i: a, r: c } = t, l = e && e.r, u = a.refs === bt ? a.refs = {} : a.refs, f = a.setupState, d = at(f), m = f === bt ? () => false : (y) => dt(d, y);
    if (l != null && l !== c && (jt(l) ? (u[l] = null, m(l) && (f[l] = null)) : Yt(l) && (l.value = null)), Ge(c)) nf(c, a, 12, [
      o,
      u
    ]);
    else {
      const y = jt(c), x = Yt(c);
      if (y || x) {
        const w = () => {
          if (t.f) {
            const R = y ? m(c) ? f[c] : u[c] : c.value;
            i ? Be(R) && p1(R, s) : Be(R) ? R.includes(s) || R.push(s) : y ? (u[c] = [
              s
            ], m(c) && (f[c] = u[c])) : (c.value = [
              s
            ], t.k && (u[t.k] = c.value));
          } else y ? (u[c] = o, m(c) && (f[c] = o)) : x && (c.value = o, t.k && (u[t.k] = o));
        };
        o ? (w.id = -1, wn(w, n)) : w();
      }
    }
  }
  Td().requestIdleCallback;
  Td().cancelIdleCallback;
  const xa = (t) => !!t.type.__asyncLoader, Pd = (t) => t.type.__isKeepAlive, eS = {
    name: "KeepAlive",
    __isKeepAlive: true,
    props: {
      include: [
        String,
        RegExp,
        Array
      ],
      exclude: [
        String,
        RegExp,
        Array
      ],
      max: [
        String,
        Number
      ]
    },
    setup(t, { slots: e }) {
      const n = xr(), r = n.ctx;
      if (!r.renderer) return () => {
        const O = e.default && e.default();
        return O && O.length === 1 ? O[0] : O;
      };
      const i = /* @__PURE__ */ new Map(), s = /* @__PURE__ */ new Set();
      let o = null;
      const a = n.suspense, { renderer: { p: c, m: l, um: u, o: { createElement: f } } } = r, d = f("div");
      r.activate = (O, B, M, D, H) => {
        const q = O.component;
        l(O, B, M, 0, a), c(q.vnode, O, B, M, q, a, D, O.slotScopeIds, H), wn(() => {
          q.isDeactivated = false, q.a && Nc(q.a);
          const S = O.props && O.props.onVnodeMounted;
          S && Ur(S, q.parent, O);
        }, a);
      }, r.deactivate = (O) => {
        const B = O.component;
        U0(B.m), U0(B.a), l(O, d, null, 1, a), wn(() => {
          B.da && Nc(B.da);
          const M = O.props && O.props.onVnodeUnmounted;
          M && Ur(M, B.parent, O), B.isDeactivated = true;
        }, a);
      };
      function m(O) {
        np(O), u(O, n, a, true);
      }
      function y(O) {
        i.forEach((B, M) => {
          const D = jg(B.type);
          D && !O(D) && x(M);
        });
      }
      function x(O) {
        const B = i.get(O);
        B && (!o || !mo(B, o)) ? m(B) : o && np(o), i.delete(O), s.delete(O);
      }
      xn(() => [
        t.include,
        t.exclude
      ], ([O, B]) => {
        O && y((M) => Xl(O, M)), B && y((M) => !Xl(B, M));
      }, {
        flush: "post",
        deep: true
      });
      let w = null;
      const R = () => {
        w != null && (H0(n.subTree.type) ? wn(() => {
          i.set(w, Mf(n.subTree));
        }, n.subTree.suspense) : i.set(w, Mf(n.subTree)));
      };
      return Si(R), d3(R), Nd(() => {
        i.forEach((O) => {
          const { subTree: B, suspense: M } = n, D = Mf(B);
          if (O.type === D.type && O.key === D.key) {
            np(D);
            const H = D.component.da;
            H && wn(H, M);
            return;
          }
          m(O);
        });
      }), () => {
        if (w = null, !e.default) return o = null;
        const O = e.default(), B = O[0];
        if (O.length > 1) return o = null, O;
        if (!Pa(B) || !(B.shapeFlag & 4) && !(B.shapeFlag & 128)) return o = null, B;
        let M = Mf(B);
        if (M.type === Dn) return o = null, M;
        const D = M.type, H = jg(xa(M) ? M.type.__asyncResolved || {} : D), { include: q, exclude: S, max: P } = t;
        if (q && (!H || !Xl(q, H)) || S && H && Xl(S, H)) return M.shapeFlag &= -257, o = M, B;
        const L = M.key == null ? D : M.key, K = i.get(L);
        return M.el && (M = Bs(M), B.shapeFlag & 128 && (B.ssContent = M)), w = L, K ? (M.el = K.el, M.component = K.component, M.transition && Jc(M, M.transition), M.shapeFlag |= 512, s.delete(L), s.add(L)) : (s.add(L), P && s.size > parseInt(P, 10) && x(s.values().next().value)), M.shapeFlag |= 256, o = M, H0(B.type) ? B : M;
      };
    }
  }, tS = eS;
  function Xl(t, e) {
    return Be(t) ? t.some((n) => Xl(n, e)) : jt(t) ? t.split(",").includes(e) : a9(t) ? (t.lastIndex = 0, t.test(e)) : false;
  }
  function _1(t, e) {
    u3(t, "a", e);
  }
  _d = function(t, e) {
    u3(t, "da", e);
  };
  function u3(t, e, n = Pn) {
    const r = t.__wdc || (t.__wdc = () => {
      let i = n;
      for (; i; ) {
        if (i.isDeactivated) return;
        i = i.parent;
      }
      return t();
    });
    if (Rd(e, r, n), n) {
      let i = n.parent;
      for (; i && i.parent; ) Pd(i.parent.vnode) && nS(r, e, n, i), i = i.parent;
    }
  }
  function nS(t, e, n, r) {
    const i = Rd(e, t, r, true);
    yl(() => {
      p1(r[e], i);
    }, n);
  }
  function np(t) {
    t.shapeFlag &= -257, t.shapeFlag &= -513;
  }
  function Mf(t) {
    return t.shapeFlag & 128 ? t.ssContent : t;
  }
  function Rd(t, e, n = Pn, r = false) {
    if (n) {
      const i = n[t] || (n[t] = []), s = e.__weh || (e.__weh = (...o) => {
        Ns();
        const a = sf(n), c = wi(e, n, t, o);
        return a(), Os(), c;
      });
      return r ? i.unshift(s) : i.push(s), s;
    }
  }
  let zs, f3, rS, iS, sS, oS;
  zs = (t) => (e, n = Pn) => {
    (!Ru || t === "sp") && Rd(t, (...r) => e(...r), n);
  };
  f3 = zs("bm");
  Si = zs("m");
  rS = zs("bu");
  d3 = zs("u");
  Nd = zs("bum");
  yl = zs("um");
  iS = zs("sp");
  sS = zs("rtg");
  oS = zs("rtc");
  function aS(t, e = Pn) {
    Rd("ec", t, e);
  }
  const h3 = "components";
  cS = function(t, e) {
    return g3(h3, t, true, e) || t;
  };
  const p3 = Symbol.for("v-ndc");
  function lS(t) {
    return jt(t) ? g3(h3, t, false) || t : t || p3;
  }
  function g3(t, e, n = true, r = false) {
    const i = En || Pn;
    if (i) {
      const s = i.type;
      {
        const a = jg(s, false);
        if (a && (a === e || a === Wr(e) || a === Sd(Wr(e)))) return s;
      }
      const o = db(i[t] || s[t], e) || db(i.appContext[t], e);
      return !o && r ? s : o;
    }
  }
  function db(t, e) {
    return t && (t[e] || t[Wr(e)] || t[Sd(Wr(e))]);
  }
  AW = function(t, e, n, r) {
    let i;
    const s = n, o = Be(t);
    if (o || jt(t)) {
      const a = o && So(t);
      let c = false, l = false;
      a && (c = !jr(t), l = _o(t), t = Cd(t)), i = new Array(t.length);
      for (let u = 0, f = t.length; u < f; u++) i[u] = e(c ? l ? M0(kn(t[u])) : kn(t[u]) : t[u], u, void 0, s);
    } else if (typeof t == "number") {
      i = new Array(t);
      for (let a = 0; a < t; a++) i[a] = e(a + 1, a, void 0, s);
    } else if (zt(t)) if (t[Symbol.iterator]) i = Array.from(t, (a, c) => e(a, c, void 0, s));
    else {
      const a = Object.keys(t);
      i = new Array(a.length);
      for (let c = 0, l = a.length; c < l; c++) {
        const u = a[c];
        i[c] = e(t[u], u, c, s);
      }
    }
    else i = [];
    return i;
  };
  wW = function(t, e, n = {}, r, i) {
    if (En.ce || En.parent && xa(En.parent) && En.parent.ce) return e !== "default" && (n.name = e), fi(), Hi(jn, null, [
      Te("slot", n, r)
    ], 64);
    let s = t[e];
    s && s._c && (s._d = false), fi();
    const o = s && m3(s(n)), a = n.key || o && o.key, c = Hi(jn, {
      key: (a && !Vs(a) ? a : `_${e}`) + ""
    }, o || [], o && t._ === 1 ? 64 : -2);
    return !i && c.scopeId && (c.slotScopeIds = [
      c.scopeId + "-s"
    ]), s && s._c && (s._d = true), c;
  };
  function m3(t) {
    return t.some((e) => Pa(e) ? !(e.type === Dn || e.type === jn && !m3(e.children)) : true) ? t : null;
  }
  const Hg = (t) => t ? B3(t) ? Md(t) : Hg(t.parent) : null, cu = Nn(/* @__PURE__ */ Object.create(null), {
    $: (t) => t,
    $el: (t) => t.vnode.el,
    $data: (t) => t.data,
    $props: (t) => t.props,
    $attrs: (t) => t.attrs,
    $slots: (t) => t.slots,
    $refs: (t) => t.refs,
    $parent: (t) => Hg(t.parent),
    $root: (t) => Hg(t.root),
    $host: (t) => t.ce,
    $emit: (t) => t.emit,
    $options: (t) => b3(t),
    $forceUpdate: (t) => t.f || (t.f = () => {
      P1(t.update);
    }),
    $nextTick: (t) => t.n || (t.n = zi.bind(t.proxy)),
    $watch: (t) => NS.bind(t)
  }), rp = (t, e) => t !== bt && !t.__isScriptSetup && dt(t, e), uS = {
    get({ _: t }, e) {
      if (e === "__v_skip") return true;
      const { ctx: n, setupState: r, data: i, props: s, accessCache: o, type: a, appContext: c } = t;
      let l;
      if (e[0] !== "$") {
        const m = o[e];
        if (m !== void 0) switch (m) {
          case 1:
            return r[e];
          case 2:
            return i[e];
          case 4:
            return n[e];
          case 3:
            return s[e];
        }
        else {
          if (rp(r, e)) return o[e] = 1, r[e];
          if (i !== bt && dt(i, e)) return o[e] = 2, i[e];
          if ((l = t.propsOptions[0]) && dt(l, e)) return o[e] = 3, s[e];
          if (n !== bt && dt(n, e)) return o[e] = 4, n[e];
          Gg && (o[e] = 0);
        }
      }
      const u = cu[e];
      let f, d;
      if (u) return e === "$attrs" && Qn(t.attrs, "get", ""), u(t);
      if ((f = a.__cssModules) && (f = f[e])) return f;
      if (n !== bt && dt(n, e)) return o[e] = 4, n[e];
      if (d = c.config.globalProperties, dt(d, e)) return d[e];
    },
    set({ _: t }, e, n) {
      const { data: r, setupState: i, ctx: s } = t;
      return rp(i, e) ? (i[e] = n, true) : r !== bt && dt(r, e) ? (r[e] = n, true) : dt(t.props, e) || e[0] === "$" && e.slice(1) in t ? false : (s[e] = n, true);
    },
    has({ _: { data: t, setupState: e, accessCache: n, ctx: r, appContext: i, propsOptions: s } }, o) {
      let a;
      return !!n[o] || t !== bt && dt(t, o) || rp(e, o) || (a = s[0]) && dt(a, o) || dt(r, o) || dt(cu, o) || dt(i.config.globalProperties, o);
    },
    defineProperty(t, e, n) {
      return n.get != null ? t._.accessCache[e] = 0 : dt(n, "value") && this.set(t, e, n.value, null), Reflect.defineProperty(t, e, n);
    }
  };
  function hb(t) {
    return Be(t) ? t.reduce((e, n) => (e[n] = null, e), {}) : t;
  }
  let Gg = true;
  function fS(t) {
    const e = b3(t), n = t.proxy, r = t.ctx;
    Gg = false, e.beforeCreate && pb(e.beforeCreate, t, "bc");
    const { data: i, computed: s, methods: o, watch: a, provide: c, inject: l, created: u, beforeMount: f, mounted: d, beforeUpdate: m, updated: y, activated: x, deactivated: w, beforeDestroy: R, beforeUnmount: O, destroyed: B, unmounted: M, render: D, renderTracked: H, renderTriggered: q, errorCaptured: S, serverPrefetch: P, expose: L, inheritAttrs: K, components: z, directives: I, filters: h } = e;
    if (l && dS(l, r, null), o) for (const C in o) {
      const N = o[C];
      Ge(N) && (r[C] = N.bind(n));
    }
    if (i) {
      const C = i.call(n, n);
      zt(C) && (t.data = $i(C));
    }
    if (Gg = true, s) for (const C in s) {
      const N = s[C], U = Ge(N) ? N.bind(n, n) : Ge(N.get) ? N.get.bind(n, n) : Ki, Y = !Ge(N) && Ge(N.set) ? N.set.bind(n) : Ki, T = it({
        get: U,
        set: Y
      });
      Object.defineProperty(r, C, {
        enumerable: true,
        configurable: true,
        get: () => T.value,
        set: (g) => T.value = g
      });
    }
    if (a) for (const C in a) y3(a[C], r, n, C);
    if (c) {
      const C = Ge(c) ? c.call(n) : c;
      Reflect.ownKeys(C).forEach((N) => {
        wa(N, C[N]);
      });
    }
    u && pb(u, t, "c");
    function A(C, N) {
      Be(N) ? N.forEach((U) => C(U.bind(n))) : N && C(N.bind(n));
    }
    if (A(f3, f), A(Si, d), A(rS, m), A(d3, y), A(_1, x), A(_d, w), A(aS, S), A(oS, H), A(sS, q), A(Nd, O), A(yl, M), A(iS, P), Be(L)) if (L.length) {
      const C = t.exposed || (t.exposed = {});
      L.forEach((N) => {
        Object.defineProperty(C, N, {
          get: () => n[N],
          set: (U) => n[N] = U
        });
      });
    } else t.exposed || (t.exposed = {});
    D && t.render === Ki && (t.render = D), K != null && (t.inheritAttrs = K), z && (t.components = z), I && (t.directives = I), P && l3(t);
  }
  function dS(t, e, n = Ki) {
    Be(t) && (t = Vg(t));
    for (const r in t) {
      const i = t[r];
      let s;
      zt(i) ? "default" in i ? s = qn(i.from || r, i.default, true) : s = qn(i.from || r) : s = qn(i), Yt(s) ? Object.defineProperty(e, r, {
        enumerable: true,
        configurable: true,
        get: () => s.value,
        set: (o) => s.value = o
      }) : e[r] = s;
    }
  }
  function pb(t, e, n) {
    wi(Be(t) ? t.map((r) => r.bind(e.proxy)) : t.bind(e.proxy), e, n);
  }
  function y3(t, e, n, r) {
    let i = r.includes(".") ? _3(n, r) : () => n[r];
    if (jt(t)) {
      const s = e[t];
      Ge(s) && xn(i, s);
    } else if (Ge(t)) xn(i, t.bind(n));
    else if (zt(t)) if (Be(t)) t.forEach((s) => y3(s, e, n, r));
    else {
      const s = Ge(t.handler) ? t.handler.bind(n) : e[t.handler];
      Ge(s) && xn(i, s, t);
    }
  }
  function b3(t) {
    const e = t.type, { mixins: n, extends: r } = e, { mixins: i, optionsCache: s, config: { optionMergeStrategies: o } } = t.appContext, a = s.get(e);
    let c;
    return a ? c = a : !i.length && !n && !r ? c = e : (c = {}, i.length && i.forEach((l) => D0(c, l, o, true)), D0(c, e, o)), zt(e) && s.set(e, c), c;
  }
  function D0(t, e, n, r = false) {
    const { mixins: i, extends: s } = e;
    s && D0(t, s, n, true), i && i.forEach((o) => D0(t, o, n, true));
    for (const o in e) if (!(r && o === "expose")) {
      const a = hS[o] || n && n[o];
      t[o] = a ? a(t[o], e[o]) : e[o];
    }
    return t;
  }
  const hS = {
    data: gb,
    props: mb,
    emits: mb,
    methods: Zl,
    computed: Zl,
    beforeCreate: Xn,
    created: Xn,
    beforeMount: Xn,
    mounted: Xn,
    beforeUpdate: Xn,
    updated: Xn,
    beforeDestroy: Xn,
    beforeUnmount: Xn,
    destroyed: Xn,
    unmounted: Xn,
    activated: Xn,
    deactivated: Xn,
    errorCaptured: Xn,
    serverPrefetch: Xn,
    components: Zl,
    directives: Zl,
    watch: gS,
    provide: gb,
    inject: pS
  };
  function gb(t, e) {
    return e ? t ? function() {
      return Nn(Ge(t) ? t.call(this, this) : t, Ge(e) ? e.call(this, this) : e);
    } : e : t;
  }
  function pS(t, e) {
    return Zl(Vg(t), Vg(e));
  }
  function Vg(t) {
    if (Be(t)) {
      const e = {};
      for (let n = 0; n < t.length; n++) e[t[n]] = t[n];
      return e;
    }
    return t;
  }
  function Xn(t, e) {
    return t ? [
      ...new Set([].concat(t, e))
    ] : e;
  }
  function Zl(t, e) {
    return t ? Nn(/* @__PURE__ */ Object.create(null), t, e) : e;
  }
  function mb(t, e) {
    return t ? Be(t) && Be(e) ? [
      .../* @__PURE__ */ new Set([
        ...t,
        ...e
      ])
    ] : Nn(/* @__PURE__ */ Object.create(null), hb(t), hb(e ?? {})) : e;
  }
  function gS(t, e) {
    if (!t) return e;
    if (!e) return t;
    const n = Nn(/* @__PURE__ */ Object.create(null), t);
    for (const r in e) n[r] = Xn(t[r], e[r]);
    return n;
  }
  function x3() {
    return {
      app: null,
      config: {
        isNativeTag: s9,
        performance: false,
        globalProperties: {},
        optionMergeStrategies: {},
        errorHandler: void 0,
        warnHandler: void 0,
        compilerOptions: {}
      },
      mixins: [],
      components: {},
      directives: {},
      provides: /* @__PURE__ */ Object.create(null),
      optionsCache: /* @__PURE__ */ new WeakMap(),
      propsCache: /* @__PURE__ */ new WeakMap(),
      emitsCache: /* @__PURE__ */ new WeakMap()
    };
  }
  let mS = 0;
  function yS(t, e) {
    return function(r, i = null) {
      Ge(r) || (r = Nn({}, r)), i != null && !zt(i) && (i = null);
      const s = x3(), o = /* @__PURE__ */ new WeakSet(), a = [];
      let c = false;
      const l = s.app = {
        _uid: mS++,
        _component: r,
        _props: i,
        _container: null,
        _context: s,
        _instance: null,
        version: XS,
        get config() {
          return s.config;
        },
        set config(u) {
        },
        use(u, ...f) {
          return o.has(u) || (u && Ge(u.install) ? (o.add(u), u.install(l, ...f)) : Ge(u) && (o.add(u), u(l, ...f))), l;
        },
        mixin(u) {
          return s.mixins.includes(u) || s.mixins.push(u), l;
        },
        component(u, f) {
          return f ? (s.components[u] = f, l) : s.components[u];
        },
        directive(u, f) {
          return f ? (s.directives[u] = f, l) : s.directives[u];
        },
        mount(u, f, d) {
          if (!c) {
            const m = l._ceVNode || Te(r, i);
            return m.appContext = s, d === true ? d = "svg" : d === false && (d = void 0), t(m, u, d), c = true, l._container = u, u.__vue_app__ = l, Md(m.component);
          }
        },
        onUnmount(u) {
          a.push(u);
        },
        unmount() {
          c && (wi(a, l._instance, 16), t(null, l._container), delete l._container.__vue_app__);
        },
        provide(u, f) {
          return s.provides[u] = f, l;
        },
        runWithContext(u) {
          const f = Aa;
          Aa = l;
          try {
            return u();
          } finally {
            Aa = f;
          }
        }
      };
      return l;
    };
  }
  let Aa = null;
  function wa(t, e) {
    if (Pn) {
      let n = Pn.provides;
      const r = Pn.parent && Pn.parent.provides;
      r === n && (n = Pn.provides = Object.create(r)), n[t] = e;
    }
  }
  qn = function(t, e, n = false) {
    const r = Pn || En;
    if (r || Aa) {
      let i = Aa ? Aa._context.provides : r ? r.parent == null || r.ce ? r.vnode.appContext && r.vnode.appContext.provides : r.parent.provides : void 0;
      if (i && t in i) return i[t];
      if (arguments.length > 1) return n && Ge(e) ? e.call(r && r.proxy) : e;
    }
  };
  function bS() {
    return !!(Pn || En || Aa);
  }
  const A3 = {}, w3 = () => Object.create(A3), v3 = (t) => Object.getPrototypeOf(t) === A3;
  function xS(t, e, n, r = false) {
    const i = {}, s = w3();
    t.propsDefaults = /* @__PURE__ */ Object.create(null), E3(t, e, i, s);
    for (const o in t.propsOptions[0]) o in i || (i[o] = void 0);
    n ? t.props = r ? i : zv(i) : t.type.props ? t.props = i : t.props = s, t.attrs = s;
  }
  function AS(t, e, n, r) {
    const { props: i, attrs: s, vnode: { patchFlag: o } } = t, a = at(i), [c] = t.propsOptions;
    let l = false;
    if ((r || o > 0) && !(o & 16)) {
      if (o & 8) {
        const u = t.vnode.dynamicProps;
        for (let f = 0; f < u.length; f++) {
          let d = u[f];
          if (Od(t.emitsOptions, d)) continue;
          const m = e[d];
          if (c) if (dt(s, d)) m !== s[d] && (s[d] = m, l = true);
          else {
            const y = Wr(d);
            i[y] = zg(c, a, y, m, t, false);
          }
          else m !== s[d] && (s[d] = m, l = true);
        }
      }
    } else {
      E3(t, e, i, s) && (l = true);
      let u;
      for (const f in a) (!e || !dt(e, f) && ((u = Da(f)) === f || !dt(e, u))) && (c ? n && (n[f] !== void 0 || n[u] !== void 0) && (i[f] = zg(c, a, f, void 0, t, true)) : delete i[f]);
      if (s !== a) for (const f in s) (!e || !dt(e, f)) && (delete s[f], l = true);
    }
    l && Ss(t.attrs, "set", "");
  }
  function E3(t, e, n, r) {
    const [i, s] = t.propsOptions;
    let o = false, a;
    if (e) for (let c in e) {
      if (ru(c)) continue;
      const l = e[c];
      let u;
      i && dt(i, u = Wr(c)) ? !s || !s.includes(u) ? n[u] = l : (a || (a = {}))[u] = l : Od(t.emitsOptions, c) || (!(c in r) || l !== r[c]) && (r[c] = l, o = true);
    }
    if (s) {
      const c = at(n), l = a || bt;
      for (let u = 0; u < s.length; u++) {
        const f = s[u];
        n[f] = zg(i, c, f, l[f], t, !dt(l, f));
      }
    }
    return o;
  }
  function zg(t, e, n, r, i, s) {
    const o = t[n];
    if (o != null) {
      const a = dt(o, "default");
      if (a && r === void 0) {
        const c = o.default;
        if (o.type !== Function && !o.skipFactory && Ge(c)) {
          const { propsDefaults: l } = i;
          if (n in l) r = l[n];
          else {
            const u = sf(i);
            r = l[n] = c.call(null, e), u();
          }
        } else r = c;
        i.ce && i.ce._setProp(n, r);
      }
      o[0] && (s && !a ? r = false : o[1] && (r === "" || r === Da(n)) && (r = true));
    }
    return r;
  }
  const wS = /* @__PURE__ */ new WeakMap();
  function S3(t, e, n = false) {
    const r = n ? wS : e.propsCache, i = r.get(t);
    if (i) return i;
    const s = t.props, o = {}, a = [];
    let c = false;
    if (!Ge(t)) {
      const u = (f) => {
        c = true;
        const [d, m] = S3(f, e, true);
        Nn(o, d), m && a.push(...m);
      };
      !n && e.mixins.length && e.mixins.forEach(u), t.extends && u(t.extends), t.mixins && t.mixins.forEach(u);
    }
    if (!s && !c) return zt(t) && r.set(t, _c), _c;
    if (Be(s)) for (let u = 0; u < s.length; u++) {
      const f = Wr(s[u]);
      yb(f) && (o[f] = bt);
    }
    else if (s) for (const u in s) {
      const f = Wr(u);
      if (yb(f)) {
        const d = s[u], m = o[f] = Be(d) || Ge(d) ? {
          type: d
        } : Nn({}, d), y = m.type;
        let x = false, w = true;
        if (Be(y)) for (let R = 0; R < y.length; ++R) {
          const O = y[R], B = Ge(O) && O.name;
          if (B === "Boolean") {
            x = true;
            break;
          } else B === "String" && (w = false);
        }
        else x = Ge(y) && y.name === "Boolean";
        m[0] = x, m[1] = w, (x || dt(m, "default")) && a.push(f);
      }
    }
    const l = [
      o,
      a
    ];
    return zt(t) && r.set(t, l), l;
  }
  function yb(t) {
    return t[0] !== "$" && !ru(t);
  }
  const R1 = (t) => t[0] === "_" || t === "$stable", N1 = (t) => Be(t) ? t.map(Li) : [
    Li(t)
  ], vS = (t, e, n) => {
    if (e._n) return e;
    const r = jc((...i) => N1(e(...i)), n);
    return r._c = false, r;
  }, T3 = (t, e, n) => {
    const r = t._ctx;
    for (const i in t) {
      if (R1(i)) continue;
      const s = t[i];
      if (Ge(s)) e[i] = vS(i, s, r);
      else if (s != null) {
        const o = N1(s);
        e[i] = () => o;
      }
    }
  }, C3 = (t, e) => {
    const n = N1(e);
    t.slots.default = () => n;
  }, I3 = (t, e, n) => {
    for (const r in e) (n || !R1(r)) && (t[r] = e[r]);
  }, ES = (t, e, n) => {
    const r = t.slots = w3();
    if (t.vnode.shapeFlag & 32) {
      const i = e.__;
      i && Bg(r, "__", i, true);
      const s = e._;
      s ? (I3(r, e, n), n && Bg(r, "_", s, true)) : T3(e, r);
    } else e && C3(t, e);
  }, SS = (t, e, n) => {
    const { vnode: r, slots: i } = t;
    let s = true, o = bt;
    if (r.shapeFlag & 32) {
      const a = e._;
      a ? n && a === 1 ? s = false : I3(i, e, n) : (s = !e.$stable, T3(e, i)), o = e;
    } else e && (C3(t, e), o = {
      default: 1
    });
    if (s) for (const a in i) !R1(a) && o[a] == null && delete i[a];
  }, wn = DS;
  function TS(t) {
    return CS(t);
  }
  function CS(t, e) {
    const n = Td();
    n.__VUE__ = true;
    const { insert: r, remove: i, patchProp: s, createElement: o, createText: a, createComment: c, setText: l, setElementText: u, parentNode: f, nextSibling: d, setScopeId: m = Ki, insertStaticContent: y } = t, x = (G, W, V, te = null, pe = null, ue = null, ye = void 0, we = null, Q = !!W.dynamicChildren) => {
      if (G === W) return;
      G && !mo(G, W) && (te = k(G), g(G, pe, ue, true), G = null), W.patchFlag === -2 && (Q = false, W.dynamicChildren = null);
      const { type: j, ref: ae, shapeFlag: le } = W;
      switch (j) {
        case rf:
          w(G, W, V, te);
          break;
        case Dn:
          R(G, W, V, te);
          break;
        case sp:
          G == null && O(W, V, te, ye);
          break;
        case jn:
          z(G, W, V, te, pe, ue, ye, we, Q);
          break;
        default:
          le & 1 ? D(G, W, V, te, pe, ue, ye, we, Q) : le & 6 ? I(G, W, V, te, pe, ue, ye, we, Q) : (le & 64 || le & 128) && j.process(G, W, V, te, pe, ue, ye, we, Q, ce);
      }
      ae != null && pe ? au(ae, G && G.ref, ue, W || G, !W) : ae == null && G && G.ref != null && au(G.ref, null, ue, G, true);
    }, w = (G, W, V, te) => {
      if (G == null) r(W.el = a(W.children), V, te);
      else {
        const pe = W.el = G.el;
        W.children !== G.children && l(pe, W.children);
      }
    }, R = (G, W, V, te) => {
      G == null ? r(W.el = c(W.children || ""), V, te) : W.el = G.el;
    }, O = (G, W, V, te) => {
      [G.el, G.anchor] = y(G.children, W, V, te, G.el, G.anchor);
    }, B = ({ el: G, anchor: W }, V, te) => {
      let pe;
      for (; G && G !== W; ) pe = d(G), r(G, V, te), G = pe;
      r(W, V, te);
    }, M = ({ el: G, anchor: W }) => {
      let V;
      for (; G && G !== W; ) V = d(G), i(G), G = V;
      i(W);
    }, D = (G, W, V, te, pe, ue, ye, we, Q) => {
      W.type === "svg" ? ye = "svg" : W.type === "math" && (ye = "mathml"), G == null ? H(W, V, te, pe, ue, ye, we, Q) : P(G, W, pe, ue, ye, we, Q);
    }, H = (G, W, V, te, pe, ue, ye, we) => {
      let Q, j;
      const { props: ae, shapeFlag: le, transition: be, dirs: xe } = G;
      if (Q = G.el = o(G.type, ue, ae && ae.is, ae), le & 8 ? u(Q, G.children) : le & 16 && S(G.children, Q, null, te, pe, ip(G, ue), ye, we), xe && Yo(G, null, te, "created"), q(Q, G, G.scopeId, ye, te), ae) {
        for (const _ in ae) _ !== "value" && !ru(_) && s(Q, _, null, ae[_], ue, te);
        "value" in ae && s(Q, "value", null, ae.value, ue), (j = ae.onVnodeBeforeMount) && Ur(j, te, G);
      }
      xe && Yo(G, null, te, "beforeMount");
      const ie = IS(pe, be);
      ie && be.beforeEnter(Q), r(Q, W, V), ((j = ae && ae.onVnodeMounted) || ie || xe) && wn(() => {
        j && Ur(j, te, G), ie && be.enter(Q), xe && Yo(G, null, te, "mounted");
      }, pe);
    }, q = (G, W, V, te, pe) => {
      if (V && m(G, V), te) for (let ue = 0; ue < te.length; ue++) m(G, te[ue]);
      if (pe) {
        let ue = pe.subTree;
        if (W === ue || H0(ue.type) && (ue.ssContent === W || ue.ssFallback === W)) {
          const ye = pe.vnode;
          q(G, ye, ye.scopeId, ye.slotScopeIds, pe.parent);
        }
      }
    }, S = (G, W, V, te, pe, ue, ye, we, Q = 0) => {
      for (let j = Q; j < G.length; j++) {
        const ae = G[j] = we ? po(G[j]) : Li(G[j]);
        x(null, ae, W, V, te, pe, ue, ye, we);
      }
    }, P = (G, W, V, te, pe, ue, ye) => {
      const we = W.el = G.el;
      let { patchFlag: Q, dynamicChildren: j, dirs: ae } = W;
      Q |= G.patchFlag & 16;
      const le = G.props || bt, be = W.props || bt;
      let xe;
      if (V && Xo(V, false), (xe = be.onVnodeBeforeUpdate) && Ur(xe, V, W, G), ae && Yo(W, G, V, "beforeUpdate"), V && Xo(V, true), (le.innerHTML && be.innerHTML == null || le.textContent && be.textContent == null) && u(we, ""), j ? L(G.dynamicChildren, j, we, V, te, ip(W, pe), ue) : ye || N(G, W, we, null, V, te, ip(W, pe), ue, false), Q > 0) {
        if (Q & 16) K(we, le, be, V, pe);
        else if (Q & 2 && le.class !== be.class && s(we, "class", null, be.class, pe), Q & 4 && s(we, "style", le.style, be.style, pe), Q & 8) {
          const ie = W.dynamicProps;
          for (let _ = 0; _ < ie.length; _++) {
            const b = ie[_], v = le[b], J = be[b];
            (J !== v || b === "value") && s(we, b, v, J, pe, V);
          }
        }
        Q & 1 && G.children !== W.children && u(we, W.children);
      } else !ye && j == null && K(we, le, be, V, pe);
      ((xe = be.onVnodeUpdated) || ae) && wn(() => {
        xe && Ur(xe, V, W, G), ae && Yo(W, G, V, "updated");
      }, te);
    }, L = (G, W, V, te, pe, ue, ye) => {
      for (let we = 0; we < W.length; we++) {
        const Q = G[we], j = W[we], ae = Q.el && (Q.type === jn || !mo(Q, j) || Q.shapeFlag & 198) ? f(Q.el) : V;
        x(Q, j, ae, null, te, pe, ue, ye, true);
      }
    }, K = (G, W, V, te, pe) => {
      if (W !== V) {
        if (W !== bt) for (const ue in W) !ru(ue) && !(ue in V) && s(G, ue, W[ue], null, pe, te);
        for (const ue in V) {
          if (ru(ue)) continue;
          const ye = V[ue], we = W[ue];
          ye !== we && ue !== "value" && s(G, ue, we, ye, pe, te);
        }
        "value" in V && s(G, "value", W.value, V.value, pe);
      }
    }, z = (G, W, V, te, pe, ue, ye, we, Q) => {
      const j = W.el = G ? G.el : a(""), ae = W.anchor = G ? G.anchor : a("");
      let { patchFlag: le, dynamicChildren: be, slotScopeIds: xe } = W;
      xe && (we = we ? we.concat(xe) : xe), G == null ? (r(j, V, te), r(ae, V, te), S(W.children || [], V, ae, pe, ue, ye, we, Q)) : le > 0 && le & 64 && be && G.dynamicChildren ? (L(G.dynamicChildren, be, V, pe, ue, ye, we), (W.key != null || pe && W === pe.subTree) && O1(G, W, true)) : N(G, W, V, ae, pe, ue, ye, we, Q);
    }, I = (G, W, V, te, pe, ue, ye, we, Q) => {
      W.slotScopeIds = we, G == null ? W.shapeFlag & 512 ? pe.ctx.activate(W, V, te, ye, Q) : h(W, V, te, pe, ue, ye, Q) : p(G, W, Q);
    }, h = (G, W, V, te, pe, ue, ye) => {
      const we = G.component = jS(G, te, pe);
      if (Pd(G) && (we.ctx.renderer = ce), JS(we, false, ye), we.asyncDep) {
        if (pe && pe.registerDep(we, A, ye), !G.el) {
          const Q = we.subTree = Te(Dn);
          R(null, Q, W, V);
        }
      } else A(we, G, W, V, pe, ue, ye);
    }, p = (G, W, V) => {
      const te = W.component = G.component;
      if (FS(G, W, V)) if (te.asyncDep && !te.asyncResolved) {
        C(te, W, V);
        return;
      } else te.next = W, te.update();
      else W.el = G.el, te.vnode = W;
    }, A = (G, W, V, te, pe, ue, ye) => {
      const we = () => {
        if (G.isMounted) {
          let { next: le, bu: be, u: xe, parent: ie, vnode: _ } = G;
          {
            const se = P3(G);
            if (se) {
              le && (le.el = _.el, C(G, le, ye)), se.asyncDep.then(() => {
                G.isUnmounted || we();
              });
              return;
            }
          }
          let b = le, v;
          Xo(G, false), le ? (le.el = _.el, C(G, le, ye)) : le = _, be && Nc(be), (v = le.props && le.props.onVnodeBeforeUpdate) && Ur(v, ie, le, _), Xo(G, true);
          const J = bb(G), ne = G.subTree;
          G.subTree = J, x(ne, J, f(ne.el), k(ne), G, pe, ue), le.el = J.el, b === null && LS(G, J.el), xe && wn(xe, pe), (v = le.props && le.props.onVnodeUpdated) && wn(() => Ur(v, ie, le, _), pe);
        } else {
          let le;
          const { el: be, props: xe } = W, { bm: ie, m: _, parent: b, root: v, type: J } = G, ne = xa(W);
          Xo(G, false), ie && Nc(ie), !ne && (le = xe && xe.onVnodeBeforeMount) && Ur(le, b, W), Xo(G, true);
          {
            v.ce && v.ce._def.shadowRoot !== false && v.ce._injectChildStyle(J);
            const se = G.subTree = bb(G);
            x(null, se, V, te, G, pe, ue), W.el = se.el;
          }
          if (_ && wn(_, pe), !ne && (le = xe && xe.onVnodeMounted)) {
            const se = W;
            wn(() => Ur(le, b, se), pe);
          }
          (W.shapeFlag & 256 || b && xa(b.vnode) && b.vnode.shapeFlag & 256) && G.a && wn(G.a, pe), G.isMounted = true, W = V = te = null;
        }
      };
      G.scope.on();
      const Q = G.effect = new _v(we);
      G.scope.off();
      const j = G.update = Q.run.bind(Q), ae = G.job = Q.runIfDirty.bind(Q);
      ae.i = G, ae.id = G.uid, Q.scheduler = () => P1(ae), Xo(G, true), j();
    }, C = (G, W, V) => {
      W.component = G;
      const te = G.vnode.props;
      G.vnode = W, G.next = null, AS(G, W.props, te, V), SS(G, W.children, V), Ns(), ab(G), Os();
    }, N = (G, W, V, te, pe, ue, ye, we, Q = false) => {
      const j = G && G.children, ae = G ? G.shapeFlag : 0, le = W.children, { patchFlag: be, shapeFlag: xe } = W;
      if (be > 0) {
        if (be & 128) {
          Y(j, le, V, te, pe, ue, ye, we, Q);
          return;
        } else if (be & 256) {
          U(j, le, V, te, pe, ue, ye, we, Q);
          return;
        }
      }
      xe & 8 ? (ae & 16 && Z(j, pe, ue), le !== j && u(V, le)) : ae & 16 ? xe & 16 ? Y(j, le, V, te, pe, ue, ye, we, Q) : Z(j, pe, ue, true) : (ae & 8 && u(V, ""), xe & 16 && S(le, V, te, pe, ue, ye, we, Q));
    }, U = (G, W, V, te, pe, ue, ye, we, Q) => {
      G = G || _c, W = W || _c;
      const j = G.length, ae = W.length, le = Math.min(j, ae);
      let be;
      for (be = 0; be < le; be++) {
        const xe = W[be] = Q ? po(W[be]) : Li(W[be]);
        x(G[be], xe, V, null, pe, ue, ye, we, Q);
      }
      j > ae ? Z(G, pe, ue, true, false, le) : S(W, V, te, pe, ue, ye, we, Q, le);
    }, Y = (G, W, V, te, pe, ue, ye, we, Q) => {
      let j = 0;
      const ae = W.length;
      let le = G.length - 1, be = ae - 1;
      for (; j <= le && j <= be; ) {
        const xe = G[j], ie = W[j] = Q ? po(W[j]) : Li(W[j]);
        if (mo(xe, ie)) x(xe, ie, V, null, pe, ue, ye, we, Q);
        else break;
        j++;
      }
      for (; j <= le && j <= be; ) {
        const xe = G[le], ie = W[be] = Q ? po(W[be]) : Li(W[be]);
        if (mo(xe, ie)) x(xe, ie, V, null, pe, ue, ye, we, Q);
        else break;
        le--, be--;
      }
      if (j > le) {
        if (j <= be) {
          const xe = be + 1, ie = xe < ae ? W[xe].el : te;
          for (; j <= be; ) x(null, W[j] = Q ? po(W[j]) : Li(W[j]), V, ie, pe, ue, ye, we, Q), j++;
        }
      } else if (j > be) for (; j <= le; ) g(G[j], pe, ue, true), j++;
      else {
        const xe = j, ie = j, _ = /* @__PURE__ */ new Map();
        for (j = ie; j <= be; j++) {
          const Re = W[j] = Q ? po(W[j]) : Li(W[j]);
          Re.key != null && _.set(Re.key, j);
        }
        let b, v = 0;
        const J = be - ie + 1;
        let ne = false, se = 0;
        const de = new Array(J);
        for (j = 0; j < J; j++) de[j] = 0;
        for (j = xe; j <= le; j++) {
          const Re = G[j];
          if (v >= J) {
            g(Re, pe, ue, true);
            continue;
          }
          let Ne;
          if (Re.key != null) Ne = _.get(Re.key);
          else for (b = ie; b <= be; b++) if (de[b - ie] === 0 && mo(Re, W[b])) {
            Ne = b;
            break;
          }
          Ne === void 0 ? g(Re, pe, ue, true) : (de[Ne - ie] = j + 1, Ne >= se ? se = Ne : ne = true, x(Re, W[Ne], V, null, pe, ue, ye, we, Q), v++);
        }
        const Fe = ne ? PS(de) : _c;
        for (b = Fe.length - 1, j = J - 1; j >= 0; j--) {
          const Re = ie + j, Ne = W[Re], ot = Re + 1 < ae ? W[Re + 1].el : te;
          de[j] === 0 ? x(null, Ne, V, ot, pe, ue, ye, we, Q) : ne && (b < 0 || j !== Fe[b] ? T(Ne, V, ot, 2) : b--);
        }
      }
    }, T = (G, W, V, te, pe = null) => {
      const { el: ue, type: ye, transition: we, children: Q, shapeFlag: j } = G;
      if (j & 6) {
        T(G.component.subTree, W, V, te);
        return;
      }
      if (j & 128) {
        G.suspense.move(W, V, te);
        return;
      }
      if (j & 64) {
        ye.move(G, W, V, ce);
        return;
      }
      if (ye === jn) {
        r(ue, W, V);
        for (let le = 0; le < Q.length; le++) T(Q[le], W, V, te);
        r(G.anchor, W, V);
        return;
      }
      if (ye === sp) {
        B(G, W, V);
        return;
      }
      if (te !== 2 && j & 1 && we) if (te === 0) we.beforeEnter(ue), r(ue, W, V), wn(() => we.enter(ue), pe);
      else {
        const { leave: le, delayLeave: be, afterLeave: xe } = we, ie = () => {
          G.ctx.isUnmounted ? i(ue) : r(ue, W, V);
        }, _ = () => {
          le(ue, () => {
            ie(), xe && xe();
          });
        };
        be ? be(ue, ie, _) : _();
      }
      else r(ue, W, V);
    }, g = (G, W, V, te = false, pe = false) => {
      const { type: ue, props: ye, ref: we, children: Q, dynamicChildren: j, shapeFlag: ae, patchFlag: le, dirs: be, cacheIndex: xe } = G;
      if (le === -2 && (pe = false), we != null && (Ns(), au(we, null, V, G, true), Os()), xe != null && (W.renderCache[xe] = void 0), ae & 256) {
        W.ctx.deactivate(G);
        return;
      }
      const ie = ae & 1 && be, _ = !xa(G);
      let b;
      if (_ && (b = ye && ye.onVnodeBeforeUnmount) && Ur(b, W, G), ae & 6) E(G.component, V, te);
      else {
        if (ae & 128) {
          G.suspense.unmount(V, te);
          return;
        }
        ie && Yo(G, null, W, "beforeUnmount"), ae & 64 ? G.type.remove(G, W, V, ce, te) : j && !j.hasOnce && (ue !== jn || le > 0 && le & 64) ? Z(j, W, V, false, true) : (ue === jn && le & 384 || !pe && ae & 16) && Z(Q, W, V), te && F(G);
      }
      (_ && (b = ye && ye.onVnodeUnmounted) || ie) && wn(() => {
        b && Ur(b, W, G), ie && Yo(G, null, W, "unmounted");
      }, V);
    }, F = (G) => {
      const { type: W, el: V, anchor: te, transition: pe } = G;
      if (W === jn) {
        ee(V, te);
        return;
      }
      if (W === sp) {
        M(G);
        return;
      }
      const ue = () => {
        i(V), pe && !pe.persisted && pe.afterLeave && pe.afterLeave();
      };
      if (G.shapeFlag & 1 && pe && !pe.persisted) {
        const { leave: ye, delayLeave: we } = pe, Q = () => ye(V, ue);
        we ? we(G.el, ue, Q) : Q();
      } else ue();
    }, ee = (G, W) => {
      let V;
      for (; G !== W; ) V = d(G), i(G), G = V;
      i(W);
    }, E = (G, W, V) => {
      const { bum: te, scope: pe, job: ue, subTree: ye, um: we, m: Q, a: j, parent: ae, slots: { __: le } } = G;
      U0(Q), U0(j), te && Nc(te), ae && Be(le) && le.forEach((be) => {
        ae.renderCache[be] = void 0;
      }), pe.stop(), ue && (ue.flags |= 8, g(ye, G, W, V)), we && wn(we, W), wn(() => {
        G.isUnmounted = true;
      }, W), W && W.pendingBranch && !W.isUnmounted && G.asyncDep && !G.asyncResolved && G.suspenseId === W.pendingId && (W.deps--, W.deps === 0 && W.resolve());
    }, Z = (G, W, V, te = false, pe = false, ue = 0) => {
      for (let ye = ue; ye < G.length; ye++) g(G[ye], W, V, te, pe);
    }, k = (G) => {
      if (G.shapeFlag & 6) return k(G.component.subTree);
      if (G.shapeFlag & 128) return G.suspense.next();
      const W = d(G.anchor || G.el), V = W && W[$v];
      return V ? d(V) : W;
    };
    let X = false;
    const $ = (G, W, V) => {
      G == null ? W._vnode && g(W._vnode, null, null, true) : x(W._vnode || null, G, W, null, null, null, V), W._vnode = G, X || (X = true, ab(), qv(), X = false);
    }, ce = {
      p: x,
      um: g,
      m: T,
      r: F,
      mt: h,
      mc: S,
      pc: N,
      pbc: L,
      n: k,
      o: t
    };
    return {
      render: $,
      hydrate: void 0,
      createApp: yS($)
    };
  }
  function ip({ type: t, props: e }, n) {
    return n === "svg" && t === "foreignObject" || n === "mathml" && t === "annotation-xml" && e && e.encoding && e.encoding.includes("html") ? void 0 : n;
  }
  function Xo({ effect: t, job: e }, n) {
    n ? (t.flags |= 32, e.flags |= 4) : (t.flags &= -33, e.flags &= -5);
  }
  function IS(t, e) {
    return (!t || t && !t.pendingBranch) && e && !e.persisted;
  }
  function O1(t, e, n = false) {
    const r = t.children, i = e.children;
    if (Be(r) && Be(i)) for (let s = 0; s < r.length; s++) {
      const o = r[s];
      let a = i[s];
      a.shapeFlag & 1 && !a.dynamicChildren && ((a.patchFlag <= 0 || a.patchFlag === 32) && (a = i[s] = po(i[s]), a.el = o.el), !n && a.patchFlag !== -2 && O1(o, a)), a.type === rf && (a.el = o.el), a.type === Dn && !a.el && (a.el = o.el);
    }
  }
  function PS(t) {
    const e = t.slice(), n = [
      0
    ];
    let r, i, s, o, a;
    const c = t.length;
    for (r = 0; r < c; r++) {
      const l = t[r];
      if (l !== 0) {
        if (i = n[n.length - 1], t[i] < l) {
          e[r] = i, n.push(r);
          continue;
        }
        for (s = 0, o = n.length - 1; s < o; ) a = s + o >> 1, t[n[a]] < l ? s = a + 1 : o = a;
        l < t[n[s]] && (s > 0 && (e[r] = n[s - 1]), n[s] = r);
      }
    }
    for (s = n.length, o = n[s - 1]; s-- > 0; ) n[s] = o, o = e[o];
    return n;
  }
  function P3(t) {
    const e = t.subTree.component;
    if (e) return e.asyncDep && !e.asyncResolved ? e : P3(e);
  }
  function U0(t) {
    if (t) for (let e = 0; e < t.length; e++) t[e].flags |= 8;
  }
  const _S = Symbol.for("v-scx"), RS = () => qn(_S);
  vW = function(t, e) {
    return B1(t, null, e);
  };
  xn = function(t, e, n) {
    return B1(t, e, n);
  };
  function B1(t, e, n = bt) {
    const { immediate: r, deep: i, flush: s, once: o } = n, a = Nn({}, n), c = e && r || !e && s !== "post";
    let l;
    if (Ru) {
      if (s === "sync") {
        const m = RS();
        l = m.__watcherHandles || (m.__watcherHandles = []);
      } else if (!c) {
        const m = () => {
        };
        return m.stop = Ki, m.resume = Ki, m.pause = Ki, m;
      }
    }
    const u = Pn;
    a.call = (m, y, x) => wi(m, u, y, x);
    let f = false;
    s === "post" ? a.scheduler = (m) => {
      wn(m, u && u.suspense);
    } : s !== "sync" && (f = true, a.scheduler = (m, y) => {
      y ? m() : P1(m);
    }), a.augmentJob = (m) => {
      e && (m.flags |= 4), f && (m.flags |= 2, u && (m.id = u.uid, m.i = u));
    };
    const d = J9(t, e, a);
    return Ru && (l ? l.push(d) : c && d()), d;
  }
  function NS(t, e, n) {
    const r = this.proxy, i = jt(t) ? t.includes(".") ? _3(r, t) : () => r[t] : t.bind(r, r);
    let s;
    Ge(e) ? s = e : (s = e.handler, n = e);
    const o = sf(this), a = B1(i, s.bind(r), n);
    return o(), a;
  }
  function _3(t, e) {
    const n = e.split(".");
    return () => {
      let r = t;
      for (let i = 0; i < n.length && r; i++) r = r[n[i]];
      return r;
    };
  }
  const OS = (t, e) => e === "modelValue" || e === "model-value" ? t.modelModifiers : t[`${e}Modifiers`] || t[`${Wr(e)}Modifiers`] || t[`${Da(e)}Modifiers`];
  function BS(t, e, ...n) {
    if (t.isUnmounted) return;
    const r = t.vnode.props || bt;
    let i = n;
    const s = e.startsWith("update:"), o = s && OS(r, e.slice(7));
    o && (o.trim && (i = n.map((u) => jt(u) ? u.trim() : u)), o.number && (i = n.map(Mg)));
    let a, c = r[a = Yh(e)] || r[a = Yh(Wr(e))];
    !c && s && (c = r[a = Yh(Da(e))]), c && wi(c, t, 6, i);
    const l = r[a + "Once"];
    if (l) {
      if (!t.emitted) t.emitted = {};
      else if (t.emitted[a]) return;
      t.emitted[a] = true, wi(l, t, 6, i);
    }
  }
  function R3(t, e, n = false) {
    const r = e.emitsCache, i = r.get(t);
    if (i !== void 0) return i;
    const s = t.emits;
    let o = {}, a = false;
    if (!Ge(t)) {
      const c = (l) => {
        const u = R3(l, e, true);
        u && (a = true, Nn(o, u));
      };
      !n && e.mixins.length && e.mixins.forEach(c), t.extends && c(t.extends), t.mixins && t.mixins.forEach(c);
    }
    return !s && !a ? (zt(t) && r.set(t, null), null) : (Be(s) ? s.forEach((c) => o[c] = null) : Nn(o, s), zt(t) && r.set(t, o), o);
  }
  function Od(t, e) {
    return !t || !vd(e) ? false : (e = e.slice(2).replace(/Once$/, ""), dt(t, e[0].toLowerCase() + e.slice(1)) || dt(t, Da(e)) || dt(t, e));
  }
  function bb(t) {
    const { type: e, vnode: n, proxy: r, withProxy: i, propsOptions: [s], slots: o, attrs: a, emit: c, render: l, renderCache: u, props: f, data: d, setupState: m, ctx: y, inheritAttrs: x } = t, w = L0(t);
    let R, O;
    try {
      if (n.shapeFlag & 4) {
        const M = i || r, D = M;
        R = Li(l.call(D, M, u, f, m, d, y)), O = a;
      } else {
        const M = e;
        R = Li(M.length > 1 ? M(f, {
          attrs: a,
          slots: o,
          emit: c
        }) : M(f, null)), O = e.props ? a : MS(a);
      }
    } catch (M) {
      lu.length = 0, Id(M, t, 1), R = Te(Dn);
    }
    let B = R;
    if (O && x !== false) {
      const M = Object.keys(O), { shapeFlag: D } = B;
      M.length && D & 7 && (s && M.some(h1) && (O = kS(O, s)), B = Bs(B, O, false, true));
    }
    return n.dirs && (B = Bs(B, null, false, true), B.dirs = B.dirs ? B.dirs.concat(n.dirs) : n.dirs), n.transition && Jc(B, n.transition), R = B, L0(w), R;
  }
  const MS = (t) => {
    let e;
    for (const n in t) (n === "class" || n === "style" || vd(n)) && ((e || (e = {}))[n] = t[n]);
    return e;
  }, kS = (t, e) => {
    const n = {};
    for (const r in t) (!h1(r) || !(r.slice(9) in e)) && (n[r] = t[r]);
    return n;
  };
  function FS(t, e, n) {
    const { props: r, children: i, component: s } = t, { props: o, children: a, patchFlag: c } = e, l = s.emitsOptions;
    if (e.dirs || e.transition) return true;
    if (n && c >= 0) {
      if (c & 1024) return true;
      if (c & 16) return r ? xb(r, o, l) : !!o;
      if (c & 8) {
        const u = e.dynamicProps;
        for (let f = 0; f < u.length; f++) {
          const d = u[f];
          if (o[d] !== r[d] && !Od(l, d)) return true;
        }
      }
    } else return (i || a) && (!a || !a.$stable) ? true : r === o ? false : r ? o ? xb(r, o, l) : true : !!o;
    return false;
  }
  function xb(t, e, n) {
    const r = Object.keys(e);
    if (r.length !== Object.keys(t).length) return true;
    for (let i = 0; i < r.length; i++) {
      const s = r[i];
      if (e[s] !== t[s] && !Od(n, s)) return true;
    }
    return false;
  }
  function LS({ vnode: t, parent: e }, n) {
    for (; e; ) {
      const r = e.subTree;
      if (r.suspense && r.suspense.activeBranch === t && (r.el = t.el), r === t) (t = e.vnode).el = n, e = e.parent;
      else break;
    }
  }
  const H0 = (t) => t.__isSuspense;
  function DS(t, e) {
    e && e.pendingBranch ? Be(t) ? e.effects.push(...t) : e.effects.push(t) : q9(t);
  }
  let rf, Dn, sp, lu;
  jn = Symbol.for("v-fgt");
  rf = Symbol.for("v-txt");
  Dn = Symbol.for("v-cmt");
  sp = Symbol.for("v-stc");
  lu = [];
  let Ir = null;
  fi = function(t = false) {
    lu.push(Ir = t ? null : []);
  };
  function US() {
    lu.pop(), Ir = lu[lu.length - 1] || null;
  }
  let _u = 1;
  function Ab(t, e = false) {
    _u += t, t < 0 && Ir && e && (Ir.hasOnce = true);
  }
  function N3(t) {
    return t.dynamicChildren = _u > 0 ? Ir || _c : null, US(), _u > 0 && Ir && Ir.push(t), t;
  }
  HS = function(t, e, n, r, i, s) {
    return N3(Qr(t, e, n, r, i, s, true));
  };
  Hi = function(t, e, n, r, i) {
    return N3(Te(t, e, n, r, i, true));
  };
  function Pa(t) {
    return t ? t.__v_isVNode === true : false;
  }
  function mo(t, e) {
    return t.type === e.type && t.key === e.key;
  }
  const O3 = ({ key: t }) => t ?? null, c0 = ({ ref: t, ref_key: e, ref_for: n }) => (typeof t == "number" && (t = "" + t), t != null ? jt(t) || Yt(t) || Ge(t) ? {
    i: En,
    r: t,
    k: e,
    f: !!n
  } : t : null);
  Qr = function(t, e = null, n = null, r = 0, i = null, s = t === jn ? 0 : 1, o = false, a = false) {
    const c = {
      __v_isVNode: true,
      __v_skip: true,
      type: t,
      props: e,
      key: e && O3(e),
      ref: e && c0(e),
      scopeId: Xv,
      slotScopeIds: null,
      children: n,
      component: null,
      suspense: null,
      ssContent: null,
      ssFallback: null,
      dirs: null,
      transition: null,
      el: null,
      anchor: null,
      target: null,
      targetStart: null,
      targetAnchor: null,
      staticCount: 0,
      shapeFlag: s,
      patchFlag: r,
      dynamicProps: i,
      dynamicChildren: null,
      appContext: null,
      ctx: En
    };
    return a ? (M1(c, n), s & 128 && t.normalize(c)) : n && (c.shapeFlag |= jt(n) ? 8 : 16), _u > 0 && !o && Ir && (c.patchFlag > 0 || s & 6) && c.patchFlag !== 32 && Ir.push(c), c;
  };
  Te = GS;
  function GS(t, e = null, n = null, r = 0, i = null, s = false) {
    if ((!t || t === p3) && (t = Dn), Pa(t)) {
      const a = Bs(t, e, true);
      return n && M1(a, n), _u > 0 && !s && Ir && (a.shapeFlag & 6 ? Ir[Ir.indexOf(t)] = a : Ir.push(a)), a.patchFlag = -2, a;
    }
    if (YS(t) && (t = t.__vccOpts), e) {
      e = VS(e);
      let { class: a, style: c } = e;
      a && !jt(a) && (e.class = y1(a)), zt(c) && (T1(c) && !Be(c) && (c = Nn({}, c)), e.style = m1(c));
    }
    const o = jt(t) ? 1 : H0(t) ? 128 : e3(t) ? 64 : zt(t) ? 4 : Ge(t) ? 2 : 0;
    return Qr(t, e, n, r, i, o, s, true);
  }
  function VS(t) {
    return t ? T1(t) || v3(t) ? Nn({}, t) : t : null;
  }
  function Bs(t, e, n = false, r = false) {
    const { props: i, ref: s, patchFlag: o, children: a, transition: c } = t, l = e ? Ms(i || {}, e) : i, u = {
      __v_isVNode: true,
      __v_skip: true,
      type: t.type,
      props: l,
      key: l && O3(l),
      ref: e && e.ref ? n && s ? Be(s) ? s.concat(c0(e)) : [
        s,
        c0(e)
      ] : c0(e) : s,
      scopeId: t.scopeId,
      slotScopeIds: t.slotScopeIds,
      children: a,
      target: t.target,
      targetStart: t.targetStart,
      targetAnchor: t.targetAnchor,
      staticCount: t.staticCount,
      shapeFlag: t.shapeFlag,
      patchFlag: e && t.type !== jn ? o === -1 ? 16 : o | 16 : o,
      dynamicProps: t.dynamicProps,
      dynamicChildren: t.dynamicChildren,
      appContext: t.appContext,
      dirs: t.dirs,
      transition: c,
      component: t.component,
      suspense: t.suspense,
      ssContent: t.ssContent && Bs(t.ssContent),
      ssFallback: t.ssFallback && Bs(t.ssFallback),
      el: t.el,
      anchor: t.anchor,
      ctx: t.ctx,
      ce: t.ce
    };
    return c && r && Jc(u, c.clone(u)), u;
  }
  Bd = function(t = " ", e = 0) {
    return Te(rf, null, t, e);
  };
  op = function(t = "", e = false) {
    return e ? (fi(), Hi(Dn, null, t)) : Te(Dn, null, t);
  };
  function Li(t) {
    return t == null || typeof t == "boolean" ? Te(Dn) : Be(t) ? Te(jn, null, t.slice()) : Pa(t) ? po(t) : Te(rf, null, String(t));
  }
  function po(t) {
    return t.el === null && t.patchFlag !== -1 || t.memo ? t : Bs(t);
  }
  function M1(t, e) {
    let n = 0;
    const { shapeFlag: r } = t;
    if (e == null) e = null;
    else if (Be(e)) n = 16;
    else if (typeof e == "object") if (r & 65) {
      const i = e.default;
      i && (i._c && (i._d = false), M1(t, i()), i._c && (i._d = true));
      return;
    } else {
      n = 32;
      const i = e._;
      !i && !v3(e) ? e._ctx = En : i === 3 && En && (En.slots._ === 1 ? e._ = 1 : (e._ = 2, t.patchFlag |= 1024));
    }
    else Ge(e) ? (e = {
      default: e,
      _ctx: En
    }, n = 32) : (e = String(e), r & 64 ? (n = 16, e = [
      Bd(e)
    ]) : n = 8);
    t.children = e, t.shapeFlag |= n;
  }
  Ms = function(...t) {
    const e = {};
    for (let n = 0; n < t.length; n++) {
      const r = t[n];
      for (const i in r) if (i === "class") e.class !== r.class && (e.class = y1([
        e.class,
        r.class
      ]));
      else if (i === "style") e.style = m1([
        e.style,
        r.style
      ]);
      else if (vd(i)) {
        const s = e[i], o = r[i];
        o && s !== o && !(Be(s) && s.includes(o)) && (e[i] = s ? [].concat(s, o) : o);
      } else i !== "" && (e[i] = r[i]);
    }
    return e;
  };
  function Ur(t, e, n, r = null) {
    wi(t, e, 7, [
      n,
      r
    ]);
  }
  const zS = x3();
  let QS = 0;
  function jS(t, e, n) {
    const r = t.type, i = (e ? e.appContext : t.appContext) || zS, s = {
      uid: QS++,
      vnode: t,
      type: r,
      parent: e,
      appContext: i,
      root: null,
      next: null,
      subTree: null,
      effect: null,
      update: null,
      job: null,
      scope: new Iv(true),
      render: null,
      proxy: null,
      exposed: null,
      exposeProxy: null,
      withProxy: null,
      provides: e ? e.provides : Object.create(i.provides),
      ids: e ? e.ids : [
        "",
        0,
        0
      ],
      accessCache: null,
      renderCache: [],
      components: null,
      directives: null,
      propsOptions: S3(r, i),
      emitsOptions: R3(r, i),
      emit: null,
      emitted: null,
      propsDefaults: bt,
      inheritAttrs: r.inheritAttrs,
      ctx: bt,
      data: bt,
      props: bt,
      attrs: bt,
      slots: bt,
      refs: bt,
      setupState: bt,
      setupContext: null,
      suspense: n,
      suspenseId: n ? n.pendingId : 0,
      asyncDep: null,
      asyncResolved: false,
      isMounted: false,
      isUnmounted: false,
      isDeactivated: false,
      bc: null,
      c: null,
      bm: null,
      m: null,
      bu: null,
      u: null,
      um: null,
      bum: null,
      da: null,
      a: null,
      rtg: null,
      rtc: null,
      ec: null,
      sp: null
    };
    return s.ctx = {
      _: s
    }, s.root = e ? e.root : s, s.emit = BS.bind(null, s), t.ce && t.ce(s), s;
  }
  let Pn = null;
  const xr = () => Pn || En;
  let G0, Qg;
  {
    const t = Td(), e = (n, r) => {
      let i;
      return (i = t[n]) || (i = t[n] = []), i.push(r), (s) => {
        i.length > 1 ? i.forEach((o) => o(s)) : i[0](s);
      };
    };
    G0 = e("__VUE_INSTANCE_SETTERS__", (n) => Pn = n), Qg = e("__VUE_SSR_SETTERS__", (n) => Ru = n);
  }
  const sf = (t) => {
    const e = Pn;
    return G0(t), t.scope.on(), () => {
      t.scope.off(), G0(e);
    };
  }, wb = () => {
    Pn && Pn.scope.off(), G0(null);
  };
  function B3(t) {
    return t.vnode.shapeFlag & 4;
  }
  let Ru = false;
  function JS(t, e = false, n = false) {
    e && Qg(e);
    const { props: r, children: i } = t.vnode, s = B3(t);
    xS(t, r, s, e), ES(t, i, n || e);
    const o = s ? KS(t, e) : void 0;
    return e && Qg(false), o;
  }
  function KS(t, e) {
    const n = t.type;
    t.accessCache = /* @__PURE__ */ Object.create(null), t.proxy = new Proxy(t.ctx, uS);
    const { setup: r } = n;
    if (r) {
      Ns();
      const i = t.setupContext = r.length > 1 ? qS(t) : null, s = sf(t), o = nf(r, t, 0, [
        t.props,
        i
      ]), a = wv(o);
      if (Os(), s(), (a || t.sp) && !xa(t) && l3(t), a) {
        if (o.then(wb, wb), e) return o.then((c) => {
          vb(t, c);
        }).catch((c) => {
          Id(c, t, 0);
        });
        t.asyncDep = o;
      } else vb(t, o);
    } else M3(t);
  }
  function vb(t, e, n) {
    Ge(e) ? t.type.__ssrInlineRender ? t.ssrRender = e : t.render = e : zt(e) && (t.setupState = Jv(e)), M3(t);
  }
  function M3(t, e, n) {
    const r = t.type;
    t.render || (t.render = r.render || Ki);
    {
      const i = sf(t);
      Ns();
      try {
        fS(t);
      } finally {
        Os(), i();
      }
    }
  }
  const WS = {
    get(t, e) {
      return Qn(t, "get", ""), t[e];
    }
  };
  function qS(t) {
    const e = (n) => {
      t.exposed = n || {};
    };
    return {
      attrs: new Proxy(t.attrs, WS),
      slots: t.slots,
      emit: t.emit,
      expose: e
    };
  }
  function Md(t) {
    return t.exposed ? t.exposeProxy || (t.exposeProxy = new Proxy(Jv(C1(t.exposed)), {
      get(e, n) {
        if (n in e) return e[n];
        if (n in cu) return cu[n](t);
      },
      has(e, n) {
        return n in e || n in cu;
      }
    })) : t.proxy;
  }
  function jg(t, e = true) {
    return Ge(t) ? t.displayName || t.name : t.name || e && t.__name;
  }
  function YS(t) {
    return Ge(t) && "__vccOpts" in t;
  }
  it = (t, e) => Q9(t, e, Ru);
  function of(t, e, n) {
    const r = arguments.length;
    return r === 2 ? zt(e) && !Be(e) ? Pa(e) ? Te(t, null, [
      e
    ]) : Te(t, e) : Te(t, null, e) : (r > 3 ? n = Array.prototype.slice.call(arguments, 2) : r === 3 && Pa(n) && (n = [
      n
    ]), Te(t, e, n));
  }
  const XS = "3.5.17";
  let Jg;
  const Eb = typeof window < "u" && window.trustedTypes;
  if (Eb) try {
    Jg = Eb.createPolicy("vue", {
      createHTML: (t) => t
    });
  } catch {
  }
  let k3, ZS, $S, ys, Sb, eT, $s, Ml, Nu, F3, tT, nT, Zo, Tb;
  k3 = Jg ? (t) => Jg.createHTML(t) : (t) => t;
  ZS = "http://www.w3.org/2000/svg";
  $S = "http://www.w3.org/1998/Math/MathML";
  ys = typeof document < "u" ? document : null;
  Sb = ys && ys.createElement("template");
  eT = {
    insert: (t, e, n) => {
      e.insertBefore(t, n || null);
    },
    remove: (t) => {
      const e = t.parentNode;
      e && e.removeChild(t);
    },
    createElement: (t, e, n, r) => {
      const i = e === "svg" ? ys.createElementNS(ZS, t) : e === "mathml" ? ys.createElementNS($S, t) : n ? ys.createElement(t, {
        is: n
      }) : ys.createElement(t);
      return t === "select" && r && r.multiple != null && i.setAttribute("multiple", r.multiple), i;
    },
    createText: (t) => ys.createTextNode(t),
    createComment: (t) => ys.createComment(t),
    setText: (t, e) => {
      t.nodeValue = e;
    },
    setElementText: (t, e) => {
      t.textContent = e;
    },
    parentNode: (t) => t.parentNode,
    nextSibling: (t) => t.nextSibling,
    querySelector: (t) => ys.querySelector(t),
    setScopeId(t, e) {
      t.setAttribute(e, "");
    },
    insertStaticContent(t, e, n, r, i, s) {
      const o = n ? n.previousSibling : e.lastChild;
      if (i && (i === s || i.nextSibling)) for (; e.insertBefore(i.cloneNode(true), n), !(i === s || !(i = i.nextSibling)); ) ;
      else {
        Sb.innerHTML = k3(r === "svg" ? `<svg>${t}</svg>` : r === "mathml" ? `<math>${t}</math>` : t);
        const a = Sb.content;
        if (r === "svg" || r === "mathml") {
          const c = a.firstChild;
          for (; c.firstChild; ) a.appendChild(c.firstChild);
          a.removeChild(c);
        }
        e.insertBefore(a, n);
      }
      return [
        o ? o.nextSibling : e.firstChild,
        n ? n.previousSibling : e.lastChild
      ];
    }
  };
  $s = "transition";
  Ml = "animation";
  Nu = Symbol("_vtc");
  F3 = {
    name: String,
    type: String,
    css: {
      type: Boolean,
      default: true
    },
    duration: [
      String,
      Number,
      Object
    ],
    enterFromClass: String,
    enterActiveClass: String,
    enterToClass: String,
    appearFromClass: String,
    appearActiveClass: String,
    appearToClass: String,
    leaveFromClass: String,
    leaveActiveClass: String,
    leaveToClass: String
  };
  tT = Nn({}, i3, F3);
  nT = (t) => (t.displayName = "Transition", t.props = tT, t);
  L3 = nT((t, { slots: e }) => of($9, rT(t), e));
  Zo = (t, e = []) => {
    Be(t) ? t.forEach((n) => n(...e)) : t && t(...e);
  };
  Tb = (t) => t ? Be(t) ? t.some((e) => e.length > 1) : t.length > 1 : false;
  function rT(t) {
    const e = {};
    for (const z in t) z in F3 || (e[z] = t[z]);
    if (t.css === false) return e;
    const { name: n = "v", type: r, duration: i, enterFromClass: s = `${n}-enter-from`, enterActiveClass: o = `${n}-enter-active`, enterToClass: a = `${n}-enter-to`, appearFromClass: c = s, appearActiveClass: l = o, appearToClass: u = a, leaveFromClass: f = `${n}-leave-from`, leaveActiveClass: d = `${n}-leave-active`, leaveToClass: m = `${n}-leave-to` } = t, y = iT(i), x = y && y[0], w = y && y[1], { onBeforeEnter: R, onEnter: O, onEnterCancelled: B, onLeave: M, onLeaveCancelled: D, onBeforeAppear: H = R, onAppear: q = O, onAppearCancelled: S = B } = e, P = (z, I, h, p) => {
      z._enterCancelled = p, $o(z, I ? u : a), $o(z, I ? l : o), h && h();
    }, L = (z, I) => {
      z._isLeaving = false, $o(z, f), $o(z, m), $o(z, d), I && I();
    }, K = (z) => (I, h) => {
      const p = z ? q : O, A = () => P(I, z, h);
      Zo(p, [
        I,
        A
      ]), Cb(() => {
        $o(I, z ? c : s), fs(I, z ? u : a), Tb(p) || Ib(I, r, x, A);
      });
    };
    return Nn(e, {
      onBeforeEnter(z) {
        Zo(R, [
          z
        ]), fs(z, s), fs(z, o);
      },
      onBeforeAppear(z) {
        Zo(H, [
          z
        ]), fs(z, c), fs(z, l);
      },
      onEnter: K(false),
      onAppear: K(true),
      onLeave(z, I) {
        z._isLeaving = true;
        const h = () => L(z, I);
        fs(z, f), z._enterCancelled ? (fs(z, d), Rb()) : (Rb(), fs(z, d)), Cb(() => {
          z._isLeaving && ($o(z, f), fs(z, m), Tb(M) || Ib(z, r, w, h));
        }), Zo(M, [
          z,
          h
        ]);
      },
      onEnterCancelled(z) {
        P(z, false, void 0, true), Zo(B, [
          z
        ]);
      },
      onAppearCancelled(z) {
        P(z, true, void 0, true), Zo(S, [
          z
        ]);
      },
      onLeaveCancelled(z) {
        L(z), Zo(D, [
          z
        ]);
      }
    });
  }
  function iT(t) {
    if (t == null) return null;
    if (zt(t)) return [
      ap(t.enter),
      ap(t.leave)
    ];
    {
      const e = ap(t);
      return [
        e,
        e
      ];
    }
  }
  function ap(t) {
    return f9(t);
  }
  function fs(t, e) {
    e.split(/\s+/).forEach((n) => n && t.classList.add(n)), (t[Nu] || (t[Nu] = /* @__PURE__ */ new Set())).add(e);
  }
  function $o(t, e) {
    e.split(/\s+/).forEach((r) => r && t.classList.remove(r));
    const n = t[Nu];
    n && (n.delete(e), n.size || (t[Nu] = void 0));
  }
  function Cb(t) {
    requestAnimationFrame(() => {
      requestAnimationFrame(t);
    });
  }
  let sT = 0;
  function Ib(t, e, n, r) {
    const i = t._endId = ++sT, s = () => {
      i === t._endId && r();
    };
    if (n != null) return setTimeout(s, n);
    const { type: o, timeout: a, propCount: c } = oT(t, e);
    if (!o) return r();
    const l = o + "end";
    let u = 0;
    const f = () => {
      t.removeEventListener(l, d), s();
    }, d = (m) => {
      m.target === t && ++u >= c && f();
    };
    setTimeout(() => {
      u < c && f();
    }, a + 1), t.addEventListener(l, d);
  }
  function oT(t, e) {
    const n = window.getComputedStyle(t), r = (y) => (n[y] || "").split(", "), i = r(`${$s}Delay`), s = r(`${$s}Duration`), o = Pb(i, s), a = r(`${Ml}Delay`), c = r(`${Ml}Duration`), l = Pb(a, c);
    let u = null, f = 0, d = 0;
    e === $s ? o > 0 && (u = $s, f = o, d = s.length) : e === Ml ? l > 0 && (u = Ml, f = l, d = c.length) : (f = Math.max(o, l), u = f > 0 ? o > l ? $s : Ml : null, d = u ? u === $s ? s.length : c.length : 0);
    const m = u === $s && /\b(transform|all)(,|$)/.test(r(`${$s}Property`).toString());
    return {
      type: u,
      timeout: f,
      propCount: d,
      hasTransform: m
    };
  }
  function Pb(t, e) {
    for (; t.length < e.length; ) t = t.concat(t);
    return Math.max(...e.map((n, r) => _b(n) + _b(t[r])));
  }
  function _b(t) {
    return t === "auto" ? 0 : Number(t.slice(0, -1).replace(",", ".")) * 1e3;
  }
  function Rb() {
    return document.body.offsetHeight;
  }
  function aT(t, e, n) {
    const r = t[Nu];
    r && (e = (e ? [
      e,
      ...r
    ] : [
      ...r
    ]).join(" ")), e == null ? t.removeAttribute("class") : n ? t.setAttribute("class", e) : t.className = e;
  }
  let V0, D3;
  V0 = Symbol("_vod");
  D3 = Symbol("_vsh");
  U3 = {
    beforeMount(t, { value: e }, { transition: n }) {
      t[V0] = t.style.display === "none" ? "" : t.style.display, n && e ? n.beforeEnter(t) : kl(t, e);
    },
    mounted(t, { value: e }, { transition: n }) {
      n && e && n.enter(t);
    },
    updated(t, { value: e, oldValue: n }, { transition: r }) {
      !e != !n && (r ? e ? (r.beforeEnter(t), kl(t, true), r.enter(t)) : r.leave(t, () => {
        kl(t, false);
      }) : kl(t, e));
    },
    beforeUnmount(t, { value: e }) {
      kl(t, e);
    }
  };
  function kl(t, e) {
    t.style.display = e ? t[V0] : "none", t[D3] = !e;
  }
  const cT = Symbol(""), lT = /(^|;)\s*display\s*:/;
  function uT(t, e, n) {
    const r = t.style, i = jt(n);
    let s = false;
    if (n && !i) {
      if (e) if (jt(e)) for (const o of e.split(";")) {
        const a = o.slice(0, o.indexOf(":")).trim();
        n[a] == null && l0(r, a, "");
      }
      else for (const o in e) n[o] == null && l0(r, o, "");
      for (const o in n) o === "display" && (s = true), l0(r, o, n[o]);
    } else if (i) {
      if (e !== n) {
        const o = r[cT];
        o && (n += ";" + o), r.cssText = n, s = lT.test(n);
      }
    } else e && t.removeAttribute("style");
    V0 in t && (t[V0] = s ? r.display : "", t[D3] && (r.display = "none"));
  }
  const Nb = /\s*!important$/;
  function l0(t, e, n) {
    if (Be(n)) n.forEach((r) => l0(t, e, r));
    else if (n == null && (n = ""), e.startsWith("--")) t.setProperty(e, n);
    else {
      const r = fT(t, e);
      Nb.test(n) ? t.setProperty(Da(r), n.replace(Nb, ""), "important") : t[r] = n;
    }
  }
  const Ob = [
    "Webkit",
    "Moz",
    "ms"
  ], cp = {};
  function fT(t, e) {
    const n = cp[e];
    if (n) return n;
    let r = Wr(e);
    if (r !== "filter" && r in t) return cp[e] = r;
    r = Sd(r);
    for (let i = 0; i < Ob.length; i++) {
      const s = Ob[i] + r;
      if (s in t) return cp[e] = s;
    }
    return e;
  }
  const Bb = "http://www.w3.org/1999/xlink";
  function Mb(t, e, n, r, i, s = y9(e)) {
    r && e.startsWith("xlink:") ? n == null ? t.removeAttributeNS(Bb, e.slice(6, e.length)) : t.setAttributeNS(Bb, e, n) : n == null || s && !Sv(n) ? t.removeAttribute(e) : t.setAttribute(e, s ? "" : Vs(n) ? String(n) : n);
  }
  function kb(t, e, n, r, i) {
    if (e === "innerHTML" || e === "textContent") {
      n != null && (t[e] = e === "innerHTML" ? k3(n) : n);
      return;
    }
    const s = t.tagName;
    if (e === "value" && s !== "PROGRESS" && !s.includes("-")) {
      const a = s === "OPTION" ? t.getAttribute("value") || "" : t.value, c = n == null ? t.type === "checkbox" ? "on" : "" : String(n);
      (a !== c || !("_value" in t)) && (t.value = c), n == null && t.removeAttribute(e), t._value = n;
      return;
    }
    let o = false;
    if (n === "" || n == null) {
      const a = typeof t[e];
      a === "boolean" ? n = Sv(n) : n == null && a === "string" ? (n = "", o = true) : a === "number" && (n = 0, o = true);
    }
    try {
      t[e] = n;
    } catch {
    }
    o && t.removeAttribute(i || e);
  }
  function cc(t, e, n, r) {
    t.addEventListener(e, n, r);
  }
  function dT(t, e, n, r) {
    t.removeEventListener(e, n, r);
  }
  const Fb = Symbol("_vei");
  function hT(t, e, n, r, i = null) {
    const s = t[Fb] || (t[Fb] = {}), o = s[e];
    if (r && o) o.value = r;
    else {
      const [a, c] = pT(e);
      if (r) {
        const l = s[e] = yT(r, i);
        cc(t, a, l, c);
      } else o && (dT(t, a, o, c), s[e] = void 0);
    }
  }
  const Lb = /(?:Once|Passive|Capture)$/;
  function pT(t) {
    let e;
    if (Lb.test(t)) {
      e = {};
      let r;
      for (; r = t.match(Lb); ) t = t.slice(0, t.length - r[0].length), e[r[0].toLowerCase()] = true;
    }
    return [
      t[2] === ":" ? t.slice(3) : Da(t.slice(2)),
      e
    ];
  }
  let lp = 0;
  const gT = Promise.resolve(), mT = () => lp || (gT.then(() => lp = 0), lp = Date.now());
  function yT(t, e) {
    const n = (r) => {
      if (!r._vts) r._vts = Date.now();
      else if (r._vts <= n.attached) return;
      wi(bT(r, n.value), e, 5, [
        r
      ]);
    };
    return n.value = t, n.attached = mT(), n;
  }
  function bT(t, e) {
    if (Be(e)) {
      const n = t.stopImmediatePropagation;
      return t.stopImmediatePropagation = () => {
        n.call(t), t._stopped = true;
      }, e.map((r) => (i) => !i._stopped && r && r(i));
    } else return e;
  }
  const Db = (t) => t.charCodeAt(0) === 111 && t.charCodeAt(1) === 110 && t.charCodeAt(2) > 96 && t.charCodeAt(2) < 123, xT = (t, e, n, r, i, s) => {
    const o = i === "svg";
    e === "class" ? aT(t, r, o) : e === "style" ? uT(t, n, r) : vd(e) ? h1(e) || hT(t, e, n, r, s) : (e[0] === "." ? (e = e.slice(1), true) : e[0] === "^" ? (e = e.slice(1), false) : AT(t, e, r, o)) ? (kb(t, e, r), !t.tagName.includes("-") && (e === "value" || e === "checked" || e === "selected") && Mb(t, e, r, o, s, e !== "value")) : t._isVueCE && (/[A-Z]/.test(e) || !jt(r)) ? kb(t, Wr(e), r, s, e) : (e === "true-value" ? t._trueValue = r : e === "false-value" && (t._falseValue = r), Mb(t, e, r, o));
  };
  function AT(t, e, n, r) {
    if (r) return !!(e === "innerHTML" || e === "textContent" || e in t && Db(e) && Ge(n));
    if (e === "spellcheck" || e === "draggable" || e === "translate" || e === "autocorrect" || e === "form" || e === "list" && t.tagName === "INPUT" || e === "type" && t.tagName === "TEXTAREA") return false;
    if (e === "width" || e === "height") {
      const i = t.tagName;
      if (i === "IMG" || i === "VIDEO" || i === "CANVAS" || i === "SOURCE") return false;
    }
    return Db(e) && jt(n) ? false : e in t;
  }
  const Ub = (t) => {
    const e = t.props["onUpdate:modelValue"] || false;
    return Be(e) ? (n) => Nc(e, n) : e;
  };
  function wT(t) {
    t.target.composing = true;
  }
  function Hb(t) {
    const e = t.target;
    e.composing && (e.composing = false, e.dispatchEvent(new Event("input")));
  }
  let up, vT, ET, ST;
  up = Symbol("_assign");
  EW = {
    created(t, { modifiers: { lazy: e, trim: n, number: r } }, i) {
      t[up] = Ub(i);
      const s = r || i.props && i.props.type === "number";
      cc(t, e ? "change" : "input", (o) => {
        if (o.target.composing) return;
        let a = t.value;
        n && (a = a.trim()), s && (a = Mg(a)), t[up](a);
      }), n && cc(t, "change", () => {
        t.value = t.value.trim();
      }), e || (cc(t, "compositionstart", wT), cc(t, "compositionend", Hb), cc(t, "change", Hb));
    },
    mounted(t, { value: e }) {
      t.value = e ?? "";
    },
    beforeUpdate(t, { value: e, oldValue: n, modifiers: { lazy: r, trim: i, number: s } }, o) {
      if (t[up] = Ub(o), t.composing) return;
      const a = (s || t.type === "number") && !/^0\d/.test(t.value) ? Mg(t.value) : t.value, c = e ?? "";
      a !== c && (document.activeElement === t && t.type !== "range" && (r && e === n || i && t.value.trim() === c) || (t.value = c));
    }
  };
  vT = [
    "ctrl",
    "shift",
    "alt",
    "meta"
  ];
  ET = {
    stop: (t) => t.stopPropagation(),
    prevent: (t) => t.preventDefault(),
    self: (t) => t.target !== t.currentTarget,
    ctrl: (t) => !t.ctrlKey,
    shift: (t) => !t.shiftKey,
    alt: (t) => !t.altKey,
    meta: (t) => !t.metaKey,
    left: (t) => "button" in t && t.button !== 0,
    middle: (t) => "button" in t && t.button !== 1,
    right: (t) => "button" in t && t.button !== 2,
    exact: (t, e) => vT.some((n) => t[`${n}Key`] && !e.includes(n))
  };
  SW = (t, e) => {
    const n = t._withMods || (t._withMods = {}), r = e.join(".");
    return n[r] || (n[r] = (i, ...s) => {
      for (let o = 0; o < e.length; o++) {
        const a = ET[e[o]];
        if (a && a(i, e)) return;
      }
      return t(i, ...s);
    });
  };
  ST = Nn({
    patchProp: xT
  }, eT);
  let Gb;
  function TT() {
    return Gb || (Gb = TS(ST));
  }
  const H3 = (...t) => {
    const e = TT().createApp(...t), { mount: n } = e;
    return e.mount = (r) => {
      const i = IT(r);
      if (!i) return;
      const s = e._component;
      !Ge(s) && !s.render && !s.template && (s.template = i.innerHTML), i.nodeType === 1 && (i.textContent = "");
      const o = n(i, false, CT(i));
      return i instanceof Element && (i.removeAttribute("v-cloak"), i.setAttribute("data-v-app", "")), o;
    }, e;
  };
  function CT(t) {
    if (t instanceof SVGElement) return "svg";
    if (typeof MathMLElement == "function" && t instanceof MathMLElement) return "mathml";
  }
  function IT(t) {
    return jt(t) ? document.querySelector(t) : t;
  }
  let G3;
  const kd = (t) => G3 = t, V3 = Symbol();
  function Kg(t) {
    return t && typeof t == "object" && Object.prototype.toString.call(t) === "[object Object]" && typeof t.toJSON != "function";
  }
  var uu;
  (function(t) {
    t.direct = "direct", t.patchObject = "patch object", t.patchFunction = "patch function";
  })(uu || (uu = {}));
  function PT() {
    const t = b1(true), e = t.run(() => Ze({}));
    let n = [], r = [];
    const i = C1({
      install(s) {
        kd(i), i._a = s, s.provide(V3, i), s.config.globalProperties.$pinia = i, r.forEach((o) => n.push(o)), r = [];
      },
      use(s) {
        return this._a ? n.push(s) : r.push(s), this;
      },
      _p: n,
      _a: null,
      _e: t,
      _s: /* @__PURE__ */ new Map(),
      state: e
    });
    return i;
  }
  const z3 = () => {
  };
  function Vb(t, e, n, r = z3) {
    t.push(e);
    const i = () => {
      const s = t.indexOf(e);
      s > -1 && (t.splice(s, 1), r());
    };
    return !n && Pv() && b9(i), i;
  }
  function Wa(t, ...e) {
    t.slice().forEach((n) => {
      n(...e);
    });
  }
  const _T = (t) => t(), zb = Symbol(), fp = Symbol();
  function Wg(t, e) {
    t instanceof Map && e instanceof Map ? e.forEach((n, r) => t.set(r, n)) : t instanceof Set && e instanceof Set && e.forEach(t.add, t);
    for (const n in e) {
      if (!e.hasOwnProperty(n)) continue;
      const r = e[n], i = t[n];
      Kg(i) && Kg(r) && t.hasOwnProperty(n) && !Yt(r) && !So(r) ? t[n] = Wg(i, r) : t[n] = r;
    }
    return t;
  }
  const RT = Symbol();
  function NT(t) {
    return !Kg(t) || !t.hasOwnProperty(RT);
  }
  const { assign: lo } = Object;
  function OT(t) {
    return !!(Yt(t) && t.effect);
  }
  function BT(t, e, n, r) {
    const { state: i, actions: s, getters: o } = e, a = n.state.value[t];
    let c;
    function l() {
      a || (n.state.value[t] = i ? i() : {});
      const u = H9(n.state.value[t]);
      return lo(u, s, Object.keys(o || {}).reduce((f, d) => (f[d] = C1(it(() => {
        kd(n);
        const m = n._s.get(t);
        return o[d].call(m, m);
      })), f), {}));
    }
    return c = Q3(t, l, e, n, r, true), c;
  }
  function Q3(t, e, n = {}, r, i, s) {
    let o;
    const a = lo({
      actions: {}
    }, n), c = {
      deep: true
    };
    let l, u, f = [], d = [], m;
    const y = r.state.value[t];
    !s && !y && (r.state.value[t] = {}), Ze({});
    let x;
    function w(S) {
      let P;
      l = u = false, typeof S == "function" ? (S(r.state.value[t]), P = {
        type: uu.patchFunction,
        storeId: t,
        events: m
      }) : (Wg(r.state.value[t], S), P = {
        type: uu.patchObject,
        payload: S,
        storeId: t,
        events: m
      });
      const L = x = Symbol();
      zi().then(() => {
        x === L && (l = true);
      }), u = true, Wa(f, P, r.state.value[t]);
    }
    const R = s ? function() {
      const { state: P } = n, L = P ? P() : {};
      this.$patch((K) => {
        lo(K, L);
      });
    } : z3;
    function O() {
      o.stop(), f = [], d = [], r._s.delete(t);
    }
    const B = (S, P = "") => {
      if (zb in S) return S[fp] = P, S;
      const L = function() {
        kd(r);
        const K = Array.from(arguments), z = [], I = [];
        function h(C) {
          z.push(C);
        }
        function p(C) {
          I.push(C);
        }
        Wa(d, {
          args: K,
          name: L[fp],
          store: D,
          after: h,
          onError: p
        });
        let A;
        try {
          A = S.apply(this && this.$id === t ? this : D, K);
        } catch (C) {
          throw Wa(I, C), C;
        }
        return A instanceof Promise ? A.then((C) => (Wa(z, C), C)).catch((C) => (Wa(I, C), Promise.reject(C))) : (Wa(z, A), A);
      };
      return L[zb] = true, L[fp] = P, L;
    }, M = {
      _p: r,
      $id: t,
      $onAction: Vb.bind(null, d),
      $patch: w,
      $reset: R,
      $subscribe(S, P = {}) {
        const L = Vb(f, S, P.detached, () => K()), K = o.run(() => xn(() => r.state.value[t], (z) => {
          (P.flush === "sync" ? u : l) && S({
            storeId: t,
            type: uu.direct,
            events: m
          }, z);
        }, lo({}, c, P)));
        return L;
      },
      $dispose: O
    }, D = $i(M);
    r._s.set(t, D);
    const q = (r._a && r._a.runWithContext || _T)(() => r._e.run(() => (o = b1()).run(() => e({
      action: B
    }))));
    for (const S in q) {
      const P = q[S];
      if (Yt(P) && !OT(P) || So(P)) s || (y && NT(P) && (Yt(P) ? P.value = y[S] : Wg(P, y[S])), r.state.value[t][S] = P);
      else if (typeof P == "function") {
        const L = B(P, S);
        q[S] = L, a.actions[S] = P;
      }
    }
    return lo(D, q), lo(at(D), q), Object.defineProperty(D, "$state", {
      get: () => r.state.value[t],
      set: (S) => {
        w((P) => {
          lo(P, S);
        });
      }
    }), r._p.forEach((S) => {
      lo(D, o.run(() => S({
        store: D,
        app: r._a,
        pinia: r,
        options: a
      })));
    }), y && s && n.hydrate && n.hydrate(D.$state, y), l = true, u = true, D;
  }
  function af(t, e, n) {
    let r, i;
    const s = typeof e == "function";
    typeof t == "string" ? (r = t, i = s ? n : e) : (i = t, r = t.id);
    function o(a, c) {
      const l = bS();
      return a = a || (l ? qn(V3, null) : null), a && kd(a), a = G3, a._s.has(r) || (s ? Q3(r, e, i, a) : BT(r, i, a)), a._s.get(r);
    }
    return o.$id = r, o;
  }
  const MT = af("reload", {
    state: () => ({
      isRouterAlive: true
    }),
    getters: {},
    actions: {
      reload() {
        this.isRouterAlive = false, zi(() => {
          this.isRouterAlive = true;
        });
      }
    }
  }), kT = "/loan/static/png/LP-DxuS8Bb-.png", FT = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFQAAABUCAYAAAAcaxDBAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAPDSURBVHgB7ZzNUtRAEMd7lqUMeMnJj1t8ANZ48whvwBu4PAFy8wbcvKk3b8DNIz4B6xsEXsDhpl7MRVkVMvbsBpdiZzaZ0DO1bvpHbRU1mUon/0zSPT0fAAzDMMzc00ui3V5y73v5ewOeCW3vmiUIQC9Z0Tf0CkBE5e/5w7grvuaXA/BAaHs36UAQiv50mdiGhbE3IZCgIp4uUzF4I7S9CYEEbQ+iTqU0iZIC4IUAkTZ50gpgHczGB+ABant4vk/Y8g4zOZRVdSsFHX/g1UtgNHtncrg/q8JML89iTrH+KO4mGC18tFWwCrqWRH1svq+BuU36IO6ef8svM9NBq1NCMXeBMSJAbduPGSid0GdgrGBLfGJyUl1L/cRUiOpL/G2BI/hwTsB8URvgAUp7eK4DMOuhy+TtQpugNiQ+lQE4gv1qY3mTc4W29zSJpLI0MBMc2BPDghLDghLDghITSFCVT5eJHLwR2t6EUOm7d4bCI1gYexOCCIoJhT19k9jDyMW49eyfyQtvOYLQ9m7iGoc2pryhYImW0PauYadEDAtKDAtKDAtKDAtKjJOXVzhIh9mXE2gRClRacyxzhGPYpGLbiOLiUl9MDb/yxLCgxLCgxLCgxDg5JQEiw2TDDrSIAoSe7JHWre/q5XNfA2vzCoaJuXKoz688MSwoMSwoMSwoMV4z9mkSrRdOXVWVd0Ac15nYOj5/HBdw0TdPATfTgU6WyZ/H4AlvgqJ3PEAx++CE0GHKbprc38jkj2xWzTRZTlHMExcxNQX+4bUdnsqh8xytOnh55deS1U3lLOY1OgFzVbmuqIDugauY/yzgtem3BzzgRVBsZ7UDYRP1MlrqTjbcPkX18SJo546LEbA3llXXuZuNDhSVNpqd1wNlb6rRxILxWHqxVV3vasc8Q6QWR5n87cUxeXNKZ3KI36nV48Lh9e+MBFo5zGReKVQm/2T4HXyGom4WTl4eBj67z17DpjI8cWwJv2rXLMOrtzBHcGBPDAtKDAtKDAtKDAtKDAtKDGebiOFsEzGcbSKGs03EcLaJGM42EcPZJmI420QMB/bEsKDEsKDEsKDEsKDEsKDEWMKmJYwDr6ZK9TqlXhLtQYtw2RFHYxF0WZoELXdm5B3HRkTYdR1OlRpfed1T8bUV5SIgRr0tc29u1t53M7d1bDMClqwLN6y7M37JL6XeCBpatxSxkv1TefHBdnDm/qF6V+3Hcfcc/9UJjkbJ3EVB7/uHwydbKOb7inr1GGe4VVo0zJL/r4wzYCJr23IihmEYhmEYz/wFfU2DU96IL+8AAAAASUVORK5CYII=", LT = "/loan/static/png/clear-BS6ph17N.png", DT = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADgAAAA4CAYAAACohjseAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAJkSURBVHgB7ZpbjtowFIZ/oCAQCIXLEwJRsQBUdsASuoMuod1Bl9TpCmYJFBCvNA+IJy4BgZCQgPpEkygdMpRjnE4c+ZMsiBMn+e1jHx/HgMHgMx6P+5QgCZUdjUafoZA0FDEcDgfn8/mZkvj/DUxEme9U9nK5/BAin6EIJQIHg8FH8fMpkPUVfPyWEyL7L/d8GGUtqAALERAngZGQCh5QJz+dTl/Ax0qlUsHBwRFm9gQGL+WtwPGT6JMOmKTT6Z/dbtd/ti+QbF6c/I0EICqm0uv13MrxTTSTyfSREIQW35oS3weNQN0xAnXHCNQdI1B3jEDd+QAmuVwOtVqN5nt3Xb/dbt0URqlUgmXdFwaKKAfL5RLH4xEc2ALb7TYKhcLd11erVUwmE/cFg1BFdTodcKDnTqdTVhm2iXLEeZTL5au8YrEILtTiXNgCF4sFdIJtovP53O1TZGJvUalU2C203++xXq+v8pvNJh6BLZDY7XY3z5M4rkAaPFar1VX+owKNH9QdKRP1oFEtzBTz+TzigrRAGkharRbijrSJyvik90Ba4L9G0rggbaLks8QCa2h/o5mLzIwnCh4aZDabjZteQ5OAuAg0flB3pEyURtBbc9FsNgsuVIZCK9WwBTYaDdTrdaiGKi0K18M20SjERQlboIz/o1DoNW8tY9zicDiAC9tEZ7OZ24riY+ld1zuOE7qOQksYtm2HRvthkM+VCbbZAullKehVwa0FKVUYP6g7RqDuGIG6YwTqTiIFilmSv8ctHcikDWw29McW6Zd38NduQ29jq/j2F8nezf8BNZS3Ec+QBP4AtOXJwOspSqwAAAAASUVORK5CYII=", UT = "/loan/static/png/empty-2-DNUTplhP.png", HT = "/loan/static/png/empty-BqqjLmdj.png", GT = "/loan/static/png/fail-MojHza-v.png", VT = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGAAAABgCAYAAADimHc4AAAACXBIWXMAABYlAAAWJQFJUiTwAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAOtSURBVHgB7d2xUtswAAbgXw60oVOm9tjMC9DwBrB1hK1b6RMQtm7A1q3lCQpv0DcoYzcML1CxtVs6tISD2JUIufZyONdYkiVb/3fHHQtJzn9s/ZZlAxARERERERERERERUdsJWNBPu2kOsSdQbBdAinaTaqOdqZ+jTI4kDBkHsJ523wDFR/VSPURFDBMUAxXCKQwYBTD55uMbIpags5HJXxkqSmBAHW4+IXIFxh9goPIewG//X+pbvFZ1PDDZA1LQg7yPiioHMEYS2aA7TzJERZUD6CCvPPC0kERFlQPQxzzdhxE5vQ1MzgeMWpDAeB+RUwG8hQGjADJ5myWGH6DZxL7p2XAHhr4P77IXvSVdZzcRl6NLOXoPQ8YBaD+Gd2cqhDX1a+U61iziWG38d7DAymTc1Mt05bxA0eoQBER2Ia83YInRGDBL4OmWMKhkoRP3M6HFDiyyugdokymK4rxts6OTjY8tG1PQM69rXz9d7ufonKNFEow3dOuDZVYPQVPtq6e6bt46OfO30oIe06J6aqVulnEWgNb8emqvbpa+A2rQxHpqu26WcTIGzGpaPXVRN+e8Vz2aUk9d1c0571cfFcKmuoz5BQFzVTfLOB2EZ6lmJFd7yz/VxfxXCJLYv5A3n1GjWgPQVAhfA62nTutmmdoD0MKrp+7rZplaWtDjb9wd6KoHz/RnuJTXA3jiLYBMDoe66vmsp3XWzTmfwS9f9bTuujnnc/jno57WXTfLeBmEZ9VfT+uvm2WCCECrsZ56qZtlgglAc19P/dXNMt5aUBlX9dR33SwTXAAu6mkIdbNMUIegKTUeDJ/3nlypjfYaFqhv2Y6qm0EuJg5uD5jqIK+85LtJgg0gFgzAMwbg2RIit552D4BisPhcVKHHqJNLeWN0j0TUe8B6uqJvMT2sNhGo/0YMVICHMBD5ISjfhTGxBwMcAzyLPABxDHNGz4qIOgA1MXeoQxCTAXUhD39zZDq/FH0LetiA8V0TpgkG4BkD8IwBeMYAPONcEOeC/OFckHecC4oe54LMtXUuqOP8ojznguZalvrRgK5xLqjEZIFW+59JF/QYIJDYOEYHLegAMvlbLyE/gjmJQAW5NPFfesX0am/pCpMV0wufMOl1oRdyZCNEJxpRQzM5OlEbcU0/AmfRRbvCzh7kTBC3KC2qn3Z3C+DgP/5ZxKmqmrsIWCMDmJofhL4ZI7z7AWY1OoCpfvpsO79/grnoJcglsHKiayyIiIiIiIiIiIgC8gdylmnwHkPtMgAAAABJRU5ErkJggg==", zT = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGAAAABgCAMAAADVRocKAAAAP1BMVEUAAAAwIAgvIAgwIAguIAcuIAgwIBAuIAguIAguIAgvIAgvIAgwIAcvIAgvIAcuIAguIAgwIAgwIAovIAcuIAhOXyyKAAAAFHRSTlMAQL8g74AQ38+QcJ8w3++gf19Qr7uZB0cAAAGQSURBVGje7djdjoIwEIbhD/pDoSCoc//Xuok1wRCTmXFqdsn2ObZOQ18aI5qmaZrz6vJCSinfIOV6+sjgIDJ7+pCfRfv39DHvwOvJoBecL5l04GR6CBEqcSrrRnDS43MT1EIpCRx6iFCLZeXvDxjKEUCtHEICZ91rUJnLuizN1DuouEG8sX6/WPTfnxRXRdIcdCprLg6Qv8sZYiOpTm6iYoPQRsUkfymLq3hD2rZXKmZFoLRCLqY9VnFAUZXd8ow1Sr9/cdhpYrUHysdqD5SP1R4oH6s9UD5We6B8rHygxlj5QO2x8oHaY+UDtce6MQEZYmUDtce6B3oHQxvrMSAmUG2sTKDWWPfnnUWB6mPtD79sbqgmvBsQUE/3bkDXBvyRAZunF36sPWCkg1B5gKcDf7YBgQ7G2oc8XujFJZwv0zbgHwxod5FhgP6/muF7d5Eri9137qL9SQzuMK6eQEV2QLyzD1svenrqs3/OQlUTHTnUFVS12Cck1OfWl/1HFLVHLOWgO3zNfLt2EU3TNCfzA2p4aD8ne8gEAAAAAElFTkSuQmCC", QT = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFQAAABUCAYAAAAcaxDBAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAUrSURBVHgB7Zw9dttGEMdnISWBnAaq7HRw5yYy0rmLfAP6BFJOEKpLJ7FMRekEkk5gu0sqMicIrQsEraswTUi9RFjPYCGbBBbAAhjYj+L83uPTE/aDwB87szuLAQEEQRAEQRAEQRAEoVdUVWEU+oca1M8akkOsGsBWo+cKvKkCfTGLl9OyWqWCHoR7Y+xkCIIFfX4T357YSnZsB0XMOtSLx8FO8H5+93uhJH+AzDwBmIBQiwfwMm/+Xr4S+UwQnEhAFazYIihNQIIjP+YP7Bbr2GdzD/z9WTyfwxYShUGQwPLvYokuaOWBI9sqJtHk2p0FFdwQQZkRQZkRQZkRQZkRQZnZda14EPoahFpkhDIjgjIjgjIjgjIjgjLjPMvfxEsFW4zrKkdGKDMiKDMiKDMiKDMiKDMiKDMiKDMiKDMiKDPOkdKmQ8/WAZYRhjtHGvQgO3xVlvTVFjZBMTQ7oqw0SpTAGPVKgX9S9zybLlLD8jVe5CH+G3vgYZt/3wATqyImsBh8SuL4GEUP8bz/wbD6DJhgETTLrLi6P1G8gGMNCxKz8u4ncHsKRkwiTEBfYl/TLkkVDiLmSHO5zoAJphG6tKTvqGEU+pScGttaYBkJmEu2otSWtK9GgjYXsT969aEa1Bj/vLKXwSkwgCZ7iiIOO4h4DYz0OsuT86d80/xxGp3kFqAjJjGYzLV5uroCTVYwuokXrInFvc/y2Uicrh/TYx5zTI6b9GNEVG9UOir3Zu96SIDrfR1KM/jqKI3CRwN0BQP4ItBLBzCirOO+sgk7CUqm+zzco2VPZQr5qr9MIBnX1J08D/0J9Q21qLfQAHJBCcBf2P+lW/9rrS03QBWOdRKUcvHpJFGEsKoejdLvQ/+YPlBfl/zrIa4AXkMNePJX0ALy382FVReWg9eWc+pE6FoRTe1UNZrZVVRfx5/ZR44bmbCT7EZXYhb/6kKl7yuVT2gdBbXetYzChYaQuwEocAyt+jYYP2g3e+UudIjncXkQfjOuq0gCvotv9+lTFl11EpS+AMPFVx4oS0TkXVcJRmXaajI67dN1OVNm9hpLPLj7AZzXmWqI88GfJkhoT+dZ3sTe2hJ/k2nAqKxdeZl62yyeLzN7irp2AhxJx3iRT/HAqNoi0kkLo63bSRdRe1024fIEN0nW16AEXRiVAQNVZk+haHYeMZkofu/LOleSiXoJLel9HWobiXjsJ2Ck3OzVYHW0GWHJTcHTqtFKKxeMwlpFUL0Lmr26tyrqqOpt3nZUmf0yspxTjNuLNf5Vj6PwW4eVxjqfZceezI1eHKMP597jPS5mb2tD/hUqRNVwVzvz52ER1NzxdV+ZN0O6gHy4h7Pw2uST+dYYWlBl9lXtSFSbnzdtKWx+1ChMZhuh5Bc94xtH2Vu6cV2bWfzf7H4GxuXSSWaGLWm/yDc+3d62LlS29LVOWZbZJmTf4bmfQSEaUxcua9oIJ6Ek3QUrYnuNu4wH9dTTNTy0MYsX52Uzf5PN8Ac1QruCGyUU21vXoK6jVJ7Lr2CCjTJf6raHK4IWKI2kjsABZ0G7bhpsCrhWPu+yJWh5ppQ+dymIR79ogP4VNotUmEbZIbRWxuukUZqfiJx2rQo/M/Qk+PoF/nkGDwLlm58E2lXv5/9PXVtR3cfBV/u4UniGM/ES+/gVJ+VfXNpuyc8MKQwzF/vwGSj4ULM0qN8tF+xYJyWzGH5Qojru2ndnp6wA/chv3wW7f9AWGPqFJ8YfbRZZYoOz/xMEQRAEQRAEQRCEDeADZvYcj77xaagAAAAASUVORK5CYII=", jT = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFQAAABUCAYAAAAcaxDBAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAQPSURBVHgB7ZxBUhNBFIb/HrWMuokrdTcXEMPOpZxAOIHZugJOAJwA2LkTTyDu2BFuMHCCXuqKbJRUCdO+zgxCQTIzDS/dPeR9VQGSGSrJl7+nu+d1BhAEQRDuioJHemknNcBXun2ABxTUvoJZz/RIwxOP4ZEcOKRfKTxhYJZJa0p/LsITCTxB6fwAjzIvIam9XvqiB094ExqWiy48MSdC/XHnTqmXdrs5zvp04H+HRk1ZdW3zQxBMRq9zWL+fGuYwPx4Bg7t2ZHcSupA+XaVfm1YS7gm9gMGxHi2BgXdp55BpBKHple2e6LMdOOLc5BfSzgY92Q6HzIhJKdXbC+mzNTjiJNSOIzFO5rxgtsv33BgnodScNjBn5FBOKXUa2Buo3lgrLykdRjbBgJnJONd8pB+NpTp1SvTGJ9pMkKzQZ1nZi+bFh7GNIJj1BCqr26ucyd3iRI8ae2KZemb6z37dPnQssi84CFYmDYMGdftRYHBfZGDPjEehndomN0M0POFNaKaHQ2p66/DP1oM9fZfRzIPO/AxyXCzDA0kxhRzAI16FWjL92zb9kM1/pkinxIwIZUaEMiNCmRGhzIhQZkQoMyKUGRHKjAhlRoQy82CE2moslbdPy1ugysADEUrlXitwsyhtj29rXHUqV1ovtCjzmglFNLWKALReaGyl7VYLLRfw9idtUzC1hcNZ0GqhVEX9NG0b1X23EIDWCi2XyPQnbSOZez7rSNdprdCLYpVdOmlbqHRavNeU6rhaOp4MqxZQqCmdUch0WqISagfn+f/Vfbm9r6kJLd0U9Dbt9DE9nd8QkGia/JSlkqldb3RzSWFFOr2XjW8SjdCK8WQptfgmR006gx07L4lCaNV4soSk5iT1+XJFOnXodFqiOIY2m+2Ybg7zfdrWGNJpCZ7QBumspUznHiIguFCOuXgs6bQEFVo9F1eN1j/FlE5LUKFV6aSTGysJLhZpr8ql5jGl0xJMaHU6i9lOpv9mCdSimrJgNrZ0WoIJrU7nVeqsWLq/NElqbOm0BBHaJJ3XH7uUinJaqcaHAbUeWzotQcahTdN5nVJyH/ccYs2aIAktrrRwm9BnijiI6nxojMdEVwIJVbuTHmt7Oi1BhJ7o0aYVaDuXooPB1ok+c/4qdYwEOzlSCnwQEq8ja5uYEaHMiFBmRCgzIpQZEcqMCGVGhDIjQpkRocyIUGZEKDMilBkWofZaomg5XO/B8fTduDh264lzjE45rsoVEnoPU7Y0uZDrFU4JVUgGmD+OXHZ2FGp2MWckME5XuX3ksvPP4bl+1X3ykv58j7lA7R7r0ReX/3ASavk1PD+YD6njazA7l2ichVqs1Dfdx0d2ESyVfl/Tk7e7RyopioY4SKA+uyZTEARBuD//AJ1OOosAK38cAAAAAElFTkSuQmCC", JT = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAABQCAYAAACOEfKtAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAmRSURBVHgB7V1NbBxFFn5V1WOiXUc7K1arXS4eBOQESkQucMGDECcQcYADJxIwQZxw4A4OcIYYTsj8JVzgAsQSHAChdLhwMnEEJwJiLCE4ARMcoSTTXcV7NdPj7p7+ma6u7rGNP8mZmZ6e/vn61fuvCoMJoqmONzf8P9tcyhZwsV+BbCkGLfqOqf7rJlQXGOuAgi4D3lFKrQNwd9rZs9ZlS12YEBjUiCFhDGYlqLlRkszAGBCxrgS2slf8w62T0FoIdHpPtYHJBQDZxlM2oWLgTZ0iMn1n+QxUjMoIJGm7LP9cACWP10FaEgaS+YIQwr3CXu9ABbBO4FYgLg4iUgE75YnlF8AyrBLY8I4dxSMuKku6zTYCiew5b5wCS7BC4B71VMvz/XfwbRu2BdgZR/BnbAxrDiXR8I8teL53HrYNeQQ1hw/8vB4xJWEsgQNdtwhKHYdtDMbYUk8sPwOGMCKQhqwv/Y9Q1x2AnQAGaw4Xh02GdGECB+Sd3aqGwhRkYAQXdxclsRCBO5W8ACYkjk1greR1r4G68GtkE2vtBZiZhqpRlMSxCKxb8uSLX+PfamQbf+VO4E/fCnWgCIljuTEDg9GCutCcGtnE/nUd1AW6Vw/vGdTR3Egql0DHf/KkLWurzv0C8tmvcvczJYukVp3+DqwA77khpxbzdsskUDuaNvy89cvg3/Ox/pOvfauJLIzWdO45aOj78+f0eehzWWDO8Xjj2pOZ959KIOk9BeoklL0IlAj/4IcR0uL6zQb8x89tnhPP5d30Hj6sb6AsFFeLxEXa96kEer48aSWbgtZTda9GNtENZkphq5i17R/v55HtbP9/wAKagzg/EYkE9mNENQcWwGb/D+xQa2R7YSnMIFXOnxvZxo/s0+e2hHZa3JwsgZiSAosQb82OWNYsKWQJVjgNpCJUZyP6e5R6/vztYBXESYJVFvENjv8E7sisSN8QewSwPQ6oT3+Kbl/f0JIygis+KDQC7I7/AjtwPRJ6HfBH9+njxCEf/lw73mGIl+9E6bsBLKPJpXNVvrTqhjdGHOmqHWb/nk9GdJX44n7joaYNVGz40gPhJPHVoOuJ3o2Y3B4WrSJD2Pf9dpUOs3j7rshnkpIiwzUOLZ0hSatk6EbRdLypiFsT1YGGuo98u7H8rhm6wYN6SIoP7kXpuw9g//VgDPwtHYN0rCbvudv1OfKgHXpTF4ephcjH4I3w5uewYP0RFAUSRz4XgZ4+EZQJ0leXro51o8WuYyP/mHhusv76gUMJ9aHE3V7jdZfeDiWQAz8EBgi7IzoSuPn9bB+Phqxt8gg5xyTS6NoC8vQ2U4de17gHb/W/aJ4dv/E7FAQRpcOmBGhlTtJYQwoqExRGPu6mPlQ9/JM8gWwMjYmWQOGLNhhArXRSv5NkIZFca8G9AUjC4mFkHOpLg7icxpE/1aY3vP+P2fClHF2gwBMvDh1c+dLXI35aLaCk7LsXR8LIAGS9SQeaujxSqTa99nUgMy9JkviL7x9JJVJbxhKuijHwnEnkBMSR9S4T6mHSVQsdM9V/aaAhS1JH0kcXSBc7SQTOOxFHXoLF+BhQD/6bOb0n2kjnWbAMRdaOEgll/Dwb10G1FRzONokLwIEddvClTelX22A11S/yUOUDVBJanO3QEmUt4Gw/x4zrDOzCCNSSjMMYtkQP33YERiEtTNIVHMLo2Sv3l75rErgnofesijDNAhTFyp1QwiP0Xn8HFD3dUjjMRCNSTALJPfHn3cx9toL7EoeiYn1OVEQPnx0Zn0A0va3S/YF/d+wSWBJ/HwLHiccNQk4m/GM/FvIFKSkZyqlFjEZQesQLmXQEMgJMKqhLAxKTjAkmedmhmaJGpFucwF0MgQmFNYpEOrALI2ABrsuZZOuwCyPQpEc0InINdmEEmjHKJVcdqAC6dSPWpjsRUORUWVmBu9wXvgs2ceG3zV7AMZopq4aui1DPIFULLRPpOVfWdFXOiiXWDY6rI+FSmdaN0gjVrAMEBXiDSlz0OIx1emL5Ru1IMwkrYAoiDp+wbmhMeMK69WwSRSWAxJJrP5a3IJFKufSiCVRMumCAoPs0K0hnD1C60X7GexxoScuoGBKRSb2F44AB00KnCRzoweLT5BO6T4cn0H0r9+vSJzTr67CPXANVDLH6xjOGK7vLTL1cE9dceh2UNaldi7lQELr7NNaHp3v5nj8IYvXByem+MKihCcubWhfHpJE+m+hCWlIgaHHbTCYo+SoYgL9yx+aBqea6erjqFrNkkJ7N0LU6R4n163Dzk2lRPRi+/fchON4xqg8XTvFTCZO03DgziXRrGeodG5YwfkzSt1pl5AEz0PL0RaMHHVjf4efwl1gjPoF7WO2PjkNbv06QQt+ny5/GmRv0OanPL2zEqnabkLDHwksGRPKBnuMtgYkxGRPU/hZuCKcbz2pQygMZsLgHUKXzTtJHK4CEt8U6VFExKmWkC3MxcLQjpyOnNmUY+w991vfX6A/fJ4WFSUaM9rMxwSYJWEg/HZ+AODpbUx1tNuTUeQyUW2AR4aEbIKs3z3PeiO6bMjQTexQxoeusPmS1NzGu+wKMpvT7Umh1fZX40NWnyXIhYvtqpFjYJCmkfamp0ipSOEmsiQyUpAs2kDB09YmfK2gBM1yUsCsVQGeDVmylOtmZtLVmUotKjhCPgQWDotyEOWx5DuylYrEzWfEkXarW/wAL6NIaM2lfphJIypLJ8kOZiHJ+eCQy8S9P+pRB8iHs0w3DyKdvg7JAI5G5QI+T9ePe1JtLTm++BYwvQBlgOEURim6+fPeikQNN7Rcs5xx6DgoaDlsOOkYHr/Ya2ctEZRJI8Bz/hCP5LFiYta6D+3FuzjD9ZTOERKu71nOWcyeb5xfW0SrTojRkxqEuTCh/GEA7zJwfHmtfGBP9iYjyrG3/MBE4XNXabxEiWft/1UzQiWFAnt1lTwLUSuIEUJQ8/RsoiJ1Kogl5hMLNRXQCOhEt2AU7BGQwTMjTv4USQBdnqbSLM2mgqzLt/POE6cq/pVewpMUYMJlKy6Nst17rLgUK5OtCCVhcApSWSbGz0kcNcClUtbEEaAWL0LLFrWpgtC+LWZUttwhtHFQaYJwf2UJE6kTxtDO9ZHuV80oIJGh3x/fbE5bIyogLUBmBYdB6DFyyOcXZEage/Ro3lmm9xpsuVIxaCAzQ/88INtpEJgg+a0syFYMOl7AimXT3ir077z8jSINeStm7fIBmjKKCn6G5Z3rqWb9TLOIWEUn0Si3J1BkK0r9AvY11ExbHX+osgT1KWcMDAAAAAElFTkSuQmCC", KT = "data:image/png;base64,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", WT = "/loan/static/png/methods1-BuNixcp2.png", qT = "/loan/static/png/methods2-DiGn8NfR.png", YT = "/loan/static/png/methods3-Dn8xEMS0.png", XT = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFQAAABUCAYAAAAcaxDBAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAZUSURBVHgB7Z2/W9tGGMffE06w20VdCmziDwg4G1th7AQZmYCtncLYDdi6gcdOoVsyAVs7xWzdEEzdemxkqhlai4J9fV+f/DwJ3EmydPLJ5j7PkwR0Z1n66r2f76s3AA6Hw+HIC4MK0Qzqq30QTQZsGS+tCSB8ARB8XgcvmMPgD+sI6J97wMKQR22oCNYFJRFRtC0BYgMvx4dciA4+hFMG3lnI/z0Fi1gRtBn4fh+ityjEbn4RtXA855EHAsWNOIyZsQu6FNT3ShLyMRz/HF/x6ADGyNgElf0jvINHfeIY4B7A2ris1YMxQFaJYn6E8YtJBPjdf8mWUT6lWij1lQK67wSwjSz1GQ4u+HeI/54BzHCAfghQ74S80xmeD+CfAMvwX9HE867jgLYKGZED1+zO8HxlUJqg2MTRMtgJ3XhaXbyINo7QLYCX7Tw3i9+1LWcK6eIy+cDelNUFlCJoPIpfQEoTl0LCgal5JD1EtNpDOQVLBPvV+usyLLUUQZeCxkWSZbLBvHFmp6w5Y2yxeyLhgZKlXvLuazDMDBgGxTyEBAuRVsm+D3n3DyiJm85DuODXsB9mq/jrvKba/Jw/43/q9H4HgxgV9BVaBgr2s74Ga+G8cBNvuLRBYQh9x6fOwy9z/otv8NcVdS22guW3WM/YwzUmKPVfIOeZugn7AYr5E4wZFOu3Ob9GXduqugZbQWv+YOohGxMULxqbuvqisc88veJ3P4IlUNQ2Xt8i/qjq1+t4hQHW+QAGMDKxjzc4tlVltDvEoLEDlsFRfTfeqXoCzQroHsDI9xiARlRdGRss+zql95lp0DUw6L3RlSfdwygUFrQZfN1MmFAf2Njx0RHye1x5gXKzhO7BhJUWFlRA763qOJOT5yOoGPKahLLF9DMukZPPXxDdqkSugOw39cfIa2ItTfGW3C/ITyFBXwVfJe2yt6Gi6K1U4L1EqXsPyecu9OH+uuo4WudxlfrOx8gBymuryoo2+0KCioEj7Sko6DlUnP5gi1CFWIcC5BZU9jXaDZA2VJwZqOs2ZoIi/WgBC4001inCKjf3IfGAydWl9wHkJLegPfA0T5FVbmTXQVt4quM96OUemHILiquOQFPEYULAKd+t6jgr4JEt0OTVX4orjmuYHLj6sLAhqEOFE9QwTlDDOEEN4wQ1jBPUME5QwzhBDeMENYwT1DBOUMM4QQ1TG6WyDOtm67jnuSHsRCOPi73loIE79yJkI7rCMwkq4z3v9vqDlw0E7ShNPUJ6IyjmYHspmD3yoJHJi5va5GMxP8o3N54rbFegBllcI6mCkmVmCev+7MsnZsdeF/CgrIka9KGbGq6TKKgMUcxumRSZ7IEoJSq5DLAZH48iKllqWrhOoqCjBFDJyOT+2iQ46IZQn+jhNet8SyrS/PaJMfYJsfK/UnhgFUNtTCDfYIF9/HFLUcyveLSo+2yKoHXlgI5mvThJlpiH+E2Wv1VlKKhWt5wT+/pUWuaXRLkcdWmCctVBAdFhHFM/lcg3ANXjBwVyJH02ZWLPzlC+J/GfNNmVE946TCPY1BNKkwcwL7lwcqZA44JpIqCHJL4FctN54Mnv+Tw3WOuSR++TaqQOSh7M7o8yT5tWSAPSIq1eqqAyOHV2LSGM+hnAWqRBlnn3SC/PDie8lLVGjLS+nzzopQuBgzKNI1XKuuNwOBzTjNXMYnIDorttKocTrt44vYxgcxfMmqDxjKGM1EOl5RPJgjU3crz5EIB58EHd7YMlbPrlAygJ3BFaBku4QAfDOEENM1LkiFnI3fzUw0Lp1HBZewkZwBH1O1XyA1wy3oIlrAmqf59J+Oiz2YcMLAeNE1DHsXCwhLUmr9u8zpqqQiaOUSc/8KDXBktY7EPrYUKqihPKZaL7ZDN40YxzkT6BdolC/p81T4PxVG1ZuelEEXoDGgDKBDDovxY/zPu1YMGfvb7p3N/QQbLKb/3algCPds11q6sW5WkCS1hfeqIH9cJUaKTMEQVWo1esTpukNwCMJcmic9kOwLDW5IeQI3DBr12jlRbK9YGf38HZgXUvrXVBCZme8iXOPQV5V0faeZIRfzObV7z7HipAJQQlcOD5k3J+oqWR2zqTv4qy7+BCYLPMXKSjYnVQ0hHHpW5Q0uo4efXAaof/bQWKfk65l6Y1+s/hcDieK/8D4QNI6EBjkbkAAAAASUVORK5CYII=", ZT = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAJAAAACQCAMAAADQmBKKAAAAPFBMVEUAAAAuIAcuIAgwIAgvIAgvIAgvIAgwIAguIAkwIAcwIBAwIAgvIAguIAcuIAgwIAkuIAgtIAguIAguIAgUFI5QAAAAE3RSTlMA74Agv9+fQJAwEGDPcN9Qr2CgDLgu6gAAAoJJREFUeNrt2gdyGzEMBdAP9rLVuP9dE2dsJc5o4m3gwjHfCf6QEMgViK7ruq777mxNi/f8kx9cmjPuVGog/ssU1oJ7xET8FIWI9qLjf3CtI2XHn3AW7ZTEGxi0kifeZLJoohJvRCMaMPxGybYZZlWJDLOqRIZZVaKRD6gQY4kPIAspEx8y4OH2AhItI8uHWUgIfJiDgMgnRPykZ4HelkhNBb3Kuhbo7YemoQe9I0BRSUuUdeKTEq418IOK86PwaUVXCTHn+y9CH62AhoNeqhO98GkBV3J82qItkOuBPuG0FfWiLVD4v/vQyqfNgJ4LrMAllph1XRmdrl/9Bcf9COgqIgtdezYAuvas4mqF+AT/vmNamnUAoGqJLF7pWSIDCcXzQb7gQcXHWcUfFHzgJzyo2DRfIMaSjhb0W96diDJEVd5phbCZeAeaIS573sxnNGA3Jxos2jAC/Ud+kYaIlqrXMCHfHIlMwQ3m5XkaF3GXMr8M/IFPc8G9SqwmhVem5oKu67qu676+kuc6mhDc4ImfIO9cSGasUfrwt/OYFk+8x+DSGItAlpoc8WHk0mxxlTguxBeYwmoFnpWf48ZTmYohvpxbcZANLGNa1azOiUh5YlHO7n5VLmzKu/KwPMqSwzHhV8QTNzFgI8ONGF0LxEwijwbkHzcGbiZJPFmUL2tuh7QF4h7oM7ra0NaifuFmgtSsV3g6TNyI/6qHa6te7e2u4bO8uGv4LM8IDFYbPkqzA4vy8ciATk4q2M8aqUgu46AqsHFkLE7I6dJMFGLBWbYudEkYZyKukk/+pTeEMeNyOY7JDbyLX8I4W4gq8dfY17nB81PeuyUkU+ds0XVd13Xfzg+Knw+Fv8CVxwAAAABJRU5ErkJggg==", $T = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFQAAABUCAYAAAAcaxDBAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAANcSURBVHgB7ZxBctMwFIaf3JZJWWUFw84XIA0nIJwAeoP0BKQnSHMC2hMkPQFhxbLlBLhhw9JL2GXXdEotnmLDDKlTKvtZUtr/m+m0ieV4/FV+ek9yTARAyCgKnG7cbmd02Vek9vhlbN7TpJKI9KckXZxTYAQrNBd5NWR9gzuapRHRQUhityhAunErzujmM8t895+mbU3Uf97epp/zX18oAIIU+qy9c8Yyuxa79F60n1z8mF9/J89EFBiduDW0lLkkIz02YYI8E5xQpk+V0Cbm9skzQQnl2NmjYiRfhUfPSUTRvhmE+O+0vI1+S57ZpoDIlpf67cSD3zm/SBcHf16z+JQHo7PVdpxOWYcKaQK75FVpDGR5/4zg69Mk7T2G1u6hJsXhEx7rvHd5PyEe1DTVhIuIhK+Wk2/pYkKW1Oqh3Xinywf+ymfQC0GmFKZzcJgZ78WtMVlSS2hGWx8fkshVTNHQiXcHNvtUFvoyfmqqmJicoOa339NzcoJ+b9O6slBFmZMRlVOhOU+ETEu2nJAbYpvGISb2fzHpEv/j3vConq5um6WLIyNVOeup96OJPHSUn2w5PAqbbUPb/cqYpZcmvg1KjqHL2y/unF2TyBCC7qGbCIQKA6HCBFPLc3B7XcTXjSYYoXm1tfzZaDxc8r7SHOXkuM6FRjzxQB5QpcWBPM6F5lNvzqqcJSb55xg9Igd4GeXzhNyNVDO7v67aagJvg5KRynOpx2apOGtoxipaLpW0pkk6dxa3vY7yRa85pkZZkEuQ2AsDocJAqDAQKgyECgOhwkCoMBAqDIQKA6HCQKgwECoMhAoDocJ4X6QrvqQwkL+Lb7l2NZmlV4fkEK89tBPvfuBfR83cEmk+Uw1cL017vuSzPjWOsrodsS6IocJ4Fupkoe6UHOJVaJP3eBafOSpueXSG91F+3T2emwpiqDAQKgyECgOhwkCoMKjlhUEtLwxqeWEQQ4VBLS8ManlhUMsLgxgqDIQKA6HCQKgwECoMhAoDocJAqDAQKgyECgOhwkCoME1MjgzzZY3HCXqoMJWF6jXPQX5o8Lyq1TNSKgvdotZUPQKpynJVobJQ89gJRTf7FNjTEYU5TSwfG1wrhibpdRKRemUOHNpjJ+uQX3nqkJdo+gQAAMAZvwGCtf/LkoyUwQAAAABJRU5ErkJggg==", eC = "data:image/png;base64,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", tC = "data:image/png;base64,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", nC = "/loan/static/png/success-_H-swI1n.png", rC = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADgAAAA4CAYAAACohjseAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAN2SURBVHgB7ZpbctowFIYPl/fSFdR9ZobLCkpWkGQFhRWQrqCwgk5WUFhByArirIDbAuquoPSdS/8ziA6WLVu2ZGJl+GYYB2Er+q2jo6MjEV25UmoqVDDz+byBS6Ner3vn5dVqddNsNhdUMNYFsiA0vn84HNqVSqWHIi/lkQXuC3B93u12frfbDcgiVgSyqFqtdoc/v0JYjwyAWB+XaavVmpAFjAUul8shLiN8GmSXAGLHpkJzC1yv1739fv+T0k3QlAD/5yav6VYpB6vV6gf+6QsVL47xMKZ/4YV+pxxk6kEx1p5Mx1leeHzCEd2jNzfaz+jeCHH8Ji/Va0lkMlktgSUSd4JFdnV6UmsMQtwTlUccc3rhqaQKZIeCS4fKR0e0LZFEgaiAI5IHMgTmNMbnM48dfA3IEtw2nq6S7lGOQRFyzcnQNOH5JpisB2f19nTNS5PE8ajsQTSCIxSPDMFb/i0VBWQXHo9KK4sVyF6TjuGXKwzFqiVCrEC8kTtyi4aqF1UmOiT3iG1zRCA7ASrXnKdLI86jRgQ6aJ7/gTeNtD3ORL+Qu9zKBSGBwhOVMWrRxZO9qdyDLos74Z1/CQnEWs922uHiQEOok0ICsZj0yHEQOYU6qX7+BR608B4UC9XEGBiXB7QlV4qCpORXrpxMkXDQjM+ILMWslxCYyypEMtiYahGVStyqAmEVHOznTWzJGurS79rZqgzwcmaOxfMMjf6bdjMa+AH39SkniQLhRRdoDBWAp5sZwH1kwna7DXVSxJshFf+H7KfhL8Wm3W5/PC+IdJfY/HCVV7kgIhBm+kqOgtXETC6LG3ATchdfLogI5InWRTPl7F1cOj/WZcJMx+QYEDiNLVc9gHnr5a12kbLCFofc603cb8pJz6VeRFsHqt+UAmHPPi6PVH4ek7bSEsMWuN0R2c9E2yQQbVSSKJA9Kiq4p2JiVFM2YiM0sW2pgScqWKCib1Qy0KaBzi6vVmSNiiZcIZUEIW6mc6/20qEkIjdC3ET3gcznZLAY7bzRljY7FD5hkel8W+bFnxiTPKlO6UJgIp+JTc7Mh/eMjnKhN/si++VRMQTCJH3Kia3DeH2xI2wlMy4O/EyzjDVlXWQRMT77dNzAySo2wOeZ13QmPSZT2IFYsQ3OglloA4H7p1NiGSICvqJsSUdhfpbjWVeuvCP+AcTYczRCVZwEAAAAAElFTkSuQmCC", iC = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAABQCAYAAACOEfKtAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAQWSURBVHgB7ZvLUhNBFIZPD8I2YYXLIYEqlvIEhicw7nQFPoH6BMATKE+gLl2hTwDu3MmSKiDM0gUFWVpQTNs/IZQmM5lLn57uGfqr4jaEdObL6dP/XCDyeDwej8fj8Xg8nqoRxEQYhu0gCN4SyS38SG5yJIQ4mp+Pd4+Po4gYYBHY7XY3pYw/qm/bVA8iIeT7s7PoG2miLbDbDftSin2qIUEgN05Po0PSICBNlLwPVFPiWHxC6yENtAR2Op1tcrff5SFUffsdaVB6Cqt3Tg0uzqn+DBcW5HrZRaV0Bap3bpuaQfvmJijdhkpVYIOq74GyC0qpClTyDqhhqMWw1IwqLFDFli2q98KRiJTUU3l2iwpSeAp3OsuYuiE1k2Ecy+UoioZ5/6BQBTYgtmTRLhprcldgExeOFArFmtwV2KDYkkWhWJOrAh9R9T2QN9bkqsAmxpYs8saaTIFNjS1Z5I01mVO44bEli8xYM7MCH0FsySIz1qRW4GNcOFKYGWtSK5AxthxhRRsMzgWmg+ouu2QMuafGWByPpa5/aJ+yp4xYk1iBjNUXqR1Zn+whnU64o4ZmzpVydzCIdia3qh7+S315RpqkxZog+cFcsUXsJTXg0Y5yVmKyvLtXIOQecYyQEmumBKqlu09MC4eaQqmrF5/EdHmj1/AkIgYQa1ZWwt7k9mD6gfIFMaGea+bU0Zc4Wx6I43iTmJAymHquhCkstfvFP8+1uboaGpKYLQ+9XD2uT0yoguhNbkvqgZwXx9u3t2J/bQ07kk5xifnk3fdyzv2ZaklTAnHrA/ESXl+LAz6JheSFxIgQOQSqZvmD+GGSaE/eiODL5Ja5yQ2tVutYVeEr4r/PBdO5v7TU/n5xMUxdna+uhoeLi22VT0Xv/9/YlkfRYDB4M7lxqgKR2+bm5EtKmO8MlKxE6/LGTqZIPRbG6qkqhrsJj4nU8eVG1mnz0RHLWGg6FcjbODmJEteGmaezXJCYhU15IPN8oMsSbcsDua6JuCjRBXkg92VNlyS6Ig8UujPBBYkuyQOFb+2wKdE1eaDwzUUYAAORwZyYdAIC21yTB0rdHwgMVyKOyT+rz3eHleosyPP7f58wQWl5oLRAYFpiBWjJA1oCQY0lassD2gJBDSWyyAMsAkGNJLLJA2wCQQ0kssoDrAKBwxLZ5QF2gcBBiUbkASMCgUMSjckDxgQCByQalQeMCgQWJRqXB4wLBBYkViIPVCIQVCixMnmgMoGgAomVygOVCgQGJVYuD1QuEBiQaEUesCIQMEq0Jg9YEwgYJFqVB6wKBBoSrcsD1gWCEhKdkAecEAgKSHRGHnBGIMgh0Sl5wCmBYIZE5+SBOXKMy8vh71ar/TUIglD9+FR9/BGCfip5r12T5/F4PB6Px1Nj/gJze6JzxfuTBwAAAABJRU5ErkJggg==", sC = "/loan/static/png/3-BiNRaIKQ.png", oC = "data:image/png;base64,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", aC = "data:image/png;base64,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", cC = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAJAAAACQCAYAAADnRuK4AAAACXBIWXMAACE4AAAhOAFFljFgAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAtRSURBVHgB7Z09kBTHFcf/vXydhCjjKiuwAm5I4OSEpVBqaYksV8klsCNsuTgFRiEgMifcVbmcSYIQHOgo2SayAYsqyxFrOTXFKjEfCQOBFEhVRoVA3J1uWv26d+72dmdnZ3Y+enrm/apgZ3dn7253/vvev79eCzQMed/bjVV4WENb3fXQwiyk3K2Pgd3907wxL/c33QrhI8CD/n0fM+iJvf4jNAiBGqPF8gxHsCU4gEC01bttQ66LpBgEHqnf0UNL9iBb/1YC64mXfR81pVYC0oJZQQcieE0J5gjGR5Ky6UEoQaF1DdvRrVOUcl5AWjTLmFdHb6q7HbhBF1JcolvXo5OTAlqPNFKehDuiGYcWkxLSEhzEKQHJ254yvcFx9WefKtzLlI+v0lwXQWvRpajkhICUcJSvkWfhfrRJhpBLSkgUlbqoOJUWUOOEMwqlt8UqC6mSAmLhjEBCeruKqa1SAjIeR36g/M0RMKOY1FYpj1QZAcm7e87W1Bznj5ALYv/DRVQA6wLqp6sPUZ1OP1fwVVo7bDsatWAJ6suR9/Z8oMRzAyyeafDUZ3ffRG57WIlA2usIeUUdtsHkgbVoVHoEkve8k8oo3wKLJ0+o8XFL3vFOoWRKjUA6ZQWi9DfZKFrynNj38DRKohQBccoqnZ5KaUfLSGmFC6gvHjbK5VOKLypUQMrvtNWI+Q3u27EETW4TSkT7/B4KojATLe96x1k8lqHPXl0DfS0KopAI1BfPEpjqIMS82O9fQs7kLiAWT4UpQES5CojF4wA5iyg3AbFhdoScjXUuAupPw7jF4nEEElEgDubRxM/cClvv52HxuANdK3XN9LXLSPZmvOlh9sC4Rjg6kIlMAtJjWzw84TLt/jWcmqk9kB5VD+Q5MDVAnBZz/lTXcioBsWmuGRlM9XQpjE1zvTCm+ope8ZuS1AJSnYU0hdIDUzfaWA1ST49NlcL6Tfb7YOqLmQLSTXp6ughk5vUwdcaskElMYgFx6moMnry9ZyHpyYlSGKeuhpGiVZYsArUCq2uPmJIxrbJEHYwTIxBHnwaTwFBPjkACqUwVUyNMhZRYYgWk161DdsA0lY7RwHjiI5AAe5+mMyEKjfVA/aoZVvp9bt7ehsv/fA4372zD4ydOVOErjF07JQ7NreLYz7/FoZdXYYUYLzReQHf3fKheOI+See+jnbj8yXNgRjn2+jOc+e03sEBXzD04HPVEpIBstbxYPJOxJiIp9kb1C0V7IAv9PjptsXgmcvmTGf1ZlU8wH/VotICk6KBkWDzJIX9YOi1xMmq6x4iAVPqah4UxLzvfKjex8llR7/TKaNXc0QgkUNg66jia3tpKw+Onlj4rs7XEJjYJyCzz4I5DZiyd4TQ2HIE6YJg49M5IG2wWkKX0xbiE3lZrnXUBmdDE6YuZyKY0thGBVjh9MQkZ0MpACgveBMMkQQad8HBDQFLwEmUmIWI92Gyl//rN90oK6L9/+QpN5pXf/AgVxCMfRJsHmwjU4gIJTEqemS25jIAkG2gmJSLQQSf0QAfAMKkQWjNGQKKa/oepMMLYnpbuFOJKG0xalGZIO1uVGWpXee/mirZCGGIVHqUwDwwzDWtos4CYLHAEYjLQwmxL+Z9ZMMw0rOGH1nZtZmpAS6oIBOmBYaZjN0cgJhNsopkseByBmExshYOc+NVTXaniiy+34OLfn8fnXyb7Hrz0YoBjr3+LfbPfoXtzu50VnjXDOQH94tVlnPjlU3NHiejHL67hnT/8INFr333rCTqvLOtjXSpF8pLqrDiXwoZr5ND9JHVzSHiheEL2z66ByUYtPNDZdyaXO/ldGLWYXCEB+XCcl1Qaowpe46DoQ+cwuePXphVGvojKwUXB0ac4SECPUAN2PS9x7GejUYhabBx9CsOvRQoLoTQ2GIWo2f7GT5fBFEcLUnyNikNC+OsfH+k1Ym+8+mzseRSFTgykK+rziYs+9LPoZ/7j3P/172BSIoQbEYj6b6jzLwlGNMF6p2ESSGTv2ql+6jYBHlBHog+Huafewgsq8gxGGhLDN082tw8+V73WX3zVsldruZ6oCLQFPVSc9/+8UwslCir39ic1nDFI59DKSKobPmcQqjn4/kcvgEmNvxXbVASquM+ksa5f/96sPFpQnYbD4vj40x36sXHRhaJPeM4g1z+dwcKF5MKhGs2muyCbX3qsouP1/+zQdbGdZga9Fi2Q1xuMOc7Fv42PMIsXskcX6oykAt9ZxUPQzyB/dsLl/imlmY3iClJUPo1NgtJQVPlbijJ5lMWNa/1NS1zveeWRxvqETvMz1IDFC7tGHrsY433S8PgJT53ajNSaCatzOB+BCPJKg6mMjpPOFZrEdeWh8oaio7OIVpduTNNmBleVka7FzoQUcegf9UjnWbycJqC9p1pqkzonk0DRjPa8yCs6WiEwQUcLiMyQvDPrw4H50cMRhWYlRhElnnuq0TnYUkvrjeii0z8GvXDnnoHOFXFN5bKTqDjht/bQT1Zx83/bcPlfyWcUhpGJZjHSaz8uIC01ArHR6Fr/msq73hFIeQWW4Coc6bBaO1KIo2K/f5UON/LBdnTBMEkY0Mq6gHSHIkQXDBNP12jFMNzGvQaGiUOKS4N3NwtoB5bAMPF0B+9sEhCnMWYC3eGNd6N2LDwPC4ybEM+MQjMvrTCUvohRAZHDtjA6zxO9kmPps/JV9FkafnBEQDqNBaL0KJR0+iljaRRfRFubcSONSygZ+lY5Pb2hJGhSm5UIFGAx6uFIARmjVL6ZPvPWExZRDCSeMzYm/wuxNGye158a9xp52+tAyBuwAA1yUtUMum36duDUuNDRWaV4az5RisNKQN2op2Kvjrzj3eB9VBtPV8w9ODzuyfjZVjI67zENQopYDUzMDxyFGk1s9CEmz/fkKNRcpHh70ikTBaTNkxBXwTSLmJbXIMlmnAc4XYe1Y0wKgmSZJ5GAtBIt9E4zlpByMUn0IVJ1ssg7s/fBhcnrjq+M896kJ6dbNJXAVDGOozoN05yeSkCmN5JTWW1JkbpCUo8T6E16l/UQB+/0XC9Spa6Q1Ot+9XQPKY5yq6xG0LVMmbpCplo4rsPchC5uxiHUtUybukIyDXWrYY5zLqxmZeKQ58Xcw1OYksxzJVTT/hbYD7lKT/meg8hA9ton5IdqVGu6Qfj9a5eJXGZrydueh5a8pQZed4OpPmSaA3FwWt8zSC7Vl/QfIpSL55ZZ9aFrJPQMQx85kFvdNrHP7ylVnwZTbdQ10tcqJ3KfcKzS2TyErEW1s9qhhqKi1nZloZAZ6yyiClKAeIhCSo/qP5QGXtkT2cf0MhciHvPjC0Te89pqgO4Gt84sERrmHD3PMIUWP+4ba+qo8sGUja+b6gWKhyi8enZ/3IwG6mpRi9oRev3FgD4KptRlnzx2VgbZxrbSUmr9fjHnqzcmeIJ+EejPVPXxlCge82stoIc+zLp7D0weUMo6WkbKGsbKDiL0RvXsN55TlAPyPHaU43eisF76gqPR1Pj9/p0uLFKZ2ilKSAtKSGfBxGNG0s8r4SygAlSq+I6ORgAJ6TiYUWiJeYDTttJVFJWs3mTSGm0/xVVBDKJLRS5sp6soKl3+y1RJw9nmCqm6wglxon6cFhIw35zUVn3hhDhVgHDAI72GurXa+uZYHS1VyeNMwtkKlmbOEY67n95EV+8OsH3zLjiu4KyAQvpRqeOWmHQJ5Wu0uY2LohnEeQENotftrygxBTii3tkB9UhV1qv5ektRga6rkWYctRLQMGa5EdrKkHbU3QPKO7ULn9xmZgDS1JXP9HbqM7haJ8EMU2sBRaGj1DO9ktbT/1qYVRfa6z/bvx1r0H1zIx6pT46OlfHFA/34FiWWbfDrLJYovgftfVEUaX3XGwAAAABJRU5ErkJggg==", lC = "data:image/png;base64,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", uC = "data:image/png;base64,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", fC = "/loan/static/png/LP-DxuS8Bb-.png", dC = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFgAAABYCAYAAABxlTA0AAAACXBIWXMAABYlAAAWJQFJUiTwAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAqiSURBVHgB7Z1NbBvXEcfn7S7ponFhNj25F6to0h7aQnTSSy8RjSC9tIBT55JeYiW2jKAHW/a9lZzeGymHIvBHI+eSXupGaE8GitCn5uDUEuJTkiLUJT01oRAnSMTdncy83aX4sbvcffsed03rB0giVxS1/HN23sy8eY8CKkRt73dN3+o1LSHmAUUDhd9EgIZAbACIxvCjsYtCdAVCh37XBYRtFLBl+U6nV//zFlQEASXi9F5ugeUvAGKLBGuOi6gKdum5toSPmwD1dpmCT11gFlVY/klEf1GfoOkIQVaO0Aa/tj5tsacicAOXG1/07i+iJU7S3RaUCbkRcivrPefqBkwBowKzsPf9Ly8A+svTstashFZ92bTQxgSueUsXEHG1asKOYlpo7QLLgUt4K1C2K8gJC21b9omvxOsd0Ig2gUN3sEIRwTI8yAix6tpXLoMmtAj8LXx5zvO9dxBhDmYAndZsQUFqeO6067l3Z0Vchl+L63l3a3vnCl+NhQR2vLMr6OFG1QcyRRpo4auOd24FCqDsImx36Q3640V4CBBCrPXsKxdBASWBHyZxI+j1blAo9yLkJLfAD6O4ESoi5xKY/NGrZYRhePt/4L/5wdhx+/oCTJu8ImcWmAc0KiGuQgngjQ/BO9MeO+64S1AKOWLlTFEEp71liVtJqATA4WmWh04UmJOIoKagF77sveduAXT3QAUx951Mj8MbH4B/5jbAzn3QCYWna6zNpMdNFJgzNJ1xrhT26X/KL9zcAf+19yf/0dxhUMX/43/AJ5HdH76lW+iG1AYXU7VJFVgmEhozNP/SvwNhSeT+sdfuqVnxkfrEh7D1Yufz/f9F96M3VgesTc2vpyYiiQJL89fud2PGVBJ3khWLRoyYjckCs/WOwoKL5qOgC3Kfy7KCmECiwIFr0Iv1hydihZloxRmsdZRR6+2fw/mfAhzL5r8zE5RnY4kVuOYuLRop3pC49vXW+PEMVhz3XGnEWS8PjPJN1k8rqTAUb8ECChU40hAnj4FY+P7Y8dy+uHEo8VeJ1vv7J1L/rghUGFqJG/DGBDZmvQPYf3lq3ALTrJgsz/7Xr8H+7/PBF99OskSKEuKs1zr9IxD0ZZCG49bHrHjcgg1abx/ygdb5n40dTrNisXAUBP2d/KLbSX4UNztj1mvQNQwj8MKoFQ8JPA3r7f9jesFi/nv9++w27L/9MlN0kIagQYxrFIOJiHQNuge2eBq1Xn1x8MCQwCjgAhSALdB/5b3Mj7f+9AsKwQ6RsM/QZf+rwDI1wK7A/uh5ehOfJJ8/l901bH86FqfnhXzxyaFziW7U9paaaMFdUIV8H2dL8klDnwnHMmRg3a+NDTyZCf2//0rgu+X53zmlfjWhfcKtvd7mm/sWbBWzXu/Urf3nJx8oU9Ms1lyyuDJ1//nNvrjyGJ1/7rBxCO/Z6Na+wEK9j0GGRdv/HzvOJ+099tdCl5wx2Gqj1D0mpFNO4RkB/UqbFFi6hwKDW1xYFMEnzy/CREVLFTYIfuOliEmQuByRKNKI0ufQgrEFBeABypowkMhCy0ttKB260jx6s5F9fwIyoqExpFjc7Lf4uxQ47HpUh+NaCo0cSgLShLZeMBroZ4NCw7gYnJGDG70OLRGNQDmfJaMImnr5jH7o623Y+Vz6X7baCBbeKmEOLRa6/N3H3ur7WJmIUKysOdPrus7V74rC4VkafDleepcGuU+kdU8p2M8EGwCSD+bExDr/EyPRjPBrx4XtnnlWgPV3MAhHGINZWyWQ1otGw0RyDy86Au0m+QswSeXEZQqm5FmgyKxpkczzcIARhLCOUBSBs9i4Vw2E37SowDMHB5gBKeEg96tmwZSVyRSTfVnoz0SFooQ84M5AqsyDX5Qid/YzT9E6mq14Nfi8nNGBYvzLhZzBOHeUqB5rUSmykoNciIzXMxSleC5RnH4cciIFNkK/gKJaMJkRCi8heNAx7dYeeoGH/K8B2EV0QWMdgqeA+kH8kUNTCeiLIOYfDWoQg4Mb/9wNqm1xteIcdIXtLX0sVGrBVO7D3bBYwp03ZU/7VBBKlTuOCCw4PySoOBA1FQrTOpbwxDYcYAaEXcrkUM2CD8iA2OJUuTLbr8waFm9xY/nmBa7krDKn+imZqA7QdzpWr36VBTbiJoaWCxh+MXnh9JgnP2VbgZlz6/L2NVGiodWKh4QNrVdO7VclbeYOzFBU2VYQCa1paUGI1DQQGPE2aCBO2P7vCnfL6COufUAK/dyt4NxjmmjyInyxyT8jC25DEcgikoQdBN/8sHwr5uaXlAYYaSRP3tTQKOO0+bsU2K1d4zvKfth76fbEgYzXRth3flN+6kw13ajzMg12Idj+BFQQQvQ3x9sv9iDcAEXSmpu5FsxdMtyqWqV0ms+ZWwmSFjTyceU+CcR2//8MHH0bFOEumNFuGU6j2Urs905p6/vVDpUq+9Y8cmXJpm1V/Np6dHNo4ZrjLvHSrRaoMNAtI3u7eB1Gllor+7lj6is5J7L9KcB8hnVx3I106V3wNzvBVUeGoYKg5KJnXz0e3R+qBwd7PSoSLtGKeruyimtgiWv/uXnQdZ/+R7bn5v467rTn87/5DCiDsD54d3jpJS42HK/2MejsU0tBxp5hvVX6vBceB+v0j4tZNMe46+8Ptaayi5Id94aRg5t95QeDx4ZnNMRGlxz0OkwBFmCwmC3jZNllXqzLKIi3h/t+5YYe04jBEcf2kBhfPDwNK+bLl2LN0R7dtA5MFk2eLM2S8DSPICtPGuXZ5YzNeJMLcz76rbEwMc56mZh1chtd8sWZdvNQhesAcQ3QaeEed0J63PJ/ph20DKR0p8c+Dy8ZyLECKjcYr1nspGevfm0NimZ3SefBG2TEFFdk43bKwDg2N7abkhHygBVj3dItGajsSetN2Fw0eVYZDVhxwjJXEysxk55PRiya03Xbsk4k/S5RYJk+o691wJOuIWaWlqMH7c3ZCct1tRedUFxO2+MytS/CdbxVNn/QhHjqKIymptJ6J6WkMW9Klun0uP0pOAmyNC0VYG3c2pXVtMekN57QgBeav5aCvFzieufUUKHF6DpiEjeyYpm6Uz0kcxI0mW6aa4jItG+aXCQO8AbohFPT9XtBEWgSVJ91KawbJdO+aXKZ7D3t6zAo0roYBgPpj4OMOL2zq3RNmN/qIIaokD8K7x1RSsss+d1JriEic28aDXqr6KNySXNmoFpDVnGZ/JuD7p3dEJbItOudNuSy1h3ZL4ZcrQutlrenmWYBnw3Mq19bzPM3uQVmShG5ZFTEZZTaV+U/0hwjVxlVcRnl/mC3dn3ZSLZXNWhAUxWXUXIRg9T2zi6jJaOLWVsO1iVxLhb9AJPCAjPBxzz47yDiHMwAnKFxElGJj3lg+ERkLXQWXAaFYY9Y3z6u6xNhtFjwIA+wNbfZQMIeEW1oFziC02vO/B4AoeUEQ5a0VwVjAkdUWGg5/3jYObzWFWvGmtCNCxwhC0a88R1CE8qlze0Jj9QOb5gUNmJqAkfwDis0kizTNMDCFK2aP1z1BgK+rdvHTmLqAg8Sit0KN2Viy9YVS7NlboVtue1pizpIqQKPwoL7lj8X7MLCG4Vgg7dbCHcEGBW/S7/jZICs0yIx/V1ffuwvbIVd+5XgG34I9XRbmzMCAAAAAElFTkSuQmCC", hC = "data:image/png;base64,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", pC = "data:image/png;base64,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", gC = "/loan/static/png/topPop-BoCCd1jR.png", j3 = "data:image/svg+xml,%3csvg%20width='230'%20height='151'%20viewBox='0%200%20230%20151'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cg%20opacity='0.1'%3e%3cpath%20d='M45.8465%20175.921C41.0967%20175.921%2037.6572%20174.648%2035.0366%20172.103C32.5798%20169.557%2031.2695%20165.898%2031.2695%20161.444V15.078C31.2695%2010.3052%2032.5798%206.80513%2035.2004%204.25964C37.821%201.71415%2041.5881%200.441406%2046.1741%200.441406C50.2687%200.441406%2053.7082%201.23687%2056.0012%202.8278C58.458%204.41873%2060.5873%206.96422%2062.7165%2010.7825L124.628%20121.989H116.602L178.513%2010.7825C180.479%207.12332%20182.608%204.41873%20185.065%202.8278C187.358%201.23687%20190.633%200.441406%20194.892%200.441406C199.642%200.441406%20203.081%201.71415%20205.702%204.25964C208.159%206.80513%20209.469%2010.4643%20209.469%2015.078V161.444C209.469%20166.057%20208.322%20169.557%20205.866%20172.103C203.409%20174.648%20199.805%20175.921%20194.892%20175.921C190.142%20175.921%20186.703%20174.648%20184.082%20172.103C181.625%20169.557%20180.315%20165.898%20180.315%20161.444V48.6466H185.884L133.308%20141.875C131.67%20144.58%20129.869%20146.648%20128.067%20147.921C126.265%20149.193%20123.645%20149.83%20120.533%20149.83C117.421%20149.83%20114.8%20149.193%20112.835%20147.762C110.87%20146.33%20109.068%20144.421%20107.594%20141.875L54.3634%2048.3284H60.4235V161.285C60.4235%20165.898%2059.277%20169.398%2056.8202%20171.944C54.1996%20174.648%2050.5963%20175.921%2045.8465%20175.921Z'%20fill='url(%23paint0_linear_14355_2113)'/%3e%3cpath%20d='M44.2223%2088.2679C44.2223%2094.7907%2038.6535%20100.2%2031.9383%20100.2H12.284C5.56873%20100.2%200%2094.7907%200%2088.2679C0%2081.7451%205.56873%2076.3359%2012.284%2076.3359H31.9383C38.6535%2076.3359%2044.2223%2081.586%2044.2223%2088.2679Z'%20fill='url(%23paint1_linear_14355_2113)'/%3e%3cpath%20d='M240.78%2088.2679C240.78%2094.7907%20235.211%20100.2%20228.496%20100.2H208.842C202.126%20100.2%20196.558%2094.7907%20196.558%2088.2679C196.558%2081.7451%20202.126%2076.3359%20208.842%2076.3359H228.496C235.211%2076.3359%20240.78%2081.586%20240.78%2088.2679Z'%20fill='url(%23paint2_linear_14355_2113)'/%3e%3c/g%3e%3cdefs%3e%3clinearGradient%20id='paint0_linear_14355_2113'%20x1='120.369'%20y1='0.441406'%20x2='120.369'%20y2='175.921'%20gradientUnits='userSpaceOnUse'%3e%3cstop%20stop-color='%23CCB040'/%3e%3cstop%20offset='1'%20stop-color='%23AE9F5F'%20stop-opacity='0'/%3e%3c/linearGradient%3e%3clinearGradient%20id='paint1_linear_14355_2113'%20x1='22.1111'%20y1='76.3359'%20x2='22.1111'%20y2='100.2'%20gradientUnits='userSpaceOnUse'%3e%3cstop%20stop-color='%23CCB040'/%3e%3cstop%20offset='1'%20stop-color='%23AE9F5F'%20stop-opacity='0'/%3e%3c/linearGradient%3e%3clinearGradient%20id='paint2_linear_14355_2113'%20x1='218.669'%20y1='76.3359'%20x2='218.669'%20y2='100.2'%20gradientUnits='userSpaceOnUse'%3e%3cstop%20stop-color='%23CCB040'/%3e%3cstop%20offset='1'%20stop-color='%23AE9F5F'%20stop-opacity='0'/%3e%3c/linearGradient%3e%3c/defs%3e%3c/svg%3e";
  var mC = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i, dp = Math.ceil, Fr = Math.floor, dr = "[BigNumber Error] ", Qb = dr + "Number primitive has more than 15 significant digits: ", ei = 1e14, Ve = 14, hp = 9007199254740991, pp = [
    1,
    10,
    100,
    1e3,
    1e4,
    1e5,
    1e6,
    1e7,
    1e8,
    1e9,
    1e10,
    1e11,
    1e12,
    1e13
  ], eo = 1e7, Tn = 1e9;
  function J3(t) {
    var e, n, r, i = O.prototype = {
      constructor: O,
      toString: null,
      valueOf: null
    }, s = new O(1), o = 20, a = 4, c = -7, l = 21, u = -1e7, f = 1e7, d = false, m = 1, y = 0, x = {
      prefix: "",
      groupSize: 3,
      secondaryGroupSize: 0,
      groupSeparator: ",",
      decimalSeparator: ".",
      fractionGroupSize: 0,
      fractionGroupSeparator: "\xA0",
      suffix: ""
    }, w = "0123456789abcdefghijklmnopqrstuvwxyz", R = true;
    function O(S, P) {
      var L, K, z, I, h, p, A, C, N = this;
      if (!(N instanceof O)) return new O(S, P);
      if (P == null) {
        if (S && S._isBigNumber === true) {
          N.s = S.s, !S.c || S.e > f ? N.c = N.e = null : S.e < u ? N.c = [
            N.e = 0
          ] : (N.e = S.e, N.c = S.c.slice());
          return;
        }
        if ((p = typeof S == "number") && S * 0 == 0) {
          if (N.s = 1 / S < 0 ? (S = -S, -1) : 1, S === ~~S) {
            for (I = 0, h = S; h >= 10; h /= 10, I++) ;
            I > f ? N.c = N.e = null : (N.e = I, N.c = [
              S
            ]);
            return;
          }
          C = String(S);
        } else {
          if (!mC.test(C = String(S))) return r(N, C, p);
          N.s = C.charCodeAt(0) == 45 ? (C = C.slice(1), -1) : 1;
        }
        (I = C.indexOf(".")) > -1 && (C = C.replace(".", "")), (h = C.search(/e/i)) > 0 ? (I < 0 && (I = h), I += +C.slice(h + 1), C = C.substring(0, h)) : I < 0 && (I = C.length);
      } else {
        if (Jt(P, 2, w.length, "Base"), P == 10 && R) return N = new O(S), H(N, o + N.e + 1, a);
        if (C = String(S), p = typeof S == "number") {
          if (S * 0 != 0) return r(N, C, p, P);
          if (N.s = 1 / S < 0 ? (C = C.slice(1), -1) : 1, O.DEBUG && C.replace(/^0\.0*|\./, "").length > 15) throw Error(Qb + S);
        } else N.s = C.charCodeAt(0) === 45 ? (C = C.slice(1), -1) : 1;
        for (L = w.slice(0, P), I = h = 0, A = C.length; h < A; h++) if (L.indexOf(K = C.charAt(h)) < 0) {
          if (K == ".") {
            if (h > I) {
              I = A;
              continue;
            }
          } else if (!z && (C == C.toUpperCase() && (C = C.toLowerCase()) || C == C.toLowerCase() && (C = C.toUpperCase()))) {
            z = true, h = -1, I = 0;
            continue;
          }
          return r(N, String(S), p, P);
        }
        p = false, C = n(C, P, 10, N.s), (I = C.indexOf(".")) > -1 ? C = C.replace(".", "") : I = C.length;
      }
      for (h = 0; C.charCodeAt(h) === 48; h++) ;
      for (A = C.length; C.charCodeAt(--A) === 48; ) ;
      if (C = C.slice(h, ++A)) {
        if (A -= h, p && O.DEBUG && A > 15 && (S > hp || S !== Fr(S))) throw Error(Qb + N.s * S);
        if ((I = I - h - 1) > f) N.c = N.e = null;
        else if (I < u) N.c = [
          N.e = 0
        ];
        else {
          if (N.e = I, N.c = [], h = (I + 1) % Ve, I < 0 && (h += Ve), h < A) {
            for (h && N.c.push(+C.slice(0, h)), A -= Ve; h < A; ) N.c.push(+C.slice(h, h += Ve));
            h = Ve - (C = C.slice(h)).length;
          } else h -= A;
          for (; h--; C += "0") ;
          N.c.push(+C);
        }
      } else N.c = [
        N.e = 0
      ];
    }
    O.clone = J3, O.ROUND_UP = 0, O.ROUND_DOWN = 1, O.ROUND_CEIL = 2, O.ROUND_FLOOR = 3, O.ROUND_HALF_UP = 4, O.ROUND_HALF_DOWN = 5, O.ROUND_HALF_EVEN = 6, O.ROUND_HALF_CEIL = 7, O.ROUND_HALF_FLOOR = 8, O.EUCLID = 9, O.config = O.set = function(S) {
      var P, L;
      if (S != null) if (typeof S == "object") {
        if (S.hasOwnProperty(P = "DECIMAL_PLACES") && (L = S[P], Jt(L, 0, Tn, P), o = L), S.hasOwnProperty(P = "ROUNDING_MODE") && (L = S[P], Jt(L, 0, 8, P), a = L), S.hasOwnProperty(P = "EXPONENTIAL_AT") && (L = S[P], L && L.pop ? (Jt(L[0], -Tn, 0, P), Jt(L[1], 0, Tn, P), c = L[0], l = L[1]) : (Jt(L, -Tn, Tn, P), c = -(l = L < 0 ? -L : L))), S.hasOwnProperty(P = "RANGE")) if (L = S[P], L && L.pop) Jt(L[0], -Tn, -1, P), Jt(L[1], 1, Tn, P), u = L[0], f = L[1];
        else if (Jt(L, -Tn, Tn, P), L) u = -(f = L < 0 ? -L : L);
        else throw Error(dr + P + " cannot be zero: " + L);
        if (S.hasOwnProperty(P = "CRYPTO")) if (L = S[P], L === !!L) if (L) if (typeof crypto < "u" && crypto && (crypto.getRandomValues || crypto.randomBytes)) d = L;
        else throw d = !L, Error(dr + "crypto unavailable");
        else d = L;
        else throw Error(dr + P + " not true or false: " + L);
        if (S.hasOwnProperty(P = "MODULO_MODE") && (L = S[P], Jt(L, 0, 9, P), m = L), S.hasOwnProperty(P = "POW_PRECISION") && (L = S[P], Jt(L, 0, Tn, P), y = L), S.hasOwnProperty(P = "FORMAT")) if (L = S[P], typeof L == "object") x = L;
        else throw Error(dr + P + " not an object: " + L);
        if (S.hasOwnProperty(P = "ALPHABET")) if (L = S[P], typeof L == "string" && !/^.?$|[+\-.\s]|(.).*\1/.test(L)) R = L.slice(0, 10) == "0123456789", w = L;
        else throw Error(dr + P + " invalid: " + L);
      } else throw Error(dr + "Object expected: " + S);
      return {
        DECIMAL_PLACES: o,
        ROUNDING_MODE: a,
        EXPONENTIAL_AT: [
          c,
          l
        ],
        RANGE: [
          u,
          f
        ],
        CRYPTO: d,
        MODULO_MODE: m,
        POW_PRECISION: y,
        FORMAT: x,
        ALPHABET: w
      };
    }, O.isBigNumber = function(S) {
      if (!S || S._isBigNumber !== true) return false;
      if (!O.DEBUG) return true;
      var P, L, K = S.c, z = S.e, I = S.s;
      e: if ({}.toString.call(K) == "[object Array]") {
        if ((I === 1 || I === -1) && z >= -Tn && z <= Tn && z === Fr(z)) {
          if (K[0] === 0) {
            if (z === 0 && K.length === 1) return true;
            break e;
          }
          if (P = (z + 1) % Ve, P < 1 && (P += Ve), String(K[0]).length == P) {
            for (P = 0; P < K.length; P++) if (L = K[P], L < 0 || L >= ei || L !== Fr(L)) break e;
            if (L !== 0) return true;
          }
        }
      } else if (K === null && z === null && (I === null || I === 1 || I === -1)) return true;
      throw Error(dr + "Invalid BigNumber: " + S);
    }, O.maximum = O.max = function() {
      return M(arguments, -1);
    }, O.minimum = O.min = function() {
      return M(arguments, 1);
    }, O.random = function() {
      var S = 9007199254740992, P = Math.random() * S & 2097151 ? function() {
        return Fr(Math.random() * S);
      } : function() {
        return (Math.random() * 1073741824 | 0) * 8388608 + (Math.random() * 8388608 | 0);
      };
      return function(L) {
        var K, z, I, h, p, A = 0, C = [], N = new O(s);
        if (L == null ? L = o : Jt(L, 0, Tn), h = dp(L / Ve), d) if (crypto.getRandomValues) {
          for (K = crypto.getRandomValues(new Uint32Array(h *= 2)); A < h; ) p = K[A] * 131072 + (K[A + 1] >>> 11), p >= 9e15 ? (z = crypto.getRandomValues(new Uint32Array(2)), K[A] = z[0], K[A + 1] = z[1]) : (C.push(p % 1e14), A += 2);
          A = h / 2;
        } else if (crypto.randomBytes) {
          for (K = crypto.randomBytes(h *= 7); A < h; ) p = (K[A] & 31) * 281474976710656 + K[A + 1] * 1099511627776 + K[A + 2] * 4294967296 + K[A + 3] * 16777216 + (K[A + 4] << 16) + (K[A + 5] << 8) + K[A + 6], p >= 9e15 ? crypto.randomBytes(7).copy(K, A) : (C.push(p % 1e14), A += 7);
          A = h / 7;
        } else throw d = false, Error(dr + "crypto unavailable");
        if (!d) for (; A < h; ) p = P(), p < 9e15 && (C[A++] = p % 1e14);
        for (h = C[--A], L %= Ve, h && L && (p = pp[Ve - L], C[A] = Fr(h / p) * p); C[A] === 0; C.pop(), A--) ;
        if (A < 0) C = [
          I = 0
        ];
        else {
          for (I = -1; C[0] === 0; C.splice(0, 1), I -= Ve) ;
          for (A = 1, p = C[0]; p >= 10; p /= 10, A++) ;
          A < Ve && (I -= Ve - A);
        }
        return N.e = I, N.c = C, N;
      };
    }(), O.sum = function() {
      for (var S = 1, P = arguments, L = new O(P[0]); S < P.length; ) L = L.plus(P[S++]);
      return L;
    }, n = /* @__PURE__ */ function() {
      var S = "0123456789";
      function P(L, K, z, I) {
        for (var h, p = [
          0
        ], A, C = 0, N = L.length; C < N; ) {
          for (A = p.length; A--; p[A] *= K) ;
          for (p[0] += I.indexOf(L.charAt(C++)), h = 0; h < p.length; h++) p[h] > z - 1 && (p[h + 1] == null && (p[h + 1] = 0), p[h + 1] += p[h] / z | 0, p[h] %= z);
        }
        return p.reverse();
      }
      return function(L, K, z, I, h) {
        var p, A, C, N, U, Y, T, g, F = L.indexOf("."), ee = o, E = a;
        for (F >= 0 && (N = y, y = 0, L = L.replace(".", ""), g = new O(K), Y = g.pow(L.length - F), y = N, g.c = P(ds(Or(Y.c), Y.e, "0"), 10, z, S), g.e = g.c.length), T = P(L, K, z, h ? (p = w, S) : (p = S, w)), C = N = T.length; T[--N] == 0; T.pop()) ;
        if (!T[0]) return p.charAt(0);
        if (F < 0 ? --C : (Y.c = T, Y.e = C, Y.s = I, Y = e(Y, g, ee, E, z), T = Y.c, U = Y.r, C = Y.e), A = C + ee + 1, F = T[A], N = z / 2, U = U || A < 0 || T[A + 1] != null, U = E < 4 ? (F != null || U) && (E == 0 || E == (Y.s < 0 ? 3 : 2)) : F > N || F == N && (E == 4 || U || E == 6 && T[A - 1] & 1 || E == (Y.s < 0 ? 8 : 7)), A < 1 || !T[0]) L = U ? ds(p.charAt(1), -ee, p.charAt(0)) : p.charAt(0);
        else {
          if (T.length = A, U) for (--z; ++T[--A] > z; ) T[A] = 0, A || (++C, T = [
            1
          ].concat(T));
          for (N = T.length; !T[--N]; ) ;
          for (F = 0, L = ""; F <= N; L += p.charAt(T[F++])) ;
          L = ds(L, C, p.charAt(0));
        }
        return L;
      };
    }(), e = /* @__PURE__ */ function() {
      function S(K, z, I) {
        var h, p, A, C, N = 0, U = K.length, Y = z % eo, T = z / eo | 0;
        for (K = K.slice(); U--; ) A = K[U] % eo, C = K[U] / eo | 0, h = T * A + C * Y, p = Y * A + h % eo * eo + N, N = (p / I | 0) + (h / eo | 0) + T * C, K[U] = p % I;
        return N && (K = [
          N
        ].concat(K)), K;
      }
      function P(K, z, I, h) {
        var p, A;
        if (I != h) A = I > h ? 1 : -1;
        else for (p = A = 0; p < I; p++) if (K[p] != z[p]) {
          A = K[p] > z[p] ? 1 : -1;
          break;
        }
        return A;
      }
      function L(K, z, I, h) {
        for (var p = 0; I--; ) K[I] -= p, p = K[I] < z[I] ? 1 : 0, K[I] = p * h + K[I] - z[I];
        for (; !K[0] && K.length > 1; K.splice(0, 1)) ;
      }
      return function(K, z, I, h, p) {
        var A, C, N, U, Y, T, g, F, ee, E, Z, k, X, $, ce, fe, G, W = K.s == z.s ? 1 : -1, V = K.c, te = z.c;
        if (!V || !V[0] || !te || !te[0]) return new O(!K.s || !z.s || (V ? te && V[0] == te[0] : !te) ? NaN : V && V[0] == 0 || !te ? W * 0 : W / 0);
        for (F = new O(W), ee = F.c = [], C = K.e - z.e, W = I + C + 1, p || (p = ei, C = Lr(K.e / Ve) - Lr(z.e / Ve), W = W / Ve | 0), N = 0; te[N] == (V[N] || 0); N++) ;
        if (te[N] > (V[N] || 0) && C--, W < 0) ee.push(1), U = true;
        else {
          for ($ = V.length, fe = te.length, N = 0, W += 2, Y = Fr(p / (te[0] + 1)), Y > 1 && (te = S(te, Y, p), V = S(V, Y, p), fe = te.length, $ = V.length), X = fe, E = V.slice(0, fe), Z = E.length; Z < fe; E[Z++] = 0) ;
          G = te.slice(), G = [
            0
          ].concat(G), ce = te[0], te[1] >= p / 2 && ce++;
          do {
            if (Y = 0, A = P(te, E, fe, Z), A < 0) {
              if (k = E[0], fe != Z && (k = k * p + (E[1] || 0)), Y = Fr(k / ce), Y > 1) for (Y >= p && (Y = p - 1), T = S(te, Y, p), g = T.length, Z = E.length; P(T, E, g, Z) == 1; ) Y--, L(T, fe < g ? G : te, g, p), g = T.length, A = 1;
              else Y == 0 && (A = Y = 1), T = te.slice(), g = T.length;
              if (g < Z && (T = [
                0
              ].concat(T)), L(E, T, Z, p), Z = E.length, A == -1) for (; P(te, E, fe, Z) < 1; ) Y++, L(E, fe < Z ? G : te, Z, p), Z = E.length;
            } else A === 0 && (Y++, E = [
              0
            ]);
            ee[N++] = Y, E[0] ? E[Z++] = V[X] || 0 : (E = [
              V[X]
            ], Z = 1);
          } while ((X++ < $ || E[0] != null) && W--);
          U = E[0] != null, ee[0] || ee.splice(0, 1);
        }
        if (p == ei) {
          for (N = 1, W = ee[0]; W >= 10; W /= 10, N++) ;
          H(F, I + (F.e = N + C * Ve - 1) + 1, h, U);
        } else F.e = C, F.r = +U;
        return F;
      };
    }();
    function B(S, P, L, K) {
      var z, I, h, p, A;
      if (L == null ? L = a : Jt(L, 0, 8), !S.c) return S.toString();
      if (z = S.c[0], h = S.e, P == null) A = Or(S.c), A = K == 1 || K == 2 && (h <= c || h >= l) ? Ff(A, h) : ds(A, h, "0");
      else if (S = H(new O(S), P, L), I = S.e, A = Or(S.c), p = A.length, K == 1 || K == 2 && (P <= I || I <= c)) {
        for (; p < P; A += "0", p++) ;
        A = Ff(A, I);
      } else if (P -= h, A = ds(A, I, "0"), I + 1 > p) {
        if (--P > 0) for (A += "."; P--; A += "0") ;
      } else if (P += I - p, P > 0) for (I + 1 == p && (A += "."); P--; A += "0") ;
      return S.s < 0 && z ? "-" + A : A;
    }
    function M(S, P) {
      for (var L, K, z = 1, I = new O(S[0]); z < S.length; z++) K = new O(S[z]), (!K.s || (L = ea(I, K)) === P || L === 0 && I.s === P) && (I = K);
      return I;
    }
    function D(S, P, L) {
      for (var K = 1, z = P.length; !P[--z]; P.pop()) ;
      for (z = P[0]; z >= 10; z /= 10, K++) ;
      return (L = K + L * Ve - 1) > f ? S.c = S.e = null : L < u ? S.c = [
        S.e = 0
      ] : (S.e = L, S.c = P), S;
    }
    r = /* @__PURE__ */ function() {
      var S = /^(-?)0([xbo])(?=\w[\w.]*$)/i, P = /^([^.]+)\.$/, L = /^\.([^.]+)$/, K = /^-?(Infinity|NaN)$/, z = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
      return function(I, h, p, A) {
        var C, N = p ? h : h.replace(z, "");
        if (K.test(N)) I.s = isNaN(N) ? null : N < 0 ? -1 : 1;
        else {
          if (!p && (N = N.replace(S, function(U, Y, T) {
            return C = (T = T.toLowerCase()) == "x" ? 16 : T == "b" ? 2 : 8, !A || A == C ? Y : U;
          }), A && (C = A, N = N.replace(P, "$1").replace(L, "0.$1")), h != N)) return new O(N, C);
          if (O.DEBUG) throw Error(dr + "Not a" + (A ? " base " + A : "") + " number: " + h);
          I.s = null;
        }
        I.c = I.e = null;
      };
    }();
    function H(S, P, L, K) {
      var z, I, h, p, A, C, N, U = S.c, Y = pp;
      if (U) {
        e: {
          for (z = 1, p = U[0]; p >= 10; p /= 10, z++) ;
          if (I = P - z, I < 0) I += Ve, h = P, A = U[C = 0], N = Fr(A / Y[z - h - 1] % 10);
          else if (C = dp((I + 1) / Ve), C >= U.length) if (K) {
            for (; U.length <= C; U.push(0)) ;
            A = N = 0, z = 1, I %= Ve, h = I - Ve + 1;
          } else break e;
          else {
            for (A = p = U[C], z = 1; p >= 10; p /= 10, z++) ;
            I %= Ve, h = I - Ve + z, N = h < 0 ? 0 : Fr(A / Y[z - h - 1] % 10);
          }
          if (K = K || P < 0 || U[C + 1] != null || (h < 0 ? A : A % Y[z - h - 1]), K = L < 4 ? (N || K) && (L == 0 || L == (S.s < 0 ? 3 : 2)) : N > 5 || N == 5 && (L == 4 || K || L == 6 && (I > 0 ? h > 0 ? A / Y[z - h] : 0 : U[C - 1]) % 10 & 1 || L == (S.s < 0 ? 8 : 7)), P < 1 || !U[0]) return U.length = 0, K ? (P -= S.e + 1, U[0] = Y[(Ve - P % Ve) % Ve], S.e = -P || 0) : U[0] = S.e = 0, S;
          if (I == 0 ? (U.length = C, p = 1, C--) : (U.length = C + 1, p = Y[Ve - I], U[C] = h > 0 ? Fr(A / Y[z - h] % Y[h]) * p : 0), K) for (; ; ) if (C == 0) {
            for (I = 1, h = U[0]; h >= 10; h /= 10, I++) ;
            for (h = U[0] += p, p = 1; h >= 10; h /= 10, p++) ;
            I != p && (S.e++, U[0] == ei && (U[0] = 1));
            break;
          } else {
            if (U[C] += p, U[C] != ei) break;
            U[C--] = 0, p = 1;
          }
          for (I = U.length; U[--I] === 0; U.pop()) ;
        }
        S.e > f ? S.c = S.e = null : S.e < u && (S.c = [
          S.e = 0
        ]);
      }
      return S;
    }
    function q(S) {
      var P, L = S.e;
      return L === null ? S.toString() : (P = Or(S.c), P = L <= c || L >= l ? Ff(P, L) : ds(P, L, "0"), S.s < 0 ? "-" + P : P);
    }
    return i.absoluteValue = i.abs = function() {
      var S = new O(this);
      return S.s < 0 && (S.s = 1), S;
    }, i.comparedTo = function(S, P) {
      return ea(this, new O(S, P));
    }, i.decimalPlaces = i.dp = function(S, P) {
      var L, K, z, I = this;
      if (S != null) return Jt(S, 0, Tn), P == null ? P = a : Jt(P, 0, 8), H(new O(I), S + I.e + 1, P);
      if (!(L = I.c)) return null;
      if (K = ((z = L.length - 1) - Lr(this.e / Ve)) * Ve, z = L[z]) for (; z % 10 == 0; z /= 10, K--) ;
      return K < 0 && (K = 0), K;
    }, i.dividedBy = i.div = function(S, P) {
      return e(this, new O(S, P), o, a);
    }, i.dividedToIntegerBy = i.idiv = function(S, P) {
      return e(this, new O(S, P), 0, 1);
    }, i.exponentiatedBy = i.pow = function(S, P) {
      var L, K, z, I, h, p, A, C, N, U = this;
      if (S = new O(S), S.c && !S.isInteger()) throw Error(dr + "Exponent not an integer: " + q(S));
      if (P != null && (P = new O(P)), p = S.e > 14, !U.c || !U.c[0] || U.c[0] == 1 && !U.e && U.c.length == 1 || !S.c || !S.c[0]) return N = new O(Math.pow(+q(U), p ? S.s * (2 - kf(S)) : +q(S))), P ? N.mod(P) : N;
      if (A = S.s < 0, P) {
        if (P.c ? !P.c[0] : !P.s) return new O(NaN);
        K = !A && U.isInteger() && P.isInteger(), K && (U = U.mod(P));
      } else {
        if (S.e > 9 && (U.e > 0 || U.e < -1 || (U.e == 0 ? U.c[0] > 1 || p && U.c[1] >= 24e7 : U.c[0] < 8e13 || p && U.c[0] <= 9999975e7))) return I = U.s < 0 && kf(S) ? -0 : 0, U.e > -1 && (I = 1 / I), new O(A ? 1 / I : I);
        y && (I = dp(y / Ve + 2));
      }
      for (p ? (L = new O(0.5), A && (S.s = 1), C = kf(S)) : (z = Math.abs(+q(S)), C = z % 2), N = new O(s); ; ) {
        if (C) {
          if (N = N.times(U), !N.c) break;
          I ? N.c.length > I && (N.c.length = I) : K && (N = N.mod(P));
        }
        if (z) {
          if (z = Fr(z / 2), z === 0) break;
          C = z % 2;
        } else if (S = S.times(L), H(S, S.e + 1, 1), S.e > 14) C = kf(S);
        else {
          if (z = +q(S), z === 0) break;
          C = z % 2;
        }
        U = U.times(U), I ? U.c && U.c.length > I && (U.c.length = I) : K && (U = U.mod(P));
      }
      return K ? N : (A && (N = s.div(N)), P ? N.mod(P) : I ? H(N, y, a, h) : N);
    }, i.integerValue = function(S) {
      var P = new O(this);
      return S == null ? S = a : Jt(S, 0, 8), H(P, P.e + 1, S);
    }, i.isEqualTo = i.eq = function(S, P) {
      return ea(this, new O(S, P)) === 0;
    }, i.isFinite = function() {
      return !!this.c;
    }, i.isGreaterThan = i.gt = function(S, P) {
      return ea(this, new O(S, P)) > 0;
    }, i.isGreaterThanOrEqualTo = i.gte = function(S, P) {
      return (P = ea(this, new O(S, P))) === 1 || P === 0;
    }, i.isInteger = function() {
      return !!this.c && Lr(this.e / Ve) > this.c.length - 2;
    }, i.isLessThan = i.lt = function(S, P) {
      return ea(this, new O(S, P)) < 0;
    }, i.isLessThanOrEqualTo = i.lte = function(S, P) {
      return (P = ea(this, new O(S, P))) === -1 || P === 0;
    }, i.isNaN = function() {
      return !this.s;
    }, i.isNegative = function() {
      return this.s < 0;
    }, i.isPositive = function() {
      return this.s > 0;
    }, i.isZero = function() {
      return !!this.c && this.c[0] == 0;
    }, i.minus = function(S, P) {
      var L, K, z, I, h = this, p = h.s;
      if (S = new O(S, P), P = S.s, !p || !P) return new O(NaN);
      if (p != P) return S.s = -P, h.plus(S);
      var A = h.e / Ve, C = S.e / Ve, N = h.c, U = S.c;
      if (!A || !C) {
        if (!N || !U) return N ? (S.s = -P, S) : new O(U ? h : NaN);
        if (!N[0] || !U[0]) return U[0] ? (S.s = -P, S) : new O(N[0] ? h : a == 3 ? -0 : 0);
      }
      if (A = Lr(A), C = Lr(C), N = N.slice(), p = A - C) {
        for ((I = p < 0) ? (p = -p, z = N) : (C = A, z = U), z.reverse(), P = p; P--; z.push(0)) ;
        z.reverse();
      } else for (K = (I = (p = N.length) < (P = U.length)) ? p : P, p = P = 0; P < K; P++) if (N[P] != U[P]) {
        I = N[P] < U[P];
        break;
      }
      if (I && (z = N, N = U, U = z, S.s = -S.s), P = (K = U.length) - (L = N.length), P > 0) for (; P--; N[L++] = 0) ;
      for (P = ei - 1; K > p; ) {
        if (N[--K] < U[K]) {
          for (L = K; L && !N[--L]; N[L] = P) ;
          --N[L], N[K] += ei;
        }
        N[K] -= U[K];
      }
      for (; N[0] == 0; N.splice(0, 1), --C) ;
      return N[0] ? D(S, N, C) : (S.s = a == 3 ? -1 : 1, S.c = [
        S.e = 0
      ], S);
    }, i.modulo = i.mod = function(S, P) {
      var L, K, z = this;
      return S = new O(S, P), !z.c || !S.s || S.c && !S.c[0] ? new O(NaN) : !S.c || z.c && !z.c[0] ? new O(z) : (m == 9 ? (K = S.s, S.s = 1, L = e(z, S, 0, 3), S.s = K, L.s *= K) : L = e(z, S, 0, m), S = z.minus(L.times(S)), !S.c[0] && m == 1 && (S.s = z.s), S);
    }, i.multipliedBy = i.times = function(S, P) {
      var L, K, z, I, h, p, A, C, N, U, Y, T, g, F, ee, E = this, Z = E.c, k = (S = new O(S, P)).c;
      if (!Z || !k || !Z[0] || !k[0]) return !E.s || !S.s || Z && !Z[0] && !k || k && !k[0] && !Z ? S.c = S.e = S.s = null : (S.s *= E.s, !Z || !k ? S.c = S.e = null : (S.c = [
        0
      ], S.e = 0)), S;
      for (K = Lr(E.e / Ve) + Lr(S.e / Ve), S.s *= E.s, A = Z.length, U = k.length, A < U && (g = Z, Z = k, k = g, z = A, A = U, U = z), z = A + U, g = []; z--; g.push(0)) ;
      for (F = ei, ee = eo, z = U; --z >= 0; ) {
        for (L = 0, Y = k[z] % ee, T = k[z] / ee | 0, h = A, I = z + h; I > z; ) C = Z[--h] % ee, N = Z[h] / ee | 0, p = T * C + N * Y, C = Y * C + p % ee * ee + g[I] + L, L = (C / F | 0) + (p / ee | 0) + T * N, g[I--] = C % F;
        g[I] = L;
      }
      return L ? ++K : g.splice(0, 1), D(S, g, K);
    }, i.negated = function() {
      var S = new O(this);
      return S.s = -S.s || null, S;
    }, i.plus = function(S, P) {
      var L, K = this, z = K.s;
      if (S = new O(S, P), P = S.s, !z || !P) return new O(NaN);
      if (z != P) return S.s = -P, K.minus(S);
      var I = K.e / Ve, h = S.e / Ve, p = K.c, A = S.c;
      if (!I || !h) {
        if (!p || !A) return new O(z / 0);
        if (!p[0] || !A[0]) return A[0] ? S : new O(p[0] ? K : z * 0);
      }
      if (I = Lr(I), h = Lr(h), p = p.slice(), z = I - h) {
        for (z > 0 ? (h = I, L = A) : (z = -z, L = p), L.reverse(); z--; L.push(0)) ;
        L.reverse();
      }
      for (z = p.length, P = A.length, z - P < 0 && (L = A, A = p, p = L, P = z), z = 0; P; ) z = (p[--P] = p[P] + A[P] + z) / ei | 0, p[P] = ei === p[P] ? 0 : p[P] % ei;
      return z && (p = [
        z
      ].concat(p), ++h), D(S, p, h);
    }, i.precision = i.sd = function(S, P) {
      var L, K, z, I = this;
      if (S != null && S !== !!S) return Jt(S, 1, Tn), P == null ? P = a : Jt(P, 0, 8), H(new O(I), S, P);
      if (!(L = I.c)) return null;
      if (z = L.length - 1, K = z * Ve + 1, z = L[z]) {
        for (; z % 10 == 0; z /= 10, K--) ;
        for (z = L[0]; z >= 10; z /= 10, K++) ;
      }
      return S && I.e + 1 > K && (K = I.e + 1), K;
    }, i.shiftedBy = function(S) {
      return Jt(S, -hp, hp), this.times("1e" + S);
    }, i.squareRoot = i.sqrt = function() {
      var S, P, L, K, z, I = this, h = I.c, p = I.s, A = I.e, C = o + 4, N = new O("0.5");
      if (p !== 1 || !h || !h[0]) return new O(!p || p < 0 && (!h || h[0]) ? NaN : h ? I : 1 / 0);
      if (p = Math.sqrt(+q(I)), p == 0 || p == 1 / 0 ? (P = Or(h), (P.length + A) % 2 == 0 && (P += "0"), p = Math.sqrt(+P), A = Lr((A + 1) / 2) - (A < 0 || A % 2), p == 1 / 0 ? P = "5e" + A : (P = p.toExponential(), P = P.slice(0, P.indexOf("e") + 1) + A), L = new O(P)) : L = new O(p + ""), L.c[0]) {
        for (A = L.e, p = A + C, p < 3 && (p = 0); ; ) if (z = L, L = N.times(z.plus(e(I, z, C, 1))), Or(z.c).slice(0, p) === (P = Or(L.c)).slice(0, p)) if (L.e < A && --p, P = P.slice(p - 3, p + 1), P == "9999" || !K && P == "4999") {
          if (!K && (H(z, z.e + o + 2, 0), z.times(z).eq(I))) {
            L = z;
            break;
          }
          C += 4, p += 4, K = 1;
        } else {
          (!+P || !+P.slice(1) && P.charAt(0) == "5") && (H(L, L.e + o + 2, 1), S = !L.times(L).eq(I));
          break;
        }
      }
      return H(L, L.e + o + 1, a, S);
    }, i.toExponential = function(S, P) {
      return S != null && (Jt(S, 0, Tn), S++), B(this, S, P, 1);
    }, i.toFixed = function(S, P) {
      return S != null && (Jt(S, 0, Tn), S = S + this.e + 1), B(this, S, P);
    }, i.toFormat = function(S, P, L) {
      var K, z = this;
      if (L == null) S != null && P && typeof P == "object" ? (L = P, P = null) : S && typeof S == "object" ? (L = S, S = P = null) : L = x;
      else if (typeof L != "object") throw Error(dr + "Argument not an object: " + L);
      if (K = z.toFixed(S, P), z.c) {
        var I, h = K.split("."), p = +L.groupSize, A = +L.secondaryGroupSize, C = L.groupSeparator || "", N = h[0], U = h[1], Y = z.s < 0, T = Y ? N.slice(1) : N, g = T.length;
        if (A && (I = p, p = A, A = I, g -= I), p > 0 && g > 0) {
          for (I = g % p || p, N = T.substr(0, I); I < g; I += p) N += C + T.substr(I, p);
          A > 0 && (N += C + T.slice(I)), Y && (N = "-" + N);
        }
        K = U ? N + (L.decimalSeparator || "") + ((A = +L.fractionGroupSize) ? U.replace(new RegExp("\\d{" + A + "}\\B", "g"), "$&" + (L.fractionGroupSeparator || "")) : U) : N;
      }
      return (L.prefix || "") + K + (L.suffix || "");
    }, i.toFraction = function(S) {
      var P, L, K, z, I, h, p, A, C, N, U, Y, T = this, g = T.c;
      if (S != null && (p = new O(S), !p.isInteger() && (p.c || p.s !== 1) || p.lt(s))) throw Error(dr + "Argument " + (p.isInteger() ? "out of range: " : "not an integer: ") + q(p));
      if (!g) return new O(T);
      for (P = new O(s), C = L = new O(s), K = A = new O(s), Y = Or(g), I = P.e = Y.length - T.e - 1, P.c[0] = pp[(h = I % Ve) < 0 ? Ve + h : h], S = !S || p.comparedTo(P) > 0 ? I > 0 ? P : C : p, h = f, f = 1 / 0, p = new O(Y), A.c[0] = 0; N = e(p, P, 0, 1), z = L.plus(N.times(K)), z.comparedTo(S) != 1; ) L = K, K = z, C = A.plus(N.times(z = C)), A = z, P = p.minus(N.times(z = P)), p = z;
      return z = e(S.minus(L), K, 0, 1), A = A.plus(z.times(C)), L = L.plus(z.times(K)), A.s = C.s = T.s, I = I * 2, U = e(C, K, I, a).minus(T).abs().comparedTo(e(A, L, I, a).minus(T).abs()) < 1 ? [
        C,
        K
      ] : [
        A,
        L
      ], f = h, U;
    }, i.toNumber = function() {
      return +q(this);
    }, i.toPrecision = function(S, P) {
      return S != null && Jt(S, 1, Tn), B(this, S, P, 2);
    }, i.toString = function(S) {
      var P, L = this, K = L.s, z = L.e;
      return z === null ? K ? (P = "Infinity", K < 0 && (P = "-" + P)) : P = "NaN" : (S == null ? P = z <= c || z >= l ? Ff(Or(L.c), z) : ds(Or(L.c), z, "0") : S === 10 && R ? (L = H(new O(L), o + z + 1, a), P = ds(Or(L.c), L.e, "0")) : (Jt(S, 2, w.length, "Base"), P = n(ds(Or(L.c), z, "0"), 10, S, K, true)), K < 0 && L.c[0] && (P = "-" + P)), P;
    }, i.valueOf = i.toJSON = function() {
      return q(this);
    }, i._isBigNumber = true, i[Symbol.toStringTag] = "BigNumber", i[Symbol.for("nodejs.util.inspect.custom")] = i.valueOf, t != null && O.set(t), O;
  }
  function Lr(t) {
    var e = t | 0;
    return t > 0 || t === e ? e : e - 1;
  }
  function Or(t) {
    for (var e, n, r = 1, i = t.length, s = t[0] + ""; r < i; ) {
      for (e = t[r++] + "", n = Ve - e.length; n--; e = "0" + e) ;
      s += e;
    }
    for (i = s.length; s.charCodeAt(--i) === 48; ) ;
    return s.slice(0, i + 1 || 1);
  }
  function ea(t, e) {
    var n, r, i = t.c, s = e.c, o = t.s, a = e.s, c = t.e, l = e.e;
    if (!o || !a) return null;
    if (n = i && !i[0], r = s && !s[0], n || r) return n ? r ? 0 : -a : o;
    if (o != a) return o;
    if (n = o < 0, r = c == l, !i || !s) return r ? 0 : !i ^ n ? 1 : -1;
    if (!r) return c > l ^ n ? 1 : -1;
    for (a = (c = i.length) < (l = s.length) ? c : l, o = 0; o < a; o++) if (i[o] != s[o]) return i[o] > s[o] ^ n ? 1 : -1;
    return c == l ? 0 : c > l ^ n ? 1 : -1;
  }
  function Jt(t, e, n, r) {
    if (t < e || t > n || t !== Fr(t)) throw Error(dr + (r || "Argument") + (typeof t == "number" ? t < e || t > n ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(t));
  }
  function kf(t) {
    var e = t.c.length - 1;
    return Lr(t.e / Ve) == e && t.c[e] % 2 != 0;
  }
  function Ff(t, e) {
    return (t.length > 1 ? t.charAt(0) + "." + t.slice(1) : t) + (e < 0 ? "e" : "e+") + e;
  }
  function ds(t, e, n) {
    var r, i;
    if (e < 0) {
      for (i = n + "."; ++e; i += n) ;
      t = i + t;
    } else if (r = t.length, ++e > r) {
      for (i = n, e -= r; --e; i += n) ;
      t += i;
    } else e < r && (t = t.slice(0, e) + "." + t.slice(e));
    return t;
  }
  k1 = J3();
  function yC() {
  }
  let cf, z0, K3, W3, bC;
  Xr = Object.assign;
  F1 = typeof window < "u";
  cf = (t) => t !== null && typeof t == "object";
  Fn = (t) => t != null;
  z0 = (t) => typeof t == "function";
  K3 = (t) => cf(t) && z0(t.then) && z0(t.catch);
  TW = (t) => Object.prototype.toString.call(t) === "[object Date]" && !Number.isNaN(t.getTime());
  W3 = (t) => typeof t == "number" || /^\d+(\.\d+)?$/.test(t);
  bC = () => F1 ? /ios|iphone|ipad|ipod/.test(navigator.userAgent.toLowerCase()) : false;
  function jb(t, e) {
    const n = e.split(".");
    let r = t;
    return n.forEach((i) => {
      var s;
      r = cf(r) && (s = r[i]) != null ? s : "";
    }), r;
  }
  xC = function(t, e, n) {
    return e.reduce((r, i) => (r[i] = t[i], r), {});
  };
  let Jb, AC;
  CW = (t, e) => JSON.stringify(t) === JSON.stringify(e);
  Jb = (t) => Array.isArray(t) ? t : [
    t
  ];
  To = null;
  pn = [
    Number,
    String
  ];
  bo = {
    type: Boolean,
    default: true
  };
  IW = (t) => ({
    type: t,
    required: true
  });
  PW = () => ({
    type: Array,
    default: () => []
  });
  AC = (t) => ({
    type: Number,
    default: t
  });
  wC = (t) => ({
    type: pn,
    default: t
  });
  yn = (t) => ({
    type: String,
    default: t
  });
  var lf = typeof window < "u";
  Kb = function(t) {
    return lf ? requestAnimationFrame(t) : -1;
  };
  _W = function(t) {
    Kb(() => Kb(t));
  };
  let vC, Wb;
  vC = (t) => t === window;
  Wb = (t, e) => ({
    top: 0,
    left: 0,
    right: t,
    bottom: e,
    width: t,
    height: e
  });
  RW = (t) => {
    const e = ar(t);
    if (vC(e)) {
      const n = e.innerWidth, r = e.innerHeight;
      return Wb(n, r);
    }
    return (e == null ? void 0 : e.getBoundingClientRect) ? e.getBoundingClientRect() : Wb(0, 0);
  };
  EC = function(t) {
    const e = qn(t, null);
    if (e) {
      const n = xr(), { link: r, unlink: i, internalChildren: s } = e;
      r(n), yl(() => i(n));
      const o = it(() => s.indexOf(n));
      return {
        parent: e,
        index: o
      };
    }
    return {
      parent: null,
      index: Ze(-1)
    };
  };
  function SC(t) {
    const e = [], n = (r) => {
      Array.isArray(r) && r.forEach((i) => {
        var s;
        Pa(i) && (e.push(i), (s = i.component) != null && s.subTree && (e.push(i.component.subTree), n(i.component.subTree.children)), i.children && n(i.children));
      });
    };
    return n(t), e;
  }
  var qb = (t, e) => {
    const n = t.indexOf(e);
    return n === -1 ? t.findIndex((r) => e.key !== void 0 && e.key !== null && r.type === e.type && r.key === e.key) : n;
  };
  function TC(t, e, n) {
    const r = SC(t.subTree.children);
    n.sort((s, o) => qb(r, s.vnode) - qb(r, o.vnode));
    const i = n.map((s) => s.proxy);
    e.sort((s, o) => {
      const a = i.indexOf(s), c = i.indexOf(o);
      return a - c;
    });
  }
  NW = function(t) {
    const e = $i([]), n = $i([]), r = xr();
    return {
      children: e,
      linkChildren: (s) => {
        wa(t, Object.assign({
          link: (c) => {
            c.proxy && (n.push(c), e.push(c.proxy), TC(r, e, n));
          },
          unlink: (c) => {
            const l = n.indexOf(c);
            e.splice(l, 1), n.splice(l, 1);
          },
          children: e,
          internalChildren: n
        }, s));
      }
    };
  };
  q3 = function(t) {
    let e;
    Si(() => {
      t(), zi(() => {
        e = true;
      });
    }), _1(() => {
      e && t();
    });
  };
  Fd = function(t, e, n = {}) {
    if (!lf) return;
    const { target: r = window, passive: i = false, capture: s = false } = n;
    let o = false, a;
    const c = (f) => {
      if (o) return;
      const d = ar(f);
      d && !a && (d.addEventListener(t, e, {
        capture: s,
        passive: i
      }), a = true);
    }, l = (f) => {
      if (o) return;
      const d = ar(f);
      d && a && (d.removeEventListener(t, e, s), a = false);
    };
    yl(() => l(r)), _d(() => l(r)), q3(() => c(r));
    let u;
    return Yt(r) && (u = xn(r, (f, d) => {
      l(d), c(f);
    })), () => {
      u == null ? void 0 : u(), l(r), o = true;
    };
  };
  OW = function(t, e, n = {}) {
    if (!lf) return;
    const { eventName: r = "click" } = n;
    Fd(r, (s) => {
      (Array.isArray(t) ? t : [
        t
      ]).every((c) => {
        const l = ar(c);
        return l && !l.contains(s.target);
      }) && e(s);
    }, {
      target: document
    });
  };
  var Lf, gp;
  function CC() {
    if (!Lf && (Lf = Ze(0), gp = Ze(0), lf)) {
      const t = () => {
        Lf.value = window.innerWidth, gp.value = window.innerHeight;
      };
      t(), window.addEventListener("resize", t, {
        passive: true
      }), window.addEventListener("orientationchange", t, {
        passive: true
      });
    }
    return {
      width: Lf,
      height: gp
    };
  }
  var IC = /scroll|auto|overlay/i, Y3 = lf ? window : void 0;
  function PC(t) {
    return t.tagName !== "HTML" && t.tagName !== "BODY" && t.nodeType === 1;
  }
  function X3(t, e = Y3) {
    let n = t;
    for (; n && n !== e && PC(n); ) {
      const { overflowY: r } = window.getComputedStyle(n);
      if (IC.test(r)) return n;
      n = n.parentNode;
    }
    return e;
  }
  BW = function(t, e = Y3) {
    const n = Ze();
    return Si(() => {
      t.value && (n.value = X3(t.value, e));
    }), n;
  };
  var Z3 = Symbol("van-field");
  MW = function(t) {
    const e = qn(Z3, null);
    e && !e.customValue.value && (e.customValue.value = t, xn(t, () => {
      e.resetValidation(), e.validateWithTrigger("onChange");
    }));
  };
  kW = function(t) {
    const e = "scrollTop" in t ? t.scrollTop : t.pageYOffset;
    return Math.max(e, 0);
  };
  function Yb(t, e) {
    "scrollTop" in t ? t.scrollTop = e : t.scrollTo(t.scrollX, e);
  }
  function $3() {
    return window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0;
  }
  function e6(t) {
    Yb(window, t), Yb(document.body, t);
  }
  const _C = bC();
  function RC() {
    _C && e6($3());
  }
  NC = (t) => t.stopPropagation();
  Bc = function(t, e) {
    (typeof t.cancelable != "boolean" || t.cancelable) && t.preventDefault(), e && NC(t);
  };
  FW = function(t) {
    const e = ar(t);
    if (!e) return false;
    const n = window.getComputedStyle(e), r = n.display === "none", i = e.offsetParent === null && n.position !== "fixed";
    return r || i;
  };
  ({ width: OC, height: BC } = CC());
  function MC(t) {
    const e = window.getComputedStyle(t);
    return e.transform !== "none" || e.perspective !== "none" || [
      "transform",
      "perspective",
      "filter"
    ].some((n) => (e.willChange || "").includes(n));
  }
  LW = function(t) {
    let e = t.parentElement;
    for (; e; ) {
      if (e && e.tagName !== "HTML" && e.tagName !== "BODY" && MC(e)) return e;
      e = e.parentElement;
    }
    return null;
  };
  Tr = function(t) {
    if (Fn(t)) return W3(t) ? `${t}px` : String(t);
  };
  function kC(t) {
    if (Fn(t)) {
      if (Array.isArray(t)) return {
        width: Tr(t[0]),
        height: Tr(t[1])
      };
      const e = Tr(t);
      return {
        width: e,
        height: e
      };
    }
  }
  FC = function(t) {
    const e = {};
    return t !== void 0 && (e.zIndex = +t), e;
  };
  let mp;
  function LC() {
    if (!mp) {
      const t = document.documentElement, e = t.style.fontSize || window.getComputedStyle(t).fontSize;
      mp = parseFloat(e);
    }
    return mp;
  }
  function DC(t) {
    return t = t.replace(/rem/g, ""), +t * LC();
  }
  function UC(t) {
    return t = t.replace(/vw/g, ""), +t * OC.value / 100;
  }
  function HC(t) {
    return t = t.replace(/vh/g, ""), +t * BC.value / 100;
  }
  DW = function(t) {
    if (typeof t == "number") return t;
    if (F1) {
      if (t.includes("rem")) return DC(t);
      if (t.includes("vw")) return UC(t);
      if (t.includes("vh")) return HC(t);
    }
    return parseFloat(t);
  };
  const GC = /-(\w)/g, t6 = (t) => t.replace(GC, (e, n) => n.toUpperCase());
  UW = function(t, e = 2) {
    let n = t + "";
    for (; n.length < e; ) n = "0" + n;
    return n;
  };
  VC = (t, e, n) => Math.min(Math.max(t, e), n);
  function Xb(t, e, n) {
    const r = t.indexOf(e);
    return r === -1 ? t : e === "-" && r !== 0 ? t.slice(0, r) : t.slice(0, r + 1) + t.slice(r).replace(n, "");
  }
  function zC(t, e = true, n = true) {
    e ? t = Xb(t, ".", /\./g) : t = t.split(".")[0], n ? t = Xb(t, "-", /-/g) : t = t.replace(/-/, "");
    const r = e ? /[^-0-9.]/g : /[^-0-9]/g;
    return t.replace(r, "");
  }
  const { hasOwnProperty: QC } = Object.prototype;
  function jC(t, e, n) {
    const r = e[n];
    Fn(r) && (!QC.call(t, n) || !cf(r) ? t[n] = r : t[n] = n6(Object(t[n]), r));
  }
  function n6(t, e) {
    return Object.keys(e).forEach((n) => {
      jC(t, e, n);
    }), t;
  }
  var JC = {
    name: "\u59D3\u540D",
    tel: "\u7535\u8BDD",
    save: "\u4FDD\u5B58",
    clear: "\u6E05\u7A7A",
    cancel: "\u53D6\u6D88",
    confirm: "\u786E\u8BA4",
    delete: "\u5220\u9664",
    loading: "\u52A0\u8F7D\u4E2D...",
    noCoupon: "\u6682\u65E0\u4F18\u60E0\u5238",
    nameEmpty: "\u8BF7\u586B\u5199\u59D3\u540D",
    addContact: "\u6DFB\u52A0\u8054\u7CFB\u4EBA",
    telInvalid: "\u8BF7\u586B\u5199\u6B63\u786E\u7684\u7535\u8BDD",
    vanCalendar: {
      end: "\u7ED3\u675F",
      start: "\u5F00\u59CB",
      title: "\u65E5\u671F\u9009\u62E9",
      weekdays: [
        "\u65E5",
        "\u4E00",
        "\u4E8C",
        "\u4E09",
        "\u56DB",
        "\u4E94",
        "\u516D"
      ],
      monthTitle: (t, e) => `${t}\u5E74${e}\u6708`,
      rangePrompt: (t) => `\u6700\u591A\u9009\u62E9 ${t} \u5929`
    },
    vanCascader: {
      select: "\u8BF7\u9009\u62E9"
    },
    vanPagination: {
      prev: "\u4E0A\u4E00\u9875",
      next: "\u4E0B\u4E00\u9875"
    },
    vanPullRefresh: {
      pulling: "\u4E0B\u62C9\u5373\u53EF\u5237\u65B0...",
      loosing: "\u91CA\u653E\u5373\u53EF\u5237\u65B0..."
    },
    vanSubmitBar: {
      label: "\u5408\u8BA1:"
    },
    vanCoupon: {
      unlimited: "\u65E0\u95E8\u69DB",
      discount: (t) => `${t}\u6298`,
      condition: (t) => `\u6EE1${t}\u5143\u53EF\u7528`
    },
    vanCouponCell: {
      title: "\u4F18\u60E0\u5238",
      count: (t) => `${t}\u5F20\u53EF\u7528`
    },
    vanCouponList: {
      exchange: "\u5151\u6362",
      close: "\u4E0D\u4F7F\u7528",
      enable: "\u53EF\u7528",
      disabled: "\u4E0D\u53EF\u7528",
      placeholder: "\u8F93\u5165\u4F18\u60E0\u7801"
    },
    vanAddressEdit: {
      area: "\u5730\u533A",
      areaEmpty: "\u8BF7\u9009\u62E9\u5730\u533A",
      addressEmpty: "\u8BF7\u586B\u5199\u8BE6\u7EC6\u5730\u5740",
      addressDetail: "\u8BE6\u7EC6\u5730\u5740",
      defaultAddress: "\u8BBE\u4E3A\u9ED8\u8BA4\u6536\u8D27\u5730\u5740"
    },
    vanAddressList: {
      add: "\u65B0\u589E\u5730\u5740"
    }
  };
  const Zb = Ze("zh-CN"), $b = $i({
    "zh-CN": JC
  }), KC = {
    messages() {
      return $b[Zb.value];
    },
    use(t, e) {
      Zb.value = t, this.add({
        [t]: e
      });
    },
    add(t = {}) {
      n6($b, t);
    }
  };
  var WC = KC;
  function qC(t) {
    const e = t6(t) + ".";
    return (n, ...r) => {
      const i = WC.messages(), s = jb(i, e + n) || jb(i, n);
      return z0(s) ? s(...r) : s;
    };
  }
  function qg(t, e) {
    return e ? typeof e == "string" ? ` ${t}--${e}` : Array.isArray(e) ? e.reduce((n, r) => n + qg(t, r), "") : Object.keys(e).reduce((n, r) => n + (e[r] ? qg(t, r) : ""), "") : "";
  }
  function YC(t) {
    return (e, n) => (e && typeof e != "string" && (n = e, e = ""), e = e ? `${t}__${e}` : t, `${e}${qg(e, n)}`);
  }
  cs = function(t) {
    const e = `van-${t}`;
    return [
      e,
      YC(e),
      qC(e)
    ];
  };
  let L1, XC, $C, ex;
  L1 = "van-hairline";
  XC = `${L1}--surround`;
  HW = `${L1}--top-bottom`;
  GW = `${L1}-unset--top-bottom`;
  ZC = "van-haptics-feedback";
  $C = Symbol("van-form");
  ex = 5;
  function eI(t, { args: e = [], done: n, canceled: r, error: i }) {
    if (t) {
      const s = t.apply(null, e);
      K3(s) ? s.then((o) => {
        o ? n() : r && r();
      }).catch(i || yC) : s ? n() : r && r();
    } else n();
  }
  Qs = function(t) {
    return t.install = (e) => {
      const { name: n } = t;
      n && (e.component(n, t), e.component(t6(`-${n}`), t));
    }, t;
  };
  const tI = Symbol();
  D1 = function(t) {
    const e = xr();
    e && Xr(e.proxy, t);
  };
  const r6 = {
    to: [
      String,
      Object
    ],
    url: String,
    replace: Boolean
  };
  function nI({ to: t, url: e, replace: n, $router: r }) {
    t && r ? r[n ? "replace" : "push"](t) : e && (n ? location.replace(e) : location.href = e);
  }
  function i6() {
    const t = xr().proxy;
    return () => nI(t);
  }
  const [rI, tx] = cs("badge"), iI = {
    dot: Boolean,
    max: pn,
    tag: yn("div"),
    color: String,
    offset: Array,
    content: pn,
    showZero: bo,
    position: yn("top-right")
  };
  var sI = Gn({
    name: rI,
    props: iI,
    setup(t, { slots: e }) {
      const n = () => {
        if (e.content) return true;
        const { content: a, showZero: c } = t;
        return Fn(a) && a !== "" && (c || a !== 0 && a !== "0");
      }, r = () => {
        const { dot: a, max: c, content: l } = t;
        if (!a && n()) return e.content ? e.content() : Fn(c) && W3(l) && +l > +c ? `${c}+` : l;
      }, i = (a) => a.startsWith("-") ? a.replace("-", "") : `-${a}`, s = it(() => {
        const a = {
          background: t.color
        };
        if (t.offset) {
          const [c, l] = t.offset, { position: u } = t, [f, d] = u.split("-");
          e.default ? (typeof l == "number" ? a[f] = Tr(f === "top" ? l : -l) : a[f] = f === "top" ? Tr(l) : i(l), typeof c == "number" ? a[d] = Tr(d === "left" ? c : -c) : a[d] = d === "left" ? Tr(c) : i(c)) : (a.marginTop = Tr(l), a.marginLeft = Tr(c));
        }
        return a;
      }), o = () => {
        if (n() || t.dot) return Te("div", {
          class: tx([
            t.position,
            {
              dot: t.dot,
              fixed: !!e.default
            }
          ]),
          style: s.value
        }, [
          r()
        ]);
      };
      return () => {
        if (e.default) {
          const { tag: a } = t;
          return Te(a, {
            class: tx("wrapper")
          }, {
            default: () => [
              e.default(),
              o()
            ]
          });
        }
        return o();
      };
    }
  });
  oI = Qs(sI);
  let aI = 2e3;
  const cI = () => ++aI, [lI, VW] = cs("config-provider"), uI = Symbol(lI), [fI, nx] = cs("icon"), dI = (t) => t == null ? void 0 : t.includes("/"), hI = {
    dot: Boolean,
    tag: yn("i"),
    name: String,
    size: pn,
    badge: pn,
    color: String,
    badgeProps: Object,
    classPrefix: String
  };
  var pI = Gn({
    name: fI,
    props: hI,
    setup(t, { slots: e }) {
      const n = qn(uI, null), r = it(() => t.classPrefix || (n == null ? void 0 : n.iconPrefix) || nx());
      return () => {
        const { tag: i, dot: s, name: o, size: a, badge: c, color: l } = t, u = dI(o);
        return Te(oI, Ms({
          dot: s,
          tag: i,
          class: [
            r.value,
            u ? "" : `${r.value}-${o}`
          ],
          style: {
            color: l,
            fontSize: Tr(a)
          },
          content: c
        }, t.badgeProps), {
          default: () => {
            var f;
            return [
              (f = e.default) == null ? void 0 : f.call(e),
              u && Te("img", {
                class: nx("image"),
                src: o
              }, null)
            ];
          }
        });
      };
    }
  });
  let gI, fu, mI, yI, bI;
  Co = Qs(pI);
  [gI, fu] = cs("loading");
  mI = Array(12).fill(null).map((t, e) => Te("i", {
    class: fu("line", String(e + 1))
  }, null));
  yI = Te("svg", {
    class: fu("circular"),
    viewBox: "25 25 50 50"
  }, [
    Te("circle", {
      cx: "50",
      cy: "50",
      r: "20",
      fill: "none"
    }, null)
  ]);
  bI = {
    size: pn,
    type: yn("circular"),
    color: String,
    vertical: Boolean,
    textSize: pn,
    textColor: String
  };
  var xI = Gn({
    name: gI,
    props: bI,
    setup(t, { slots: e }) {
      const n = it(() => Xr({
        color: t.color
      }, kC(t.size))), r = () => {
        const s = t.type === "spinner" ? mI : yI;
        return Te("span", {
          class: fu("spinner", t.type),
          style: n.value
        }, [
          e.icon ? e.icon() : s
        ]);
      }, i = () => {
        var s;
        if (e.default) return Te("span", {
          class: fu("text"),
          style: {
            fontSize: Tr(t.textSize),
            color: (s = t.textColor) != null ? s : t.color
          }
        }, [
          e.default()
        ]);
      };
      return () => {
        const { type: s, vertical: o } = t;
        return Te("div", {
          class: fu([
            s,
            {
              vertical: o
            }
          ]),
          "aria-live": "polite",
          "aria-busy": true
        }, [
          r(),
          i()
        ]);
      };
    }
  });
  let AI, qa, wI;
  s6 = Qs(xI);
  [AI, qa] = cs("button");
  wI = Xr({}, r6, {
    tag: yn("button"),
    text: String,
    icon: String,
    type: yn("default"),
    size: yn("normal"),
    color: String,
    block: Boolean,
    plain: Boolean,
    round: Boolean,
    square: Boolean,
    loading: Boolean,
    hairline: Boolean,
    disabled: Boolean,
    iconPrefix: String,
    nativeType: yn("button"),
    loadingSize: pn,
    loadingText: String,
    loadingType: String,
    iconPosition: yn("left")
  });
  var vI = Gn({
    name: AI,
    props: wI,
    emits: [
      "click"
    ],
    setup(t, { emit: e, slots: n }) {
      const r = i6(), i = () => n.loading ? n.loading() : Te(s6, {
        size: t.loadingSize,
        type: t.loadingType,
        class: qa("loading")
      }, null), s = () => {
        if (t.loading) return i();
        if (n.icon) return Te("div", {
          class: qa("icon")
        }, [
          n.icon()
        ]);
        if (t.icon) return Te(Co, {
          name: t.icon,
          class: qa("icon"),
          classPrefix: t.iconPrefix
        }, null);
      }, o = () => {
        let l;
        if (t.loading ? l = t.loadingText : l = n.default ? n.default() : t.text, l) return Te("span", {
          class: qa("text")
        }, [
          l
        ]);
      }, a = () => {
        const { color: l, plain: u } = t;
        if (l) {
          const f = {
            color: u ? l : "white"
          };
          return u || (f.background = l), l.includes("gradient") ? f.border = 0 : f.borderColor = l, f;
        }
      }, c = (l) => {
        t.loading ? Bc(l) : t.disabled || (e("click", l), r());
      };
      return () => {
        const { tag: l, type: u, size: f, block: d, round: m, plain: y, square: x, loading: w, disabled: R, hairline: O, nativeType: B, iconPosition: M } = t, D = [
          qa([
            u,
            f,
            {
              plain: y,
              block: d,
              round: m,
              square: x,
              loading: w,
              disabled: R,
              hairline: O
            }
          ]),
          {
            [XC]: O
          }
        ];
        return Te(l, {
          type: B,
          class: D,
          style: a(),
          disabled: R,
          onClick: c
        }, {
          default: () => [
            Te("div", {
              class: qa("content")
            }, [
              M === "left" && s(),
              o(),
              M === "right" && s()
            ])
          ]
        });
      };
    }
  });
  let EI;
  o6 = Qs(vI);
  EI = {
    show: Boolean,
    zIndex: pn,
    overlay: bo,
    duration: pn,
    teleport: [
      String,
      Object
    ],
    lockScroll: bo,
    lazyRender: bo,
    beforeClose: Function,
    overlayProps: Object,
    overlayStyle: Object,
    overlayClass: To,
    transitionAppear: Boolean,
    closeOnClickOverlay: bo
  };
  function SI(t, e) {
    return t > e ? "horizontal" : e > t ? "vertical" : "";
  }
  TI = function() {
    const t = Ze(0), e = Ze(0), n = Ze(0), r = Ze(0), i = Ze(0), s = Ze(0), o = Ze(""), a = Ze(true), c = () => o.value === "vertical", l = () => o.value === "horizontal", u = () => {
      n.value = 0, r.value = 0, i.value = 0, s.value = 0, o.value = "", a.value = true;
    };
    return {
      move: (m) => {
        const y = m.touches[0];
        n.value = (y.clientX < 0 ? 0 : y.clientX) - t.value, r.value = y.clientY - e.value, i.value = Math.abs(n.value), s.value = Math.abs(r.value);
        const x = 10;
        (!o.value || i.value < x && s.value < x) && (o.value = SI(i.value, s.value)), a.value && (i.value > ex || s.value > ex) && (a.value = false);
      },
      start: (m) => {
        u(), t.value = m.touches[0].clientX, e.value = m.touches[0].clientY;
      },
      reset: u,
      startX: t,
      startY: e,
      deltaX: n,
      deltaY: r,
      offsetX: i,
      offsetY: s,
      direction: o,
      isVertical: c,
      isHorizontal: l,
      isTap: a
    };
  };
  let Fl = 0;
  const rx = "van-overflow-hidden";
  function CI(t, e) {
    const n = TI(), r = "01", i = "10", s = (u) => {
      n.move(u);
      const f = n.deltaY.value > 0 ? i : r, d = X3(u.target, t.value), { scrollHeight: m, offsetHeight: y, scrollTop: x } = d;
      let w = "11";
      x === 0 ? w = y >= m ? "00" : "01" : x + y >= m && (w = "10"), w !== "11" && n.isVertical() && !(parseInt(w, 2) & parseInt(f, 2)) && Bc(u, true);
    }, o = () => {
      document.addEventListener("touchstart", n.start), document.addEventListener("touchmove", s, {
        passive: false
      }), Fl || document.body.classList.add(rx), Fl++;
    }, a = () => {
      Fl && (document.removeEventListener("touchstart", n.start), document.removeEventListener("touchmove", s), Fl--, Fl || document.body.classList.remove(rx));
    }, c = () => e() && o(), l = () => e() && a();
    q3(c), _d(l), Nd(l), xn(e, (u) => {
      u ? o() : a();
    });
  }
  a6 = function(t) {
    const e = Ze(false);
    return xn(t, (n) => {
      n && (e.value = n);
    }, {
      immediate: true
    }), (n) => () => e.value ? n() : null;
  };
  let II, PI, _I;
  ix = () => {
    var t;
    const { scopeId: e } = ((t = xr()) == null ? void 0 : t.vnode) || {};
    return e ? {
      [e]: ""
    } : null;
  };
  [II, PI] = cs("overlay");
  _I = {
    show: Boolean,
    zIndex: pn,
    duration: pn,
    className: To,
    lockScroll: bo,
    lazyRender: bo,
    customStyle: Object,
    teleport: [
      String,
      Object
    ]
  };
  var RI = Gn({
    name: II,
    inheritAttrs: false,
    props: _I,
    setup(t, { attrs: e, slots: n }) {
      const r = Ze(), i = a6(() => t.show || !t.lazyRender), s = (a) => {
        t.lockScroll && Bc(a, true);
      }, o = i(() => {
        var a;
        const c = Xr(FC(t.zIndex), t.customStyle);
        return Fn(t.duration) && (c.animationDuration = `${t.duration}s`), Zv(Te("div", Ms({
          ref: r,
          style: c,
          class: [
            PI(),
            t.className
          ]
        }, e), [
          (a = n.default) == null ? void 0 : a.call(n)
        ]), [
          [
            U3,
            t.show
          ]
        ]);
      });
      return Fd("touchmove", s, {
        target: r
      }), () => {
        const a = Te(L3, {
          name: "van-fade",
          appear: true
        }, {
          default: o
        });
        return t.teleport ? Te(n3, {
          to: t.teleport
        }, {
          default: () => [
            a
          ]
        }) : a;
      };
    }
  });
  const NI = Qs(RI), OI = Xr({}, EI, {
    round: Boolean,
    position: yn("center"),
    closeIcon: yn("cross"),
    closeable: Boolean,
    transition: String,
    iconPrefix: String,
    closeOnPopstate: Boolean,
    closeIconPosition: yn("top-right"),
    destroyOnClose: Boolean,
    safeAreaInsetTop: Boolean,
    safeAreaInsetBottom: Boolean
  }), [BI, sx] = cs("popup");
  var MI = Gn({
    name: BI,
    inheritAttrs: false,
    props: OI,
    emits: [
      "open",
      "close",
      "opened",
      "closed",
      "keydown",
      "update:show",
      "clickOverlay",
      "clickCloseIcon"
    ],
    setup(t, { emit: e, attrs: n, slots: r }) {
      let i, s;
      const o = Ze(), a = Ze(), c = a6(() => t.show || !t.lazyRender), l = it(() => {
        const H = {
          zIndex: o.value
        };
        if (Fn(t.duration)) {
          const q = t.position === "center" ? "animationDuration" : "transitionDuration";
          H[q] = `${t.duration}s`;
        }
        return H;
      }), u = () => {
        i || (i = true, o.value = t.zIndex !== void 0 ? +t.zIndex : cI(), e("open"));
      }, f = () => {
        i && eI(t.beforeClose, {
          done() {
            i = false, e("close"), e("update:show", false);
          }
        });
      }, d = (H) => {
        e("clickOverlay", H), t.closeOnClickOverlay && f();
      }, m = () => {
        if (t.overlay) {
          const H = Xr({
            show: t.show,
            class: t.overlayClass,
            zIndex: o.value,
            duration: t.duration,
            customStyle: t.overlayStyle,
            role: t.closeOnClickOverlay ? "button" : void 0,
            tabindex: t.closeOnClickOverlay ? 0 : void 0
          }, t.overlayProps);
          return Te(NI, Ms(H, ix(), {
            onClick: d
          }), {
            default: r["overlay-content"]
          });
        }
      }, y = (H) => {
        e("clickCloseIcon", H), f();
      }, x = () => {
        if (t.closeable) return Te(Co, {
          role: "button",
          tabindex: 0,
          name: t.closeIcon,
          class: [
            sx("close-icon", t.closeIconPosition),
            ZC
          ],
          classPrefix: t.iconPrefix,
          onClick: y
        }, null);
      };
      let w;
      const R = () => {
        w && clearTimeout(w), w = setTimeout(() => {
          e("opened");
        });
      }, O = () => e("closed"), B = (H) => e("keydown", H), M = c(() => {
        var H;
        const { destroyOnClose: q, round: S, position: P, safeAreaInsetTop: L, safeAreaInsetBottom: K, show: z } = t;
        if (!(!z && q)) return Zv(Te("div", Ms({
          ref: a,
          style: l.value,
          role: "dialog",
          tabindex: 0,
          class: [
            sx({
              round: S,
              [P]: P
            }),
            {
              "van-safe-area-top": L,
              "van-safe-area-bottom": K
            }
          ],
          onKeydown: B
        }, n, ix()), [
          (H = r.default) == null ? void 0 : H.call(r),
          x()
        ]), [
          [
            U3,
            z
          ]
        ]);
      }), D = () => {
        const { position: H, transition: q, transitionAppear: S } = t, P = H === "center" ? "van-fade" : `van-popup-slide-${H}`;
        return Te(L3, {
          name: q || P,
          appear: S,
          onAfterEnter: R,
          onAfterLeave: O
        }, {
          default: M
        });
      };
      return xn(() => t.show, (H) => {
        H && !i && (u(), n.tabindex === 0 && zi(() => {
          var q;
          (q = a.value) == null || q.focus();
        })), !H && i && (i = false, e("close"));
      }), D1({
        popupRef: a
      }), CI(a, () => t.show && t.lockScroll), Fd("popstate", () => {
        t.closeOnPopstate && (f(), s = false);
      }), Si(() => {
        t.show && u();
      }), _1(() => {
        s && (e("update:show", true), s = false);
      }), _d(() => {
        t.show && t.teleport && (f(), s = true);
      }), wa(tI, () => t.show), () => t.teleport ? Te(n3, {
        to: t.teleport
      }, {
        default: () => [
          m(),
          D()
        ]
      }) : Te(jn, null, [
        m(),
        D()
      ]);
    }
  });
  U1 = Qs(MI);
  let kI = 0;
  FI = function() {
    const t = xr(), { name: e = "unknown" } = (t == null ? void 0 : t.type) || {};
    return `${e}-${++kI}`;
  };
  let LI, Ya, DI;
  [LI, Ya] = cs("cell");
  c6 = {
    tag: yn("div"),
    icon: String,
    size: String,
    title: pn,
    value: pn,
    label: pn,
    center: Boolean,
    isLink: Boolean,
    border: bo,
    iconPrefix: String,
    valueClass: To,
    labelClass: To,
    titleClass: To,
    titleStyle: null,
    arrowDirection: String,
    required: {
      type: [
        Boolean,
        String
      ],
      default: null
    },
    clickable: {
      type: Boolean,
      default: null
    }
  };
  DI = Xr({}, c6, r6);
  var UI = Gn({
    name: LI,
    props: DI,
    setup(t, { slots: e }) {
      const n = i6(), r = () => {
        if (e.label || Fn(t.label)) return Te("div", {
          class: [
            Ya("label"),
            t.labelClass
          ]
        }, [
          e.label ? e.label() : t.label
        ]);
      }, i = () => {
        var c;
        if (e.title || Fn(t.title)) {
          const l = (c = e.title) == null ? void 0 : c.call(e);
          return Array.isArray(l) && l.length === 0 ? void 0 : Te("div", {
            class: [
              Ya("title"),
              t.titleClass
            ],
            style: t.titleStyle
          }, [
            l || Te("span", null, [
              t.title
            ]),
            r()
          ]);
        }
      }, s = () => {
        const c = e.value || e.default;
        if (c || Fn(t.value)) return Te("div", {
          class: [
            Ya("value"),
            t.valueClass
          ]
        }, [
          c ? c() : Te("span", null, [
            t.value
          ])
        ]);
      }, o = () => {
        if (e.icon) return e.icon();
        if (t.icon) return Te(Co, {
          name: t.icon,
          class: Ya("left-icon"),
          classPrefix: t.iconPrefix
        }, null);
      }, a = () => {
        if (e["right-icon"]) return e["right-icon"]();
        if (t.isLink) {
          const c = t.arrowDirection && t.arrowDirection !== "right" ? `arrow-${t.arrowDirection}` : "arrow";
          return Te(Co, {
            name: c,
            class: Ya("right-icon")
          }, null);
        }
      };
      return () => {
        var c;
        const { tag: l, size: u, center: f, border: d, isLink: m, required: y } = t, x = (c = t.clickable) != null ? c : m, w = {
          center: f,
          required: !!y,
          clickable: x,
          borderless: !d
        };
        return u && (w[u] = !!u), Te(l, {
          class: Ya(w),
          role: x ? "button" : void 0,
          tabindex: x ? 0 : void 0,
          onClick: n
        }, {
          default: () => {
            var R;
            return [
              o(),
              i(),
              s(),
              a(),
              (R = e.extra) == null ? void 0 : R.call(e)
            ];
          }
        });
      };
    }
  });
  HI = Qs(UI);
  function l6(t) {
    return Array.isArray(t) ? !t.length : t === 0 ? false : !t;
  }
  function GI(t, e) {
    if (l6(t)) {
      if (e.required) return false;
      if (e.validateEmpty === false) return true;
    }
    return !(e.pattern && !e.pattern.test(String(t)));
  }
  function VI(t, e) {
    return new Promise((n) => {
      const r = e.validator(t, e);
      if (K3(r)) {
        r.then(n);
        return;
      }
      n(r);
    });
  }
  function ox(t, e) {
    const { message: n } = e;
    return z0(n) ? n(t, e) : n || "";
  }
  function zI({ target: t }) {
    t.composing = true;
  }
  function ax({ target: t }) {
    t.composing && (t.composing = false, t.dispatchEvent(new Event("input")));
  }
  function QI(t, e) {
    const n = $3();
    t.style.height = "auto";
    let r = t.scrollHeight;
    if (cf(e)) {
      const { maxHeight: i, minHeight: s } = e;
      i !== void 0 && (r = Math.min(r, i)), s !== void 0 && (r = Math.max(r, s));
    }
    r && (t.style.height = `${r}px`, e6(n));
  }
  function jI(t, e) {
    return t === "number" && (t = "text", e ?? (e = "decimal")), t === "digit" && (t = "tel", e ?? (e = "numeric")), {
      type: t,
      inputmode: e
    };
  }
  function hs(t) {
    return [
      ...t
    ].length;
  }
  function yp(t, e) {
    return [
      ...t
    ].slice(0, e).join("");
  }
  const [JI, Br] = cs("field"), KI = {
    id: String,
    name: String,
    leftIcon: String,
    rightIcon: String,
    autofocus: Boolean,
    clearable: Boolean,
    maxlength: pn,
    max: Number,
    min: Number,
    formatter: Function,
    clearIcon: yn("clear"),
    modelValue: wC(""),
    inputAlign: String,
    placeholder: String,
    autocomplete: String,
    autocapitalize: String,
    autocorrect: String,
    errorMessage: String,
    enterkeyhint: String,
    clearTrigger: yn("focus"),
    formatTrigger: yn("onChange"),
    spellcheck: {
      type: Boolean,
      default: null
    },
    error: {
      type: Boolean,
      default: null
    },
    disabled: {
      type: Boolean,
      default: null
    },
    readonly: {
      type: Boolean,
      default: null
    },
    inputmode: String
  }, WI = Xr({}, c6, KI, {
    rows: pn,
    type: yn("text"),
    rules: Array,
    autosize: [
      Boolean,
      Object
    ],
    labelWidth: pn,
    labelClass: To,
    labelAlign: String,
    showWordLimit: Boolean,
    errorMessageAlign: String,
    colon: {
      type: Boolean,
      default: null
    }
  });
  var qI = Gn({
    name: JI,
    props: WI,
    emits: [
      "blur",
      "focus",
      "clear",
      "keypress",
      "clickInput",
      "endValidate",
      "startValidate",
      "clickLeftIcon",
      "clickRightIcon",
      "update:modelValue"
    ],
    setup(t, { emit: e, slots: n }) {
      const r = FI(), i = $i({
        status: "unvalidated",
        focused: false,
        validateMessage: ""
      }), s = Ze(), o = Ze(), a = Ze(), { parent: c } = EC($C), l = () => {
        var k;
        return String((k = t.modelValue) != null ? k : "");
      }, u = (k) => {
        if (Fn(t[k])) return t[k];
        if (c && Fn(c.props[k])) return c.props[k];
      }, f = it(() => {
        const k = u("readonly");
        if (t.clearable && !k) {
          const X = l() !== "", $ = t.clearTrigger === "always" || t.clearTrigger === "focus" && i.focused;
          return X && $;
        }
        return false;
      }), d = it(() => a.value && n.input ? a.value() : t.modelValue), m = it(() => {
        var k;
        const X = u("required");
        return X === "auto" ? (k = t.rules) == null ? void 0 : k.some(($) => $.required) : X;
      }), y = (k) => k.reduce((X, $) => X.then(() => {
        if (i.status === "failed") return;
        let { value: ce } = d;
        if ($.formatter && (ce = $.formatter(ce, $)), !GI(ce, $)) {
          i.status = "failed", i.validateMessage = ox(ce, $);
          return;
        }
        if ($.validator) return l6(ce) && $.validateEmpty === false ? void 0 : VI(ce, $).then((fe) => {
          fe && typeof fe == "string" ? (i.status = "failed", i.validateMessage = fe) : fe === false && (i.status = "failed", i.validateMessage = ox(ce, $));
        });
      }), Promise.resolve()), x = () => {
        i.status = "unvalidated", i.validateMessage = "";
      }, w = () => e("endValidate", {
        status: i.status,
        message: i.validateMessage
      }), R = (k = t.rules) => new Promise((X) => {
        x(), k ? (e("startValidate"), y(k).then(() => {
          i.status === "failed" ? (X({
            name: t.name,
            message: i.validateMessage
          }), w()) : (i.status = "passed", X(), w());
        })) : X();
      }), O = (k) => {
        if (c && t.rules) {
          const { validateTrigger: X } = c.props, $ = Jb(X).includes(k), ce = t.rules.filter((fe) => fe.trigger ? Jb(fe.trigger).includes(k) : $);
          ce.length && R(ce);
        }
      }, B = (k) => {
        var X;
        const { maxlength: $ } = t;
        if (Fn($) && hs(k) > +$) {
          const ce = l();
          if (ce && hs(ce) === +$) return ce;
          const fe = (X = s.value) == null ? void 0 : X.selectionEnd;
          if (i.focused && fe) {
            const G = [
              ...k
            ], W = G.length - +$;
            return G.splice(fe - W, W), G.join("");
          }
          return yp(k, +$);
        }
        return k;
      }, M = (k, X = "onChange") => {
        var $, ce;
        const fe = k;
        k = B(k);
        const G = hs(fe) - hs(k);
        if (t.type === "number" || t.type === "digit") {
          const V = t.type === "number";
          if (k = zC(k, V, V), X === "onBlur" && k !== "" && (t.min !== void 0 || t.max !== void 0)) {
            const te = VC(+k, ($ = t.min) != null ? $ : -1 / 0, (ce = t.max) != null ? ce : 1 / 0);
            +k !== te && (k = te.toString());
          }
        }
        let W = 0;
        if (t.formatter && X === t.formatTrigger) {
          const { formatter: V, maxlength: te } = t;
          if (k = V(k), Fn(te) && hs(k) > +te && (k = yp(k, +te)), s.value && i.focused) {
            const { selectionEnd: pe } = s.value, ue = yp(fe, pe);
            W = hs(V(ue)) - hs(ue);
          }
        }
        if (s.value && s.value.value !== k) if (i.focused) {
          let { selectionStart: V, selectionEnd: te } = s.value;
          if (s.value.value = k, Fn(V) && Fn(te)) {
            const pe = hs(k);
            G ? (V -= G, te -= G) : W && (V += W, te += W), s.value.setSelectionRange(Math.min(V, pe), Math.min(te, pe));
          }
        } else s.value.value = k;
        k !== t.modelValue && e("update:modelValue", k);
      }, D = (k) => {
        k.target.composing || M(k.target.value);
      }, H = () => {
        var k;
        return (k = s.value) == null ? void 0 : k.blur();
      }, q = () => {
        var k;
        return (k = s.value) == null ? void 0 : k.focus();
      }, S = () => {
        const k = s.value;
        t.type === "textarea" && t.autosize && k && QI(k, t.autosize);
      }, P = (k) => {
        i.focused = true, e("focus", k), zi(S), u("readonly") && H();
      }, L = (k) => {
        i.focused = false, M(l(), "onBlur"), e("blur", k), !u("readonly") && (O("onBlur"), zi(S), RC());
      }, K = (k) => e("clickInput", k), z = (k) => e("clickLeftIcon", k), I = (k) => e("clickRightIcon", k), h = (k) => {
        Bc(k), e("update:modelValue", ""), e("clear", k);
      }, p = it(() => {
        if (typeof t.error == "boolean") return t.error;
        if (c && c.props.showError && i.status === "failed") return true;
      }), A = it(() => {
        const k = u("labelWidth"), X = u("labelAlign");
        if (k && X !== "top") return {
          width: Tr(k)
        };
      }), C = (k) => {
        k.keyCode === 13 && (!(c && c.props.submitOnEnter) && t.type !== "textarea" && Bc(k), t.type === "search" && H()), e("keypress", k);
      }, N = () => t.id || `${r}-input`, U = () => i.status, Y = () => {
        const k = Br("control", [
          u("inputAlign"),
          {
            error: p.value,
            custom: !!n.input,
            "min-height": t.type === "textarea" && !t.autosize
          }
        ]);
        if (n.input) return Te("div", {
          class: k,
          onClick: K
        }, [
          n.input()
        ]);
        const X = {
          id: N(),
          ref: s,
          name: t.name,
          rows: t.rows !== void 0 ? +t.rows : void 0,
          class: k,
          disabled: u("disabled"),
          readonly: u("readonly"),
          autofocus: t.autofocus,
          placeholder: t.placeholder,
          autocomplete: t.autocomplete,
          autocapitalize: t.autocapitalize,
          autocorrect: t.autocorrect,
          enterkeyhint: t.enterkeyhint,
          spellcheck: t.spellcheck,
          "aria-labelledby": t.label ? `${r}-label` : void 0,
          "data-allow-mismatch": "attribute",
          onBlur: L,
          onFocus: P,
          onInput: D,
          onClick: K,
          onChange: ax,
          onKeypress: C,
          onCompositionend: ax,
          onCompositionstart: zI
        };
        return t.type === "textarea" ? Te("textarea", Ms(X, {
          inputmode: t.inputmode
        }), null) : Te("input", Ms(jI(t.type, t.inputmode), X), null);
      }, T = () => {
        const k = n["left-icon"];
        if (t.leftIcon || k) return Te("div", {
          class: Br("left-icon"),
          onClick: z
        }, [
          k ? k() : Te(Co, {
            name: t.leftIcon,
            classPrefix: t.iconPrefix
          }, null)
        ]);
      }, g = () => {
        const k = n["right-icon"];
        if (t.rightIcon || k) return Te("div", {
          class: Br("right-icon"),
          onClick: I
        }, [
          k ? k() : Te(Co, {
            name: t.rightIcon,
            classPrefix: t.iconPrefix
          }, null)
        ]);
      }, F = () => {
        if (t.showWordLimit && t.maxlength) {
          const k = hs(l());
          return Te("div", {
            class: Br("word-limit")
          }, [
            Te("span", {
              class: Br("word-num")
            }, [
              k
            ]),
            Bd("/"),
            t.maxlength
          ]);
        }
      }, ee = () => {
        if (c && c.props.showErrorMessage === false) return;
        const k = t.errorMessage || i.validateMessage;
        if (k) {
          const X = n["error-message"], $ = u("errorMessageAlign");
          return Te("div", {
            class: Br("error-message", $)
          }, [
            X ? X({
              message: k
            }) : k
          ]);
        }
      }, E = () => {
        const k = u("labelWidth"), X = u("labelAlign"), $ = u("colon") ? ":" : "";
        if (n.label) return [
          n.label(),
          $
        ];
        if (t.label) return Te("label", {
          id: `${r}-label`,
          for: n.input ? void 0 : N(),
          "data-allow-mismatch": "attribute",
          onClick: (ce) => {
            Bc(ce), q();
          },
          style: X === "top" && k ? {
            width: Tr(k)
          } : void 0
        }, [
          t.label + $
        ]);
      }, Z = () => [
        Te("div", {
          class: Br("body")
        }, [
          Y(),
          f.value && Te(Co, {
            ref: o,
            name: t.clearIcon,
            class: Br("clear")
          }, null),
          g(),
          n.button && Te("div", {
            class: Br("button")
          }, [
            n.button()
          ])
        ]),
        F(),
        ee()
      ];
      return D1({
        blur: H,
        focus: q,
        validate: R,
        formValue: d,
        resetValidation: x,
        getValidationStatus: U
      }), wa(Z3, {
        customValue: a,
        resetValidation: x,
        validateWithTrigger: O
      }), xn(() => t.modelValue, () => {
        M(l()), x(), O("onChange"), zi(S);
      }), Si(() => {
        M(l(), t.formatTrigger), zi(S);
      }), Fd("touchstart", h, {
        target: it(() => {
          var k;
          return (k = o.value) == null ? void 0 : k.$el;
        })
      }), () => {
        const k = u("disabled"), X = u("labelAlign"), $ = T(), ce = () => {
          const fe = E();
          return X === "top" ? [
            $,
            fe
          ].filter(Boolean) : fe || [];
        };
        return Te(HI, {
          size: t.size,
          class: Br({
            error: p.value,
            disabled: k,
            [`label-${X}`]: X
          }),
          center: t.center,
          border: t.border,
          isLink: t.isLink,
          clickable: t.clickable,
          titleStyle: A.value,
          valueClass: Br("value"),
          titleClass: [
            Br("label", [
              X,
              {
                required: m.value
              }
            ]),
            t.labelClass
          ],
          arrowDirection: t.arrowDirection
        }, {
          icon: $ && X !== "top" ? () => $ : null,
          title: ce,
          value: Z,
          extra: n.extra
        });
      };
    }
  });
  YI = Qs(qI);
  let Ll = 0;
  function XI(t) {
    t ? (Ll || document.body.classList.add("van-toast--unclickable"), Ll++) : Ll && (Ll--, Ll || document.body.classList.remove("van-toast--unclickable"));
  }
  const [ZI, Xa] = cs("toast"), $I = [
    "show",
    "overlay",
    "teleport",
    "transition",
    "overlayClass",
    "overlayStyle",
    "closeOnClickOverlay",
    "zIndex"
  ], eP = {
    icon: String,
    show: Boolean,
    type: yn("text"),
    overlay: Boolean,
    message: pn,
    iconSize: pn,
    duration: AC(2e3),
    position: yn("middle"),
    teleport: [
      String,
      Object
    ],
    wordBreak: String,
    className: To,
    iconPrefix: String,
    transition: yn("van-fade"),
    loadingType: String,
    forbidClick: Boolean,
    overlayClass: To,
    overlayStyle: Object,
    closeOnClick: Boolean,
    closeOnClickOverlay: Boolean,
    zIndex: pn
  };
  var u6 = Gn({
    name: ZI,
    props: eP,
    emits: [
      "update:show"
    ],
    setup(t, { emit: e, slots: n }) {
      let r, i = false;
      const s = () => {
        const f = t.show && t.forbidClick;
        i !== f && (i = f, XI(i));
      }, o = (f) => e("update:show", f), a = () => {
        t.closeOnClick && o(false);
      }, c = () => clearTimeout(r), l = () => {
        const { icon: f, type: d, iconSize: m, iconPrefix: y, loadingType: x } = t;
        if (f || d === "success" || d === "fail") return Te(Co, {
          name: f || d,
          size: m,
          class: Xa("icon"),
          classPrefix: y
        }, null);
        if (d === "loading") return Te(s6, {
          class: Xa("loading"),
          size: m,
          type: x
        }, null);
      }, u = () => {
        const { type: f, message: d } = t;
        if (n.message) return Te("div", {
          class: Xa("text")
        }, [
          n.message()
        ]);
        if (Fn(d) && d !== "") return f === "html" ? Te("div", {
          key: 0,
          class: Xa("text"),
          innerHTML: String(d)
        }, null) : Te("div", {
          class: Xa("text")
        }, [
          d
        ]);
      };
      return xn(() => [
        t.show,
        t.forbidClick
      ], s), xn(() => [
        t.show,
        t.type,
        t.message,
        t.duration
      ], () => {
        c(), t.show && t.duration > 0 && (r = setTimeout(() => {
          o(false);
        }, t.duration));
      }), Si(s), yl(s), () => Te(U1, Ms({
        class: [
          Xa([
            t.position,
            t.wordBreak === "normal" ? "break-normal" : t.wordBreak,
            {
              [t.type]: !t.icon
            }
          ]),
          t.className
        ],
        lockScroll: false,
        onClick: a,
        onClosed: c,
        "onUpdate:show": o
      }, xC(t, $I)), {
        default: () => [
          l(),
          u()
        ]
      });
    }
  });
  function tP() {
    const t = $i({
      show: false
    }), e = (i) => {
      t.show = i;
    }, n = (i) => {
      Xr(t, i, {
        transitionAppear: true
      }), e(true);
    }, r = () => e(false);
    return D1({
      open: n,
      close: r,
      toggle: e
    }), {
      open: n,
      close: r,
      state: t,
      toggle: e
    };
  }
  function nP(t) {
    const e = H3(t), n = document.createElement("div");
    return document.body.appendChild(n), {
      instance: e.mount(n),
      unmount() {
        e.unmount(), document.body.removeChild(n);
      }
    };
  }
  const rP = {
    icon: "",
    type: "text",
    message: "",
    className: "",
    overlay: false,
    onClose: void 0,
    onOpened: void 0,
    duration: 2e3,
    teleport: "body",
    iconSize: void 0,
    iconPrefix: void 0,
    position: "middle",
    transition: "van-fade",
    forbidClick: false,
    loadingType: void 0,
    overlayClass: "",
    overlayStyle: void 0,
    closeOnClick: false,
    closeOnClickOverlay: false
  };
  let Ac = [], iP = false, cx = Xr({}, rP);
  const sP = /* @__PURE__ */ new Map();
  function f6(t) {
    return cf(t) ? t : {
      message: t
    };
  }
  function oP() {
    const { instance: t } = nP({
      setup() {
        const e = Ze(""), { open: n, state: r, close: i, toggle: s } = tP(), o = () => {
        }, a = () => Te(u6, Ms(r, {
          onClosed: o,
          "onUpdate:show": s
        }), null);
        return xn(e, (c) => {
          r.message = c;
        }), xr().render = a, {
          open: n,
          close: i,
          message: e
        };
      }
    });
    return t;
  }
  function aP() {
    if (!Ac.length || iP) {
      const t = oP();
      Ac.push(t);
    }
    return Ac[Ac.length - 1];
  }
  Kc = function(t = {}) {
    if (!F1) return {};
    const e = aP(), n = f6(t);
    return e.open(Xr({}, cx, sP.get(n.type || cx.type), n)), e;
  };
  const d6 = (t) => (e) => Kc(Xr({
    type: t
  }, f6(e))), cP = d6("loading"), lx = d6("fail"), Yg = (t) => {
    Ac.length && Ac[0].close();
  };
  Qs(u6);
  xo = (t) => t ? t.toLowerCase() : "";
  zW = (t, e = 4) => {
    if (!t || +t < 1e-4) return 0;
    t = typeof t == "string" ? t : t.toString();
    const n = new RegExp(`^\\d+(?:\\.\\d{0,${e}})?`);
    return t = Number(t.match(n)), t;
  };
  QW = (t) => new Date(t).getFullYear();
  jW = (t, e = "...", n = 3, r = 3) => {
    if (!t) return 0;
    const i = t.slice(0, n), s = t.slice(-r);
    return i + e + s;
  };
  JW = function(t) {
    var _a6;
    const e = `${(_a6 = window.location) == null ? void 0 : _a6.origin}/#${t || ""}`;
    window.location.href = e;
  };
  lP = (t) => new URL(Object.assign({
    "/src/assets/images/loan/LP.png": kT,
    "/src/assets/images/loan/calendar.png": FT,
    "/src/assets/images/loan/clear.png": LT,
    "/src/assets/images/loan/cycle.png": DT,
    "/src/assets/images/loan/empty-2.png": UT,
    "/src/assets/images/loan/empty.png": HT,
    "/src/assets/images/loan/fail.png": GT,
    "/src/assets/images/loan/filter-o.png": VT,
    "/src/assets/images/loan/filter.png": zT,
    "/src/assets/images/loan/in-advance.png": QT,
    "/src/assets/images/loan/invest-record.png": jT,
    "/src/assets/images/loan/mai.png": JT,
    "/src/assets/images/loan/mcoin.png": KT,
    "/src/assets/images/loan/methods1.png": WT,
    "/src/assets/images/loan/methods2.png": qT,
    "/src/assets/images/loan/methods3.png": YT,
    "/src/assets/images/loan/notice.png": XT,
    "/src/assets/images/loan/person.png": ZT,
    "/src/assets/images/loan/record.png": $T,
    "/src/assets/images/loan/repayment.png": eC,
    "/src/assets/images/loan/shop.png": tC,
    "/src/assets/images/loan/success.png": nC,
    "/src/assets/images/loan/time.png": rC,
    "/src/assets/images/loan/vip.png": iC,
    "/src/assets/images/mascot/3.png": sC,
    "/src/assets/images/news/Borrow.png": oC,
    "/src/assets/images/news/Refund.png": aC,
    "/src/assets/images/news/Repayment.png": cC,
    "/src/assets/images/news/lend.png": lC,
    "/src/assets/images/news/platform.png": uC,
    "/src/assets/images/tokens/LP.png": fC,
    "/src/assets/images/tokens/MAI.png": dC,
    "/src/assets/images/tokens/MCOIN.png": hC,
    "/src/assets/images/tokens/USDT.png": pC,
    "/src/assets/images/topPop.png": gC,
    "/src/assets/svg/mai-bg.svg": j3
  })[`/src/assets/${t}`], import.meta.url).href;
  KW = (t) => new URL(Object.assign({
    "/src/assets/svg/mai-bg.svg": j3
  })[`/src/assets/svg/${t}`], import.meta.url).href;
  WW = function(t) {
    if (!t) return 0;
    const e = t.toExponential().match(/\d(?:\.(\d*))?e([+-]\d+)/);
    return t.toFixed(Math.max(0, (e[1] || "").length - e[2]));
  };
  let uP, fP, h6, dP;
  qW = (t, e) => {
    Kc({
      message: e,
      icon: lP(`images/loan/${t}.png`),
      className: "my-toash",
      overlay: true
    });
  };
  uP = "Y-m-d H:i:s";
  YW = (t, e = uP, n = 1) => {
    e = e || "Y-m-d";
    const r = function(f) {
      return f < 10 ? "0" + f : f;
    };
    t = +k1(t).times(n);
    const i = t ? new Date(t) : /* @__PURE__ */ new Date(), s = i.getFullYear(), o = r(i.getMonth() + 1), a = r(i.getDate()), c = r(i.getHours()), l = r(i.getMinutes()), u = r(i.getSeconds());
    return e.replace(/Y|m|d|H|i|s/gi, function(f) {
      return {
        Y: s,
        m: o,
        d: a,
        H: c,
        i: l,
        s: u
      }[f];
    });
  };
  XW = (t) => t ? t < 30 ? t + "\u5929" : t / 30 + "\u4E2A\u6708" : "";
  ZW = (t) => {
    if (Array.isArray(t)) return t[0] + "-" + t[1] + "-" + t[2];
    {
      const e = new Date(t), n = e.getFullYear(), r = ("0" + (e.getMonth() + 1)).slice(-2), i = ("0" + e.getDate()).slice(-2);
      return `${n}-${r}-${i} `;
    }
  };
  fP = af("user", {
    persist: {
      paths: [
        "account",
        "users",
        "store",
        "sign"
      ]
    },
    state: () => ({
      linked: false,
      account: "",
      sign: {
        address: "",
        message: "",
        signature: ""
      },
      store: {
        id: "",
        merchant: "",
        pers: "",
        storeName: "",
        viewOnlyFlag: 0
      },
      userInfo: {},
      users: {}
    }),
    getters: {
      isSign: (t) => {
        const { address: e, message: n, signature: r } = t.sign;
        return !!(e && n && r && xo(t.account) === xo(e));
      },
      isLogin: (t) => {
        const { address: e, signature: n, message: r } = t.sign;
        return !!(e && r && n && xo(t.account) === xo(e));
      },
      isOnlyView: (t) => {
        var _a6;
        return ((_a6 = t.store) == null ? void 0 : _a6.viewOnlyFlag) || 0;
      }
    },
    actions: {
      changeLinked(t) {
        this.linked = t;
      },
      changeAccount(t) {
        this.account = t;
      },
      changeSign(t) {
        this.sign = t;
      },
      changeUsers(t) {
        this.users[t.address || this.account] = t;
      },
      changeStore(t) {
        this.store = t;
      },
      changeUserInfo(t) {
        this.userInfo = t;
      }
    }
  });
  h6 = af("tokenBalance", {
    state: () => ({
      balances: {}
    }),
    actions: {
      addTokenBalance(t, e) {
        this.balances[t] = e;
      },
      clearBalance() {
        this.balances = {};
      }
    }
  });
  dP = af("region", {
    persist: true,
    state: () => ({
      country: "CN"
    }),
    actions: {
      changeCountry(t) {
        this.country = t;
      }
    }
  });
  ks = function() {
    return {
      reloadStore: MT(),
      accountStore: fP(),
      tokenBalanceStore: h6(),
      regionStore: dP()
    };
  };
  const H1 = PT();
  function hP(t) {
    return typeof t == "object" && t !== null;
  }
  function pP(t, e) {
    return t = hP(t) ? t : /* @__PURE__ */ Object.create(null), new Proxy(t, {
      get(n, r, i) {
        return Reflect.get(n, r, i) || Reflect.get(e, r, i);
      }
    });
  }
  function gP(t, e) {
    return e.reduce((n, r) => n == null ? void 0 : n[r], t);
  }
  function mP(t, e, n) {
    return e.slice(0, -1).reduce((r, i) => /^(__proto__)$/.test(i) ? {} : r[i] = r[i] || {}, t)[e[e.length - 1]] = n, t;
  }
  function yP(t, e) {
    return e.reduce((n, r) => {
      const i = r.split(".");
      return mP(n, i, gP(t, i));
    }, {});
  }
  function bP(t = {}) {
    return function(e) {
      const { options: { persist: n }, store: r } = e;
      if (!n) return;
      const { storage: i = localStorage, beforeRestore: s = null, afterRestore: o = null, serializer: a = {
        serialize: JSON.stringify,
        deserialize: JSON.parse
      }, key: c = r.$id, paths: l = null } = pP(n, t);
      s == null ? void 0 : s(e);
      try {
        const u = i.getItem(c);
        u && r.$patch(a.deserialize(u));
      } catch {
      }
      o == null ? void 0 : o(e), r.$subscribe((u, f) => {
        try {
          const d = Array.isArray(l) ? yP(f, l) : f;
          i.setItem(c, a.serialize(d));
        } catch {
        }
      }, {
        detached: true
      });
    };
  }
  var xP = bP();
  if (typeof window < "u") {
    let t = function() {
      var e = document.body, n = document.getElementById("__svg__icons__dom__");
      n || (n = document.createElementNS("http://www.w3.org/2000/svg", "svg"), n.style.position = "absolute", n.style.width = "0", n.style.height = "0", n.id = "__svg__icons__dom__", n.setAttribute("xmlns", "http://www.w3.org/2000/svg"), n.setAttribute("xmlns:link", "http://www.w3.org/1999/xlink")), n.innerHTML = '<symbol class="icon" viewBox="0 0 1024 1024"  id="icon-check-in"><path d="M781.9 572.5V334c0-19.5-15.5-35.3-34.7-35.3H279.1c-19.1 0-34.7 15.8-34.7 35.3v477c0 19.5 15.5 35.3 34.7 35.3H683c19.1 0 98.9-64 98.9-83.5V572.5z" fill="#FCEE21" /><path d="M781.9 764.3V343.6c0-8.3-3-16-7.9-22-68.7 307.3-434 456.3-526.3 504.6 5.5 11.9 17.5 20.1 31.4 20.1H683c19.2 0 98.9-62.8 98.9-82z" fill="#F8B62D" /><path d="M781.9 569.7c-5.6 0-10.1-4.5-10.1-10.1V309.8c0-14.8-12.1-26.9-26.9-26.9h-457c-5.6 0-10.1-4.5-10.1-10.1s4.5-10.1 10.1-10.1H745c26 0 47.1 21.1 47.1 47.1v249.7c-.1 5.7-4.6 10.2-10.2 10.2zM208.5 334.6c-5.6 0-10.1-4.5-10.1-10.1v-14.7c0-26 21.1-47.1 47.1-47.1h2.1c5.6 0 10.1 4.5 10.1 10.1s-4.5 10.1-10.1 10.1h-2.1c-14.8 0-26.9 12.1-26.9 26.9v14.7c-.1 5.6-4.6 10.1-10.1 10.1zm274.4 521.8H245.4c-26 0-47.1-21.1-47.1-47.1V358.2c0-5.6 4.5-10.1 10.1-10.1s10.1 4.5 10.1 10.1v451.2c0 14.8 12.1 26.9 26.9 26.9h237.4c5.6 0 10.1 4.5 10.1 10.1s-4.5 10-10 10z" fill="#3E3A39" /><path d="M313.2 506.9h232.1" fill="#FCEE21" /><path d="M545.3 517H313.2c-5.6 0-10.1-4.5-10.1-10.1s4.5-10.1 10.1-10.1h232.1c5.6 0 10.1 4.5 10.1 10.1s-4.5 10.1-10.1 10.1z" fill="#3E3A39" /><path d="M313.2 603.4h188.7" fill="#FCEE21" /><path d="M501.9 613.5H313.2c-5.6 0-10.1-4.5-10.1-10.1s4.5-10.1 10.1-10.1h188.7c5.6 0 10.1 4.5 10.1 10.1s-4.5 10.1-10.1 10.1z" fill="#3E3A39" /><path d="M313.2 699.8h125.1" fill="#FCEE21" /><path d="M438.3 709.9h-125c-5.6 0-10.1-4.5-10.1-10.1s4.5-10.1 10.1-10.1h125c5.6 0 10.1 4.5 10.1 10.1s-4.6 10.1-10.1 10.1z" fill="#3E3A39" /><path d="M316.1 404h465.8" fill="#FCEE21" /><path d="M781.9 414.1H316.1c-5.6 0-10.1-4.5-10.1-10.1s4.5-10.1 10.1-10.1H782c5.6 0 10.1 4.5 10.1 10.1s-4.6 10.1-10.2 10.1z" fill="#3E3A39" /><path d="M381.9 330.3h-43.1c-2.1 0-3.8-1.7-3.8-3.8V209.9c0-2.1 1.7-3.8 3.8-3.8h43.1c2.1 0 3.8 1.7 3.8 3.8v116.7c0 2-1.7 3.7-3.8 3.7z" fill="#F8B62D" /><path d="M360.3 340.4c-19.5 0-35.4-15.9-35.4-35.4v-73.6c0-19.5 15.9-35.4 35.4-35.4s35.4 15.9 35.4 35.4V305c.1 19.5-15.8 35.4-35.4 35.4zm0-124.2c-8.4 0-15.2 6.8-15.2 15.2V305c0 8.4 6.8 15.2 15.2 15.2 8.4 0 15.2-6.8 15.2-15.2v-73.6c.1-8.4-6.8-15.2-15.2-15.2zm506 640.2h-24c-5.6 0-10.1-4.5-10.1-10.1s4.5-10.1 10.1-10.1h24c5.6 0 10.1 4.5 10.1 10.1s-4.6 10.1-10.1 10.1zm-742.7 0H92.9c-5.6 0-10.1-4.5-10.1-10.1s4.5-10.1 10.1-10.1h30.7c5.6 0 10.1 4.5 10.1 10.1s-4.5 10.1-10.1 10.1zm680.1 0H155.4c-5.6 0-10.1-4.5-10.1-10.1s4.5-10.1 10.1-10.1h648.3c5.6 0 10.1 4.5 10.1 10.1s-4.5 10.1-10.1 10.1z" fill="#3E3A39" /><path d="M538.6 737.2a127.1 127.1 0 1 0 254.2 0 127.1 127.1 0 1 0-254.2 0Z" fill="#FFF" /><path d="M659.8 874.3c-82.6 0-149.8-67.2-149.8-149.8 0-82.6 67.2-149.8 149.8-149.8S809.5 642 809.5 724.6c0 82.5-67.1 149.7-149.7 149.7zm0-279.3c-71.5 0-129.6 58.1-129.6 129.6s58.1 129.6 129.6 129.6S789.4 796 789.4 724.6c0-71.5-58.2-129.6-129.6-129.6z" fill="#3E3A39" /><path d="M649.3 797c-2.5 0-4.9-.9-6.7-2.6l-64.8-58.2c-4.1-3.7-4.5-10.1-.8-14.2s10.1-4.5 14.2-.8l56.7 50.9 77.4-101.2c3.4-4.4 9.7-5.3 14.1-1.9s5.3 9.7 1.9 14.1l-84 109.9c-1.7 2.2-4.3 3.7-7.1 3.9-.2.1-.6.1-.9.1z" fill="#3E3A39" /><path d="M692.1 126.3c-15.1 0-27.3-12.3-27.3-27.3 0-15.1 12.3-27.3 27.3-27.3 15.1 0 27.3 12.3 27.3 27.3 0 15.1-12.2 27.3-27.3 27.3zm0-41.2c-7.7 0-13.9 6.2-13.9 13.9s6.2 13.9 13.9 13.9S706 106.7 706 99s-6.2-13.9-13.9-13.9z" fill="#47B7F8" /><path d="M249 169.9h-12v-12c0-3.2-2.6-5.8-5.8-5.8-3.2 0-5.8 2.6-5.8 5.8v12h-12c-3.2 0-5.8 2.6-5.8 5.8 0 3.2 2.6 5.8 5.8 5.8h12v12c0 3.2 2.6 5.8 5.8 5.8 3.2 0 5.8-2.6 5.8-5.8v-12h12c3.2 0 5.8-2.6 5.8-5.8 0-3.2-2.6-5.8-5.8-5.8zm604.2 116.3h-12v-12c0-3.2-2.6-5.8-5.8-5.8-3.2 0-5.8 2.6-5.8 5.8v12h-12c-3.2 0-5.8 2.6-5.8 5.8s2.6 5.8 5.8 5.8h12v12c0 3.2 2.6 5.8 5.8 5.8 3.2 0 5.8-2.6 5.8-5.8v-12h12c3.2 0 5.8-2.6 5.8-5.8s-2.6-5.8-5.8-5.8z" fill="#F7E42F" /><path d="M112.5 443.7H98.6v-13.9a6.7 6.7 0 0 0-13.4 0v13.9h-14a6.7 6.7 0 0 0 0 13.4h13.9V471a6.7 6.7 0 0 0 13.4 0v-13.9h13.9c3.7 0 6.7-3 6.7-6.7s-2.9-6.7-6.6-6.7zM330 109.1a10.1 10.1 0 1 0 20.2 0 10.1 10.1 0 1 0-20.2 0ZM777.4 162.3a13.4 13.4 0 1 0 26.8 0 13.4 13.4 0 1 0-26.8 0Z" fill="#F8B62D" /><path d="M531.9 115.7a13.4 13.4 0 1 0 26.8 0 13.4 13.4 0 1 0-26.8 0Z" fill="#F7E42F" /><path d="M125.5 291.9c-15.1 0-27.3-12.3-27.3-27.3 0-15.1 12.3-27.3 27.3-27.3s27.3 12.3 27.3 27.3c0 15.1-12.3 27.3-27.3 27.3zm0-41.2c-7.7 0-13.9 6.2-13.9 13.9s6.2 13.9 13.9 13.9 13.9-6.2 13.9-13.9-6.3-13.9-13.9-13.9z" fill="#F8B62D" /><path d="M472.7 166.3c-1.5-1.4-3.8-1.4-5.3 0-.7.7-1.1 1.6-1.1 2.6s.4 1.9 1.1 2.6l11.9 11.9c.7.7 1.6 1.1 2.6 1.1s1.9-.4 2.6-1.1c1.4-1.5 1.4-3.8 0-5.3l-11.8-11.8zm31.6 31.6c-.7-.7-1.6-1.1-2.6-1.1s-1.9.4-2.6 1.1c-1.4 1.5-1.4 3.8 0 5.3l11.9 11.9c.7.7 1.6 1.1 2.6 1.1s1.9-.4 2.6-1.1c.7-.7 1.1-1.6 1.1-2.6s-.4-1.9-1.1-2.6l-11.9-12zm-2.7-13.3c1 0 1.9-.4 2.6-1.1l11.9-11.9c.7-.7 1.1-1.6 1.1-2.6s-.4-1.9-1.1-2.6c-1.5-1.5-3.8-1.5-5.3 0L499 178.3c-1.4 1.5-1.4 3.8 0 5.3.7.7 1.6 1 2.6 1zm-22.2 13.3-11.9 11.9c-.7.7-1.1 1.6-1.1 2.6s.4 1.9 1.1 2.6c.7.7 1.6 1.1 2.6 1.1s1.9-.4 2.6-1.1l11.9-11.9c1.4-1.5 1.4-3.8 0-5.3-1.3-1.3-3.8-1.3-5.2.1zm2.3-7.2c0-2.1-1.7-3.7-3.7-3.7h-16.9c-2.1 0-3.7 1.7-3.7 3.7 0 2.1 1.7 3.7 3.7 3.7H478c2 0 3.7-1.6 3.7-3.7zm40.9-3.7h-16.9c-2.1 0-3.7 1.7-3.7 3.7 0 2.1 1.7 3.7 3.7 3.7h16.9c2.1 0 3.7-1.7 3.7-3.7s-1.7-3.7-3.7-3.7zm-30.8-30.8c-2.1 0-3.7 1.7-3.7 3.7v16.9c0 2.1 1.7 3.7 3.7 3.7 2.1 0 3.7-1.7 3.7-3.7V160c0-2.1-1.6-3.8-3.7-3.8zm0 44.6c-2.1 0-3.7 1.7-3.7 3.7v16.9c0 2.1 1.7 3.7 3.7 3.7 2.1 0 3.7-1.7 3.7-3.7v-16.9c0-2-1.6-3.7-3.7-3.7z" fill="#FAEE00" /><path d="M905.9 417c-1.5-1.4-3.8-1.4-5.3 0-.7.7-1.1 1.6-1.1 2.6s.4 1.9 1.1 2.6l11.9 11.9c.7.7 1.6 1.1 2.6 1.1s1.9-.4 2.6-1.1c1.4-1.5 1.4-3.8 0-5.3L905.9 417zm31.6 31.5c-.7-.7-1.6-1.1-2.6-1.1s-1.9.4-2.6 1.1c-1.4 1.5-1.4 3.8 0 5.3l11.9 11.9c.7.7 1.6 1.1 2.6 1.1s1.9-.4 2.6-1.1c.7-.7 1.1-1.6 1.1-2.6s-.4-1.9-1.1-2.6l-11.9-12zm-2.7-13.2c1 0 1.9-.4 2.6-1.1l11.9-11.9c.7-.7 1.1-1.6 1.1-2.6s-.4-1.9-1.1-2.6c-1.5-1.5-3.8-1.5-5.3 0L932.1 429c-1.4 1.5-1.4 3.8 0 5.3.8.6 1.7 1 2.7 1zm-22.2 13.2-11.9 11.9c-.7.7-1.1 1.6-1.1 2.6s.4 1.9 1.1 2.6c.7.7 1.6 1.1 2.6 1.1s1.9-.4 2.6-1.1l11.9-11.9c1.4-1.5 1.4-3.8 0-5.3-1.3-1.3-3.8-1.3-5.2.1zm2.3-7.1c0-2.1-1.7-3.7-3.7-3.7h-16.9c-2.1 0-3.7 1.7-3.7 3.7s1.7 3.7 3.7 3.7h16.9c2 0 3.7-1.7 3.7-3.7zm40.9-3.8h-16.9c-2.1 0-3.7 1.7-3.7 3.7s1.7 3.7 3.7 3.7h16.9c2.1 0 3.7-1.7 3.7-3.7s-1.7-3.7-3.7-3.7zM925 406.9c-2.1 0-3.7 1.7-3.7 3.7v16.9c0 2.1 1.7 3.7 3.7 3.7s3.7-1.7 3.7-3.7v-16.9c.1-2-1.6-3.7-3.7-3.7zm0 44.6c-2.1 0-3.7 1.7-3.7 3.7v16.9c0 2.1 1.7 3.7 3.7 3.7s3.7-1.7 3.7-3.7v-16.9c.1-2.1-1.6-3.7-3.7-3.7zM648.3 330.3h-43.1c-2.1 0-3.8-1.7-3.8-3.8V209.9c0-2.1 1.7-3.8 3.8-3.8h43.1c2.1 0 3.8 1.7 3.8 3.8v116.7c0 2-1.7 3.7-3.8 3.7z" fill="#F8B62D" /><path d="M626.7 340.4c-19.5 0-35.4-15.9-35.4-35.4v-73.6c0-19.5 15.9-35.4 35.4-35.4s35.4 15.9 35.4 35.4V305c.1 19.5-15.8 35.4-35.4 35.4zm0-124.2c-8.4 0-15.2 6.8-15.2 15.2V305c0 8.4 6.8 15.2 15.2 15.2 8.4 0 15.2-6.8 15.2-15.2v-73.6c.1-8.4-6.8-15.2-15.2-15.2z" fill="#3E3A39" /><path d="M271.3 381.9c-5.6 0-10.1-4.5-10.1-10.1V341c0-17.7 14.4-32.1 32.1-32.1h17.8c5.6 0 10.1 4.5 10.1 10.1s-4.5 10.1-10.1 10.1h-17.8c-6.6 0-12 5.4-12 12v30.8c.1 5.5-4.4 10-10 10zM271.3 576.4c-5.6 0-10.1-4.5-10.1-10.1V455.6c0-5.6 4.5-10.1 10.1-10.1s10.1 4.5 10.1 10.1v110.7c0 5.6-4.5 10.1-10.1 10.1z" fill="#FFF" /></symbol><symbol class="icon" viewBox="0 0 1024 1024"  id="icon-dark"><path d="M448.22 48C704.358 48 912 255.74 912 512l-.062 7.673C907.842 772.394 701.797 976 448.22 976c-110.645 0-198.866-26.169-264.663-78.506a32 32 0 0 1-4.325-4.159c-11.419-13.256-10.058-33.192 2.962-44.78l.399-.35 2.742-2.383c89.13-78.201 134.016-188.043 134.66-329.525L320 512c.253-143.557-44.635-254.831-134.665-333.822l-2.742-2.384c-13.39-11.534-14.895-31.74-3.36-45.13a32 32 0 0 1 4.324-4.158C249.354 74.17 337.575 48 448.22 48zm0 64c-78.634 0-142.266 14.443-192.055 42.56l-1.809 1.03.175.18c85.695 88.653 128.775 207.05 129.462 351.494l.007 4.825-.007 4.499c-.65 143.074-42.893 260.596-126.9 348.969l-2.737 2.852 1.809 1.031c49.174 27.77 111.852 42.201 189.149 42.56h2.906c216.135 0 392.63-171.775 399.568-386.834l.154-6.358.057-6.946-.053-6.477C844.452 289.716 670.368 115.55 454.83 112.054l-6.61-.054z" /></symbol><symbol class="icon" viewBox="0 0 1024 1024"  id="icon-github"><path d="M1021.724 512a495.16 495.16 0 0 1-97.575 299.645 500.622 500.622 0 0 1-250.858 184.23 30.583 30.583 0 0 1-26.214-4.734 25.85 25.85 0 0 1-8.01-20.025v-139.81a119.057 119.057 0 0 0-34.588-94.3 473.316 473.316 0 0 0 67.72-11.65 248.309 248.309 0 0 0 62.26-26.214 187.506 187.506 0 0 0 53.52-43.691 209.351 209.351 0 0 0 36.41-69.905 334.234 334.234 0 0 0 13.835-100.124 191.875 191.875 0 0 0-52.793-136.534 176.219 176.219 0 0 0-5.097-135.44 87.017 87.017 0 0 0-53.522 7.28 341.88 341.88 0 0 0-61.166 29.128l-25.123 15.656a473.316 473.316 0 0 0-254.862 0c-7.282-5.097-16.384-10.559-28.035-17.84a371.007 371.007 0 0 0-56.798-26.943 94.299 94.299 0 0 0-57.162-9.102 178.404 178.404 0 0 0-4.733 136.533 197.7 197.7 0 0 0-52.428 137.262 327.68 327.68 0 0 0 13.835 99.396 223.55 223.55 0 0 0 36.409 69.905 172.942 172.942 0 0 0 53.52 44.419 304.742 304.742 0 0 0 62.26 26.214 471.131 471.131 0 0 0 68.085 11.65 105.222 105.222 0 0 0-32.768 68.45 112.868 112.868 0 0 1-30.22 9.466 190.418 190.418 0 0 1-36.409 3.277 78.643 78.643 0 0 1-46.603-14.928 124.518 124.518 0 0 1-36.409-41.506 109.227 109.227 0 0 0-32.04-34.588 91.75 91.75 0 0 0-32.768-16.02H160.29a47.332 47.332 0 0 0-19.297 2.912q-5.46 3.277-3.276 7.646a50.244 50.244 0 0 0 6.19 9.102 62.987 62.987 0 0 0 8.737 8.374l4.733 2.913a88.838 88.838 0 0 1 29.128 25.122 179.496 179.496 0 0 1 20.753 33.496l6.553 15.292a82.284 82.284 0 0 0 29.127 41.142 109.227 109.227 0 0 0 44.055 18.933 223.186 223.186 0 0 0 45.875 4.733 207.167 207.167 0 0 0 36.41-2.549l15.29-2.548v95.391a26.214 26.214 0 0 1-8.737 20.025 31.676 31.676 0 0 1-26.579 4.733 498.438 498.438 0 0 1-249.4-185.321A486.787 486.787 0 0 1 2.275 512a497.71 497.71 0 0 1 68.448-254.862A504.627 504.627 0 0 1 257.138 70.724 497.71 497.71 0 0 1 512 2.276a497.71 497.71 0 0 1 254.862 68.448 504.627 504.627 0 0 1 186.414 186.414A496.981 496.981 0 0 1 1021.724 512z" /></symbol><symbol class="icon" viewBox="0 0 1024 1024"  id="icon-light"><path d="M512 224c159.058 0 288 128.942 288 288S671.058 800 512 800 224 671.058 224 512s128.942-288 288-288zm0 64c-123.712 0-224 100.288-224 224s100.288 224 224 224 224-100.288 224-224-100.288-224-224-224zm0 576c17.673 0 32 14.327 32 32v64c0 17.673-14.327 32-32 32-17.673 0-32-14.327-32-32v-64c0-17.673 14.327-32 32-32zM263.098 760.902c12.497 12.496 12.497 32.758 0 45.254l-45.254 45.255c-12.497 12.497-32.758 12.497-45.255 0s-12.497-32.758 0-45.255l45.255-45.254c12.496-12.497 32.758-12.497 45.254 0zm543.058 0 45.255 45.254c12.497 12.497 12.497 32.758 0 45.255s-32.758 12.497-45.255 0l-45.254-45.255c-12.497-12.496-12.497-32.758 0-45.254 12.496-12.497 32.758-12.497 45.254 0zM128 480c17.673 0 32 14.327 32 32 0 17.673-14.327 32-32 32H64c-17.673 0-32-14.327-32-32 0-17.673 14.327-32 32-32h64zm832 0c17.673 0 32 14.327 32 32 0 17.673-14.327 32-32 32h-64c-17.673 0-32-14.327-32-32 0-17.673 14.327-32 32-32h64zM217.844 172.589l45.254 45.255c12.497 12.496 12.497 32.758 0 45.254-12.496 12.497-32.758 12.497-45.254 0l-45.255-45.254c-12.497-12.497-12.497-32.758 0-45.255s32.758-12.497 45.255 0zm633.567 0c12.497 12.497 12.497 32.758 0 45.255l-45.255 45.254c-12.496 12.497-32.758 12.497-45.254 0-12.497-12.496-12.497-32.758 0-45.254l45.254-45.255c12.497-12.497 32.758-12.497 45.255 0zM512 32c17.673 0 32 14.327 32 32v64c0 17.673-14.327 32-32 32-17.673 0-32-14.327-32-32V64c0-17.673 14.327-32 32-32z" /></symbol><symbol class="icon" viewBox="0 0 1024 1024"  id="icon-link"><path d="M883.46 504.827a46.043 46.043 0 0 1-60.709-.938 41.61 41.61 0 0 1-3.496-58.236l77.591-77.933a163.539 163.539 0 0 0-16.967-229.107c-67.36-67.274-166.864-73.328-223.054-16.712l-216.83 218.364a163.539 163.539 0 0 0 17.054 229.107 41.61 41.61 0 0 1 0 60.368 45.617 45.617 0 0 1-63.437 0 246.33 246.33 0 0 1-16.968-347.285L593.474 65.37c93.28-93.45 251.616-85.777 352.485 17.053a246.246 246.246 0 0 1 15.604 343.619l-78.103 78.785zm-742.318 13.642a46.043 46.043 0 0 1 60.708.938c16.798 15.518 18.418 40.927 3.496 58.236l-77.591 77.932a163.539 163.539 0 0 0 16.968 229.108c67.36 67.274 166.864 73.328 223.053 16.712l216.83-218.364a163.539 163.539 0 0 0-17.054-229.108 41.61 41.61 0 0 1 0-60.367 45.532 45.532 0 0 1 63.438 0 246.33 246.33 0 0 1 16.968 347.285l-216.83 217.17c-93.28 93.365-251.617 85.691-352.486-17.053A246.246 246.246 0 0 1 63.04 597.339l78.103-78.785z" /></symbol>', e.insertBefore(n, e.lastChild);
    };
    document.readyState === "loading" ? document.addEventListener("DOMContentLoaded", t) : t();
  }
  const Q0 = typeof window < "u", Mo = (t, e = false) => e ? Symbol.for(t) : Symbol(t), AP = (t, e, n) => wP({
    l: t,
    k: e,
    s: n
  }), wP = (t) => JSON.stringify(t).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029").replace(/\u0027/g, "\\u0027"), fn = (t) => typeof t == "number" && isFinite(t), vP = (t) => g6(t) === "[object Date]", Ro = (t) => g6(t) === "[object RegExp]", Ld = (t) => Ue(t) && Object.keys(t).length === 0, Hn = Object.assign, EP = Object.create, yt = (t = null) => EP(t);
  let ux;
  const Cs = () => ux || (ux = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : typeof global < "u" ? global : yt());
  function fx(t) {
    return t.replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&apos;");
  }
  const SP = Object.prototype.hasOwnProperty;
  function mi(t, e) {
    return SP.call(t, e);
  }
  const Vt = Array.isArray, wt = (t) => typeof t == "function", Ce = (t) => typeof t == "string", Ye = (t) => typeof t == "boolean", ut = (t) => t !== null && typeof t == "object", TP = (t) => ut(t) && wt(t.then) && wt(t.catch), p6 = Object.prototype.toString, g6 = (t) => p6.call(t), Ue = (t) => {
    if (!ut(t)) return false;
    const e = Object.getPrototypeOf(t);
    return e === null || e.constructor === Object;
  }, CP = (t) => t == null ? "" : Vt(t) || Ue(t) && t.toString === p6 ? JSON.stringify(t, null, 2) : String(t);
  function IP(t, e = "") {
    return t.reduce((n, r, i) => i === 0 ? n + r : n + e + r, "");
  }
  function Dd(t) {
    let e = t;
    return () => ++e;
  }
  function PP(t, e) {
    typeof console < "u" && (console.warn("[intlify] " + t), e && console.warn(e.stack));
  }
  const Df = (t) => !ut(t) || Vt(t);
  function u0(t, e) {
    if (Df(t) || Df(e)) throw new Error("Invalid value");
    const n = [
      {
        src: t,
        des: e
      }
    ];
    for (; n.length; ) {
      const { src: r, des: i } = n.pop();
      Object.keys(r).forEach((s) => {
        s !== "__proto__" && (ut(r[s]) && !ut(i[s]) && (i[s] = Array.isArray(r[s]) ? [] : yt()), Df(i[s]) || Df(r[s]) ? i[s] = r[s] : n.push({
          src: r[s],
          des: i[s]
        }));
      });
    }
  }
  function _P(t, e, n) {
    return {
      line: t,
      column: e,
      offset: n
    };
  }
  function j0(t, e, n) {
    return {
      start: t,
      end: e
    };
  }
  const RP = /\{([0-9a-zA-Z]+)\}/g;
  function m6(t, ...e) {
    return e.length === 1 && NP(e[0]) && (e = e[0]), (!e || !e.hasOwnProperty) && (e = {}), t.replace(RP, (n, r) => e.hasOwnProperty(r) ? e[r] : "");
  }
  const y6 = Object.assign, dx = (t) => typeof t == "string", NP = (t) => t !== null && typeof t == "object";
  function b6(t, e = "") {
    return t.reduce((n, r, i) => i === 0 ? n + r : n + e + r, "");
  }
  const G1 = {
    USE_MODULO_SYNTAX: 1,
    __EXTEND_POINT__: 2
  }, OP = {
    [G1.USE_MODULO_SYNTAX]: "Use modulo before '{{0}}'."
  };
  function BP(t, e, ...n) {
    const r = m6(OP[t], ...n || []), i = {
      message: String(r),
      code: t
    };
    return e && (i.location = e), i;
  }
  const Le = {
    EXPECTED_TOKEN: 1,
    INVALID_TOKEN_IN_PLACEHOLDER: 2,
    UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER: 3,
    UNKNOWN_ESCAPE_SEQUENCE: 4,
    INVALID_UNICODE_ESCAPE_SEQUENCE: 5,
    UNBALANCED_CLOSING_BRACE: 6,
    UNTERMINATED_CLOSING_BRACE: 7,
    EMPTY_PLACEHOLDER: 8,
    NOT_ALLOW_NEST_PLACEHOLDER: 9,
    INVALID_LINKED_FORMAT: 10,
    MUST_HAVE_MESSAGES_IN_PLURAL: 11,
    UNEXPECTED_EMPTY_LINKED_MODIFIER: 12,
    UNEXPECTED_EMPTY_LINKED_KEY: 13,
    UNEXPECTED_LEXICAL_ANALYSIS: 14,
    UNHANDLED_CODEGEN_NODE_TYPE: 15,
    UNHANDLED_MINIFIER_NODE_TYPE: 16,
    __EXTEND_POINT__: 17
  }, MP = {
    [Le.EXPECTED_TOKEN]: "Expected token: '{0}'",
    [Le.INVALID_TOKEN_IN_PLACEHOLDER]: "Invalid token in placeholder: '{0}'",
    [Le.UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER]: "Unterminated single quote in placeholder",
    [Le.UNKNOWN_ESCAPE_SEQUENCE]: "Unknown escape sequence: \\{0}",
    [Le.INVALID_UNICODE_ESCAPE_SEQUENCE]: "Invalid unicode escape sequence: {0}",
    [Le.UNBALANCED_CLOSING_BRACE]: "Unbalanced closing brace",
    [Le.UNTERMINATED_CLOSING_BRACE]: "Unterminated closing brace",
    [Le.EMPTY_PLACEHOLDER]: "Empty placeholder",
    [Le.NOT_ALLOW_NEST_PLACEHOLDER]: "Not allowed nest placeholder",
    [Le.INVALID_LINKED_FORMAT]: "Invalid linked format",
    [Le.MUST_HAVE_MESSAGES_IN_PLURAL]: "Plural must have messages",
    [Le.UNEXPECTED_EMPTY_LINKED_MODIFIER]: "Unexpected empty linked modifier",
    [Le.UNEXPECTED_EMPTY_LINKED_KEY]: "Unexpected empty linked key",
    [Le.UNEXPECTED_LEXICAL_ANALYSIS]: "Unexpected lexical analysis in token: '{0}'",
    [Le.UNHANDLED_CODEGEN_NODE_TYPE]: "unhandled codegen node type: '{0}'",
    [Le.UNHANDLED_MINIFIER_NODE_TYPE]: "unhandled mimifier node type: '{0}'"
  };
  function bl(t, e, n = {}) {
    const { domain: r, messages: i, args: s } = n, o = m6((i || MP)[t] || "", ...s || []), a = new SyntaxError(String(o));
    return a.code = t, e && (a.location = e), a.domain = r, a;
  }
  function kP(t) {
    throw t;
  }
  const ps = " ", FP = "\r", Zn = `
`, LP = "\u2028", DP = "\u2029";
  function UP(t) {
    const e = t;
    let n = 0, r = 1, i = 1, s = 0;
    const o = (q) => e[q] === FP && e[q + 1] === Zn, a = (q) => e[q] === Zn, c = (q) => e[q] === DP, l = (q) => e[q] === LP, u = (q) => o(q) || a(q) || c(q) || l(q), f = () => n, d = () => r, m = () => i, y = () => s, x = (q) => o(q) || c(q) || l(q) ? Zn : e[q], w = () => x(n), R = () => x(n + s);
    function O() {
      return s = 0, u(n) && (r++, i = 0), o(n) && n++, n++, i++, e[n];
    }
    function B() {
      return o(n + s) && s++, s++, e[n + s];
    }
    function M() {
      n = 0, r = 1, i = 1, s = 0;
    }
    function D(q = 0) {
      s = q;
    }
    function H() {
      const q = n + s;
      for (; q !== n; ) O();
      s = 0;
    }
    return {
      index: f,
      line: d,
      column: m,
      peekOffset: y,
      charAt: x,
      currentChar: w,
      currentPeek: R,
      next: O,
      peek: B,
      reset: M,
      resetPeek: D,
      skipToPeek: H
    };
  }
  const to = void 0, HP = ".", hx = "'", GP = "tokenizer";
  function VP(t, e = {}) {
    const n = e.location !== false, r = UP(t), i = () => r.index(), s = () => _P(r.line(), r.column(), r.index()), o = s(), a = i(), c = {
      currentType: 14,
      offset: a,
      startLoc: o,
      endLoc: o,
      lastType: 14,
      lastOffset: a,
      lastStartLoc: o,
      lastEndLoc: o,
      braceNest: 0,
      inLinked: false,
      text: ""
    }, l = () => c, { onError: u } = e;
    function f(Q, j, ae, ...le) {
      const be = l();
      if (j.column += ae, j.offset += ae, u) {
        const xe = n ? j0(be.startLoc, j) : null, ie = bl(Q, xe, {
          domain: GP,
          args: le
        });
        u(ie);
      }
    }
    function d(Q, j, ae) {
      Q.endLoc = s(), Q.currentType = j;
      const le = {
        type: j
      };
      return n && (le.loc = j0(Q.startLoc, Q.endLoc)), ae != null && (le.value = ae), le;
    }
    const m = (Q) => d(Q, 14);
    function y(Q, j) {
      return Q.currentChar() === j ? (Q.next(), j) : (f(Le.EXPECTED_TOKEN, s(), 0, j), "");
    }
    function x(Q) {
      let j = "";
      for (; Q.currentPeek() === ps || Q.currentPeek() === Zn; ) j += Q.currentPeek(), Q.peek();
      return j;
    }
    function w(Q) {
      const j = x(Q);
      return Q.skipToPeek(), j;
    }
    function R(Q) {
      if (Q === to) return false;
      const j = Q.charCodeAt(0);
      return j >= 97 && j <= 122 || j >= 65 && j <= 90 || j === 95;
    }
    function O(Q) {
      if (Q === to) return false;
      const j = Q.charCodeAt(0);
      return j >= 48 && j <= 57;
    }
    function B(Q, j) {
      const { currentType: ae } = j;
      if (ae !== 2) return false;
      x(Q);
      const le = R(Q.currentPeek());
      return Q.resetPeek(), le;
    }
    function M(Q, j) {
      const { currentType: ae } = j;
      if (ae !== 2) return false;
      x(Q);
      const le = Q.currentPeek() === "-" ? Q.peek() : Q.currentPeek(), be = O(le);
      return Q.resetPeek(), be;
    }
    function D(Q, j) {
      const { currentType: ae } = j;
      if (ae !== 2) return false;
      x(Q);
      const le = Q.currentPeek() === hx;
      return Q.resetPeek(), le;
    }
    function H(Q, j) {
      const { currentType: ae } = j;
      if (ae !== 8) return false;
      x(Q);
      const le = Q.currentPeek() === ".";
      return Q.resetPeek(), le;
    }
    function q(Q, j) {
      const { currentType: ae } = j;
      if (ae !== 9) return false;
      x(Q);
      const le = R(Q.currentPeek());
      return Q.resetPeek(), le;
    }
    function S(Q, j) {
      const { currentType: ae } = j;
      if (!(ae === 8 || ae === 12)) return false;
      x(Q);
      const le = Q.currentPeek() === ":";
      return Q.resetPeek(), le;
    }
    function P(Q, j) {
      const { currentType: ae } = j;
      if (ae !== 10) return false;
      const le = () => {
        const xe = Q.currentPeek();
        return xe === "{" ? R(Q.peek()) : xe === "@" || xe === "%" || xe === "|" || xe === ":" || xe === "." || xe === ps || !xe ? false : xe === Zn ? (Q.peek(), le()) : z(Q, false);
      }, be = le();
      return Q.resetPeek(), be;
    }
    function L(Q) {
      x(Q);
      const j = Q.currentPeek() === "|";
      return Q.resetPeek(), j;
    }
    function K(Q) {
      const j = x(Q), ae = Q.currentPeek() === "%" && Q.peek() === "{";
      return Q.resetPeek(), {
        isModulo: ae,
        hasSpace: j.length > 0
      };
    }
    function z(Q, j = true) {
      const ae = (be = false, xe = "", ie = false) => {
        const _ = Q.currentPeek();
        return _ === "{" ? xe === "%" ? false : be : _ === "@" || !_ ? xe === "%" ? true : be : _ === "%" ? (Q.peek(), ae(be, "%", true)) : _ === "|" ? xe === "%" || ie ? true : !(xe === ps || xe === Zn) : _ === ps ? (Q.peek(), ae(true, ps, ie)) : _ === Zn ? (Q.peek(), ae(true, Zn, ie)) : true;
      }, le = ae();
      return j && Q.resetPeek(), le;
    }
    function I(Q, j) {
      const ae = Q.currentChar();
      return ae === to ? to : j(ae) ? (Q.next(), ae) : null;
    }
    function h(Q) {
      const j = Q.charCodeAt(0);
      return j >= 97 && j <= 122 || j >= 65 && j <= 90 || j >= 48 && j <= 57 || j === 95 || j === 36;
    }
    function p(Q) {
      return I(Q, h);
    }
    function A(Q) {
      const j = Q.charCodeAt(0);
      return j >= 97 && j <= 122 || j >= 65 && j <= 90 || j >= 48 && j <= 57 || j === 95 || j === 36 || j === 45;
    }
    function C(Q) {
      return I(Q, A);
    }
    function N(Q) {
      const j = Q.charCodeAt(0);
      return j >= 48 && j <= 57;
    }
    function U(Q) {
      return I(Q, N);
    }
    function Y(Q) {
      const j = Q.charCodeAt(0);
      return j >= 48 && j <= 57 || j >= 65 && j <= 70 || j >= 97 && j <= 102;
    }
    function T(Q) {
      return I(Q, Y);
    }
    function g(Q) {
      let j = "", ae = "";
      for (; j = U(Q); ) ae += j;
      return ae;
    }
    function F(Q) {
      w(Q);
      const j = Q.currentChar();
      return j !== "%" && f(Le.EXPECTED_TOKEN, s(), 0, j), Q.next(), "%";
    }
    function ee(Q) {
      let j = "";
      for (; ; ) {
        const ae = Q.currentChar();
        if (ae === "{" || ae === "}" || ae === "@" || ae === "|" || !ae) break;
        if (ae === "%") if (z(Q)) j += ae, Q.next();
        else break;
        else if (ae === ps || ae === Zn) if (z(Q)) j += ae, Q.next();
        else {
          if (L(Q)) break;
          j += ae, Q.next();
        }
        else j += ae, Q.next();
      }
      return j;
    }
    function E(Q) {
      w(Q);
      let j = "", ae = "";
      for (; j = C(Q); ) ae += j;
      return Q.currentChar() === to && f(Le.UNTERMINATED_CLOSING_BRACE, s(), 0), ae;
    }
    function Z(Q) {
      w(Q);
      let j = "";
      return Q.currentChar() === "-" ? (Q.next(), j += `-${g(Q)}`) : j += g(Q), Q.currentChar() === to && f(Le.UNTERMINATED_CLOSING_BRACE, s(), 0), j;
    }
    function k(Q) {
      return Q !== hx && Q !== Zn;
    }
    function X(Q) {
      w(Q), y(Q, "'");
      let j = "", ae = "";
      for (; j = I(Q, k); ) j === "\\" ? ae += $(Q) : ae += j;
      const le = Q.currentChar();
      return le === Zn || le === to ? (f(Le.UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER, s(), 0), le === Zn && (Q.next(), y(Q, "'")), ae) : (y(Q, "'"), ae);
    }
    function $(Q) {
      const j = Q.currentChar();
      switch (j) {
        case "\\":
        case "'":
          return Q.next(), `\\${j}`;
        case "u":
          return ce(Q, j, 4);
        case "U":
          return ce(Q, j, 6);
        default:
          return f(Le.UNKNOWN_ESCAPE_SEQUENCE, s(), 0, j), "";
      }
    }
    function ce(Q, j, ae) {
      y(Q, j);
      let le = "";
      for (let be = 0; be < ae; be++) {
        const xe = T(Q);
        if (!xe) {
          f(Le.INVALID_UNICODE_ESCAPE_SEQUENCE, s(), 0, `\\${j}${le}${Q.currentChar()}`);
          break;
        }
        le += xe;
      }
      return `\\${j}${le}`;
    }
    function fe(Q) {
      return Q !== "{" && Q !== "}" && Q !== ps && Q !== Zn;
    }
    function G(Q) {
      w(Q);
      let j = "", ae = "";
      for (; j = I(Q, fe); ) ae += j;
      return ae;
    }
    function W(Q) {
      let j = "", ae = "";
      for (; j = p(Q); ) ae += j;
      return ae;
    }
    function V(Q) {
      const j = (ae) => {
        const le = Q.currentChar();
        return le === "{" || le === "%" || le === "@" || le === "|" || le === "(" || le === ")" || !le || le === ps ? ae : (ae += le, Q.next(), j(ae));
      };
      return j("");
    }
    function te(Q) {
      w(Q);
      const j = y(Q, "|");
      return w(Q), j;
    }
    function pe(Q, j) {
      let ae = null;
      switch (Q.currentChar()) {
        case "{":
          return j.braceNest >= 1 && f(Le.NOT_ALLOW_NEST_PLACEHOLDER, s(), 0), Q.next(), ae = d(j, 2, "{"), w(Q), j.braceNest++, ae;
        case "}":
          return j.braceNest > 0 && j.currentType === 2 && f(Le.EMPTY_PLACEHOLDER, s(), 0), Q.next(), ae = d(j, 3, "}"), j.braceNest--, j.braceNest > 0 && w(Q), j.inLinked && j.braceNest === 0 && (j.inLinked = false), ae;
        case "@":
          return j.braceNest > 0 && f(Le.UNTERMINATED_CLOSING_BRACE, s(), 0), ae = ue(Q, j) || m(j), j.braceNest = 0, ae;
        default: {
          let be = true, xe = true, ie = true;
          if (L(Q)) return j.braceNest > 0 && f(Le.UNTERMINATED_CLOSING_BRACE, s(), 0), ae = d(j, 1, te(Q)), j.braceNest = 0, j.inLinked = false, ae;
          if (j.braceNest > 0 && (j.currentType === 5 || j.currentType === 6 || j.currentType === 7)) return f(Le.UNTERMINATED_CLOSING_BRACE, s(), 0), j.braceNest = 0, ye(Q, j);
          if (be = B(Q, j)) return ae = d(j, 5, E(Q)), w(Q), ae;
          if (xe = M(Q, j)) return ae = d(j, 6, Z(Q)), w(Q), ae;
          if (ie = D(Q, j)) return ae = d(j, 7, X(Q)), w(Q), ae;
          if (!be && !xe && !ie) return ae = d(j, 13, G(Q)), f(Le.INVALID_TOKEN_IN_PLACEHOLDER, s(), 0, ae.value), w(Q), ae;
          break;
        }
      }
      return ae;
    }
    function ue(Q, j) {
      const { currentType: ae } = j;
      let le = null;
      const be = Q.currentChar();
      switch ((ae === 8 || ae === 9 || ae === 12 || ae === 10) && (be === Zn || be === ps) && f(Le.INVALID_LINKED_FORMAT, s(), 0), be) {
        case "@":
          return Q.next(), le = d(j, 8, "@"), j.inLinked = true, le;
        case ".":
          return w(Q), Q.next(), d(j, 9, ".");
        case ":":
          return w(Q), Q.next(), d(j, 10, ":");
        default:
          return L(Q) ? (le = d(j, 1, te(Q)), j.braceNest = 0, j.inLinked = false, le) : H(Q, j) || S(Q, j) ? (w(Q), ue(Q, j)) : q(Q, j) ? (w(Q), d(j, 12, W(Q))) : P(Q, j) ? (w(Q), be === "{" ? pe(Q, j) || le : d(j, 11, V(Q))) : (ae === 8 && f(Le.INVALID_LINKED_FORMAT, s(), 0), j.braceNest = 0, j.inLinked = false, ye(Q, j));
      }
    }
    function ye(Q, j) {
      let ae = {
        type: 14
      };
      if (j.braceNest > 0) return pe(Q, j) || m(j);
      if (j.inLinked) return ue(Q, j) || m(j);
      switch (Q.currentChar()) {
        case "{":
          return pe(Q, j) || m(j);
        case "}":
          return f(Le.UNBALANCED_CLOSING_BRACE, s(), 0), Q.next(), d(j, 3, "}");
        case "@":
          return ue(Q, j) || m(j);
        default: {
          if (L(Q)) return ae = d(j, 1, te(Q)), j.braceNest = 0, j.inLinked = false, ae;
          const { isModulo: be, hasSpace: xe } = K(Q);
          if (be) return xe ? d(j, 0, ee(Q)) : d(j, 4, F(Q));
          if (z(Q)) return d(j, 0, ee(Q));
          break;
        }
      }
      return ae;
    }
    function we() {
      const { currentType: Q, offset: j, startLoc: ae, endLoc: le } = c;
      return c.lastType = Q, c.lastOffset = j, c.lastStartLoc = ae, c.lastEndLoc = le, c.offset = i(), c.startLoc = s(), r.currentChar() === to ? d(c, 14) : ye(r, c);
    }
    return {
      nextToken: we,
      currentOffset: i,
      currentPosition: s,
      context: l
    };
  }
  const zP = "parser", QP = /(?:\\\\|\\'|\\u([0-9a-fA-F]{4})|\\U([0-9a-fA-F]{6}))/g;
  function jP(t, e, n) {
    switch (t) {
      case "\\\\":
        return "\\";
      case "\\'":
        return "'";
      default: {
        const r = parseInt(e || n, 16);
        return r <= 55295 || r >= 57344 ? String.fromCodePoint(r) : "\uFFFD";
      }
    }
  }
  function JP(t = {}) {
    const e = t.location !== false, { onError: n, onWarn: r } = t;
    function i(B, M, D, H, ...q) {
      const S = B.currentPosition();
      if (S.offset += H, S.column += H, n) {
        const P = e ? j0(D, S) : null, L = bl(M, P, {
          domain: zP,
          args: q
        });
        n(L);
      }
    }
    function s(B, M, D, H, ...q) {
      const S = B.currentPosition();
      if (S.offset += H, S.column += H, r) {
        const P = e ? j0(D, S) : null;
        r(BP(M, P, q));
      }
    }
    function o(B, M, D) {
      const H = {
        type: B
      };
      return e && (H.start = M, H.end = M, H.loc = {
        start: D,
        end: D
      }), H;
    }
    function a(B, M, D, H) {
      e && (B.end = M, B.loc && (B.loc.end = D));
    }
    function c(B, M) {
      const D = B.context(), H = o(3, D.offset, D.startLoc);
      return H.value = M, a(H, B.currentOffset(), B.currentPosition()), H;
    }
    function l(B, M) {
      const D = B.context(), { lastOffset: H, lastStartLoc: q } = D, S = o(5, H, q);
      return S.index = parseInt(M, 10), B.nextToken(), a(S, B.currentOffset(), B.currentPosition()), S;
    }
    function u(B, M, D) {
      const H = B.context(), { lastOffset: q, lastStartLoc: S } = H, P = o(4, q, S);
      return P.key = M, D === true && (P.modulo = true), B.nextToken(), a(P, B.currentOffset(), B.currentPosition()), P;
    }
    function f(B, M) {
      const D = B.context(), { lastOffset: H, lastStartLoc: q } = D, S = o(9, H, q);
      return S.value = M.replace(QP, jP), B.nextToken(), a(S, B.currentOffset(), B.currentPosition()), S;
    }
    function d(B) {
      const M = B.nextToken(), D = B.context(), { lastOffset: H, lastStartLoc: q } = D, S = o(8, H, q);
      return M.type !== 12 ? (i(B, Le.UNEXPECTED_EMPTY_LINKED_MODIFIER, D.lastStartLoc, 0), S.value = "", a(S, H, q), {
        nextConsumeToken: M,
        node: S
      }) : (M.value == null && i(B, Le.UNEXPECTED_LEXICAL_ANALYSIS, D.lastStartLoc, 0, ti(M)), S.value = M.value || "", a(S, B.currentOffset(), B.currentPosition()), {
        node: S
      });
    }
    function m(B, M) {
      const D = B.context(), H = o(7, D.offset, D.startLoc);
      return H.value = M, a(H, B.currentOffset(), B.currentPosition()), H;
    }
    function y(B) {
      const M = B.context(), D = o(6, M.offset, M.startLoc);
      let H = B.nextToken();
      if (H.type === 9) {
        const q = d(B);
        D.modifier = q.node, H = q.nextConsumeToken || B.nextToken();
      }
      switch (H.type !== 10 && i(B, Le.UNEXPECTED_LEXICAL_ANALYSIS, M.lastStartLoc, 0, ti(H)), H = B.nextToken(), H.type === 2 && (H = B.nextToken()), H.type) {
        case 11:
          H.value == null && i(B, Le.UNEXPECTED_LEXICAL_ANALYSIS, M.lastStartLoc, 0, ti(H)), D.key = m(B, H.value || "");
          break;
        case 5:
          H.value == null && i(B, Le.UNEXPECTED_LEXICAL_ANALYSIS, M.lastStartLoc, 0, ti(H)), D.key = u(B, H.value || "");
          break;
        case 6:
          H.value == null && i(B, Le.UNEXPECTED_LEXICAL_ANALYSIS, M.lastStartLoc, 0, ti(H)), D.key = l(B, H.value || "");
          break;
        case 7:
          H.value == null && i(B, Le.UNEXPECTED_LEXICAL_ANALYSIS, M.lastStartLoc, 0, ti(H)), D.key = f(B, H.value || "");
          break;
        default: {
          i(B, Le.UNEXPECTED_EMPTY_LINKED_KEY, M.lastStartLoc, 0);
          const q = B.context(), S = o(7, q.offset, q.startLoc);
          return S.value = "", a(S, q.offset, q.startLoc), D.key = S, a(D, q.offset, q.startLoc), {
            nextConsumeToken: H,
            node: D
          };
        }
      }
      return a(D, B.currentOffset(), B.currentPosition()), {
        node: D
      };
    }
    function x(B) {
      const M = B.context(), D = M.currentType === 1 ? B.currentOffset() : M.offset, H = M.currentType === 1 ? M.endLoc : M.startLoc, q = o(2, D, H);
      q.items = [];
      let S = null, P = null;
      do {
        const z = S || B.nextToken();
        switch (S = null, z.type) {
          case 0:
            z.value == null && i(B, Le.UNEXPECTED_LEXICAL_ANALYSIS, M.lastStartLoc, 0, ti(z)), q.items.push(c(B, z.value || ""));
            break;
          case 6:
            z.value == null && i(B, Le.UNEXPECTED_LEXICAL_ANALYSIS, M.lastStartLoc, 0, ti(z)), q.items.push(l(B, z.value || ""));
            break;
          case 4:
            P = true;
            break;
          case 5:
            z.value == null && i(B, Le.UNEXPECTED_LEXICAL_ANALYSIS, M.lastStartLoc, 0, ti(z)), q.items.push(u(B, z.value || "", !!P)), P && (s(B, G1.USE_MODULO_SYNTAX, M.lastStartLoc, 0, ti(z)), P = null);
            break;
          case 7:
            z.value == null && i(B, Le.UNEXPECTED_LEXICAL_ANALYSIS, M.lastStartLoc, 0, ti(z)), q.items.push(f(B, z.value || ""));
            break;
          case 8: {
            const I = y(B);
            q.items.push(I.node), S = I.nextConsumeToken || null;
            break;
          }
        }
      } while (M.currentType !== 14 && M.currentType !== 1);
      const L = M.currentType === 1 ? M.lastOffset : B.currentOffset(), K = M.currentType === 1 ? M.lastEndLoc : B.currentPosition();
      return a(q, L, K), q;
    }
    function w(B, M, D, H) {
      const q = B.context();
      let S = H.items.length === 0;
      const P = o(1, M, D);
      P.cases = [], P.cases.push(H);
      do {
        const L = x(B);
        S || (S = L.items.length === 0), P.cases.push(L);
      } while (q.currentType !== 14);
      return S && i(B, Le.MUST_HAVE_MESSAGES_IN_PLURAL, D, 0), a(P, B.currentOffset(), B.currentPosition()), P;
    }
    function R(B) {
      const M = B.context(), { offset: D, startLoc: H } = M, q = x(B);
      return M.currentType === 14 ? q : w(B, D, H, q);
    }
    function O(B) {
      const M = VP(B, y6({}, t)), D = M.context(), H = o(0, D.offset, D.startLoc);
      return e && H.loc && (H.loc.source = B), H.body = R(M), t.onCacheKey && (H.cacheKey = t.onCacheKey(B)), D.currentType !== 14 && i(M, Le.UNEXPECTED_LEXICAL_ANALYSIS, D.lastStartLoc, 0, B[D.offset] || ""), a(H, M.currentOffset(), M.currentPosition()), H;
    }
    return {
      parse: O
    };
  }
  function ti(t) {
    if (t.type === 14) return "EOF";
    const e = (t.value || "").replace(/\r?\n/gu, "\\n");
    return e.length > 10 ? e.slice(0, 9) + "\u2026" : e;
  }
  function KP(t, e = {}) {
    const n = {
      ast: t,
      helpers: /* @__PURE__ */ new Set()
    };
    return {
      context: () => n,
      helper: (s) => (n.helpers.add(s), s)
    };
  }
  function px(t, e) {
    for (let n = 0; n < t.length; n++) V1(t[n], e);
  }
  function V1(t, e) {
    switch (t.type) {
      case 1:
        px(t.cases, e), e.helper("plural");
        break;
      case 2:
        px(t.items, e);
        break;
      case 6: {
        V1(t.key, e), e.helper("linked"), e.helper("type");
        break;
      }
      case 5:
        e.helper("interpolate"), e.helper("list");
        break;
      case 4:
        e.helper("interpolate"), e.helper("named");
        break;
    }
  }
  function WP(t, e = {}) {
    const n = KP(t);
    n.helper("normalize"), t.body && V1(t.body, n);
    const r = n.context();
    t.helpers = Array.from(r.helpers);
  }
  function qP(t) {
    const e = t.body;
    return e.type === 2 ? gx(e) : e.cases.forEach((n) => gx(n)), t;
  }
  function gx(t) {
    if (t.items.length === 1) {
      const e = t.items[0];
      (e.type === 3 || e.type === 9) && (t.static = e.value, delete e.value);
    } else {
      const e = [];
      for (let n = 0; n < t.items.length; n++) {
        const r = t.items[n];
        if (!(r.type === 3 || r.type === 9) || r.value == null) break;
        e.push(r.value);
      }
      if (e.length === t.items.length) {
        t.static = b6(e);
        for (let n = 0; n < t.items.length; n++) {
          const r = t.items[n];
          (r.type === 3 || r.type === 9) && delete r.value;
        }
      }
    }
  }
  const YP = "minifier";
  function lc(t) {
    switch (t.t = t.type, t.type) {
      case 0: {
        const e = t;
        lc(e.body), e.b = e.body, delete e.body;
        break;
      }
      case 1: {
        const e = t, n = e.cases;
        for (let r = 0; r < n.length; r++) lc(n[r]);
        e.c = n, delete e.cases;
        break;
      }
      case 2: {
        const e = t, n = e.items;
        for (let r = 0; r < n.length; r++) lc(n[r]);
        e.i = n, delete e.items, e.static && (e.s = e.static, delete e.static);
        break;
      }
      case 3:
      case 9:
      case 8:
      case 7: {
        const e = t;
        e.value && (e.v = e.value, delete e.value);
        break;
      }
      case 6: {
        const e = t;
        lc(e.key), e.k = e.key, delete e.key, e.modifier && (lc(e.modifier), e.m = e.modifier, delete e.modifier);
        break;
      }
      case 5: {
        const e = t;
        e.i = e.index, delete e.index;
        break;
      }
      case 4: {
        const e = t;
        e.k = e.key, delete e.key;
        break;
      }
      default:
        throw bl(Le.UNHANDLED_MINIFIER_NODE_TYPE, null, {
          domain: YP,
          args: [
            t.type
          ]
        });
    }
    delete t.type;
  }
  const XP = "parser";
  function ZP(t, e) {
    const { filename: n, breakLineCode: r, needIndent: i } = e, s = e.location !== false, o = {
      filename: n,
      code: "",
      column: 1,
      line: 1,
      offset: 0,
      map: void 0,
      breakLineCode: r,
      needIndent: i,
      indentLevel: 0
    };
    s && t.loc && (o.source = t.loc.source);
    const a = () => o;
    function c(x, w) {
      o.code += x;
    }
    function l(x, w = true) {
      const R = w ? r : "";
      c(i ? R + "  ".repeat(x) : R);
    }
    function u(x = true) {
      const w = ++o.indentLevel;
      x && l(w);
    }
    function f(x = true) {
      const w = --o.indentLevel;
      x && l(w);
    }
    function d() {
      l(o.indentLevel);
    }
    return {
      context: a,
      push: c,
      indent: u,
      deindent: f,
      newline: d,
      helper: (x) => `_${x}`,
      needIndent: () => o.needIndent
    };
  }
  function $P(t, e) {
    const { helper: n } = t;
    t.push(`${n("linked")}(`), Wc(t, e.key), e.modifier ? (t.push(", "), Wc(t, e.modifier), t.push(", _type")) : t.push(", undefined, _type"), t.push(")");
  }
  function e_(t, e) {
    const { helper: n, needIndent: r } = t;
    t.push(`${n("normalize")}([`), t.indent(r());
    const i = e.items.length;
    for (let s = 0; s < i && (Wc(t, e.items[s]), s !== i - 1); s++) t.push(", ");
    t.deindent(r()), t.push("])");
  }
  function t_(t, e) {
    const { helper: n, needIndent: r } = t;
    if (e.cases.length > 1) {
      t.push(`${n("plural")}([`), t.indent(r());
      const i = e.cases.length;
      for (let s = 0; s < i && (Wc(t, e.cases[s]), s !== i - 1); s++) t.push(", ");
      t.deindent(r()), t.push("])");
    }
  }
  function n_(t, e) {
    e.body ? Wc(t, e.body) : t.push("null");
  }
  function Wc(t, e) {
    const { helper: n } = t;
    switch (e.type) {
      case 0:
        n_(t, e);
        break;
      case 1:
        t_(t, e);
        break;
      case 2:
        e_(t, e);
        break;
      case 6:
        $P(t, e);
        break;
      case 8:
        t.push(JSON.stringify(e.value), e);
        break;
      case 7:
        t.push(JSON.stringify(e.value), e);
        break;
      case 5:
        t.push(`${n("interpolate")}(${n("list")}(${e.index}))`, e);
        break;
      case 4:
        t.push(`${n("interpolate")}(${n("named")}(${JSON.stringify(e.key)}))`, e);
        break;
      case 9:
        t.push(JSON.stringify(e.value), e);
        break;
      case 3:
        t.push(JSON.stringify(e.value), e);
        break;
      default:
        throw bl(Le.UNHANDLED_CODEGEN_NODE_TYPE, null, {
          domain: XP,
          args: [
            e.type
          ]
        });
    }
  }
  const r_ = (t, e = {}) => {
    const n = dx(e.mode) ? e.mode : "normal", r = dx(e.filename) ? e.filename : "message.intl";
    e.sourceMap;
    const i = e.breakLineCode != null ? e.breakLineCode : n === "arrow" ? ";" : `
`, s = e.needIndent ? e.needIndent : n !== "arrow", o = t.helpers || [], a = ZP(t, {
      filename: r,
      breakLineCode: i,
      needIndent: s
    });
    a.push(n === "normal" ? "function __msg__ (ctx) {" : "(ctx) => {"), a.indent(s), o.length > 0 && (a.push(`const { ${b6(o.map((u) => `${u}: _${u}`), ", ")} } = ctx`), a.newline()), a.push("return "), Wc(a, t), a.deindent(s), a.push("}"), delete t.helpers;
    const { code: c, map: l } = a.context();
    return {
      ast: t,
      code: c,
      map: l ? l.toJSON() : void 0
    };
  };
  function i_(t, e = {}) {
    const n = y6({}, e), r = !!n.jit, i = !!n.minify, s = n.optimize == null ? true : n.optimize, a = JP(n).parse(t);
    return r ? (s && qP(a), i && lc(a), {
      ast: a,
      code: ""
    }) : (WP(a, n), r_(a, n));
  }
  function s_() {
    typeof __INTLIFY_PROD_DEVTOOLS__ != "boolean" && (Cs().__INTLIFY_PROD_DEVTOOLS__ = false), typeof __INTLIFY_JIT_COMPILATION__ != "boolean" && (Cs().__INTLIFY_JIT_COMPILATION__ = false), typeof __INTLIFY_DROP_MESSAGE_COMPILER__ != "boolean" && (Cs().__INTLIFY_DROP_MESSAGE_COMPILER__ = false);
  }
  function Wi(t) {
    return ut(t) && z1(t) === 0 && (mi(t, "b") || mi(t, "body"));
  }
  const x6 = [
    "b",
    "body"
  ];
  function o_(t) {
    return ko(t, x6);
  }
  const A6 = [
    "c",
    "cases"
  ];
  function a_(t) {
    return ko(t, A6, []);
  }
  const w6 = [
    "s",
    "static"
  ];
  function c_(t) {
    return ko(t, w6);
  }
  const v6 = [
    "i",
    "items"
  ];
  function l_(t) {
    return ko(t, v6, []);
  }
  const E6 = [
    "t",
    "type"
  ];
  function z1(t) {
    return ko(t, E6);
  }
  const S6 = [
    "v",
    "value"
  ];
  function Uf(t, e) {
    const n = ko(t, S6);
    if (n != null) return n;
    throw Ou(e);
  }
  const T6 = [
    "m",
    "modifier"
  ];
  function u_(t) {
    return ko(t, T6);
  }
  const C6 = [
    "k",
    "key"
  ];
  function f_(t) {
    const e = ko(t, C6);
    if (e) return e;
    throw Ou(6);
  }
  function ko(t, e, n) {
    for (let r = 0; r < e.length; r++) {
      const i = e[r];
      if (mi(t, i) && t[i] != null) return t[i];
    }
    return n;
  }
  const I6 = [
    ...x6,
    ...A6,
    ...w6,
    ...v6,
    ...C6,
    ...T6,
    ...S6,
    ...E6
  ];
  function Ou(t) {
    return new Error(`unhandled node type: ${t}`);
  }
  const Fo = [];
  Fo[0] = {
    w: [
      0
    ],
    i: [
      3,
      0
    ],
    "[": [
      4
    ],
    o: [
      7
    ]
  };
  Fo[1] = {
    w: [
      1
    ],
    ".": [
      2
    ],
    "[": [
      4
    ],
    o: [
      7
    ]
  };
  Fo[2] = {
    w: [
      2
    ],
    i: [
      3,
      0
    ],
    0: [
      3,
      0
    ]
  };
  Fo[3] = {
    i: [
      3,
      0
    ],
    0: [
      3,
      0
    ],
    w: [
      1,
      1
    ],
    ".": [
      2,
      1
    ],
    "[": [
      4,
      1
    ],
    o: [
      7,
      1
    ]
  };
  Fo[4] = {
    "'": [
      5,
      0
    ],
    '"': [
      6,
      0
    ],
    "[": [
      4,
      2
    ],
    "]": [
      1,
      3
    ],
    o: 8,
    l: [
      4,
      0
    ]
  };
  Fo[5] = {
    "'": [
      4,
      0
    ],
    o: 8,
    l: [
      5,
      0
    ]
  };
  Fo[6] = {
    '"': [
      4,
      0
    ],
    o: 8,
    l: [
      6,
      0
    ]
  };
  const d_ = /^\s?(?:true|false|-?[\d.]+|'[^']*'|"[^"]*")\s?$/;
  function h_(t) {
    return d_.test(t);
  }
  function p_(t) {
    const e = t.charCodeAt(0), n = t.charCodeAt(t.length - 1);
    return e === n && (e === 34 || e === 39) ? t.slice(1, -1) : t;
  }
  function g_(t) {
    if (t == null) return "o";
    switch (t.charCodeAt(0)) {
      case 91:
      case 93:
      case 46:
      case 34:
      case 39:
        return t;
      case 95:
      case 36:
      case 45:
        return "i";
      case 9:
      case 10:
      case 13:
      case 160:
      case 65279:
      case 8232:
      case 8233:
        return "w";
    }
    return "i";
  }
  function m_(t) {
    const e = t.trim();
    return t.charAt(0) === "0" && isNaN(parseInt(t)) ? false : h_(e) ? p_(e) : "*" + e;
  }
  function y_(t) {
    const e = [];
    let n = -1, r = 0, i = 0, s, o, a, c, l, u, f;
    const d = [];
    d[0] = () => {
      o === void 0 ? o = a : o += a;
    }, d[1] = () => {
      o !== void 0 && (e.push(o), o = void 0);
    }, d[2] = () => {
      d[0](), i++;
    }, d[3] = () => {
      if (i > 0) i--, r = 4, d[0]();
      else {
        if (i = 0, o === void 0 || (o = m_(o), o === false)) return false;
        d[1]();
      }
    };
    function m() {
      const y = t[n + 1];
      if (r === 5 && y === "'" || r === 6 && y === '"') return n++, a = "\\" + y, d[0](), true;
    }
    for (; r !== null; ) if (n++, s = t[n], !(s === "\\" && m())) {
      if (c = g_(s), f = Fo[r], l = f[c] || f.l || 8, l === 8 || (r = l[0], l[1] !== void 0 && (u = d[l[1]], u && (a = s, u() === false)))) return;
      if (r === 7) return e;
    }
  }
  const mx = /* @__PURE__ */ new Map();
  function b_(t, e) {
    return ut(t) ? t[e] : null;
  }
  function x_(t, e) {
    if (!ut(t)) return null;
    let n = mx.get(e);
    if (n || (n = y_(e), n && mx.set(e, n)), !n) return null;
    const r = n.length;
    let i = t, s = 0;
    for (; s < r; ) {
      const o = n[s];
      if (I6.includes(o) && Wi(i)) return null;
      const a = i[o];
      if (a === void 0 || wt(i)) return null;
      i = a, s++;
    }
    return i;
  }
  const A_ = (t) => t, w_ = (t) => "", v_ = "text", E_ = (t) => t.length === 0 ? "" : IP(t), S_ = CP;
  function yx(t, e) {
    return t = Math.abs(t), e === 2 ? t ? t > 1 ? 1 : 0 : 1 : t ? Math.min(t, 2) : 0;
  }
  function T_(t) {
    const e = fn(t.pluralIndex) ? t.pluralIndex : -1;
    return t.named && (fn(t.named.count) || fn(t.named.n)) ? fn(t.named.count) ? t.named.count : fn(t.named.n) ? t.named.n : e : e;
  }
  function C_(t, e) {
    e.count || (e.count = t), e.n || (e.n = t);
  }
  function I_(t = {}) {
    const e = t.locale, n = T_(t), r = ut(t.pluralRules) && Ce(e) && wt(t.pluralRules[e]) ? t.pluralRules[e] : yx, i = ut(t.pluralRules) && Ce(e) && wt(t.pluralRules[e]) ? yx : void 0, s = (R) => R[r(n, R.length, i)], o = t.list || [], a = (R) => o[R], c = t.named || yt();
    fn(t.pluralIndex) && C_(n, c);
    const l = (R) => c[R];
    function u(R) {
      const O = wt(t.messages) ? t.messages(R) : ut(t.messages) ? t.messages[R] : false;
      return O || (t.parent ? t.parent.message(R) : w_);
    }
    const f = (R) => t.modifiers ? t.modifiers[R] : A_, d = Ue(t.processor) && wt(t.processor.normalize) ? t.processor.normalize : E_, m = Ue(t.processor) && wt(t.processor.interpolate) ? t.processor.interpolate : S_, y = Ue(t.processor) && Ce(t.processor.type) ? t.processor.type : v_, w = {
      list: a,
      named: l,
      plural: s,
      linked: (R, ...O) => {
        const [B, M] = O;
        let D = "text", H = "";
        O.length === 1 ? ut(B) ? (H = B.modifier || H, D = B.type || D) : Ce(B) && (H = B || H) : O.length === 2 && (Ce(B) && (H = B || H), Ce(M) && (D = M || D));
        const q = u(R)(w), S = D === "vnode" && Vt(q) && H ? q[0] : q;
        return H ? f(H)(S, D) : S;
      },
      message: u,
      type: y,
      interpolate: m,
      normalize: d,
      values: Hn(yt(), o, c)
    };
    return w;
  }
  let Bu = null;
  function P_(t) {
    Bu = t;
  }
  function __(t, e, n) {
    Bu && Bu.emit("i18n:init", {
      timestamp: Date.now(),
      i18n: t,
      version: e,
      meta: n
    });
  }
  const R_ = N_("function:translate");
  function N_(t) {
    return (e) => Bu && Bu.emit(t, e);
  }
  const O_ = G1.__EXTEND_POINT__, ta = Dd(O_), B_ = {
    FALLBACK_TO_TRANSLATE: ta(),
    CANNOT_FORMAT_NUMBER: ta(),
    FALLBACK_TO_NUMBER_FORMAT: ta(),
    CANNOT_FORMAT_DATE: ta(),
    FALLBACK_TO_DATE_FORMAT: ta(),
    EXPERIMENTAL_CUSTOM_MESSAGE_COMPILER: ta(),
    __EXTEND_POINT__: ta()
  }, P6 = Le.__EXTEND_POINT__, na = Dd(P6), yi = {
    INVALID_ARGUMENT: P6,
    INVALID_DATE_ARGUMENT: na(),
    INVALID_ISO_DATE_ARGUMENT: na(),
    NOT_SUPPORT_NON_STRING_MESSAGE: na(),
    NOT_SUPPORT_LOCALE_PROMISE_VALUE: na(),
    NOT_SUPPORT_LOCALE_ASYNC_FUNCTION: na(),
    NOT_SUPPORT_LOCALE_TYPE: na(),
    __EXTEND_POINT__: na()
  };
  function Qi(t) {
    return bl(t, null, void 0);
  }
  function Q1(t, e) {
    return e.locale != null ? bx(e.locale) : bx(t.locale);
  }
  let bp;
  function bx(t) {
    if (Ce(t)) return t;
    if (wt(t)) {
      if (t.resolvedOnce && bp != null) return bp;
      if (t.constructor.name === "Function") {
        const e = t();
        if (TP(e)) throw Qi(yi.NOT_SUPPORT_LOCALE_PROMISE_VALUE);
        return bp = e;
      } else throw Qi(yi.NOT_SUPPORT_LOCALE_ASYNC_FUNCTION);
    } else throw Qi(yi.NOT_SUPPORT_LOCALE_TYPE);
  }
  function M_(t, e, n) {
    return [
      .../* @__PURE__ */ new Set([
        n,
        ...Vt(e) ? e : ut(e) ? Object.keys(e) : Ce(e) ? [
          e
        ] : [
          n
        ]
      ])
    ];
  }
  function _6(t, e, n) {
    const r = Ce(n) ? n : qc, i = t;
    i.__localeChainCache || (i.__localeChainCache = /* @__PURE__ */ new Map());
    let s = i.__localeChainCache.get(r);
    if (!s) {
      s = [];
      let o = [
        n
      ];
      for (; Vt(o); ) o = xx(s, o, e);
      const a = Vt(e) || !Ue(e) ? e : e.default ? e.default : null;
      o = Ce(a) ? [
        a
      ] : a, Vt(o) && xx(s, o, false), i.__localeChainCache.set(r, s);
    }
    return s;
  }
  function xx(t, e, n) {
    let r = true;
    for (let i = 0; i < e.length && Ye(r); i++) {
      const s = e[i];
      Ce(s) && (r = k_(t, e[i], n));
    }
    return r;
  }
  function k_(t, e, n) {
    let r;
    const i = e.split("-");
    do {
      const s = i.join("-");
      r = F_(t, s, n), i.splice(-1, 1);
    } while (i.length && r === true);
    return r;
  }
  function F_(t, e, n) {
    let r = false;
    if (!t.includes(e) && (r = true, e)) {
      r = e[e.length - 1] !== "!";
      const i = e.replace(/!/g, "");
      t.push(i), (Vt(n) || Ue(n)) && n[i] && (r = n[i]);
    }
    return r;
  }
  const L_ = "9.14.4", Ud = -1, qc = "en-US", Ax = "", wx = (t) => `${t.charAt(0).toLocaleUpperCase()}${t.substr(1)}`;
  function D_() {
    return {
      upper: (t, e) => e === "text" && Ce(t) ? t.toUpperCase() : e === "vnode" && ut(t) && "__v_isVNode" in t ? t.children.toUpperCase() : t,
      lower: (t, e) => e === "text" && Ce(t) ? t.toLowerCase() : e === "vnode" && ut(t) && "__v_isVNode" in t ? t.children.toLowerCase() : t,
      capitalize: (t, e) => e === "text" && Ce(t) ? wx(t) : e === "vnode" && ut(t) && "__v_isVNode" in t ? wx(t.children) : t
    };
  }
  let R6;
  function vx(t) {
    R6 = t;
  }
  let N6;
  function U_(t) {
    N6 = t;
  }
  let O6;
  function H_(t) {
    O6 = t;
  }
  let B6 = null;
  const G_ = (t) => {
    B6 = t;
  }, V_ = () => B6;
  let M6 = null;
  const Ex = (t) => {
    M6 = t;
  }, z_ = () => M6;
  let Sx = 0;
  function Q_(t = {}) {
    const e = wt(t.onWarn) ? t.onWarn : PP, n = Ce(t.version) ? t.version : L_, r = Ce(t.locale) || wt(t.locale) ? t.locale : qc, i = wt(r) ? qc : r, s = Vt(t.fallbackLocale) || Ue(t.fallbackLocale) || Ce(t.fallbackLocale) || t.fallbackLocale === false ? t.fallbackLocale : i, o = Ue(t.messages) ? t.messages : xp(i), a = Ue(t.datetimeFormats) ? t.datetimeFormats : xp(i), c = Ue(t.numberFormats) ? t.numberFormats : xp(i), l = Hn(yt(), t.modifiers, D_()), u = t.pluralRules || yt(), f = wt(t.missing) ? t.missing : null, d = Ye(t.missingWarn) || Ro(t.missingWarn) ? t.missingWarn : true, m = Ye(t.fallbackWarn) || Ro(t.fallbackWarn) ? t.fallbackWarn : true, y = !!t.fallbackFormat, x = !!t.unresolving, w = wt(t.postTranslation) ? t.postTranslation : null, R = Ue(t.processor) ? t.processor : null, O = Ye(t.warnHtmlMessage) ? t.warnHtmlMessage : true, B = !!t.escapeParameter, M = wt(t.messageCompiler) ? t.messageCompiler : R6, D = wt(t.messageResolver) ? t.messageResolver : N6 || b_, H = wt(t.localeFallbacker) ? t.localeFallbacker : O6 || M_, q = ut(t.fallbackContext) ? t.fallbackContext : void 0, S = t, P = ut(S.__datetimeFormatters) ? S.__datetimeFormatters : /* @__PURE__ */ new Map(), L = ut(S.__numberFormatters) ? S.__numberFormatters : /* @__PURE__ */ new Map(), K = ut(S.__meta) ? S.__meta : {};
    Sx++;
    const z = {
      version: n,
      cid: Sx,
      locale: r,
      fallbackLocale: s,
      messages: o,
      modifiers: l,
      pluralRules: u,
      missing: f,
      missingWarn: d,
      fallbackWarn: m,
      fallbackFormat: y,
      unresolving: x,
      postTranslation: w,
      processor: R,
      warnHtmlMessage: O,
      escapeParameter: B,
      messageCompiler: M,
      messageResolver: D,
      localeFallbacker: H,
      fallbackContext: q,
      onWarn: e,
      __meta: K
    };
    return z.datetimeFormats = a, z.numberFormats = c, z.__datetimeFormatters = P, z.__numberFormatters = L, __INTLIFY_PROD_DEVTOOLS__ && __(z, n, K), z;
  }
  const xp = (t) => ({
    [t]: yt()
  });
  function j1(t, e, n, r, i) {
    const { missing: s, onWarn: o } = t;
    if (s !== null) {
      const a = s(t, n, e, i);
      return Ce(a) ? a : e;
    } else return e;
  }
  function Dl(t, e, n) {
    const r = t;
    r.__localeChainCache = /* @__PURE__ */ new Map(), t.localeFallbacker(t, n, e);
  }
  function j_(t, e) {
    return t === e ? false : t.split("-")[0] === e.split("-")[0];
  }
  function J_(t, e) {
    const n = e.indexOf(t);
    if (n === -1) return false;
    for (let r = n + 1; r < e.length; r++) if (j_(t, e[r])) return true;
    return false;
  }
  function Ap(t) {
    return (n) => K_(n, t);
  }
  function K_(t, e) {
    const n = o_(e);
    if (n == null) throw Ou(0);
    if (z1(n) === 1) {
      const s = a_(n);
      return t.plural(s.reduce((o, a) => [
        ...o,
        Tx(t, a)
      ], []));
    } else return Tx(t, n);
  }
  function Tx(t, e) {
    const n = c_(e);
    if (n != null) return t.type === "text" ? n : t.normalize([
      n
    ]);
    {
      const r = l_(e).reduce((i, s) => [
        ...i,
        Xg(t, s)
      ], []);
      return t.normalize(r);
    }
  }
  function Xg(t, e) {
    const n = z1(e);
    switch (n) {
      case 3:
        return Uf(e, n);
      case 9:
        return Uf(e, n);
      case 4: {
        const r = e;
        if (mi(r, "k") && r.k) return t.interpolate(t.named(r.k));
        if (mi(r, "key") && r.key) return t.interpolate(t.named(r.key));
        throw Ou(n);
      }
      case 5: {
        const r = e;
        if (mi(r, "i") && fn(r.i)) return t.interpolate(t.list(r.i));
        if (mi(r, "index") && fn(r.index)) return t.interpolate(t.list(r.index));
        throw Ou(n);
      }
      case 6: {
        const r = e, i = u_(r), s = f_(r);
        return t.linked(Xg(t, s), i ? Xg(t, i) : void 0, t.type);
      }
      case 7:
        return Uf(e, n);
      case 8:
        return Uf(e, n);
      default:
        throw new Error(`unhandled node on format message part: ${n}`);
    }
  }
  const k6 = (t) => t;
  let wc = yt();
  function F6(t, e = {}) {
    let n = false;
    const r = e.onError || kP;
    return e.onError = (i) => {
      n = true, r(i);
    }, {
      ...i_(t, e),
      detectError: n
    };
  }
  const W_ = (t, e) => {
    if (!Ce(t)) throw Qi(yi.NOT_SUPPORT_NON_STRING_MESSAGE);
    {
      Ye(e.warnHtmlMessage) && e.warnHtmlMessage;
      const r = (e.onCacheKey || k6)(t), i = wc[r];
      if (i) return i;
      const { code: s, detectError: o } = F6(t, e), a = new Function(`return ${s}`)();
      return o ? a : wc[r] = a;
    }
  };
  function q_(t, e) {
    if (__INTLIFY_JIT_COMPILATION__ && !__INTLIFY_DROP_MESSAGE_COMPILER__ && Ce(t)) {
      Ye(e.warnHtmlMessage) && e.warnHtmlMessage;
      const r = (e.onCacheKey || k6)(t), i = wc[r];
      if (i) return i;
      const { ast: s, detectError: o } = F6(t, {
        ...e,
        location: false,
        jit: true
      }), a = Ap(s);
      return o ? a : wc[r] = a;
    } else {
      const n = t.cacheKey;
      if (n) {
        const r = wc[n];
        return r || (wc[n] = Ap(t));
      } else return Ap(t);
    }
  }
  const Cx = () => "", zr = (t) => wt(t);
  function Ix(t, ...e) {
    const { fallbackFormat: n, postTranslation: r, unresolving: i, messageCompiler: s, fallbackLocale: o, messages: a } = t, [c, l] = Zg(...e), u = Ye(l.missingWarn) ? l.missingWarn : t.missingWarn, f = Ye(l.fallbackWarn) ? l.fallbackWarn : t.fallbackWarn, d = Ye(l.escapeParameter) ? l.escapeParameter : t.escapeParameter, m = !!l.resolvedMessage, y = Ce(l.default) || Ye(l.default) ? Ye(l.default) ? s ? c : () => c : l.default : n ? s ? c : () => c : "", x = n || y !== "", w = Q1(t, l);
    d && Y_(l);
    let [R, O, B] = m ? [
      c,
      w,
      a[w] || yt()
    ] : L6(t, c, w, o, f, u), M = R, D = c;
    if (!m && !(Ce(M) || Wi(M) || zr(M)) && x && (M = y, D = M), !m && (!(Ce(M) || Wi(M) || zr(M)) || !Ce(O))) return i ? Ud : c;
    let H = false;
    const q = () => {
      H = true;
    }, S = zr(M) ? M : D6(t, c, O, M, D, q);
    if (H) return M;
    const P = $_(t, O, B, l), L = I_(P), K = X_(t, S, L), z = r ? r(K, c) : K;
    if (__INTLIFY_PROD_DEVTOOLS__) {
      const I = {
        timestamp: Date.now(),
        key: Ce(c) ? c : zr(M) ? M.key : "",
        locale: O || (zr(M) ? M.locale : ""),
        format: Ce(M) ? M : zr(M) ? M.source : "",
        message: z
      };
      I.meta = Hn({}, t.__meta, V_() || {}), R_(I);
    }
    return z;
  }
  function Y_(t) {
    Vt(t.list) ? t.list = t.list.map((e) => Ce(e) ? fx(e) : e) : ut(t.named) && Object.keys(t.named).forEach((e) => {
      Ce(t.named[e]) && (t.named[e] = fx(t.named[e]));
    });
  }
  function L6(t, e, n, r, i, s) {
    const { messages: o, onWarn: a, messageResolver: c, localeFallbacker: l } = t, u = l(t, r, n);
    let f = yt(), d, m = null;
    const y = "translate";
    for (let x = 0; x < u.length && (d = u[x], f = o[d] || yt(), (m = c(f, e)) === null && (m = f[e]), !(Ce(m) || Wi(m) || zr(m))); x++) if (!J_(d, u)) {
      const w = j1(t, e, d, s, y);
      w !== e && (m = w);
    }
    return [
      m,
      d,
      f
    ];
  }
  function D6(t, e, n, r, i, s) {
    const { messageCompiler: o, warnHtmlMessage: a } = t;
    if (zr(r)) {
      const l = r;
      return l.locale = l.locale || n, l.key = l.key || e, l;
    }
    if (o == null) {
      const l = () => r;
      return l.locale = n, l.key = e, l;
    }
    const c = o(r, Z_(t, n, i, r, a, s));
    return c.locale = n, c.key = e, c.source = r, c;
  }
  function X_(t, e, n) {
    return e(n);
  }
  function Zg(...t) {
    const [e, n, r] = t, i = yt();
    if (!Ce(e) && !fn(e) && !zr(e) && !Wi(e)) throw Qi(yi.INVALID_ARGUMENT);
    const s = fn(e) ? String(e) : (zr(e), e);
    return fn(n) ? i.plural = n : Ce(n) ? i.default = n : Ue(n) && !Ld(n) ? i.named = n : Vt(n) && (i.list = n), fn(r) ? i.plural = r : Ce(r) ? i.default = r : Ue(r) && Hn(i, r), [
      s,
      i
    ];
  }
  function Z_(t, e, n, r, i, s) {
    return {
      locale: e,
      key: n,
      warnHtmlMessage: i,
      onError: (o) => {
        throw s && s(o), o;
      },
      onCacheKey: (o) => AP(e, n, o)
    };
  }
  function $_(t, e, n, r) {
    const { modifiers: i, pluralRules: s, messageResolver: o, fallbackLocale: a, fallbackWarn: c, missingWarn: l, fallbackContext: u } = t, d = {
      locale: e,
      modifiers: i,
      pluralRules: s,
      messages: (m) => {
        let y = o(n, m);
        if (y == null && u) {
          const [, , x] = L6(u, m, e, a, c, l);
          y = o(x, m);
        }
        if (Ce(y) || Wi(y)) {
          let x = false;
          const R = D6(t, m, e, y, m, () => {
            x = true;
          });
          return x ? Cx : R;
        } else return zr(y) ? y : Cx;
      }
    };
    return t.processor && (d.processor = t.processor), r.list && (d.list = r.list), r.named && (d.named = r.named), fn(r.plural) && (d.pluralIndex = r.plural), d;
  }
  function Px(t, ...e) {
    const { datetimeFormats: n, unresolving: r, fallbackLocale: i, onWarn: s, localeFallbacker: o } = t, { __datetimeFormatters: a } = t, [c, l, u, f] = $g(...e), d = Ye(u.missingWarn) ? u.missingWarn : t.missingWarn;
    Ye(u.fallbackWarn) ? u.fallbackWarn : t.fallbackWarn;
    const m = !!u.part, y = Q1(t, u), x = o(t, i, y);
    if (!Ce(c) || c === "") return new Intl.DateTimeFormat(y, f).format(l);
    let w = {}, R, O = null;
    const B = "datetime format";
    for (let H = 0; H < x.length && (R = x[H], w = n[R] || {}, O = w[c], !Ue(O)); H++) j1(t, c, R, d, B);
    if (!Ue(O) || !Ce(R)) return r ? Ud : c;
    let M = `${R}__${c}`;
    Ld(f) || (M = `${M}__${JSON.stringify(f)}`);
    let D = a.get(M);
    return D || (D = new Intl.DateTimeFormat(R, Hn({}, O, f)), a.set(M, D)), m ? D.formatToParts(l) : D.format(l);
  }
  const U6 = [
    "localeMatcher",
    "weekday",
    "era",
    "year",
    "month",
    "day",
    "hour",
    "minute",
    "second",
    "timeZoneName",
    "formatMatcher",
    "hour12",
    "timeZone",
    "dateStyle",
    "timeStyle",
    "calendar",
    "dayPeriod",
    "numberingSystem",
    "hourCycle",
    "fractionalSecondDigits"
  ];
  function $g(...t) {
    const [e, n, r, i] = t, s = yt();
    let o = yt(), a;
    if (Ce(e)) {
      const c = e.match(/(\d{4}-\d{2}-\d{2})(T|\s)?(.*)/);
      if (!c) throw Qi(yi.INVALID_ISO_DATE_ARGUMENT);
      const l = c[3] ? c[3].trim().startsWith("T") ? `${c[1].trim()}${c[3].trim()}` : `${c[1].trim()}T${c[3].trim()}` : c[1].trim();
      a = new Date(l);
      try {
        a.toISOString();
      } catch {
        throw Qi(yi.INVALID_ISO_DATE_ARGUMENT);
      }
    } else if (vP(e)) {
      if (isNaN(e.getTime())) throw Qi(yi.INVALID_DATE_ARGUMENT);
      a = e;
    } else if (fn(e)) a = e;
    else throw Qi(yi.INVALID_ARGUMENT);
    return Ce(n) ? s.key = n : Ue(n) && Object.keys(n).forEach((c) => {
      U6.includes(c) ? o[c] = n[c] : s[c] = n[c];
    }), Ce(r) ? s.locale = r : Ue(r) && (o = r), Ue(i) && (o = i), [
      s.key || "",
      a,
      s,
      o
    ];
  }
  function _x(t, e, n) {
    const r = t;
    for (const i in n) {
      const s = `${e}__${i}`;
      r.__datetimeFormatters.has(s) && r.__datetimeFormatters.delete(s);
    }
  }
  function Rx(t, ...e) {
    const { numberFormats: n, unresolving: r, fallbackLocale: i, onWarn: s, localeFallbacker: o } = t, { __numberFormatters: a } = t, [c, l, u, f] = em(...e), d = Ye(u.missingWarn) ? u.missingWarn : t.missingWarn;
    Ye(u.fallbackWarn) ? u.fallbackWarn : t.fallbackWarn;
    const m = !!u.part, y = Q1(t, u), x = o(t, i, y);
    if (!Ce(c) || c === "") return new Intl.NumberFormat(y, f).format(l);
    let w = {}, R, O = null;
    const B = "number format";
    for (let H = 0; H < x.length && (R = x[H], w = n[R] || {}, O = w[c], !Ue(O)); H++) j1(t, c, R, d, B);
    if (!Ue(O) || !Ce(R)) return r ? Ud : c;
    let M = `${R}__${c}`;
    Ld(f) || (M = `${M}__${JSON.stringify(f)}`);
    let D = a.get(M);
    return D || (D = new Intl.NumberFormat(R, Hn({}, O, f)), a.set(M, D)), m ? D.formatToParts(l) : D.format(l);
  }
  const H6 = [
    "localeMatcher",
    "style",
    "currency",
    "currencyDisplay",
    "currencySign",
    "useGrouping",
    "minimumIntegerDigits",
    "minimumFractionDigits",
    "maximumFractionDigits",
    "minimumSignificantDigits",
    "maximumSignificantDigits",
    "compactDisplay",
    "notation",
    "signDisplay",
    "unit",
    "unitDisplay",
    "roundingMode",
    "roundingPriority",
    "roundingIncrement",
    "trailingZeroDisplay"
  ];
  function em(...t) {
    const [e, n, r, i] = t, s = yt();
    let o = yt();
    if (!fn(e)) throw Qi(yi.INVALID_ARGUMENT);
    const a = e;
    return Ce(n) ? s.key = n : Ue(n) && Object.keys(n).forEach((c) => {
      H6.includes(c) ? o[c] = n[c] : s[c] = n[c];
    }), Ce(r) ? s.locale = r : Ue(r) && (o = r), Ue(i) && (o = i), [
      s.key || "",
      a,
      s,
      o
    ];
  }
  function Nx(t, e, n) {
    const r = t;
    for (const i in n) {
      const s = `${e}__${i}`;
      r.__numberFormatters.has(s) && r.__numberFormatters.delete(s);
    }
  }
  s_();
  const eR = "9.14.4";
  function tR() {
    typeof __VUE_I18N_FULL_INSTALL__ != "boolean" && (Cs().__VUE_I18N_FULL_INSTALL__ = true), typeof __VUE_I18N_LEGACY_API__ != "boolean" && (Cs().__VUE_I18N_LEGACY_API__ = true), typeof __INTLIFY_JIT_COMPILATION__ != "boolean" && (Cs().__INTLIFY_JIT_COMPILATION__ = false), typeof __INTLIFY_DROP_MESSAGE_COMPILER__ != "boolean" && (Cs().__INTLIFY_DROP_MESSAGE_COMPILER__ = false), typeof __INTLIFY_PROD_DEVTOOLS__ != "boolean" && (Cs().__INTLIFY_PROD_DEVTOOLS__ = false);
  }
  const nR = B_.__EXTEND_POINT__, gs = Dd(nR);
  gs(), gs(), gs(), gs(), gs(), gs(), gs(), gs(), gs();
  const G6 = yi.__EXTEND_POINT__, lr = Dd(G6), Sn = {
    UNEXPECTED_RETURN_TYPE: G6,
    INVALID_ARGUMENT: lr(),
    MUST_BE_CALL_SETUP_TOP: lr(),
    NOT_INSTALLED: lr(),
    NOT_AVAILABLE_IN_LEGACY_MODE: lr(),
    REQUIRED_VALUE: lr(),
    INVALID_VALUE: lr(),
    CANNOT_SETUP_VUE_DEVTOOLS_PLUGIN: lr(),
    NOT_INSTALLED_WITH_PROVIDE: lr(),
    UNEXPECTED_ERROR: lr(),
    NOT_COMPATIBLE_LEGACY_VUE_I18N: lr(),
    BRIDGE_SUPPORT_VUE_2_ONLY: lr(),
    MUST_DEFINE_I18N_OPTION_IN_ALLOW_COMPOSITION: lr(),
    NOT_AVAILABLE_COMPOSITION_IN_LEGACY: lr(),
    __EXTEND_POINT__: lr()
  };
  function Rn(t, ...e) {
    return bl(t, null, void 0);
  }
  const tm = Mo("__translateVNode"), nm = Mo("__datetimeParts"), rm = Mo("__numberParts"), V6 = Mo("__setPluralRules"), z6 = Mo("__injectWithOption"), im = Mo("__dispose");
  function Mu(t) {
    if (!ut(t) || Wi(t)) return t;
    for (const e in t) if (mi(t, e)) if (!e.includes(".")) ut(t[e]) && Mu(t[e]);
    else {
      const n = e.split("."), r = n.length - 1;
      let i = t, s = false;
      for (let o = 0; o < r; o++) {
        if (n[o] === "__proto__") throw new Error(`unsafe key: ${n[o]}`);
        if (n[o] in i || (i[n[o]] = yt()), !ut(i[n[o]])) {
          s = true;
          break;
        }
        i = i[n[o]];
      }
      if (s || (Wi(i) ? I6.includes(n[r]) || delete t[e] : (i[n[r]] = t[e], delete t[e])), !Wi(i)) {
        const o = i[n[r]];
        ut(o) && Mu(o);
      }
    }
    return t;
  }
  function Hd(t, e) {
    const { messages: n, __i18n: r, messageResolver: i, flatJson: s } = e, o = Ue(n) ? n : Vt(r) ? yt() : {
      [t]: yt()
    };
    if (Vt(r) && r.forEach((a) => {
      if ("locale" in a && "resource" in a) {
        const { locale: c, resource: l } = a;
        c ? (o[c] = o[c] || yt(), u0(l, o[c])) : u0(l, o);
      } else Ce(a) && u0(JSON.parse(a), o);
    }), i == null && s) for (const a in o) mi(o, a) && Mu(o[a]);
    return o;
  }
  function Q6(t) {
    return t.type;
  }
  function j6(t, e, n) {
    let r = ut(e.messages) ? e.messages : yt();
    "__i18nGlobal" in n && (r = Hd(t.locale.value, {
      messages: r,
      __i18n: n.__i18nGlobal
    }));
    const i = Object.keys(r);
    i.length && i.forEach((s) => {
      t.mergeLocaleMessage(s, r[s]);
    });
    {
      if (ut(e.datetimeFormats)) {
        const s = Object.keys(e.datetimeFormats);
        s.length && s.forEach((o) => {
          t.mergeDateTimeFormat(o, e.datetimeFormats[o]);
        });
      }
      if (ut(e.numberFormats)) {
        const s = Object.keys(e.numberFormats);
        s.length && s.forEach((o) => {
          t.mergeNumberFormat(o, e.numberFormats[o]);
        });
      }
    }
  }
  function Ox(t) {
    return Te(rf, null, t, 0);
  }
  const Bx = "__INTLIFY_META__", Mx = () => [], rR = () => false;
  let kx = 0;
  function Fx(t) {
    return (e, n, r, i) => t(n, r, xr() || void 0, i);
  }
  const iR = () => {
    const t = xr();
    let e = null;
    return t && (e = Q6(t)[Bx]) ? {
      [Bx]: e
    } : null;
  };
  function J1(t = {}, e) {
    const { __root: n, __injectWithOption: r } = t, i = n === void 0, s = t.flatJson, o = Q0 ? Ze : I1, a = !!t.translateExistCompatible;
    let c = Ye(t.inheritLocale) ? t.inheritLocale : true;
    const l = o(n && c ? n.locale.value : Ce(t.locale) ? t.locale : qc), u = o(n && c ? n.fallbackLocale.value : Ce(t.fallbackLocale) || Vt(t.fallbackLocale) || Ue(t.fallbackLocale) || t.fallbackLocale === false ? t.fallbackLocale : l.value), f = o(Hd(l.value, t)), d = o(Ue(t.datetimeFormats) ? t.datetimeFormats : {
      [l.value]: {}
    }), m = o(Ue(t.numberFormats) ? t.numberFormats : {
      [l.value]: {}
    });
    let y = n ? n.missingWarn : Ye(t.missingWarn) || Ro(t.missingWarn) ? t.missingWarn : true, x = n ? n.fallbackWarn : Ye(t.fallbackWarn) || Ro(t.fallbackWarn) ? t.fallbackWarn : true, w = n ? n.fallbackRoot : Ye(t.fallbackRoot) ? t.fallbackRoot : true, R = !!t.fallbackFormat, O = wt(t.missing) ? t.missing : null, B = wt(t.missing) ? Fx(t.missing) : null, M = wt(t.postTranslation) ? t.postTranslation : null, D = n ? n.warnHtmlMessage : Ye(t.warnHtmlMessage) ? t.warnHtmlMessage : true, H = !!t.escapeParameter;
    const q = n ? n.modifiers : Ue(t.modifiers) ? t.modifiers : {};
    let S = t.pluralRules || n && n.pluralRules, P;
    P = (() => {
      i && Ex(null);
      const ie = {
        version: eR,
        locale: l.value,
        fallbackLocale: u.value,
        messages: f.value,
        modifiers: q,
        pluralRules: S,
        missing: B === null ? void 0 : B,
        missingWarn: y,
        fallbackWarn: x,
        fallbackFormat: R,
        unresolving: true,
        postTranslation: M === null ? void 0 : M,
        warnHtmlMessage: D,
        escapeParameter: H,
        messageResolver: t.messageResolver,
        messageCompiler: t.messageCompiler,
        __meta: {
          framework: "vue"
        }
      };
      ie.datetimeFormats = d.value, ie.numberFormats = m.value, ie.__datetimeFormatters = Ue(P) ? P.__datetimeFormatters : void 0, ie.__numberFormatters = Ue(P) ? P.__numberFormatters : void 0;
      const _ = Q_(ie);
      return i && Ex(_), _;
    })(), Dl(P, l.value, u.value);
    function K() {
      return [
        l.value,
        u.value,
        f.value,
        d.value,
        m.value
      ];
    }
    const z = it({
      get: () => l.value,
      set: (ie) => {
        l.value = ie, P.locale = l.value;
      }
    }), I = it({
      get: () => u.value,
      set: (ie) => {
        u.value = ie, P.fallbackLocale = u.value, Dl(P, l.value, ie);
      }
    }), h = it(() => f.value), p = it(() => d.value), A = it(() => m.value);
    function C() {
      return wt(M) ? M : null;
    }
    function N(ie) {
      M = ie, P.postTranslation = ie;
    }
    function U() {
      return O;
    }
    function Y(ie) {
      ie !== null && (B = Fx(ie)), O = ie, P.missing = B;
    }
    const T = (ie, _, b, v, J, ne) => {
      K();
      let se;
      try {
        __INTLIFY_PROD_DEVTOOLS__, i || (P.fallbackContext = n ? z_() : void 0), se = ie(P);
      } finally {
        __INTLIFY_PROD_DEVTOOLS__, i || (P.fallbackContext = void 0);
      }
      if (b !== "translate exists" && fn(se) && se === Ud || b === "translate exists" && !se) {
        const [de, Fe] = _();
        return n && w ? v(n) : J(de);
      } else {
        if (ne(se)) return se;
        throw Rn(Sn.UNEXPECTED_RETURN_TYPE);
      }
    };
    function g(...ie) {
      return T((_) => Reflect.apply(Ix, null, [
        _,
        ...ie
      ]), () => Zg(...ie), "translate", (_) => Reflect.apply(_.t, _, [
        ...ie
      ]), (_) => _, (_) => Ce(_));
    }
    function F(...ie) {
      const [_, b, v] = ie;
      if (v && !ut(v)) throw Rn(Sn.INVALID_ARGUMENT);
      return g(_, b, Hn({
        resolvedMessage: true
      }, v || {}));
    }
    function ee(...ie) {
      return T((_) => Reflect.apply(Px, null, [
        _,
        ...ie
      ]), () => $g(...ie), "datetime format", (_) => Reflect.apply(_.d, _, [
        ...ie
      ]), () => Ax, (_) => Ce(_));
    }
    function E(...ie) {
      return T((_) => Reflect.apply(Rx, null, [
        _,
        ...ie
      ]), () => em(...ie), "number format", (_) => Reflect.apply(_.n, _, [
        ...ie
      ]), () => Ax, (_) => Ce(_));
    }
    function Z(ie) {
      return ie.map((_) => Ce(_) || fn(_) || Ye(_) ? Ox(String(_)) : _);
    }
    const X = {
      normalize: Z,
      interpolate: (ie) => ie,
      type: "vnode"
    };
    function $(...ie) {
      return T((_) => {
        let b;
        const v = _;
        try {
          v.processor = X, b = Reflect.apply(Ix, null, [
            v,
            ...ie
          ]);
        } finally {
          v.processor = null;
        }
        return b;
      }, () => Zg(...ie), "translate", (_) => _[tm](...ie), (_) => [
        Ox(_)
      ], (_) => Vt(_));
    }
    function ce(...ie) {
      return T((_) => Reflect.apply(Rx, null, [
        _,
        ...ie
      ]), () => em(...ie), "number format", (_) => _[rm](...ie), Mx, (_) => Ce(_) || Vt(_));
    }
    function fe(...ie) {
      return T((_) => Reflect.apply(Px, null, [
        _,
        ...ie
      ]), () => $g(...ie), "datetime format", (_) => _[nm](...ie), Mx, (_) => Ce(_) || Vt(_));
    }
    function G(ie) {
      S = ie, P.pluralRules = S;
    }
    function W(ie, _) {
      return T(() => {
        if (!ie) return false;
        const b = Ce(_) ? _ : l.value, v = pe(b), J = P.messageResolver(v, ie);
        return a ? J != null : Wi(J) || zr(J) || Ce(J);
      }, () => [
        ie
      ], "translate exists", (b) => Reflect.apply(b.te, b, [
        ie,
        _
      ]), rR, (b) => Ye(b));
    }
    function V(ie) {
      let _ = null;
      const b = _6(P, u.value, l.value);
      for (let v = 0; v < b.length; v++) {
        const J = f.value[b[v]] || {}, ne = P.messageResolver(J, ie);
        if (ne != null) {
          _ = ne;
          break;
        }
      }
      return _;
    }
    function te(ie) {
      const _ = V(ie);
      return _ ?? (n ? n.tm(ie) || {} : {});
    }
    function pe(ie) {
      return f.value[ie] || {};
    }
    function ue(ie, _) {
      if (s) {
        const b = {
          [ie]: _
        };
        for (const v in b) mi(b, v) && Mu(b[v]);
        _ = b[ie];
      }
      f.value[ie] = _, P.messages = f.value;
    }
    function ye(ie, _) {
      f.value[ie] = f.value[ie] || {};
      const b = {
        [ie]: _
      };
      if (s) for (const v in b) mi(b, v) && Mu(b[v]);
      _ = b[ie], u0(_, f.value[ie]), P.messages = f.value;
    }
    function we(ie) {
      return d.value[ie] || {};
    }
    function Q(ie, _) {
      d.value[ie] = _, P.datetimeFormats = d.value, _x(P, ie, _);
    }
    function j(ie, _) {
      d.value[ie] = Hn(d.value[ie] || {}, _), P.datetimeFormats = d.value, _x(P, ie, _);
    }
    function ae(ie) {
      return m.value[ie] || {};
    }
    function le(ie, _) {
      m.value[ie] = _, P.numberFormats = m.value, Nx(P, ie, _);
    }
    function be(ie, _) {
      m.value[ie] = Hn(m.value[ie] || {}, _), P.numberFormats = m.value, Nx(P, ie, _);
    }
    kx++, n && Q0 && (xn(n.locale, (ie) => {
      c && (l.value = ie, P.locale = ie, Dl(P, l.value, u.value));
    }), xn(n.fallbackLocale, (ie) => {
      c && (u.value = ie, P.fallbackLocale = ie, Dl(P, l.value, u.value));
    }));
    const xe = {
      id: kx,
      locale: z,
      fallbackLocale: I,
      get inheritLocale() {
        return c;
      },
      set inheritLocale(ie) {
        c = ie, ie && n && (l.value = n.locale.value, u.value = n.fallbackLocale.value, Dl(P, l.value, u.value));
      },
      get availableLocales() {
        return Object.keys(f.value).sort();
      },
      messages: h,
      get modifiers() {
        return q;
      },
      get pluralRules() {
        return S || {};
      },
      get isGlobal() {
        return i;
      },
      get missingWarn() {
        return y;
      },
      set missingWarn(ie) {
        y = ie, P.missingWarn = y;
      },
      get fallbackWarn() {
        return x;
      },
      set fallbackWarn(ie) {
        x = ie, P.fallbackWarn = x;
      },
      get fallbackRoot() {
        return w;
      },
      set fallbackRoot(ie) {
        w = ie;
      },
      get fallbackFormat() {
        return R;
      },
      set fallbackFormat(ie) {
        R = ie, P.fallbackFormat = R;
      },
      get warnHtmlMessage() {
        return D;
      },
      set warnHtmlMessage(ie) {
        D = ie, P.warnHtmlMessage = ie;
      },
      get escapeParameter() {
        return H;
      },
      set escapeParameter(ie) {
        H = ie, P.escapeParameter = ie;
      },
      t: g,
      getLocaleMessage: pe,
      setLocaleMessage: ue,
      mergeLocaleMessage: ye,
      getPostTranslationHandler: C,
      setPostTranslationHandler: N,
      getMissingHandler: U,
      setMissingHandler: Y,
      [V6]: G
    };
    return xe.datetimeFormats = p, xe.numberFormats = A, xe.rt = F, xe.te = W, xe.tm = te, xe.d = ee, xe.n = E, xe.getDateTimeFormat = we, xe.setDateTimeFormat = Q, xe.mergeDateTimeFormat = j, xe.getNumberFormat = ae, xe.setNumberFormat = le, xe.mergeNumberFormat = be, xe[z6] = r, xe[tm] = $, xe[nm] = fe, xe[rm] = ce, xe;
  }
  function sR(t) {
    const e = Ce(t.locale) ? t.locale : qc, n = Ce(t.fallbackLocale) || Vt(t.fallbackLocale) || Ue(t.fallbackLocale) || t.fallbackLocale === false ? t.fallbackLocale : e, r = wt(t.missing) ? t.missing : void 0, i = Ye(t.silentTranslationWarn) || Ro(t.silentTranslationWarn) ? !t.silentTranslationWarn : true, s = Ye(t.silentFallbackWarn) || Ro(t.silentFallbackWarn) ? !t.silentFallbackWarn : true, o = Ye(t.fallbackRoot) ? t.fallbackRoot : true, a = !!t.formatFallbackMessages, c = Ue(t.modifiers) ? t.modifiers : {}, l = t.pluralizationRules, u = wt(t.postTranslation) ? t.postTranslation : void 0, f = Ce(t.warnHtmlInMessage) ? t.warnHtmlInMessage !== "off" : true, d = !!t.escapeParameterHtml, m = Ye(t.sync) ? t.sync : true;
    let y = t.messages;
    if (Ue(t.sharedMessages)) {
      const H = t.sharedMessages;
      y = Object.keys(H).reduce((S, P) => {
        const L = S[P] || (S[P] = {});
        return Hn(L, H[P]), S;
      }, y || {});
    }
    const { __i18n: x, __root: w, __injectWithOption: R } = t, O = t.datetimeFormats, B = t.numberFormats, M = t.flatJson, D = t.translateExistCompatible;
    return {
      locale: e,
      fallbackLocale: n,
      messages: y,
      flatJson: M,
      datetimeFormats: O,
      numberFormats: B,
      missing: r,
      missingWarn: i,
      fallbackWarn: s,
      fallbackRoot: o,
      fallbackFormat: a,
      modifiers: c,
      pluralRules: l,
      postTranslation: u,
      warnHtmlMessage: f,
      escapeParameter: d,
      messageResolver: t.messageResolver,
      inheritLocale: m,
      translateExistCompatible: D,
      __i18n: x,
      __root: w,
      __injectWithOption: R
    };
  }
  function sm(t = {}, e) {
    {
      const n = J1(sR(t)), { __extender: r } = t, i = {
        id: n.id,
        get locale() {
          return n.locale.value;
        },
        set locale(s) {
          n.locale.value = s;
        },
        get fallbackLocale() {
          return n.fallbackLocale.value;
        },
        set fallbackLocale(s) {
          n.fallbackLocale.value = s;
        },
        get messages() {
          return n.messages.value;
        },
        get datetimeFormats() {
          return n.datetimeFormats.value;
        },
        get numberFormats() {
          return n.numberFormats.value;
        },
        get availableLocales() {
          return n.availableLocales;
        },
        get formatter() {
          return {
            interpolate() {
              return [];
            }
          };
        },
        set formatter(s) {
        },
        get missing() {
          return n.getMissingHandler();
        },
        set missing(s) {
          n.setMissingHandler(s);
        },
        get silentTranslationWarn() {
          return Ye(n.missingWarn) ? !n.missingWarn : n.missingWarn;
        },
        set silentTranslationWarn(s) {
          n.missingWarn = Ye(s) ? !s : s;
        },
        get silentFallbackWarn() {
          return Ye(n.fallbackWarn) ? !n.fallbackWarn : n.fallbackWarn;
        },
        set silentFallbackWarn(s) {
          n.fallbackWarn = Ye(s) ? !s : s;
        },
        get modifiers() {
          return n.modifiers;
        },
        get formatFallbackMessages() {
          return n.fallbackFormat;
        },
        set formatFallbackMessages(s) {
          n.fallbackFormat = s;
        },
        get postTranslation() {
          return n.getPostTranslationHandler();
        },
        set postTranslation(s) {
          n.setPostTranslationHandler(s);
        },
        get sync() {
          return n.inheritLocale;
        },
        set sync(s) {
          n.inheritLocale = s;
        },
        get warnHtmlInMessage() {
          return n.warnHtmlMessage ? "warn" : "off";
        },
        set warnHtmlInMessage(s) {
          n.warnHtmlMessage = s !== "off";
        },
        get escapeParameterHtml() {
          return n.escapeParameter;
        },
        set escapeParameterHtml(s) {
          n.escapeParameter = s;
        },
        get preserveDirectiveContent() {
          return true;
        },
        set preserveDirectiveContent(s) {
        },
        get pluralizationRules() {
          return n.pluralRules || {};
        },
        __composer: n,
        t(...s) {
          const [o, a, c] = s, l = {};
          let u = null, f = null;
          if (!Ce(o)) throw Rn(Sn.INVALID_ARGUMENT);
          const d = o;
          return Ce(a) ? l.locale = a : Vt(a) ? u = a : Ue(a) && (f = a), Vt(c) ? u = c : Ue(c) && (f = c), Reflect.apply(n.t, n, [
            d,
            u || f || {},
            l
          ]);
        },
        rt(...s) {
          return Reflect.apply(n.rt, n, [
            ...s
          ]);
        },
        tc(...s) {
          const [o, a, c] = s, l = {
            plural: 1
          };
          let u = null, f = null;
          if (!Ce(o)) throw Rn(Sn.INVALID_ARGUMENT);
          const d = o;
          return Ce(a) ? l.locale = a : fn(a) ? l.plural = a : Vt(a) ? u = a : Ue(a) && (f = a), Ce(c) ? l.locale = c : Vt(c) ? u = c : Ue(c) && (f = c), Reflect.apply(n.t, n, [
            d,
            u || f || {},
            l
          ]);
        },
        te(s, o) {
          return n.te(s, o);
        },
        tm(s) {
          return n.tm(s);
        },
        getLocaleMessage(s) {
          return n.getLocaleMessage(s);
        },
        setLocaleMessage(s, o) {
          n.setLocaleMessage(s, o);
        },
        mergeLocaleMessage(s, o) {
          n.mergeLocaleMessage(s, o);
        },
        d(...s) {
          return Reflect.apply(n.d, n, [
            ...s
          ]);
        },
        getDateTimeFormat(s) {
          return n.getDateTimeFormat(s);
        },
        setDateTimeFormat(s, o) {
          n.setDateTimeFormat(s, o);
        },
        mergeDateTimeFormat(s, o) {
          n.mergeDateTimeFormat(s, o);
        },
        n(...s) {
          return Reflect.apply(n.n, n, [
            ...s
          ]);
        },
        getNumberFormat(s) {
          return n.getNumberFormat(s);
        },
        setNumberFormat(s, o) {
          n.setNumberFormat(s, o);
        },
        mergeNumberFormat(s, o) {
          n.mergeNumberFormat(s, o);
        },
        getChoiceIndex(s, o) {
          return -1;
        }
      };
      return i.__extender = r, i;
    }
  }
  const K1 = {
    tag: {
      type: [
        String,
        Object
      ]
    },
    locale: {
      type: String
    },
    scope: {
      type: String,
      validator: (t) => t === "parent" || t === "global",
      default: "parent"
    },
    i18n: {
      type: Object
    }
  };
  function oR({ slots: t }, e) {
    return e.length === 1 && e[0] === "default" ? (t.default ? t.default() : []).reduce((r, i) => [
      ...r,
      ...i.type === jn ? i.children : [
        i
      ]
    ], []) : e.reduce((n, r) => {
      const i = t[r];
      return i && (n[r] = i()), n;
    }, yt());
  }
  function J6(t) {
    return jn;
  }
  const aR = Gn({
    name: "i18n-t",
    props: Hn({
      keypath: {
        type: String,
        required: true
      },
      plural: {
        type: [
          Number,
          String
        ],
        validator: (t) => fn(t) || !isNaN(t)
      }
    }, K1),
    setup(t, e) {
      const { slots: n, attrs: r } = e, i = t.i18n || W1({
        useScope: t.scope,
        __useComponent: true
      });
      return () => {
        const s = Object.keys(n).filter((f) => f !== "_"), o = yt();
        t.locale && (o.locale = t.locale), t.plural !== void 0 && (o.plural = Ce(t.plural) ? +t.plural : t.plural);
        const a = oR(e, s), c = i[tm](t.keypath, a, o), l = Hn(yt(), r), u = Ce(t.tag) || ut(t.tag) ? t.tag : J6();
        return of(u, l, c);
      };
    }
  }), Lx = aR;
  function cR(t) {
    return Vt(t) && !Ce(t[0]);
  }
  function K6(t, e, n, r) {
    const { slots: i, attrs: s } = e;
    return () => {
      const o = {
        part: true
      };
      let a = yt();
      t.locale && (o.locale = t.locale), Ce(t.format) ? o.key = t.format : ut(t.format) && (Ce(t.format.key) && (o.key = t.format.key), a = Object.keys(t.format).reduce((d, m) => n.includes(m) ? Hn(yt(), d, {
        [m]: t.format[m]
      }) : d, yt()));
      const c = r(t.value, o, a);
      let l = [
        o.key
      ];
      Vt(c) ? l = c.map((d, m) => {
        const y = i[d.type], x = y ? y({
          [d.type]: d.value,
          index: m,
          parts: c
        }) : [
          d.value
        ];
        return cR(x) && (x[0].key = `${d.type}-${m}`), x;
      }) : Ce(c) && (l = [
        c
      ]);
      const u = Hn(yt(), s), f = Ce(t.tag) || ut(t.tag) ? t.tag : J6();
      return of(f, u, l);
    };
  }
  const lR = Gn({
    name: "i18n-n",
    props: Hn({
      value: {
        type: Number,
        required: true
      },
      format: {
        type: [
          String,
          Object
        ]
      }
    }, K1),
    setup(t, e) {
      const n = t.i18n || W1({
        useScope: t.scope,
        __useComponent: true
      });
      return K6(t, e, H6, (...r) => n[rm](...r));
    }
  }), Dx = lR, uR = Gn({
    name: "i18n-d",
    props: Hn({
      value: {
        type: [
          Number,
          Date
        ],
        required: true
      },
      format: {
        type: [
          String,
          Object
        ]
      }
    }, K1),
    setup(t, e) {
      const n = t.i18n || W1({
        useScope: t.scope,
        __useComponent: true
      });
      return K6(t, e, U6, (...r) => n[nm](...r));
    }
  }), Ux = uR;
  function fR(t, e) {
    const n = t;
    if (t.mode === "composition") return n.__getInstance(e) || t.global;
    {
      const r = n.__getInstance(e);
      return r != null ? r.__composer : t.global.__composer;
    }
  }
  function dR(t) {
    const e = (o) => {
      const { instance: a, modifiers: c, value: l } = o;
      if (!a || !a.$) throw Rn(Sn.UNEXPECTED_ERROR);
      const u = fR(t, a.$), f = Hx(l);
      return [
        Reflect.apply(u.t, u, [
          ...Gx(f)
        ]),
        u
      ];
    };
    return {
      created: (o, a) => {
        const [c, l] = e(a);
        Q0 && t.global === l && (o.__i18nWatcher = xn(l.locale, () => {
          a.instance && a.instance.$forceUpdate();
        })), o.__composer = l, o.textContent = c;
      },
      unmounted: (o) => {
        Q0 && o.__i18nWatcher && (o.__i18nWatcher(), o.__i18nWatcher = void 0, delete o.__i18nWatcher), o.__composer && (o.__composer = void 0, delete o.__composer);
      },
      beforeUpdate: (o, { value: a }) => {
        if (o.__composer) {
          const c = o.__composer, l = Hx(a);
          o.textContent = Reflect.apply(c.t, c, [
            ...Gx(l)
          ]);
        }
      },
      getSSRProps: (o) => {
        const [a] = e(o);
        return {
          textContent: a
        };
      }
    };
  }
  function Hx(t) {
    if (Ce(t)) return {
      path: t
    };
    if (Ue(t)) {
      if (!("path" in t)) throw Rn(Sn.REQUIRED_VALUE, "path");
      return t;
    } else throw Rn(Sn.INVALID_VALUE);
  }
  function Gx(t) {
    const { path: e, locale: n, args: r, choice: i, plural: s } = t, o = {}, a = r || {};
    return Ce(n) && (o.locale = n), fn(i) && (o.plural = i), fn(s) && (o.plural = s), [
      e,
      a,
      o
    ];
  }
  function hR(t, e, ...n) {
    const r = Ue(n[0]) ? n[0] : {}, i = !!r.useI18nComponentName;
    (Ye(r.globalInstall) ? r.globalInstall : true) && ([
      i ? "i18n" : Lx.name,
      "I18nT"
    ].forEach((o) => t.component(o, Lx)), [
      Dx.name,
      "I18nN"
    ].forEach((o) => t.component(o, Dx)), [
      Ux.name,
      "I18nD"
    ].forEach((o) => t.component(o, Ux))), t.directive("t", dR(e));
  }
  function pR(t, e, n) {
    return {
      beforeCreate() {
        const r = xr();
        if (!r) throw Rn(Sn.UNEXPECTED_ERROR);
        const i = this.$options;
        if (i.i18n) {
          const s = i.i18n;
          if (i.__i18n && (s.__i18n = i.__i18n), s.__root = e, this === this.$root) this.$i18n = Vx(t, s);
          else {
            s.__injectWithOption = true, s.__extender = n.__vueI18nExtend, this.$i18n = sm(s);
            const o = this.$i18n;
            o.__extender && (o.__disposer = o.__extender(this.$i18n));
          }
        } else if (i.__i18n) if (this === this.$root) this.$i18n = Vx(t, i);
        else {
          this.$i18n = sm({
            __i18n: i.__i18n,
            __injectWithOption: true,
            __extender: n.__vueI18nExtend,
            __root: e
          });
          const s = this.$i18n;
          s.__extender && (s.__disposer = s.__extender(this.$i18n));
        }
        else this.$i18n = t;
        i.__i18nGlobal && j6(e, i, i), this.$t = (...s) => this.$i18n.t(...s), this.$rt = (...s) => this.$i18n.rt(...s), this.$tc = (...s) => this.$i18n.tc(...s), this.$te = (s, o) => this.$i18n.te(s, o), this.$d = (...s) => this.$i18n.d(...s), this.$n = (...s) => this.$i18n.n(...s), this.$tm = (s) => this.$i18n.tm(s), n.__setInstance(r, this.$i18n);
      },
      mounted() {
      },
      unmounted() {
        const r = xr();
        if (!r) throw Rn(Sn.UNEXPECTED_ERROR);
        const i = this.$i18n;
        delete this.$t, delete this.$rt, delete this.$tc, delete this.$te, delete this.$d, delete this.$n, delete this.$tm, i.__disposer && (i.__disposer(), delete i.__disposer, delete i.__extender), n.__deleteInstance(r), delete this.$i18n;
      }
    };
  }
  function Vx(t, e) {
    t.locale = e.locale || t.locale, t.fallbackLocale = e.fallbackLocale || t.fallbackLocale, t.missing = e.missing || t.missing, t.silentTranslationWarn = e.silentTranslationWarn || t.silentFallbackWarn, t.silentFallbackWarn = e.silentFallbackWarn || t.silentFallbackWarn, t.formatFallbackMessages = e.formatFallbackMessages || t.formatFallbackMessages, t.postTranslation = e.postTranslation || t.postTranslation, t.warnHtmlInMessage = e.warnHtmlInMessage || t.warnHtmlInMessage, t.escapeParameterHtml = e.escapeParameterHtml || t.escapeParameterHtml, t.sync = e.sync || t.sync, t.__composer[V6](e.pluralizationRules || t.pluralizationRules);
    const n = Hd(t.locale, {
      messages: e.messages,
      __i18n: e.__i18n
    });
    return Object.keys(n).forEach((r) => t.mergeLocaleMessage(r, n[r])), e.datetimeFormats && Object.keys(e.datetimeFormats).forEach((r) => t.mergeDateTimeFormat(r, e.datetimeFormats[r])), e.numberFormats && Object.keys(e.numberFormats).forEach((r) => t.mergeNumberFormat(r, e.numberFormats[r])), t;
  }
  const gR = Mo("global-vue-i18n");
  function mR(t = {}, e) {
    const n = __VUE_I18N_LEGACY_API__ && Ye(t.legacy) ? t.legacy : __VUE_I18N_LEGACY_API__, r = Ye(t.globalInjection) ? t.globalInjection : true, i = __VUE_I18N_LEGACY_API__ && n ? !!t.allowComposition : true, s = /* @__PURE__ */ new Map(), [o, a] = yR(t, n), c = Mo("");
    function l(d) {
      return s.get(d) || null;
    }
    function u(d, m) {
      s.set(d, m);
    }
    function f(d) {
      s.delete(d);
    }
    {
      const d = {
        get mode() {
          return __VUE_I18N_LEGACY_API__ && n ? "legacy" : "composition";
        },
        get allowComposition() {
          return i;
        },
        async install(m, ...y) {
          if (m.__VUE_I18N_SYMBOL__ = c, m.provide(m.__VUE_I18N_SYMBOL__, d), Ue(y[0])) {
            const R = y[0];
            d.__composerExtend = R.__composerExtend, d.__vueI18nExtend = R.__vueI18nExtend;
          }
          let x = null;
          !n && r && (x = CR(m, d.global)), __VUE_I18N_FULL_INSTALL__ && hR(m, d, ...y), __VUE_I18N_LEGACY_API__ && n && m.mixin(pR(a, a.__composer, d));
          const w = m.unmount;
          m.unmount = () => {
            x && x(), d.dispose(), w();
          };
        },
        get global() {
          return a;
        },
        dispose() {
          o.stop();
        },
        __instances: s,
        __getInstance: l,
        __setInstance: u,
        __deleteInstance: f
      };
      return d;
    }
  }
  W1 = function(t = {}) {
    const e = xr();
    if (e == null) throw Rn(Sn.MUST_BE_CALL_SETUP_TOP);
    if (!e.isCE && e.appContext.app != null && !e.appContext.app.__VUE_I18N_SYMBOL__) throw Rn(Sn.NOT_INSTALLED);
    const n = bR(e), r = AR(n), i = Q6(e), s = xR(t, i);
    if (__VUE_I18N_LEGACY_API__ && n.mode === "legacy" && !t.__useComponent) {
      if (!n.allowComposition) throw Rn(Sn.NOT_AVAILABLE_IN_LEGACY_MODE);
      return SR(e, s, r, t);
    }
    if (s === "global") return j6(r, t, i), r;
    if (s === "parent") {
      let c = wR(n, e, t.__useComponent);
      return c == null && (c = r), c;
    }
    const o = n;
    let a = o.__getInstance(e);
    if (a == null) {
      const c = Hn({}, t);
      "__i18n" in i && (c.__i18n = i.__i18n), r && (c.__root = r), a = J1(c), o.__composerExtend && (a[im] = o.__composerExtend(a)), ER(o, e, a), o.__setInstance(e, a);
    }
    return a;
  };
  function yR(t, e, n) {
    const r = b1();
    {
      const i = __VUE_I18N_LEGACY_API__ && e ? r.run(() => sm(t)) : r.run(() => J1(t));
      if (i == null) throw Rn(Sn.UNEXPECTED_ERROR);
      return [
        r,
        i
      ];
    }
  }
  function bR(t) {
    {
      const e = qn(t.isCE ? gR : t.appContext.app.__VUE_I18N_SYMBOL__);
      if (!e) throw Rn(t.isCE ? Sn.NOT_INSTALLED_WITH_PROVIDE : Sn.UNEXPECTED_ERROR);
      return e;
    }
  }
  function xR(t, e) {
    return Ld(t) ? "__i18n" in e ? "local" : "global" : t.useScope ? t.useScope : "local";
  }
  function AR(t) {
    return t.mode === "composition" ? t.global : t.global.__composer;
  }
  function wR(t, e, n = false) {
    let r = null;
    const i = e.root;
    let s = vR(e, n);
    for (; s != null; ) {
      const o = t;
      if (t.mode === "composition") r = o.__getInstance(s);
      else if (__VUE_I18N_LEGACY_API__) {
        const a = o.__getInstance(s);
        a != null && (r = a.__composer, n && r && !r[z6] && (r = null));
      }
      if (r != null || i === s) break;
      s = s.parent;
    }
    return r;
  }
  function vR(t, e = false) {
    return t == null ? null : e && t.vnode.ctx || t.parent;
  }
  function ER(t, e, n) {
    Si(() => {
    }, e), yl(() => {
      const r = n;
      t.__deleteInstance(e);
      const i = r[im];
      i && (i(), delete r[im]);
    }, e);
  }
  function SR(t, e, n, r = {}) {
    const i = e === "local", s = I1(null);
    if (i && t.proxy && !(t.proxy.$options.i18n || t.proxy.$options.__i18n)) throw Rn(Sn.MUST_DEFINE_I18N_OPTION_IN_ALLOW_COMPOSITION);
    const o = Ye(r.inheritLocale) ? r.inheritLocale : !Ce(r.locale), a = Ze(!i || o ? n.locale.value : Ce(r.locale) ? r.locale : qc), c = Ze(!i || o ? n.fallbackLocale.value : Ce(r.fallbackLocale) || Vt(r.fallbackLocale) || Ue(r.fallbackLocale) || r.fallbackLocale === false ? r.fallbackLocale : a.value), l = Ze(Hd(a.value, r)), u = Ze(Ue(r.datetimeFormats) ? r.datetimeFormats : {
      [a.value]: {}
    }), f = Ze(Ue(r.numberFormats) ? r.numberFormats : {
      [a.value]: {}
    }), d = i ? n.missingWarn : Ye(r.missingWarn) || Ro(r.missingWarn) ? r.missingWarn : true, m = i ? n.fallbackWarn : Ye(r.fallbackWarn) || Ro(r.fallbackWarn) ? r.fallbackWarn : true, y = i ? n.fallbackRoot : Ye(r.fallbackRoot) ? r.fallbackRoot : true, x = !!r.fallbackFormat, w = wt(r.missing) ? r.missing : null, R = wt(r.postTranslation) ? r.postTranslation : null, O = i ? n.warnHtmlMessage : Ye(r.warnHtmlMessage) ? r.warnHtmlMessage : true, B = !!r.escapeParameter, M = i ? n.modifiers : Ue(r.modifiers) ? r.modifiers : {}, D = r.pluralRules || i && n.pluralRules;
    function H() {
      return [
        a.value,
        c.value,
        l.value,
        u.value,
        f.value
      ];
    }
    const q = it({
      get: () => s.value ? s.value.locale.value : a.value,
      set: (V) => {
        s.value && (s.value.locale.value = V), a.value = V;
      }
    }), S = it({
      get: () => s.value ? s.value.fallbackLocale.value : c.value,
      set: (V) => {
        s.value && (s.value.fallbackLocale.value = V), c.value = V;
      }
    }), P = it(() => s.value ? s.value.messages.value : l.value), L = it(() => u.value), K = it(() => f.value);
    function z() {
      return s.value ? s.value.getPostTranslationHandler() : R;
    }
    function I(V) {
      s.value && s.value.setPostTranslationHandler(V);
    }
    function h() {
      return s.value ? s.value.getMissingHandler() : w;
    }
    function p(V) {
      s.value && s.value.setMissingHandler(V);
    }
    function A(V) {
      return H(), V();
    }
    function C(...V) {
      return s.value ? A(() => Reflect.apply(s.value.t, null, [
        ...V
      ])) : A(() => "");
    }
    function N(...V) {
      return s.value ? Reflect.apply(s.value.rt, null, [
        ...V
      ]) : "";
    }
    function U(...V) {
      return s.value ? A(() => Reflect.apply(s.value.d, null, [
        ...V
      ])) : A(() => "");
    }
    function Y(...V) {
      return s.value ? A(() => Reflect.apply(s.value.n, null, [
        ...V
      ])) : A(() => "");
    }
    function T(V) {
      return s.value ? s.value.tm(V) : {};
    }
    function g(V, te) {
      return s.value ? s.value.te(V, te) : false;
    }
    function F(V) {
      return s.value ? s.value.getLocaleMessage(V) : {};
    }
    function ee(V, te) {
      s.value && (s.value.setLocaleMessage(V, te), l.value[V] = te);
    }
    function E(V, te) {
      s.value && s.value.mergeLocaleMessage(V, te);
    }
    function Z(V) {
      return s.value ? s.value.getDateTimeFormat(V) : {};
    }
    function k(V, te) {
      s.value && (s.value.setDateTimeFormat(V, te), u.value[V] = te);
    }
    function X(V, te) {
      s.value && s.value.mergeDateTimeFormat(V, te);
    }
    function $(V) {
      return s.value ? s.value.getNumberFormat(V) : {};
    }
    function ce(V, te) {
      s.value && (s.value.setNumberFormat(V, te), f.value[V] = te);
    }
    function fe(V, te) {
      s.value && s.value.mergeNumberFormat(V, te);
    }
    const G = {
      get id() {
        return s.value ? s.value.id : -1;
      },
      locale: q,
      fallbackLocale: S,
      messages: P,
      datetimeFormats: L,
      numberFormats: K,
      get inheritLocale() {
        return s.value ? s.value.inheritLocale : o;
      },
      set inheritLocale(V) {
        s.value && (s.value.inheritLocale = V);
      },
      get availableLocales() {
        return s.value ? s.value.availableLocales : Object.keys(l.value);
      },
      get modifiers() {
        return s.value ? s.value.modifiers : M;
      },
      get pluralRules() {
        return s.value ? s.value.pluralRules : D;
      },
      get isGlobal() {
        return s.value ? s.value.isGlobal : false;
      },
      get missingWarn() {
        return s.value ? s.value.missingWarn : d;
      },
      set missingWarn(V) {
        s.value && (s.value.missingWarn = V);
      },
      get fallbackWarn() {
        return s.value ? s.value.fallbackWarn : m;
      },
      set fallbackWarn(V) {
        s.value && (s.value.missingWarn = V);
      },
      get fallbackRoot() {
        return s.value ? s.value.fallbackRoot : y;
      },
      set fallbackRoot(V) {
        s.value && (s.value.fallbackRoot = V);
      },
      get fallbackFormat() {
        return s.value ? s.value.fallbackFormat : x;
      },
      set fallbackFormat(V) {
        s.value && (s.value.fallbackFormat = V);
      },
      get warnHtmlMessage() {
        return s.value ? s.value.warnHtmlMessage : O;
      },
      set warnHtmlMessage(V) {
        s.value && (s.value.warnHtmlMessage = V);
      },
      get escapeParameter() {
        return s.value ? s.value.escapeParameter : B;
      },
      set escapeParameter(V) {
        s.value && (s.value.escapeParameter = V);
      },
      t: C,
      getPostTranslationHandler: z,
      setPostTranslationHandler: I,
      getMissingHandler: h,
      setMissingHandler: p,
      rt: N,
      d: U,
      n: Y,
      tm: T,
      te: g,
      getLocaleMessage: F,
      setLocaleMessage: ee,
      mergeLocaleMessage: E,
      getDateTimeFormat: Z,
      setDateTimeFormat: k,
      mergeDateTimeFormat: X,
      getNumberFormat: $,
      setNumberFormat: ce,
      mergeNumberFormat: fe
    };
    function W(V) {
      V.locale.value = a.value, V.fallbackLocale.value = c.value, Object.keys(l.value).forEach((te) => {
        V.mergeLocaleMessage(te, l.value[te]);
      }), Object.keys(u.value).forEach((te) => {
        V.mergeDateTimeFormat(te, u.value[te]);
      }), Object.keys(f.value).forEach((te) => {
        V.mergeNumberFormat(te, f.value[te]);
      }), V.escapeParameter = B, V.fallbackFormat = x, V.fallbackRoot = y, V.fallbackWarn = m, V.missingWarn = d, V.warnHtmlMessage = O;
    }
    return f3(() => {
      if (t.proxy == null || t.proxy.$i18n == null) throw Rn(Sn.NOT_AVAILABLE_COMPOSITION_IN_LEGACY);
      const V = s.value = t.proxy.$i18n.__composer;
      e === "global" ? (a.value = V.locale.value, c.value = V.fallbackLocale.value, l.value = V.messages.value, u.value = V.datetimeFormats.value, f.value = V.numberFormats.value) : i && W(V);
    }), G;
  }
  const TR = [
    "locale",
    "fallbackLocale",
    "availableLocales"
  ], zx = [
    "t",
    "rt",
    "d",
    "n",
    "tm",
    "te"
  ];
  function CR(t, e) {
    const n = /* @__PURE__ */ Object.create(null);
    return TR.forEach((i) => {
      const s = Object.getOwnPropertyDescriptor(e, i);
      if (!s) throw Rn(Sn.UNEXPECTED_ERROR);
      const o = Yt(s.value) ? {
        get() {
          return s.value.value;
        },
        set(a) {
          s.value.value = a;
        }
      } : {
        get() {
          return s.get && s.get();
        }
      };
      Object.defineProperty(n, i, o);
    }), t.config.globalProperties.$i18n = n, zx.forEach((i) => {
      const s = Object.getOwnPropertyDescriptor(e, i);
      if (!s || !s.value) throw Rn(Sn.UNEXPECTED_ERROR);
      Object.defineProperty(t.config.globalProperties, `$${i}`, s);
    }), () => {
      delete t.config.globalProperties.$i18n, zx.forEach((i) => {
        delete t.config.globalProperties[`$${i}`];
      });
    };
  }
  tR();
  __INTLIFY_JIT_COMPILATION__ ? vx(q_) : vx(W_);
  U_(x_);
  H_(_6);
  if (__INTLIFY_PROD_DEVTOOLS__) {
    const t = Cs();
    t.__INTLIFY__ = true, P_(t.__INTLIFY_DEVTOOLS_GLOBAL_HOOK__);
  }
  const IR = {
    "deng-lu": "\u767B\u9304",
    "dian-ji-jin-hang-zhu-ce": "\u9EDE\u64CA\u9032\u884C\u8A3B\u518A",
    "dui-huan": "\u514C\u63DB",
    "qing-shu-ru-yao-qing-ma": "\u8ACB\u8F38\u5165\u9080\u8ACB\u78BC",
    "qing-xian-deng-lu": "\u8ACB\u5148\u767B\u9304",
    "shou-quan": "\u6388\u6B0A",
    "zhu-ce": "\u8A3B\u518A",
    "zi-chan": "\u8CC7\u7522",
    "que-ren": "\u786E\u8BA4"
  }, PR = {
    "deng-lu": "Log in",
    "dian-ji-jin-hang-zhu-ce": "Click to register",
    "dui-huan": "exchange",
    "qing-shu-ru-yao-qing-ma": "Please enter the invitation code",
    "qing-xian-deng-lu": "Please log in first",
    "shou-quan": "Authorize",
    "zhu-ce": "register",
    "zi-chan": "assets",
    "que-ren": "confirm"
  }, _R = {
    "deng-lu": "\u30ED\u30B0\u30A4\u30F3",
    "dian-ji-jin-hang-zhu-ce": "\u30AF\u30EA\u30C3\u30AF\u3057\u3066\u767B\u9332",
    "dui-huan": "\u4EA4\u63DB",
    "qing-shu-ru-yao-qing-ma": "\u62DB\u5F85\u30B3\u30FC\u30C9\u3092\u5165\u529B\u3057\u3066\u304F\u3060\u3055\u3044",
    "qing-xian-deng-lu": "\u307E\u305A\u30ED\u30B0\u30A4\u30F3\u3057\u3066\u304F\u3060\u3055\u3044",
    "shou-quan": "\u627F\u8A8D\u3059\u308B",
    "zhu-ce": "\u767B\u9332\u3059\u308B",
    "zi-chan": "\u8CC7\u7523",
    "que-ren": "\u78BA\u8A8D\u3059\u308B"
  }, RR = {
    "deng-lu": "\u767B\u5F55",
    "dian-ji-jin-hang-zhu-ce": "\u70B9\u51FB\u8FDB\u884C\u6CE8\u518C",
    "dui-huan": "\u5151\u6362",
    "qing-shu-ru-yao-qing-ma": "\u8BF7\u8F93\u5165\u9080\u8BF7\u7801",
    "qing-xian-deng-lu": "\u8BF7\u5148\u767B\u5F55",
    "shou-quan": "\u6388\u6743",
    "zhu-ce": "\u6CE8\u518C",
    "zi-chan": "\u8D44\u4EA7",
    "que-ren": "\u786E\u8BA4"
  }, W6 = {
    "zh-CN": RR,
    "zh-HK": IR,
    "en-US": PR,
    "ja-JP": _R
  }, q6 = "zh-HK", uf = mR({
    legacy: false,
    locale: NR(),
    fallbackLocale: q6,
    messages: W6
  });
  uf.global.t;
  uf.global.locale;
  function NR() {
    const t = Object.keys(W6), e = localStorage.getItem("locale");
    return e && t.includes(e) ? e : q6;
  }
  const Y6 = "/loan/static/png/3-BiNRaIKQ.png", X6 = "/loan/static/png/topPop-BoCCd1jR.png";
  const uc = typeof document < "u";
  function Z6(t) {
    return typeof t == "object" || "displayName" in t || "props" in t || "__vccOpts" in t;
  }
  function OR(t) {
    return t.__esModule || t[Symbol.toStringTag] === "Module" || t.default && Z6(t.default);
  }
  const ft = Object.assign;
  function wp(t, e) {
    const n = {};
    for (const r in e) {
      const i = e[r];
      n[r] = vi(i) ? i.map(t) : t(i);
    }
    return n;
  }
  const du = () => {
  }, vi = Array.isArray, $6 = /#/g, BR = /&/g, MR = /\//g, kR = /=/g, FR = /\?/g, eE = /\+/g, LR = /%5B/g, DR = /%5D/g, tE = /%5E/g, UR = /%60/g, nE = /%7B/g, HR = /%7C/g, rE = /%7D/g, GR = /%20/g;
  function q1(t) {
    return encodeURI("" + t).replace(HR, "|").replace(LR, "[").replace(DR, "]");
  }
  function VR(t) {
    return q1(t).replace(nE, "{").replace(rE, "}").replace(tE, "^");
  }
  function om(t) {
    return q1(t).replace(eE, "%2B").replace(GR, "+").replace($6, "%23").replace(BR, "%26").replace(UR, "`").replace(nE, "{").replace(rE, "}").replace(tE, "^");
  }
  function zR(t) {
    return om(t).replace(kR, "%3D");
  }
  function QR(t) {
    return q1(t).replace($6, "%23").replace(FR, "%3F");
  }
  function jR(t) {
    return t == null ? "" : QR(t).replace(MR, "%2F");
  }
  function ku(t) {
    try {
      return decodeURIComponent("" + t);
    } catch {
    }
    return "" + t;
  }
  const JR = /\/$/, KR = (t) => t.replace(JR, "");
  function vp(t, e, n = "/") {
    let r, i = {}, s = "", o = "";
    const a = e.indexOf("#");
    let c = e.indexOf("?");
    return a < c && a >= 0 && (c = -1), c > -1 && (r = e.slice(0, c), s = e.slice(c + 1, a > -1 ? a : e.length), i = t(s)), a > -1 && (r = r || e.slice(0, a), o = e.slice(a, e.length)), r = XR(r ?? e, n), {
      fullPath: r + (s && "?") + s + o,
      path: r,
      query: i,
      hash: ku(o)
    };
  }
  function WR(t, e) {
    const n = e.query ? t(e.query) : "";
    return e.path + (n && "?") + n + (e.hash || "");
  }
  function Qx(t, e) {
    return !e || !t.toLowerCase().startsWith(e.toLowerCase()) ? t : t.slice(e.length) || "/";
  }
  function qR(t, e, n) {
    const r = e.matched.length - 1, i = n.matched.length - 1;
    return r > -1 && r === i && Yc(e.matched[r], n.matched[i]) && iE(e.params, n.params) && t(e.query) === t(n.query) && e.hash === n.hash;
  }
  function Yc(t, e) {
    return (t.aliasOf || t) === (e.aliasOf || e);
  }
  function iE(t, e) {
    if (Object.keys(t).length !== Object.keys(e).length) return false;
    for (const n in t) if (!YR(t[n], e[n])) return false;
    return true;
  }
  function YR(t, e) {
    return vi(t) ? jx(t, e) : vi(e) ? jx(e, t) : t === e;
  }
  function jx(t, e) {
    return vi(e) ? t.length === e.length && t.every((n, r) => n === e[r]) : t.length === 1 && t[0] === e;
  }
  function XR(t, e) {
    if (t.startsWith("/")) return t;
    if (!t) return e;
    const n = e.split("/"), r = t.split("/"), i = r[r.length - 1];
    (i === ".." || i === ".") && r.push("");
    let s = n.length - 1, o, a;
    for (o = 0; o < r.length; o++) if (a = r[o], a !== ".") if (a === "..") s > 1 && s--;
    else break;
    return n.slice(0, s).join("/") + "/" + r.slice(o).join("/");
  }
  const no = {
    path: "/",
    name: void 0,
    params: {},
    query: {},
    hash: "",
    fullPath: "/",
    matched: [],
    meta: {},
    redirectedFrom: void 0
  };
  var Fu;
  (function(t) {
    t.pop = "pop", t.push = "push";
  })(Fu || (Fu = {}));
  var hu;
  (function(t) {
    t.back = "back", t.forward = "forward", t.unknown = "";
  })(hu || (hu = {}));
  function ZR(t) {
    if (!t) if (uc) {
      const e = document.querySelector("base");
      t = e && e.getAttribute("href") || "/", t = t.replace(/^\w+:\/\/[^\/]+/, "");
    } else t = "/";
    return t[0] !== "/" && t[0] !== "#" && (t = "/" + t), KR(t);
  }
  const $R = /^[^#]+#/;
  function eN(t, e) {
    return t.replace($R, "#") + e;
  }
  function tN(t, e) {
    const n = document.documentElement.getBoundingClientRect(), r = t.getBoundingClientRect();
    return {
      behavior: e.behavior,
      left: r.left - n.left - (e.left || 0),
      top: r.top - n.top - (e.top || 0)
    };
  }
  const Gd = () => ({
    left: window.scrollX,
    top: window.scrollY
  });
  function nN(t) {
    let e;
    if ("el" in t) {
      const n = t.el, r = typeof n == "string" && n.startsWith("#"), i = typeof n == "string" ? r ? document.getElementById(n.slice(1)) : document.querySelector(n) : n;
      if (!i) return;
      e = tN(i, t);
    } else e = t;
    "scrollBehavior" in document.documentElement.style ? window.scrollTo(e) : window.scrollTo(e.left != null ? e.left : window.scrollX, e.top != null ? e.top : window.scrollY);
  }
  function Jx(t, e) {
    return (history.state ? history.state.position - e : -1) + t;
  }
  const am = /* @__PURE__ */ new Map();
  function rN(t, e) {
    am.set(t, e);
  }
  function iN(t) {
    const e = am.get(t);
    return am.delete(t), e;
  }
  let sN = () => location.protocol + "//" + location.host;
  function sE(t, e) {
    const { pathname: n, search: r, hash: i } = e, s = t.indexOf("#");
    if (s > -1) {
      let a = i.includes(t.slice(s)) ? t.slice(s).length : 1, c = i.slice(a);
      return c[0] !== "/" && (c = "/" + c), Qx(c, "");
    }
    return Qx(n, t) + r + i;
  }
  function oN(t, e, n, r) {
    let i = [], s = [], o = null;
    const a = ({ state: d }) => {
      const m = sE(t, location), y = n.value, x = e.value;
      let w = 0;
      if (d) {
        if (n.value = m, e.value = d, o && o === y) {
          o = null;
          return;
        }
        w = x ? d.position - x.position : 0;
      } else r(m);
      i.forEach((R) => {
        R(n.value, y, {
          delta: w,
          type: Fu.pop,
          direction: w ? w > 0 ? hu.forward : hu.back : hu.unknown
        });
      });
    };
    function c() {
      o = n.value;
    }
    function l(d) {
      i.push(d);
      const m = () => {
        const y = i.indexOf(d);
        y > -1 && i.splice(y, 1);
      };
      return s.push(m), m;
    }
    function u() {
      const { history: d } = window;
      d.state && d.replaceState(ft({}, d.state, {
        scroll: Gd()
      }), "");
    }
    function f() {
      for (const d of s) d();
      s = [], window.removeEventListener("popstate", a), window.removeEventListener("beforeunload", u);
    }
    return window.addEventListener("popstate", a), window.addEventListener("beforeunload", u, {
      passive: true
    }), {
      pauseListeners: c,
      listen: l,
      destroy: f
    };
  }
  function Kx(t, e, n, r = false, i = false) {
    return {
      back: t,
      current: e,
      forward: n,
      replaced: r,
      position: window.history.length,
      scroll: i ? Gd() : null
    };
  }
  function aN(t) {
    const { history: e, location: n } = window, r = {
      value: sE(t, n)
    }, i = {
      value: e.state
    };
    i.value || s(r.value, {
      back: null,
      current: r.value,
      forward: null,
      position: e.length - 1,
      replaced: true,
      scroll: null
    }, true);
    function s(c, l, u) {
      const f = t.indexOf("#"), d = f > -1 ? (n.host && document.querySelector("base") ? t : t.slice(f)) + c : sN() + t + c;
      try {
        e[u ? "replaceState" : "pushState"](l, "", d), i.value = l;
      } catch (m) {
        console.error(m), n[u ? "replace" : "assign"](d);
      }
    }
    function o(c, l) {
      const u = ft({}, e.state, Kx(i.value.back, c, i.value.forward, true), l, {
        position: i.value.position
      });
      s(c, u, true), r.value = c;
    }
    function a(c, l) {
      const u = ft({}, i.value, e.state, {
        forward: c,
        scroll: Gd()
      });
      s(u.current, u, true);
      const f = ft({}, Kx(r.value, c, null), {
        position: u.position + 1
      }, l);
      s(c, f, false), r.value = c;
    }
    return {
      location: r,
      state: i,
      push: a,
      replace: o
    };
  }
  function cN(t) {
    t = ZR(t);
    const e = aN(t), n = oN(t, e.state, e.location, e.replace);
    function r(s, o = true) {
      o || n.pauseListeners(), history.go(s);
    }
    const i = ft({
      location: "",
      base: t,
      go: r,
      createHref: eN.bind(null, t)
    }, e, n);
    return Object.defineProperty(i, "location", {
      enumerable: true,
      get: () => e.location.value
    }), Object.defineProperty(i, "state", {
      enumerable: true,
      get: () => e.state.value
    }), i;
  }
  function lN(t) {
    return t = location.host ? t || location.pathname + location.search : "", t.includes("#") || (t += "#"), cN(t);
  }
  function uN(t) {
    return typeof t == "string" || t && typeof t == "object";
  }
  function oE(t) {
    return typeof t == "string" || typeof t == "symbol";
  }
  const aE = Symbol("");
  var Wx;
  (function(t) {
    t[t.aborted = 4] = "aborted", t[t.cancelled = 8] = "cancelled", t[t.duplicated = 16] = "duplicated";
  })(Wx || (Wx = {}));
  function Xc(t, e) {
    return ft(new Error(), {
      type: t,
      [aE]: true
    }, e);
  }
  function ms(t, e) {
    return t instanceof Error && aE in t && (e == null || !!(t.type & e));
  }
  const qx = "[^/]+?", fN = {
    sensitive: false,
    strict: false,
    start: true,
    end: true
  }, dN = /[.+*?^${}()[\]/\\]/g;
  function hN(t, e) {
    const n = ft({}, fN, e), r = [];
    let i = n.start ? "^" : "";
    const s = [];
    for (const l of t) {
      const u = l.length ? [] : [
        90
      ];
      n.strict && !l.length && (i += "/");
      for (let f = 0; f < l.length; f++) {
        const d = l[f];
        let m = 40 + (n.sensitive ? 0.25 : 0);
        if (d.type === 0) f || (i += "/"), i += d.value.replace(dN, "\\$&"), m += 40;
        else if (d.type === 1) {
          const { value: y, repeatable: x, optional: w, regexp: R } = d;
          s.push({
            name: y,
            repeatable: x,
            optional: w
          });
          const O = R || qx;
          if (O !== qx) {
            m += 10;
            try {
              new RegExp(`(${O})`);
            } catch (M) {
              throw new Error(`Invalid custom RegExp for param "${y}" (${O}): ` + M.message);
            }
          }
          let B = x ? `((?:${O})(?:/(?:${O}))*)` : `(${O})`;
          f || (B = w && l.length < 2 ? `(?:/${B})` : "/" + B), w && (B += "?"), i += B, m += 20, w && (m += -8), x && (m += -20), O === ".*" && (m += -50);
        }
        u.push(m);
      }
      r.push(u);
    }
    if (n.strict && n.end) {
      const l = r.length - 1;
      r[l][r[l].length - 1] += 0.7000000000000001;
    }
    n.strict || (i += "/?"), n.end ? i += "$" : n.strict && !i.endsWith("/") && (i += "(?:/|$)");
    const o = new RegExp(i, n.sensitive ? "" : "i");
    function a(l) {
      const u = l.match(o), f = {};
      if (!u) return null;
      for (let d = 1; d < u.length; d++) {
        const m = u[d] || "", y = s[d - 1];
        f[y.name] = m && y.repeatable ? m.split("/") : m;
      }
      return f;
    }
    function c(l) {
      let u = "", f = false;
      for (const d of t) {
        (!f || !u.endsWith("/")) && (u += "/"), f = false;
        for (const m of d) if (m.type === 0) u += m.value;
        else if (m.type === 1) {
          const { value: y, repeatable: x, optional: w } = m, R = y in l ? l[y] : "";
          if (vi(R) && !x) throw new Error(`Provided param "${y}" is an array but it is not repeatable (* or + modifiers)`);
          const O = vi(R) ? R.join("/") : R;
          if (!O) if (w) d.length < 2 && (u.endsWith("/") ? u = u.slice(0, -1) : f = true);
          else throw new Error(`Missing required param "${y}"`);
          u += O;
        }
      }
      return u || "/";
    }
    return {
      re: o,
      score: r,
      keys: s,
      parse: a,
      stringify: c
    };
  }
  function pN(t, e) {
    let n = 0;
    for (; n < t.length && n < e.length; ) {
      const r = e[n] - t[n];
      if (r) return r;
      n++;
    }
    return t.length < e.length ? t.length === 1 && t[0] === 80 ? -1 : 1 : t.length > e.length ? e.length === 1 && e[0] === 80 ? 1 : -1 : 0;
  }
  function cE(t, e) {
    let n = 0;
    const r = t.score, i = e.score;
    for (; n < r.length && n < i.length; ) {
      const s = pN(r[n], i[n]);
      if (s) return s;
      n++;
    }
    if (Math.abs(i.length - r.length) === 1) {
      if (Yx(r)) return 1;
      if (Yx(i)) return -1;
    }
    return i.length - r.length;
  }
  function Yx(t) {
    const e = t[t.length - 1];
    return t.length > 0 && e[e.length - 1] < 0;
  }
  const gN = {
    type: 0,
    value: ""
  }, mN = /[a-zA-Z0-9_]/;
  function yN(t) {
    if (!t) return [
      []
    ];
    if (t === "/") return [
      [
        gN
      ]
    ];
    if (!t.startsWith("/")) throw new Error(`Invalid path "${t}"`);
    function e(m) {
      throw new Error(`ERR (${n})/"${l}": ${m}`);
    }
    let n = 0, r = n;
    const i = [];
    let s;
    function o() {
      s && i.push(s), s = [];
    }
    let a = 0, c, l = "", u = "";
    function f() {
      l && (n === 0 ? s.push({
        type: 0,
        value: l
      }) : n === 1 || n === 2 || n === 3 ? (s.length > 1 && (c === "*" || c === "+") && e(`A repeatable param (${l}) must be alone in its segment. eg: '/:ids+.`), s.push({
        type: 1,
        value: l,
        regexp: u,
        repeatable: c === "*" || c === "+",
        optional: c === "*" || c === "?"
      })) : e("Invalid state to consume buffer"), l = "");
    }
    function d() {
      l += c;
    }
    for (; a < t.length; ) {
      if (c = t[a++], c === "\\" && n !== 2) {
        r = n, n = 4;
        continue;
      }
      switch (n) {
        case 0:
          c === "/" ? (l && f(), o()) : c === ":" ? (f(), n = 1) : d();
          break;
        case 4:
          d(), n = r;
          break;
        case 1:
          c === "(" ? n = 2 : mN.test(c) ? d() : (f(), n = 0, c !== "*" && c !== "?" && c !== "+" && a--);
          break;
        case 2:
          c === ")" ? u[u.length - 1] == "\\" ? u = u.slice(0, -1) + c : n = 3 : u += c;
          break;
        case 3:
          f(), n = 0, c !== "*" && c !== "?" && c !== "+" && a--, u = "";
          break;
        default:
          e("Unknown state");
          break;
      }
    }
    return n === 2 && e(`Unfinished custom RegExp for param "${l}"`), f(), o(), i;
  }
  function bN(t, e, n) {
    const r = hN(yN(t.path), n), i = ft(r, {
      record: t,
      parent: e,
      children: [],
      alias: []
    });
    return e && !i.record.aliasOf == !e.record.aliasOf && e.children.push(i), i;
  }
  function xN(t, e) {
    const n = [], r = /* @__PURE__ */ new Map();
    e = e2({
      strict: false,
      end: true,
      sensitive: false
    }, e);
    function i(f) {
      return r.get(f);
    }
    function s(f, d, m) {
      const y = !m, x = Zx(f);
      x.aliasOf = m && m.record;
      const w = e2(e, f), R = [
        x
      ];
      if ("alias" in f) {
        const M = typeof f.alias == "string" ? [
          f.alias
        ] : f.alias;
        for (const D of M) R.push(Zx(ft({}, x, {
          components: m ? m.record.components : x.components,
          path: D,
          aliasOf: m ? m.record : x
        })));
      }
      let O, B;
      for (const M of R) {
        const { path: D } = M;
        if (d && D[0] !== "/") {
          const H = d.record.path, q = H[H.length - 1] === "/" ? "" : "/";
          M.path = d.record.path + (D && q + D);
        }
        if (O = bN(M, d, w), m ? m.alias.push(O) : (B = B || O, B !== O && B.alias.push(O), y && f.name && !$x(O) && o(f.name)), lE(O) && c(O), x.children) {
          const H = x.children;
          for (let q = 0; q < H.length; q++) s(H[q], O, m && m.children[q]);
        }
        m = m || O;
      }
      return B ? () => {
        o(B);
      } : du;
    }
    function o(f) {
      if (oE(f)) {
        const d = r.get(f);
        d && (r.delete(f), n.splice(n.indexOf(d), 1), d.children.forEach(o), d.alias.forEach(o));
      } else {
        const d = n.indexOf(f);
        d > -1 && (n.splice(d, 1), f.record.name && r.delete(f.record.name), f.children.forEach(o), f.alias.forEach(o));
      }
    }
    function a() {
      return n;
    }
    function c(f) {
      const d = vN(f, n);
      n.splice(d, 0, f), f.record.name && !$x(f) && r.set(f.record.name, f);
    }
    function l(f, d) {
      let m, y = {}, x, w;
      if ("name" in f && f.name) {
        if (m = r.get(f.name), !m) throw Xc(1, {
          location: f
        });
        w = m.record.name, y = ft(Xx(d.params, m.keys.filter((B) => !B.optional).concat(m.parent ? m.parent.keys.filter((B) => B.optional) : []).map((B) => B.name)), f.params && Xx(f.params, m.keys.map((B) => B.name))), x = m.stringify(y);
      } else if (f.path != null) x = f.path, m = n.find((B) => B.re.test(x)), m && (y = m.parse(x), w = m.record.name);
      else {
        if (m = d.name ? r.get(d.name) : n.find((B) => B.re.test(d.path)), !m) throw Xc(1, {
          location: f,
          currentLocation: d
        });
        w = m.record.name, y = ft({}, d.params, f.params), x = m.stringify(y);
      }
      const R = [];
      let O = m;
      for (; O; ) R.unshift(O.record), O = O.parent;
      return {
        name: w,
        path: x,
        params: y,
        matched: R,
        meta: wN(R)
      };
    }
    t.forEach((f) => s(f));
    function u() {
      n.length = 0, r.clear();
    }
    return {
      addRoute: s,
      resolve: l,
      removeRoute: o,
      clearRoutes: u,
      getRoutes: a,
      getRecordMatcher: i
    };
  }
  function Xx(t, e) {
    const n = {};
    for (const r of e) r in t && (n[r] = t[r]);
    return n;
  }
  function Zx(t) {
    const e = {
      path: t.path,
      redirect: t.redirect,
      name: t.name,
      meta: t.meta || {},
      aliasOf: t.aliasOf,
      beforeEnter: t.beforeEnter,
      props: AN(t),
      children: t.children || [],
      instances: {},
      leaveGuards: /* @__PURE__ */ new Set(),
      updateGuards: /* @__PURE__ */ new Set(),
      enterCallbacks: {},
      components: "components" in t ? t.components || null : t.component && {
        default: t.component
      }
    };
    return Object.defineProperty(e, "mods", {
      value: {}
    }), e;
  }
  function AN(t) {
    const e = {}, n = t.props || false;
    if ("component" in t) e.default = n;
    else for (const r in t.components) e[r] = typeof n == "object" ? n[r] : n;
    return e;
  }
  function $x(t) {
    for (; t; ) {
      if (t.record.aliasOf) return true;
      t = t.parent;
    }
    return false;
  }
  function wN(t) {
    return t.reduce((e, n) => ft(e, n.meta), {});
  }
  function e2(t, e) {
    const n = {};
    for (const r in t) n[r] = r in e ? e[r] : t[r];
    return n;
  }
  function vN(t, e) {
    let n = 0, r = e.length;
    for (; n !== r; ) {
      const s = n + r >> 1;
      cE(t, e[s]) < 0 ? r = s : n = s + 1;
    }
    const i = EN(t);
    return i && (r = e.lastIndexOf(i, r - 1)), r;
  }
  function EN(t) {
    let e = t;
    for (; e = e.parent; ) if (lE(e) && cE(t, e) === 0) return e;
  }
  function lE({ record: t }) {
    return !!(t.name || t.components && Object.keys(t.components).length || t.redirect);
  }
  function SN(t) {
    const e = {};
    if (t === "" || t === "?") return e;
    const r = (t[0] === "?" ? t.slice(1) : t).split("&");
    for (let i = 0; i < r.length; ++i) {
      const s = r[i].replace(eE, " "), o = s.indexOf("="), a = ku(o < 0 ? s : s.slice(0, o)), c = o < 0 ? null : ku(s.slice(o + 1));
      if (a in e) {
        let l = e[a];
        vi(l) || (l = e[a] = [
          l
        ]), l.push(c);
      } else e[a] = c;
    }
    return e;
  }
  function t2(t) {
    let e = "";
    for (let n in t) {
      const r = t[n];
      if (n = zR(n), r == null) {
        r !== void 0 && (e += (e.length ? "&" : "") + n);
        continue;
      }
      (vi(r) ? r.map((s) => s && om(s)) : [
        r && om(r)
      ]).forEach((s) => {
        s !== void 0 && (e += (e.length ? "&" : "") + n, s != null && (e += "=" + s));
      });
    }
    return e;
  }
  function TN(t) {
    const e = {};
    for (const n in t) {
      const r = t[n];
      r !== void 0 && (e[n] = vi(r) ? r.map((i) => i == null ? null : "" + i) : r == null ? r : "" + r);
    }
    return e;
  }
  const CN = Symbol(""), n2 = Symbol(""), Vd = Symbol(""), Y1 = Symbol(""), cm = Symbol("");
  function Ul() {
    let t = [];
    function e(r) {
      return t.push(r), () => {
        const i = t.indexOf(r);
        i > -1 && t.splice(i, 1);
      };
    }
    function n() {
      t = [];
    }
    return {
      add: e,
      list: () => t.slice(),
      reset: n
    };
  }
  function go(t, e, n, r, i, s = (o) => o()) {
    const o = r && (r.enterCallbacks[i] = r.enterCallbacks[i] || []);
    return () => new Promise((a, c) => {
      const l = (d) => {
        d === false ? c(Xc(4, {
          from: n,
          to: e
        })) : d instanceof Error ? c(d) : uN(d) ? c(Xc(2, {
          from: e,
          to: d
        })) : (o && r.enterCallbacks[i] === o && typeof d == "function" && o.push(d), a());
      }, u = s(() => t.call(r && r.instances[i], e, n, l));
      let f = Promise.resolve(u);
      t.length < 3 && (f = f.then(l)), f.catch((d) => c(d));
    });
  }
  function Ep(t, e, n, r, i = (s) => s()) {
    const s = [];
    for (const o of t) for (const a in o.components) {
      let c = o.components[a];
      if (!(e !== "beforeRouteEnter" && !o.instances[a])) if (Z6(c)) {
        const u = (c.__vccOpts || c)[e];
        u && s.push(go(u, n, r, o, a, i));
      } else {
        let l = c();
        s.push(() => l.then((u) => {
          if (!u) throw new Error(`Couldn't resolve component "${a}" at "${o.path}"`);
          const f = OR(u) ? u.default : u;
          o.mods[a] = u, o.components[a] = f;
          const m = (f.__vccOpts || f)[e];
          return m && go(m, n, r, o, a, i)();
        }));
      }
    }
    return s;
  }
  function r2(t) {
    const e = qn(Vd), n = qn(Y1), r = it(() => {
      const c = ar(t.to);
      return e.resolve(c);
    }), i = it(() => {
      const { matched: c } = r.value, { length: l } = c, u = c[l - 1], f = n.matched;
      if (!u || !f.length) return -1;
      const d = f.findIndex(Yc.bind(null, u));
      if (d > -1) return d;
      const m = i2(c[l - 2]);
      return l > 1 && i2(u) === m && f[f.length - 1].path !== m ? f.findIndex(Yc.bind(null, c[l - 2])) : d;
    }), s = it(() => i.value > -1 && NN(n.params, r.value.params)), o = it(() => i.value > -1 && i.value === n.matched.length - 1 && iE(n.params, r.value.params));
    function a(c = {}) {
      if (RN(c)) {
        const l = e[ar(t.replace) ? "replace" : "push"](ar(t.to)).catch(du);
        return t.viewTransition && typeof document < "u" && "startViewTransition" in document && document.startViewTransition(() => l), l;
      }
      return Promise.resolve();
    }
    return {
      route: r,
      href: it(() => r.value.href),
      isActive: s,
      isExactActive: o,
      navigate: a
    };
  }
  function IN(t) {
    return t.length === 1 ? t[0] : t;
  }
  const PN = Gn({
    name: "RouterLink",
    compatConfig: {
      MODE: 3
    },
    props: {
      to: {
        type: [
          String,
          Object
        ],
        required: true
      },
      replace: Boolean,
      activeClass: String,
      exactActiveClass: String,
      custom: Boolean,
      ariaCurrentValue: {
        type: String,
        default: "page"
      },
      viewTransition: Boolean
    },
    useLink: r2,
    setup(t, { slots: e }) {
      const n = $i(r2(t)), { options: r } = qn(Vd), i = it(() => ({
        [s2(t.activeClass, r.linkActiveClass, "router-link-active")]: n.isActive,
        [s2(t.exactActiveClass, r.linkExactActiveClass, "router-link-exact-active")]: n.isExactActive
      }));
      return () => {
        const s = e.default && IN(e.default(n));
        return t.custom ? s : of("a", {
          "aria-current": n.isExactActive ? t.ariaCurrentValue : null,
          href: n.href,
          onClick: n.navigate,
          class: i.value
        }, s);
      };
    }
  }), _N = PN;
  function RN(t) {
    if (!(t.metaKey || t.altKey || t.ctrlKey || t.shiftKey) && !t.defaultPrevented && !(t.button !== void 0 && t.button !== 0)) {
      if (t.currentTarget && t.currentTarget.getAttribute) {
        const e = t.currentTarget.getAttribute("target");
        if (/\b_blank\b/i.test(e)) return;
      }
      return t.preventDefault && t.preventDefault(), true;
    }
  }
  function NN(t, e) {
    for (const n in e) {
      const r = e[n], i = t[n];
      if (typeof r == "string") {
        if (r !== i) return false;
      } else if (!vi(i) || i.length !== r.length || r.some((s, o) => s !== i[o])) return false;
    }
    return true;
  }
  function i2(t) {
    return t ? t.aliasOf ? t.aliasOf.path : t.path : "";
  }
  const s2 = (t, e, n) => t ?? e ?? n, ON = Gn({
    name: "RouterView",
    inheritAttrs: false,
    props: {
      name: {
        type: String,
        default: "default"
      },
      route: Object
    },
    compatConfig: {
      MODE: 3
    },
    setup(t, { attrs: e, slots: n }) {
      const r = qn(cm), i = it(() => t.route || r.value), s = qn(n2, 0), o = it(() => {
        let l = ar(s);
        const { matched: u } = i.value;
        let f;
        for (; (f = u[l]) && !f.components; ) l++;
        return l;
      }), a = it(() => i.value.matched[o.value]);
      wa(n2, it(() => o.value + 1)), wa(CN, a), wa(cm, i);
      const c = Ze();
      return xn(() => [
        c.value,
        a.value,
        t.name
      ], ([l, u, f], [d, m, y]) => {
        u && (u.instances[f] = l, m && m !== u && l && l === d && (u.leaveGuards.size || (u.leaveGuards = m.leaveGuards), u.updateGuards.size || (u.updateGuards = m.updateGuards))), l && u && (!m || !Yc(u, m) || !d) && (u.enterCallbacks[f] || []).forEach((x) => x(l));
      }, {
        flush: "post"
      }), () => {
        const l = i.value, u = t.name, f = a.value, d = f && f.components[u];
        if (!d) return o2(n.default, {
          Component: d,
          route: l
        });
        const m = f.props[u], y = m ? m === true ? l.params : typeof m == "function" ? m(l) : m : null, w = of(d, ft({}, y, e, {
          onVnodeUnmounted: (R) => {
            R.component.isUnmounted && (f.instances[u] = null);
          },
          ref: c
        }));
        return o2(n.default, {
          Component: w,
          route: l
        }) || w;
      };
    }
  });
  function o2(t, e) {
    if (!t) return null;
    const n = t(e);
    return n.length === 1 ? n[0] : n;
  }
  const BN = ON;
  function MN(t) {
    const e = xN(t.routes, t), n = t.parseQuery || SN, r = t.stringifyQuery || t2, i = t.history, s = Ul(), o = Ul(), a = Ul(), c = I1(no);
    let l = no;
    uc && t.scrollBehavior && "scrollRestoration" in history && (history.scrollRestoration = "manual");
    const u = wp.bind(null, (k) => "" + k), f = wp.bind(null, jR), d = wp.bind(null, ku);
    function m(k, X) {
      let $, ce;
      return oE(k) ? ($ = e.getRecordMatcher(k), ce = X) : ce = k, e.addRoute(ce, $);
    }
    function y(k) {
      const X = e.getRecordMatcher(k);
      X && e.removeRoute(X);
    }
    function x() {
      return e.getRoutes().map((k) => k.record);
    }
    function w(k) {
      return !!e.getRecordMatcher(k);
    }
    function R(k, X) {
      if (X = ft({}, X || c.value), typeof k == "string") {
        const V = vp(n, k, X.path), te = e.resolve({
          path: V.path
        }, X), pe = i.createHref(V.fullPath);
        return ft(V, te, {
          params: d(te.params),
          hash: ku(V.hash),
          redirectedFrom: void 0,
          href: pe
        });
      }
      let $;
      if (k.path != null) $ = ft({}, k, {
        path: vp(n, k.path, X.path).path
      });
      else {
        const V = ft({}, k.params);
        for (const te in V) V[te] == null && delete V[te];
        $ = ft({}, k, {
          params: f(V)
        }), X.params = f(X.params);
      }
      const ce = e.resolve($, X), fe = k.hash || "";
      ce.params = u(d(ce.params));
      const G = WR(r, ft({}, k, {
        hash: VR(fe),
        path: ce.path
      })), W = i.createHref(G);
      return ft({
        fullPath: G,
        hash: fe,
        query: r === t2 ? TN(k.query) : k.query || {}
      }, ce, {
        redirectedFrom: void 0,
        href: W
      });
    }
    function O(k) {
      return typeof k == "string" ? vp(n, k, c.value.path) : ft({}, k);
    }
    function B(k, X) {
      if (l !== k) return Xc(8, {
        from: X,
        to: k
      });
    }
    function M(k) {
      return q(k);
    }
    function D(k) {
      return M(ft(O(k), {
        replace: true
      }));
    }
    function H(k) {
      const X = k.matched[k.matched.length - 1];
      if (X && X.redirect) {
        const { redirect: $ } = X;
        let ce = typeof $ == "function" ? $(k) : $;
        return typeof ce == "string" && (ce = ce.includes("?") || ce.includes("#") ? ce = O(ce) : {
          path: ce
        }, ce.params = {}), ft({
          query: k.query,
          hash: k.hash,
          params: ce.path != null ? {} : k.params
        }, ce);
      }
    }
    function q(k, X) {
      const $ = l = R(k), ce = c.value, fe = k.state, G = k.force, W = k.replace === true, V = H($);
      if (V) return q(ft(O(V), {
        state: typeof V == "object" ? ft({}, fe, V.state) : fe,
        force: G,
        replace: W
      }), X || $);
      const te = $;
      te.redirectedFrom = X;
      let pe;
      return !G && qR(r, ce, $) && (pe = Xc(16, {
        to: te,
        from: ce
      }), T(ce, ce, true, false)), (pe ? Promise.resolve(pe) : L(te, ce)).catch((ue) => ms(ue) ? ms(ue, 2) ? ue : Y(ue) : N(ue, te, ce)).then((ue) => {
        if (ue) {
          if (ms(ue, 2)) return q(ft({
            replace: W
          }, O(ue.to), {
            state: typeof ue.to == "object" ? ft({}, fe, ue.to.state) : fe,
            force: G
          }), X || te);
        } else ue = z(te, ce, true, W, fe);
        return K(te, ce, ue), ue;
      });
    }
    function S(k, X) {
      const $ = B(k, X);
      return $ ? Promise.reject($) : Promise.resolve();
    }
    function P(k) {
      const X = ee.values().next().value;
      return X && typeof X.runWithContext == "function" ? X.runWithContext(k) : k();
    }
    function L(k, X) {
      let $;
      const [ce, fe, G] = kN(k, X);
      $ = Ep(ce.reverse(), "beforeRouteLeave", k, X);
      for (const V of ce) V.leaveGuards.forEach((te) => {
        $.push(go(te, k, X));
      });
      const W = S.bind(null, k, X);
      return $.push(W), Z($).then(() => {
        $ = [];
        for (const V of s.list()) $.push(go(V, k, X));
        return $.push(W), Z($);
      }).then(() => {
        $ = Ep(fe, "beforeRouteUpdate", k, X);
        for (const V of fe) V.updateGuards.forEach((te) => {
          $.push(go(te, k, X));
        });
        return $.push(W), Z($);
      }).then(() => {
        $ = [];
        for (const V of G) if (V.beforeEnter) if (vi(V.beforeEnter)) for (const te of V.beforeEnter) $.push(go(te, k, X));
        else $.push(go(V.beforeEnter, k, X));
        return $.push(W), Z($);
      }).then(() => (k.matched.forEach((V) => V.enterCallbacks = {}), $ = Ep(G, "beforeRouteEnter", k, X, P), $.push(W), Z($))).then(() => {
        $ = [];
        for (const V of o.list()) $.push(go(V, k, X));
        return $.push(W), Z($);
      }).catch((V) => ms(V, 8) ? V : Promise.reject(V));
    }
    function K(k, X, $) {
      a.list().forEach((ce) => P(() => ce(k, X, $)));
    }
    function z(k, X, $, ce, fe) {
      const G = B(k, X);
      if (G) return G;
      const W = X === no, V = uc ? history.state : {};
      $ && (ce || W ? i.replace(k.fullPath, ft({
        scroll: W && V && V.scroll
      }, fe)) : i.push(k.fullPath, fe)), c.value = k, T(k, X, $, W), Y();
    }
    let I;
    function h() {
      I || (I = i.listen((k, X, $) => {
        if (!E.listening) return;
        const ce = R(k), fe = H(ce);
        if (fe) {
          q(ft(fe, {
            replace: true,
            force: true
          }), ce).catch(du);
          return;
        }
        l = ce;
        const G = c.value;
        uc && rN(Jx(G.fullPath, $.delta), Gd()), L(ce, G).catch((W) => ms(W, 12) ? W : ms(W, 2) ? (q(ft(O(W.to), {
          force: true
        }), ce).then((V) => {
          ms(V, 20) && !$.delta && $.type === Fu.pop && i.go(-1, false);
        }).catch(du), Promise.reject()) : ($.delta && i.go(-$.delta, false), N(W, ce, G))).then((W) => {
          W = W || z(ce, G, false), W && ($.delta && !ms(W, 8) ? i.go(-$.delta, false) : $.type === Fu.pop && ms(W, 20) && i.go(-1, false)), K(ce, G, W);
        }).catch(du);
      }));
    }
    let p = Ul(), A = Ul(), C;
    function N(k, X, $) {
      Y(k);
      const ce = A.list();
      return ce.length ? ce.forEach((fe) => fe(k, X, $)) : console.error(k), Promise.reject(k);
    }
    function U() {
      return C && c.value !== no ? Promise.resolve() : new Promise((k, X) => {
        p.add([
          k,
          X
        ]);
      });
    }
    function Y(k) {
      return C || (C = !k, h(), p.list().forEach(([X, $]) => k ? $(k) : X()), p.reset()), k;
    }
    function T(k, X, $, ce) {
      const { scrollBehavior: fe } = t;
      if (!uc || !fe) return Promise.resolve();
      const G = !$ && iN(Jx(k.fullPath, 0)) || (ce || !$) && history.state && history.state.scroll || null;
      return zi().then(() => fe(k, X, G)).then((W) => W && nN(W)).catch((W) => N(W, k, X));
    }
    const g = (k) => i.go(k);
    let F;
    const ee = /* @__PURE__ */ new Set(), E = {
      currentRoute: c,
      listening: true,
      addRoute: m,
      removeRoute: y,
      clearRoutes: e.clearRoutes,
      hasRoute: w,
      getRoutes: x,
      resolve: R,
      options: t,
      push: M,
      replace: D,
      go: g,
      back: () => g(-1),
      forward: () => g(1),
      beforeEach: s.add,
      beforeResolve: o.add,
      afterEach: a.add,
      onError: A.add,
      isReady: U,
      install(k) {
        const X = this;
        k.component("RouterLink", _N), k.component("RouterView", BN), k.config.globalProperties.$router = X, Object.defineProperty(k.config.globalProperties, "$route", {
          enumerable: true,
          get: () => ar(c)
        }), uc && !F && c.value === no && (F = true, M(i.location).catch((fe) => {
        }));
        const $ = {};
        for (const fe in no) Object.defineProperty($, fe, {
          get: () => c.value[fe],
          enumerable: true
        });
        k.provide(Vd, X), k.provide(Y1, zv($)), k.provide(cm, c);
        const ce = k.unmount;
        ee.add(k), k.unmount = function() {
          ee.delete(k), ee.size < 1 && (l = no, I && I(), I = null, c.value = no, F = false, C = false), ce();
        };
      }
    };
    function Z(k) {
      return k.reduce((X, $) => X.then(() => P($)), Promise.resolve());
    }
    return E;
  }
  function kN(t, e) {
    const n = [], r = [], i = [], s = Math.max(e.matched.length, t.matched.length);
    for (let o = 0; o < s; o++) {
      const a = e.matched[o];
      a && (t.matched.find((l) => Yc(l, a)) ? r.push(a) : n.push(a));
      const c = t.matched[o];
      c && (e.matched.find((l) => Yc(l, c)) || i.push(c));
    }
    return [
      n,
      r,
      i
    ];
  }
  $W = function() {
    return qn(Vd);
  };
  FN = function(t) {
    return qn(Y1);
  };
  const LN = "6.14.4";
  function DN(t, e, n) {
    const r = e.split("|").map((s) => s.trim());
    for (let s = 0; s < r.length; s++) switch (e) {
      case "any":
        return;
      case "bigint":
      case "boolean":
      case "number":
      case "string":
        if (typeof t === e) return;
    }
    const i = new Error(`invalid value for type ${e}`);
    throw i.code = "INVALID_ARGUMENT", i.argument = `value.${n}`, i.value = t, i;
  }
  async function $n(t) {
    const e = Object.keys(t);
    return (await Promise.all(e.map((r) => Promise.resolve(t[r])))).reduce((r, i, s) => (r[e[s]] = i, r), {});
  }
  function Me(t, e, n) {
    for (let r in e) {
      let i = e[r];
      const s = n ? n[r] : null;
      s && DN(i, s, r), Object.defineProperty(t, r, {
        enumerable: true,
        value: i,
        writable: false
      });
    }
  }
  function vc(t, e) {
    if (t == null) return "null";
    if (e == null && (e = /* @__PURE__ */ new Set()), typeof t == "object") {
      if (e.has(t)) return "[Circular]";
      e.add(t);
    }
    if (Array.isArray(t)) return "[ " + t.map((n) => vc(n, e)).join(", ") + " ]";
    if (t instanceof Uint8Array) {
      const n = "0123456789abcdef";
      let r = "0x";
      for (let i = 0; i < t.length; i++) r += n[t[i] >> 4], r += n[t[i] & 15];
      return r;
    }
    if (typeof t == "object" && typeof t.toJSON == "function") return vc(t.toJSON(), e);
    switch (typeof t) {
      case "boolean":
      case "number":
      case "symbol":
        return t.toString();
      case "bigint":
        return BigInt(t).toString();
      case "string":
        return JSON.stringify(t);
      case "object": {
        const n = Object.keys(t);
        return n.sort(), "{ " + n.map((r) => `${vc(r, e)}: ${vc(t[r], e)}`).join(", ") + " }";
      }
    }
    return "[ COULD NOT SERIALIZE ]";
  }
  function Un(t, e) {
    return t && t.code === e;
  }
  function X1(t) {
    return Un(t, "CALL_EXCEPTION");
  }
  function Qt(t, e, n) {
    let r = t;
    {
      const s = [];
      if (n) {
        if ("message" in n || "code" in n || "name" in n) throw new Error(`value will overwrite populated values: ${vc(n)}`);
        for (const o in n) {
          if (o === "shortMessage") continue;
          const a = n[o];
          s.push(o + "=" + vc(a));
        }
      }
      s.push(`code=${e}`), s.push(`version=${LN}`), s.length && (t += " (" + s.join(", ") + ")");
    }
    let i;
    switch (e) {
      case "INVALID_ARGUMENT":
        i = new TypeError(t);
        break;
      case "NUMERIC_FAULT":
      case "BUFFER_OVERRUN":
        i = new RangeError(t);
        break;
      default:
        i = new Error(t);
    }
    return Me(i, {
      code: e
    }), n && Object.assign(i, n), i.shortMessage == null && Me(i, {
      shortMessage: r
    }), i;
  }
  function me(t, e, n, r) {
    if (!t) throw Qt(e, n, r);
  }
  function re(t, e, n, r) {
    me(t, e, "INVALID_ARGUMENT", {
      argument: n,
      value: r
    });
  }
  function uE(t, e, n) {
    n == null && (n = ""), n && (n = ": " + n), me(t >= e, "missing argument" + n, "MISSING_ARGUMENT", {
      count: t,
      expectedCount: e
    }), me(t <= e, "too many arguments" + n, "UNEXPECTED_ARGUMENT", {
      count: t,
      expectedCount: e
    });
  }
  [
    "NFD",
    "NFC",
    "NFKD",
    "NFKC"
  ].reduce((t, e) => {
    try {
      if ("test".normalize(e) !== "test") throw new Error("bad");
      if (e === "NFD" && "\xE9".normalize("NFD") !== "e\u0301") throw new Error("broken");
      t.push(e);
    } catch {
    }
    return t;
  }, []);
  function ff(t, e, n) {
    if (n == null && (n = ""), t !== e) {
      let r = n, i = "new";
      n && (r += ".", i += " " + n), me(false, `private constructor; use ${r}from* methods`, "UNSUPPORTED_OPERATION", {
        operation: i
      });
    }
  }
  function fE(t, e, n) {
    if (t instanceof Uint8Array) return n ? new Uint8Array(t) : t;
    if (typeof t == "string" && t.match(/^0x(?:[0-9a-f][0-9a-f])*$/i)) {
      const r = new Uint8Array((t.length - 2) / 2);
      let i = 2;
      for (let s = 0; s < r.length; s++) r[s] = parseInt(t.substring(i, i + 2), 16), i += 2;
      return r;
    }
    re(false, "invalid BytesLike value", e || "value", t);
  }
  function Je(t, e) {
    return fE(t, e, false);
  }
  function tr(t, e) {
    return fE(t, e, true);
  }
  function vt(t, e) {
    return !(typeof t != "string" || !t.match(/^0x[0-9A-Fa-f]*$/) || typeof e == "number" && t.length !== 2 + 2 * e || e === true && t.length % 2 !== 0);
  }
  function Z1(t) {
    return vt(t, true) || t instanceof Uint8Array;
  }
  const a2 = "0123456789abcdef";
  function Se(t) {
    const e = Je(t);
    let n = "0x";
    for (let r = 0; r < e.length; r++) {
      const i = e[r];
      n += a2[(i & 240) >> 4] + a2[i & 15];
    }
    return n;
  }
  function Xt(t) {
    return "0x" + t.map((e) => Se(e).substring(2)).join("");
  }
  function Mc(t) {
    return vt(t, true) ? (t.length - 2) / 2 : Je(t).length;
  }
  function en(t, e, n) {
    const r = Je(t);
    return n != null && n > r.length && me(false, "cannot slice beyond data bounds", "BUFFER_OVERRUN", {
      buffer: r,
      length: r.length,
      offset: n
    }), Se(r.slice(e ?? 0, n ?? r.length));
  }
  function dE(t, e, n) {
    const r = Je(t);
    me(e >= r.length, "padding exceeds data length", "BUFFER_OVERRUN", {
      buffer: new Uint8Array(r),
      length: e,
      offset: e + 1
    });
    const i = new Uint8Array(e);
    return i.fill(0), n ? i.set(r, e - r.length) : i.set(r, 0), Se(i);
  }
  function Fs(t, e) {
    return dE(t, e, true);
  }
  function UN(t, e) {
    return dE(t, e, false);
  }
  const zd = BigInt(0), hi = BigInt(1), Ec = 9007199254740991;
  function J0(t, e) {
    const n = Qd(t, "value"), r = BigInt(Qe(e, "width"));
    if (me(n >> r === zd, "overflow", "NUMERIC_FAULT", {
      operation: "fromTwos",
      fault: "overflow",
      value: t
    }), n >> r - hi) {
      const i = (hi << r) - hi;
      return -((~n & i) + hi);
    }
    return n;
  }
  function hE(t, e) {
    let n = Pe(t, "value");
    const r = BigInt(Qe(e, "width")), i = hi << r - hi;
    if (n < zd) {
      n = -n, me(n <= i, "too low", "NUMERIC_FAULT", {
        operation: "toTwos",
        fault: "overflow",
        value: t
      });
      const s = (hi << r) - hi;
      return (~n & s) + hi;
    } else me(n < i, "too high", "NUMERIC_FAULT", {
      operation: "toTwos",
      fault: "overflow",
      value: t
    });
    return n;
  }
  function ha(t, e) {
    const n = Qd(t, "value"), r = BigInt(Qe(e, "bits"));
    return n & (hi << r) - hi;
  }
  function Pe(t, e) {
    switch (typeof t) {
      case "bigint":
        return t;
      case "number":
        return re(Number.isInteger(t), "underflow", e || "value", t), re(t >= -Ec && t <= Ec, "overflow", e || "value", t), BigInt(t);
      case "string":
        try {
          if (t === "") throw new Error("empty string");
          return t[0] === "-" && t[1] !== "-" ? -BigInt(t.substring(1)) : BigInt(t);
        } catch (n) {
          re(false, `invalid BigNumberish string: ${n.message}`, e || "value", t);
        }
    }
    re(false, "invalid BigNumberish value", e || "value", t);
  }
  function Qd(t, e) {
    const n = Pe(t, e);
    return me(n >= zd, "unsigned value cannot be negative", "NUMERIC_FAULT", {
      fault: "overflow",
      operation: "getUint",
      value: t
    }), n;
  }
  const c2 = "0123456789abcdef";
  function jd(t) {
    if (t instanceof Uint8Array) {
      let e = "0x0";
      for (const n of t) e += c2[n >> 4], e += c2[n & 15];
      return BigInt(e);
    }
    return Pe(t);
  }
  function Qe(t, e) {
    switch (typeof t) {
      case "bigint":
        return re(t >= -Ec && t <= Ec, "overflow", e || "value", t), Number(t);
      case "number":
        return re(Number.isInteger(t), "underflow", e || "value", t), re(t >= -Ec && t <= Ec, "overflow", e || "value", t), t;
      case "string":
        try {
          if (t === "") throw new Error("empty string");
          return Qe(BigInt(t), e);
        } catch (n) {
          re(false, `invalid numeric string: ${n.message}`, e || "value", t);
        }
    }
    re(false, "invalid numeric value", e || "value", t);
  }
  function HN(t) {
    return Qe(jd(t));
  }
  function No(t, e) {
    let r = Qd(t, "value").toString(16);
    if (e == null) r.length % 2 && (r = "0" + r);
    else {
      const i = Qe(e, "width");
      for (me(i * 2 >= r.length, `value exceeds width (${i} bytes)`, "NUMERIC_FAULT", {
        operation: "toBeHex",
        fault: "overflow",
        value: t
      }); r.length < i * 2; ) r = "0" + r;
    }
    return "0x" + r;
  }
  function hn(t) {
    const e = Qd(t, "value");
    if (e === zd) return new Uint8Array([]);
    let n = e.toString(16);
    n.length % 2 && (n = "0" + n);
    const r = new Uint8Array(n.length / 2);
    for (let i = 0; i < r.length; i++) {
      const s = i * 2;
      r[i] = parseInt(n.substring(s, s + 2), 16);
    }
    return r;
  }
  function di(t) {
    let e = Se(Z1(t) ? t : hn(t)).substring(2);
    for (; e.startsWith("0"); ) e = e.substring(1);
    return e === "" && (e = "0"), "0x" + e;
  }
  const l2 = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
  BigInt(0);
  const u2 = BigInt(58);
  function GN(t) {
    const e = Je(t);
    let n = jd(e), r = "";
    for (; n; ) r = l2[Number(n % u2)] + r, n /= u2;
    for (let i = 0; i < e.length && !e[i]; i++) r = l2[0] + r;
    return r;
  }
  function VN(t) {
    t = atob(t);
    const e = new Uint8Array(t.length);
    for (let n = 0; n < t.length; n++) e[n] = t.charCodeAt(n);
    return Je(e);
  }
  function zN(t) {
    const e = Je(t);
    let n = "";
    for (let r = 0; r < e.length; r++) n += String.fromCharCode(e[r]);
    return btoa(n);
  }
  class pE {
    constructor(e, n, r) {
      __publicField(this, "filter");
      __publicField(this, "emitter");
      __privateAdd(this, _e2);
      __privateSet(this, _e2, n), Me(this, {
        emitter: e,
        filter: r
      });
    }
    async removeListener() {
      __privateGet(this, _e2) != null && await this.emitter.off(this.filter, __privateGet(this, _e2));
    }
  }
  _e2 = new WeakMap();
  function QN(t, e, n, r, i) {
    re(false, `invalid codepoint at offset ${e}; ${t}`, "bytes", n);
  }
  function gE(t, e, n, r, i) {
    if (t === "BAD_PREFIX" || t === "UNEXPECTED_CONTINUE") {
      let s = 0;
      for (let o = e + 1; o < n.length && n[o] >> 6 === 2; o++) s++;
      return s;
    }
    return t === "OVERRUN" ? n.length - e - 1 : 0;
  }
  function jN(t, e, n, r, i) {
    return t === "OVERLONG" ? (re(typeof i == "number", "invalid bad code point for replacement", "badCodepoint", i), r.push(i), 0) : (r.push(65533), gE(t, e, n));
  }
  const JN = Object.freeze({
    error: QN,
    ignore: gE,
    replace: jN
  });
  function KN(t, e) {
    e == null && (e = JN.error);
    const n = Je(t, "bytes"), r = [];
    let i = 0;
    for (; i < n.length; ) {
      const s = n[i++];
      if (!(s >> 7)) {
        r.push(s);
        continue;
      }
      let o = null, a = null;
      if ((s & 224) === 192) o = 1, a = 127;
      else if ((s & 240) === 224) o = 2, a = 2047;
      else if ((s & 248) === 240) o = 3, a = 65535;
      else {
        (s & 192) === 128 ? i += e("UNEXPECTED_CONTINUE", i - 1, n, r) : i += e("BAD_PREFIX", i - 1, n, r);
        continue;
      }
      if (i - 1 + o >= n.length) {
        i += e("OVERRUN", i - 1, n, r);
        continue;
      }
      let c = s & (1 << 8 - o - 1) - 1;
      for (let l = 0; l < o; l++) {
        let u = n[i];
        if ((u & 192) != 128) {
          i += e("MISSING_CONTINUE", i, n, r), c = null;
          break;
        }
        c = c << 6 | u & 63, i++;
      }
      if (c !== null) {
        if (c > 1114111) {
          i += e("OUT_OF_RANGE", i - 1 - o, n, r, c);
          continue;
        }
        if (c >= 55296 && c <= 57343) {
          i += e("UTF16_SURROGATE", i - 1 - o, n, r, c);
          continue;
        }
        if (c <= a) {
          i += e("OVERLONG", i - 1 - o, n, r, c);
          continue;
        }
        r.push(c);
      }
    }
    return r;
  }
  function Jr(t, e) {
    re(typeof t == "string", "invalid string value", "str", t);
    let n = [];
    for (let r = 0; r < t.length; r++) {
      const i = t.charCodeAt(r);
      if (i < 128) n.push(i);
      else if (i < 2048) n.push(i >> 6 | 192), n.push(i & 63 | 128);
      else if ((i & 64512) == 55296) {
        r++;
        const s = t.charCodeAt(r);
        re(r < t.length && (s & 64512) === 56320, "invalid surrogate pair", "str", t);
        const o = 65536 + ((i & 1023) << 10) + (s & 1023);
        n.push(o >> 18 | 240), n.push(o >> 12 & 63 | 128), n.push(o >> 6 & 63 | 128), n.push(o & 63 | 128);
      } else n.push(i >> 12 | 224), n.push(i >> 6 & 63 | 128), n.push(i & 63 | 128);
    }
    return new Uint8Array(n);
  }
  function WN(t) {
    return t.map((e) => e <= 65535 ? String.fromCharCode(e) : (e -= 65536, String.fromCharCode((e >> 10 & 1023) + 55296, (e & 1023) + 56320))).join("");
  }
  function K0(t, e) {
    return WN(KN(t, e));
  }
  function mE(t) {
    async function e(n, r) {
      me(r == null || !r.cancelled, "request cancelled before sending", "CANCELLED");
      const i = n.url.split(":")[0].toLowerCase();
      me(i === "http" || i === "https", `unsupported protocol ${i}`, "UNSUPPORTED_OPERATION", {
        info: {
          protocol: i
        },
        operation: "request"
      }), me(i === "https" || !n.credentials || n.allowInsecureAuthentication, "insecure authorized connections unsupported", "UNSUPPORTED_OPERATION", {
        operation: "request"
      });
      let s = null;
      const o = new AbortController(), a = setTimeout(() => {
        s = Qt("request timeout", "TIMEOUT"), o.abort();
      }, n.timeout);
      r && r.addListener(() => {
        s = Qt("request cancelled", "CANCELLED"), o.abort();
      });
      const c = Object.assign({}, t, {
        method: n.method,
        headers: new Headers(Array.from(n)),
        body: n.body || void 0,
        signal: o.signal
      });
      let l;
      try {
        l = await fetch(n.url, c);
      } catch (m) {
        throw clearTimeout(a), s || m;
      }
      clearTimeout(a);
      const u = {};
      l.headers.forEach((m, y) => {
        u[y.toLowerCase()] = m;
      });
      const f = await l.arrayBuffer(), d = f == null ? null : new Uint8Array(f);
      return {
        statusCode: l.status,
        statusMessage: l.statusText,
        headers: u,
        body: d
      };
    }
    return e;
  }
  const qN = 12, YN = 250;
  let f2 = mE();
  const XN = new RegExp("^data:([^;:]*)?(;base64)?,(.*)$", "i"), ZN = new RegExp("^ipfs://(ipfs/)?(.*)$", "i");
  let Sp = false;
  async function yE(t, e) {
    try {
      const n = t.match(XN);
      if (!n) throw new Error("invalid data");
      return new Io(200, "OK", {
        "content-type": n[1] || "text/plain"
      }, n[2] ? VN(n[3]) : eO(n[3]));
    } catch {
      return new Io(599, "BAD REQUEST (invalid data: URI)", {}, null, new Ls(t));
    }
  }
  function bE(t) {
    async function e(n, r) {
      try {
        const i = n.match(ZN);
        if (!i) throw new Error("invalid link");
        return new Ls(`${t}${i[2]}`);
      } catch {
        return new Io(599, "BAD REQUEST (invalid IPFS URI)", {}, null, new Ls(n));
      }
    }
    return e;
  }
  const Hf = {
    data: yE,
    ipfs: bE("https://gateway.ipfs.io/ipfs/")
  }, xE = /* @__PURE__ */ new WeakMap();
  class $N {
    constructor(e) {
      __privateAdd(this, _e3);
      __privateAdd(this, _t);
      __privateSet(this, _e3, []), __privateSet(this, _t, false), xE.set(e, () => {
        if (!__privateGet(this, _t)) {
          __privateSet(this, _t, true);
          for (const n of __privateGet(this, _e3)) setTimeout(() => {
            n();
          }, 0);
          __privateSet(this, _e3, []);
        }
      });
    }
    addListener(e) {
      me(!__privateGet(this, _t), "singal already cancelled", "UNSUPPORTED_OPERATION", {
        operation: "fetchCancelSignal.addCancelListener"
      }), __privateGet(this, _e3).push(e);
    }
    get cancelled() {
      return __privateGet(this, _t);
    }
    checkSignal() {
      me(!this.cancelled, "cancelled", "CANCELLED", {});
    }
  }
  _e3 = new WeakMap();
  _t = new WeakMap();
  function Gf(t) {
    if (t == null) throw new Error("missing signal; should not happen");
    return t.checkSignal(), t;
  }
  const _Ls = class _Ls {
    constructor(e) {
      __privateAdd(this, _Ls_instances);
      __privateAdd(this, _e4);
      __privateAdd(this, _t2);
      __privateAdd(this, _n2);
      __privateAdd(this, _r2);
      __privateAdd(this, _i2);
      __privateAdd(this, _o2);
      __privateAdd(this, _s2);
      __privateAdd(this, _a2);
      __privateAdd(this, _f2);
      __privateAdd(this, _l2);
      __privateAdd(this, _p2);
      __privateAdd(this, _g2);
      __privateAdd(this, _c2);
      __privateAdd(this, _u2);
      __privateAdd(this, _d2);
      __privateSet(this, _o2, String(e)), __privateSet(this, _e4, false), __privateSet(this, _t2, true), __privateSet(this, _n2, {}), __privateSet(this, _r2, ""), __privateSet(this, _i2, 3e5), __privateSet(this, _u2, {
        slotInterval: YN,
        maxAttempts: qN
      }), __privateSet(this, _d2, null);
    }
    get url() {
      return __privateGet(this, _o2);
    }
    set url(e) {
      __privateSet(this, _o2, String(e));
    }
    get body() {
      return __privateGet(this, _s2) == null ? null : new Uint8Array(__privateGet(this, _s2));
    }
    set body(e) {
      if (e == null) __privateSet(this, _s2, void 0), __privateSet(this, _a2, void 0);
      else if (typeof e == "string") __privateSet(this, _s2, Jr(e)), __privateSet(this, _a2, "text/plain");
      else if (e instanceof Uint8Array) __privateSet(this, _s2, e), __privateSet(this, _a2, "application/octet-stream");
      else if (typeof e == "object") __privateSet(this, _s2, Jr(JSON.stringify(e))), __privateSet(this, _a2, "application/json");
      else throw new Error("invalid body");
    }
    hasBody() {
      return __privateGet(this, _s2) != null;
    }
    get method() {
      return __privateGet(this, _r2) ? __privateGet(this, _r2) : this.hasBody() ? "POST" : "GET";
    }
    set method(e) {
      e == null && (e = ""), __privateSet(this, _r2, String(e).toUpperCase());
    }
    get headers() {
      const e = Object.assign({}, __privateGet(this, _n2));
      return __privateGet(this, _f2) && (e.authorization = `Basic ${zN(Jr(__privateGet(this, _f2)))}`), this.allowGzip && (e["accept-encoding"] = "gzip"), e["content-type"] == null && __privateGet(this, _a2) && (e["content-type"] = __privateGet(this, _a2)), this.body && (e["content-length"] = String(this.body.length)), e;
    }
    getHeader(e) {
      return this.headers[e.toLowerCase()];
    }
    setHeader(e, n) {
      __privateGet(this, _n2)[String(e).toLowerCase()] = String(n);
    }
    clearHeaders() {
      __privateSet(this, _n2, {});
    }
    [Symbol.iterator]() {
      const e = this.headers, n = Object.keys(e);
      let r = 0;
      return {
        next: () => {
          if (r < n.length) {
            const i = n[r++];
            return {
              value: [
                i,
                e[i]
              ],
              done: false
            };
          }
          return {
            value: void 0,
            done: true
          };
        }
      };
    }
    get credentials() {
      return __privateGet(this, _f2) || null;
    }
    setCredentials(e, n) {
      re(!e.match(/:/), "invalid basic authentication username", "username", "[REDACTED]"), __privateSet(this, _f2, `${e}:${n}`);
    }
    get allowGzip() {
      return __privateGet(this, _t2);
    }
    set allowGzip(e) {
      __privateSet(this, _t2, !!e);
    }
    get allowInsecureAuthentication() {
      return !!__privateGet(this, _e4);
    }
    set allowInsecureAuthentication(e) {
      __privateSet(this, _e4, !!e);
    }
    get timeout() {
      return __privateGet(this, _i2);
    }
    set timeout(e) {
      re(e >= 0, "timeout must be non-zero", "timeout", e), __privateSet(this, _i2, e);
    }
    get preflightFunc() {
      return __privateGet(this, _l2) || null;
    }
    set preflightFunc(e) {
      __privateSet(this, _l2, e);
    }
    get processFunc() {
      return __privateGet(this, _p2) || null;
    }
    set processFunc(e) {
      __privateSet(this, _p2, e);
    }
    get retryFunc() {
      return __privateGet(this, _g2) || null;
    }
    set retryFunc(e) {
      __privateSet(this, _g2, e);
    }
    get getUrlFunc() {
      return __privateGet(this, _d2) || f2;
    }
    set getUrlFunc(e) {
      __privateSet(this, _d2, e);
    }
    toString() {
      return `<FetchRequest method=${JSON.stringify(this.method)} url=${JSON.stringify(this.url)} headers=${JSON.stringify(this.headers)} body=${__privateGet(this, _s2) ? Se(__privateGet(this, _s2)) : "null"}>`;
    }
    setThrottleParams(e) {
      e.slotInterval != null && (__privateGet(this, _u2).slotInterval = e.slotInterval), e.maxAttempts != null && (__privateGet(this, _u2).maxAttempts = e.maxAttempts);
    }
    send() {
      return me(__privateGet(this, _c2) == null, "request already sent", "UNSUPPORTED_OPERATION", {
        operation: "fetchRequest.send"
      }), __privateSet(this, _c2, new $N(this)), __privateMethod(this, _Ls_instances, h_fn).call(this, 0, d2() + this.timeout, 0, this, new Io(0, "", {}, null, this));
    }
    cancel() {
      me(__privateGet(this, _c2) != null, "request has not been sent", "UNSUPPORTED_OPERATION", {
        operation: "fetchRequest.cancel"
      });
      const e = xE.get(this);
      if (!e) throw new Error("missing signal; should not happen");
      e();
    }
    redirect(e) {
      const n = this.url.split(":")[0].toLowerCase(), r = e.split(":")[0].toLowerCase();
      me(this.method === "GET" && (n !== "https" || r !== "http") && e.match(/^https?:/), "unsupported redirect", "UNSUPPORTED_OPERATION", {
        operation: `redirect(${this.method} ${JSON.stringify(this.url)} => ${JSON.stringify(e)})`
      });
      const i = new _Ls(e);
      return i.method = "GET", i.allowGzip = this.allowGzip, i.timeout = this.timeout, __privateSet(i, _n2, Object.assign({}, __privateGet(this, _n2))), __privateGet(this, _s2) && __privateSet(i, _s2, new Uint8Array(__privateGet(this, _s2))), __privateSet(i, _a2, __privateGet(this, _a2)), i;
    }
    clone() {
      const e = new _Ls(this.url);
      return __privateSet(e, _r2, __privateGet(this, _r2)), __privateGet(this, _s2) && __privateSet(e, _s2, __privateGet(this, _s2)), __privateSet(e, _a2, __privateGet(this, _a2)), __privateSet(e, _n2, Object.assign({}, __privateGet(this, _n2))), __privateSet(e, _f2, __privateGet(this, _f2)), this.allowGzip && (e.allowGzip = true), e.timeout = this.timeout, this.allowInsecureAuthentication && (e.allowInsecureAuthentication = true), __privateSet(e, _l2, __privateGet(this, _l2)), __privateSet(e, _p2, __privateGet(this, _p2)), __privateSet(e, _g2, __privateGet(this, _g2)), __privateSet(e, _u2, Object.assign({}, __privateGet(this, _u2))), __privateSet(e, _d2, __privateGet(this, _d2)), e;
    }
    static lockConfig() {
      Sp = true;
    }
    static getGateway(e) {
      return Hf[e.toLowerCase()] || null;
    }
    static registerGateway(e, n) {
      if (e = e.toLowerCase(), e === "http" || e === "https") throw new Error(`cannot intercept ${e}; use registerGetUrl`);
      if (Sp) throw new Error("gateways locked");
      Hf[e] = n;
    }
    static registerGetUrl(e) {
      if (Sp) throw new Error("gateways locked");
      f2 = e;
    }
    static createGetUrlFunc(e) {
      return mE(e);
    }
    static createDataGateway() {
      return yE;
    }
    static createIpfsGatewayFunc(e) {
      return bE(e);
    }
  };
  _e4 = new WeakMap();
  _t2 = new WeakMap();
  _n2 = new WeakMap();
  _r2 = new WeakMap();
  _i2 = new WeakMap();
  _o2 = new WeakMap();
  _s2 = new WeakMap();
  _a2 = new WeakMap();
  _f2 = new WeakMap();
  _l2 = new WeakMap();
  _p2 = new WeakMap();
  _g2 = new WeakMap();
  _c2 = new WeakMap();
  _u2 = new WeakMap();
  _d2 = new WeakMap();
  _Ls_instances = new WeakSet();
  h_fn = async function(e, n, r, i, s) {
    var _a6, _b3, _c5;
    if (e >= __privateGet(this, _u2).maxAttempts) return s.makeServerError("exceeded maximum retry limit");
    me(d2() <= n, "timeout", "TIMEOUT", {
      operation: "request.send",
      reason: "timeout",
      request: i
    }), r > 0 && await tO(r);
    let o = this.clone();
    const a = (o.url.split(":")[0] || "").toLowerCase();
    if (a in Hf) {
      const u = await Hf[a](o.url, Gf(__privateGet(i, _c2)));
      if (u instanceof Io) {
        let f = u;
        if (this.processFunc) {
          Gf(__privateGet(i, _c2));
          try {
            f = await this.processFunc(o, f);
          } catch (d) {
            (d.throttle == null || typeof d.stall != "number") && f.makeServerError("error in post-processing function", d).assertOk();
          }
        }
        return f;
      }
      o = u;
    }
    this.preflightFunc && (o = await this.preflightFunc(o));
    const c = await this.getUrlFunc(o, Gf(__privateGet(i, _c2)));
    let l = new Io(c.statusCode, c.statusMessage, c.headers, c.body, i);
    if (l.statusCode === 301 || l.statusCode === 302) {
      try {
        const u = l.headers.location || "";
        return __privateMethod(_a6 = o.redirect(u), _Ls_instances, h_fn).call(_a6, e + 1, n, 0, i, l);
      } catch {
      }
      return l;
    } else if (l.statusCode === 429 && (this.retryFunc == null || await this.retryFunc(o, l, e))) {
      const u = l.headers["retry-after"];
      let f = __privateGet(this, _u2).slotInterval * Math.trunc(Math.random() * Math.pow(2, e));
      return typeof u == "string" && u.match(/^[1-9][0-9]*$/) && (f = parseInt(u)), __privateMethod(_b3 = o.clone(), _Ls_instances, h_fn).call(_b3, e + 1, n, f, i, l);
    }
    if (this.processFunc) {
      Gf(__privateGet(i, _c2));
      try {
        l = await this.processFunc(o, l);
      } catch (u) {
        (u.throttle == null || typeof u.stall != "number") && l.makeServerError("error in post-processing function", u).assertOk();
        let f = __privateGet(this, _u2).slotInterval * Math.trunc(Math.random() * Math.pow(2, e));
        return u.stall >= 0 && (f = u.stall), __privateMethod(_c5 = o.clone(), _Ls_instances, h_fn).call(_c5, e + 1, n, f, i, l);
      }
    }
    return l;
  };
  let Ls = _Ls;
  const _Io = class _Io {
    constructor(e, n, r, i, s) {
      __privateAdd(this, _e5);
      __privateAdd(this, _t3);
      __privateAdd(this, _n3);
      __privateAdd(this, _r3);
      __privateAdd(this, _i3);
      __privateAdd(this, _o3);
      __privateSet(this, _e5, e), __privateSet(this, _t3, n), __privateSet(this, _n3, Object.keys(r).reduce((o, a) => (o[a.toLowerCase()] = String(r[a]), o), {})), __privateSet(this, _r3, i == null ? null : new Uint8Array(i)), __privateSet(this, _i3, s || null), __privateSet(this, _o3, {
        message: ""
      });
    }
    toString() {
      return `<FetchResponse status=${this.statusCode} body=${__privateGet(this, _r3) ? Se(__privateGet(this, _r3)) : "null"}>`;
    }
    get statusCode() {
      return __privateGet(this, _e5);
    }
    get statusMessage() {
      return __privateGet(this, _t3);
    }
    get headers() {
      return Object.assign({}, __privateGet(this, _n3));
    }
    get body() {
      return __privateGet(this, _r3) == null ? null : new Uint8Array(__privateGet(this, _r3));
    }
    get bodyText() {
      try {
        return __privateGet(this, _r3) == null ? "" : K0(__privateGet(this, _r3));
      } catch {
        me(false, "response body is not valid UTF-8 data", "UNSUPPORTED_OPERATION", {
          operation: "bodyText",
          info: {
            response: this
          }
        });
      }
    }
    get bodyJson() {
      try {
        return JSON.parse(this.bodyText);
      } catch {
        me(false, "response body is not valid JSON", "UNSUPPORTED_OPERATION", {
          operation: "bodyJson",
          info: {
            response: this
          }
        });
      }
    }
    [Symbol.iterator]() {
      const e = this.headers, n = Object.keys(e);
      let r = 0;
      return {
        next: () => {
          if (r < n.length) {
            const i = n[r++];
            return {
              value: [
                i,
                e[i]
              ],
              done: false
            };
          }
          return {
            value: void 0,
            done: true
          };
        }
      };
    }
    makeServerError(e, n) {
      let r;
      e ? r = `CLIENT ESCALATED SERVER ERROR (${this.statusCode} ${this.statusMessage}; ${e})` : (e = `${this.statusCode} ${this.statusMessage}`, r = `CLIENT ESCALATED SERVER ERROR (${e})`);
      const i = new _Io(599, r, this.headers, this.body, __privateGet(this, _i3) || void 0);
      return __privateSet(i, _o3, {
        message: e,
        error: n
      }), i;
    }
    throwThrottleError(e, n) {
      n == null ? n = -1 : re(Number.isInteger(n) && n >= 0, "invalid stall timeout", "stall", n);
      const r = new Error(e || "throttling requests");
      throw Me(r, {
        stall: n,
        throttle: true
      }), r;
    }
    getHeader(e) {
      return this.headers[e.toLowerCase()];
    }
    hasBody() {
      return __privateGet(this, _r3) != null;
    }
    get request() {
      return __privateGet(this, _i3);
    }
    ok() {
      return __privateGet(this, _o3).message === "" && this.statusCode >= 200 && this.statusCode < 300;
    }
    assertOk() {
      if (this.ok()) return;
      let { message: e, error: n } = __privateGet(this, _o3);
      e === "" && (e = `server response ${this.statusCode} ${this.statusMessage}`);
      let r = null;
      this.request && (r = this.request.url);
      let i = null;
      try {
        __privateGet(this, _r3) && (i = K0(__privateGet(this, _r3)));
      } catch {
      }
      me(false, e, "SERVER_ERROR", {
        request: this.request || "unknown request",
        response: this,
        error: n,
        info: {
          requestUrl: r,
          responseBody: i,
          responseStatus: `${this.statusCode} ${this.statusMessage}`
        }
      });
    }
  };
  _e5 = new WeakMap();
  _t3 = new WeakMap();
  _n3 = new WeakMap();
  _r3 = new WeakMap();
  _i3 = new WeakMap();
  _o3 = new WeakMap();
  let Io = _Io;
  function d2() {
    return (/* @__PURE__ */ new Date()).getTime();
  }
  function eO(t) {
    return Jr(t.replace(/%([0-9a-f][0-9a-f])/gi, (e, n) => String.fromCharCode(parseInt(n, 16))));
  }
  function tO(t) {
    return new Promise((e) => setTimeout(e, t));
  }
  const nO = BigInt(-1), ai = BigInt(0), Sc = BigInt(1), rO = BigInt(5), Za = {};
  let kc = "0000";
  for (; kc.length < 80; ) kc += kc;
  function ra(t) {
    let e = kc;
    for (; e.length < t; ) e += e;
    return BigInt("1" + e.substring(0, t));
  }
  function Hl(t, e, n) {
    const r = BigInt(e.width);
    if (e.signed) {
      const i = Sc << r - Sc;
      me(n == null || t >= -i && t < i, "overflow", "NUMERIC_FAULT", {
        operation: n,
        fault: "overflow",
        value: t
      }), t > ai ? t = J0(ha(t, r), r) : t = -J0(ha(-t, r), r);
    } else {
      const i = Sc << r;
      me(n == null || t >= 0 && t < i, "overflow", "NUMERIC_FAULT", {
        operation: n,
        fault: "overflow",
        value: t
      }), t = (t % i + i) % i & i - Sc;
    }
    return t;
  }
  function Tp(t) {
    typeof t == "number" && (t = `fixed128x${t}`);
    let e = true, n = 128, r = 18;
    if (typeof t == "string") {
      if (t !== "fixed") if (t === "ufixed") e = false;
      else {
        const s = t.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);
        re(s, "invalid fixed format", "format", t), e = s[1] !== "u", n = parseInt(s[2]), r = parseInt(s[3]);
      }
    } else if (t) {
      const s = t, o = (a, c, l) => s[a] == null ? l : (re(typeof s[a] === c, "invalid fixed format (" + a + " not " + c + ")", "format." + a, s[a]), s[a]);
      e = o("signed", "boolean", e), n = o("width", "number", n), r = o("decimals", "number", r);
    }
    re(n % 8 === 0, "invalid FixedNumber width (not byte aligned)", "format.width", n), re(r <= 80, "invalid FixedNumber decimals (too large)", "format.decimals", r);
    const i = (e ? "" : "u") + "fixed" + String(n) + "x" + String(r);
    return {
      signed: e,
      width: n,
      decimals: r,
      name: i
    };
  }
  function iO(t, e) {
    let n = "";
    t < ai && (n = "-", t *= nO);
    let r = t.toString();
    if (e === 0) return n + r;
    for (; r.length <= e; ) r = kc + r;
    const i = r.length - e;
    for (r = r.substring(0, i) + "." + r.substring(i); r[0] === "0" && r[1] !== "."; ) r = r.substring(1);
    for (; r[r.length - 1] === "0" && r[r.length - 2] !== "."; ) r = r.substring(0, r.length - 1);
    return n + r;
  }
  let AE = (_a3 = class {
    constructor(e, n, r) {
      __privateAdd(this, _oa_instances);
      __publicField(this, "format");
      __privateAdd(this, _e6);
      __privateAdd(this, _t4);
      __privateAdd(this, _n4);
      __publicField(this, "_value");
      ff(e, Za, "FixedNumber"), __privateSet(this, _t4, n), __privateSet(this, _e6, r);
      const i = iO(n, r.decimals);
      Me(this, {
        format: r.name,
        _value: i
      }), __privateSet(this, _n4, ra(r.decimals));
    }
    get signed() {
      return __privateGet(this, _e6).signed;
    }
    get width() {
      return __privateGet(this, _e6).width;
    }
    get decimals() {
      return __privateGet(this, _e6).decimals;
    }
    get value() {
      return __privateGet(this, _t4);
    }
    addUnsafe(e) {
      return __privateMethod(this, _oa_instances, o_fn).call(this, e);
    }
    add(e) {
      return __privateMethod(this, _oa_instances, o_fn).call(this, e, "add");
    }
    subUnsafe(e) {
      return __privateMethod(this, _oa_instances, s_fn).call(this, e);
    }
    sub(e) {
      return __privateMethod(this, _oa_instances, s_fn).call(this, e, "sub");
    }
    mulUnsafe(e) {
      return __privateMethod(this, _oa_instances, a_fn).call(this, e);
    }
    mul(e) {
      return __privateMethod(this, _oa_instances, a_fn).call(this, e, "mul");
    }
    mulSignal(e) {
      __privateMethod(this, _oa_instances, r_fn).call(this, e);
      const n = __privateGet(this, _t4) * __privateGet(e, _t4);
      return me(n % __privateGet(this, _n4) === ai, "precision lost during signalling mul", "NUMERIC_FAULT", {
        operation: "mulSignal",
        fault: "underflow",
        value: this
      }), __privateMethod(this, _oa_instances, i_fn).call(this, n / __privateGet(this, _n4), "mulSignal");
    }
    divUnsafe(e) {
      return __privateMethod(this, _oa_instances, f_fn).call(this, e);
    }
    div(e) {
      return __privateMethod(this, _oa_instances, f_fn).call(this, e, "div");
    }
    divSignal(e) {
      me(__privateGet(e, _t4) !== ai, "division by zero", "NUMERIC_FAULT", {
        operation: "div",
        fault: "divide-by-zero",
        value: this
      }), __privateMethod(this, _oa_instances, r_fn).call(this, e);
      const n = __privateGet(this, _t4) * __privateGet(this, _n4);
      return me(n % __privateGet(e, _t4) === ai, "precision lost during signalling div", "NUMERIC_FAULT", {
        operation: "divSignal",
        fault: "underflow",
        value: this
      }), __privateMethod(this, _oa_instances, i_fn).call(this, n / __privateGet(e, _t4), "divSignal");
    }
    cmp(e) {
      let n = this.value, r = e.value;
      const i = this.decimals - e.decimals;
      return i > 0 ? r *= ra(i) : i < 0 && (n *= ra(-i)), n < r ? -1 : n > r ? 1 : 0;
    }
    eq(e) {
      return this.cmp(e) === 0;
    }
    lt(e) {
      return this.cmp(e) < 0;
    }
    lte(e) {
      return this.cmp(e) <= 0;
    }
    gt(e) {
      return this.cmp(e) > 0;
    }
    gte(e) {
      return this.cmp(e) >= 0;
    }
    floor() {
      let e = __privateGet(this, _t4);
      return __privateGet(this, _t4) < ai && (e -= __privateGet(this, _n4) - Sc), e = __privateGet(this, _t4) / __privateGet(this, _n4) * __privateGet(this, _n4), __privateMethod(this, _oa_instances, i_fn).call(this, e, "floor");
    }
    ceiling() {
      let e = __privateGet(this, _t4);
      return __privateGet(this, _t4) > ai && (e += __privateGet(this, _n4) - Sc), e = __privateGet(this, _t4) / __privateGet(this, _n4) * __privateGet(this, _n4), __privateMethod(this, _oa_instances, i_fn).call(this, e, "ceiling");
    }
    round(e) {
      if (e == null && (e = 0), e >= this.decimals) return this;
      const n = this.decimals - e, r = rO * ra(n - 1);
      let i = this.value + r;
      const s = ra(n);
      return i = i / s * s, Hl(i, __privateGet(this, _e6), "round"), new _a3(Za, i, __privateGet(this, _e6));
    }
    isZero() {
      return __privateGet(this, _t4) === ai;
    }
    isNegative() {
      return __privateGet(this, _t4) < ai;
    }
    toString() {
      return this._value;
    }
    toUnsafeFloat() {
      return parseFloat(this.toString());
    }
    toFormat(e) {
      return _a3.fromString(this.toString(), e);
    }
    static fromValue(e, n, r) {
      const i = n == null ? 0 : Qe(n), s = Tp(r);
      let o = Pe(e, "value");
      const a = i - s.decimals;
      if (a > 0) {
        const c = ra(a);
        me(o % c === ai, "value loses precision for format", "NUMERIC_FAULT", {
          operation: "fromValue",
          fault: "underflow",
          value: e
        }), o /= c;
      } else a < 0 && (o *= ra(-a));
      return Hl(o, s, "fromValue"), new _a3(Za, o, s);
    }
    static fromString(e, n) {
      const r = e.match(/^(-?)([0-9]*)\.?([0-9]*)$/);
      re(r && r[2].length + r[3].length > 0, "invalid FixedNumber string value", "value", e);
      const i = Tp(n);
      let s = r[2] || "0", o = r[3] || "";
      for (; o.length < i.decimals; ) o += kc;
      me(o.substring(i.decimals).match(/^0*$/), "too many decimals for format", "NUMERIC_FAULT", {
        operation: "fromString",
        fault: "underflow",
        value: e
      }), o = o.substring(0, i.decimals);
      const a = BigInt(r[1] + s + o);
      return Hl(a, i, "fromString"), new _a3(Za, a, i);
    }
    static fromBytes(e, n) {
      let r = jd(Je(e, "value"));
      const i = Tp(n);
      return i.signed && (r = J0(r, i.width)), Hl(r, i, "fromBytes"), new _a3(Za, r, i);
    }
  }, _e6 = new WeakMap(), _t4 = new WeakMap(), _n4 = new WeakMap(), _oa_instances = new WeakSet(), r_fn = function(e) {
    re(this.format === e.format, "incompatible format; use fixedNumber.toFormat", "other", e);
  }, i_fn = function(e, n) {
    return e = Hl(e, __privateGet(this, _e6), n), new _a3(Za, e, __privateGet(this, _e6));
  }, o_fn = function(e, n) {
    return __privateMethod(this, _oa_instances, r_fn).call(this, e), __privateMethod(this, _oa_instances, i_fn).call(this, __privateGet(this, _t4) + __privateGet(e, _t4), n);
  }, s_fn = function(e, n) {
    return __privateMethod(this, _oa_instances, r_fn).call(this, e), __privateMethod(this, _oa_instances, i_fn).call(this, __privateGet(this, _t4) - __privateGet(e, _t4), n);
  }, a_fn = function(e, n) {
    return __privateMethod(this, _oa_instances, r_fn).call(this, e), __privateMethod(this, _oa_instances, i_fn).call(this, __privateGet(this, _t4) * __privateGet(e, _t4) / __privateGet(this, _n4), n);
  }, f_fn = function(e, n) {
    return me(__privateGet(e, _t4) !== ai, "division by zero", "NUMERIC_FAULT", {
      operation: "div",
      fault: "divide-by-zero",
      value: this
    }), __privateMethod(this, _oa_instances, r_fn).call(this, e), __privateMethod(this, _oa_instances, i_fn).call(this, __privateGet(this, _t4) * __privateGet(this, _n4) / __privateGet(e, _t4), n);
  }, _a3);
  function sO(t) {
    let e = t.toString(16);
    for (; e.length < 2; ) e = "0" + e;
    return "0x" + e;
  }
  function h2(t, e, n) {
    let r = 0;
    for (let i = 0; i < n; i++) r = r * 256 + t[e + i];
    return r;
  }
  function p2(t, e, n, r) {
    const i = [];
    for (; n < e + 1 + r; ) {
      const s = wE(t, n);
      i.push(s.result), n += s.consumed, me(n <= e + 1 + r, "child data too short", "BUFFER_OVERRUN", {
        buffer: t,
        length: r,
        offset: e
      });
    }
    return {
      consumed: 1 + r,
      result: i
    };
  }
  function wE(t, e) {
    me(t.length !== 0, "data too short", "BUFFER_OVERRUN", {
      buffer: t,
      length: 0,
      offset: 1
    });
    const n = (r) => {
      me(r <= t.length, "data short segment too short", "BUFFER_OVERRUN", {
        buffer: t,
        length: t.length,
        offset: r
      });
    };
    if (t[e] >= 248) {
      const r = t[e] - 247;
      n(e + 1 + r);
      const i = h2(t, e + 1, r);
      return n(e + 1 + r + i), p2(t, e, e + 1 + r, r + i);
    } else if (t[e] >= 192) {
      const r = t[e] - 192;
      return n(e + 1 + r), p2(t, e, e + 1, r);
    } else if (t[e] >= 184) {
      const r = t[e] - 183;
      n(e + 1 + r);
      const i = h2(t, e + 1, r);
      n(e + 1 + r + i);
      const s = Se(t.slice(e + 1 + r, e + 1 + r + i));
      return {
        consumed: 1 + r + i,
        result: s
      };
    } else if (t[e] >= 128) {
      const r = t[e] - 128;
      n(e + 1 + r);
      const i = Se(t.slice(e + 1, e + 1 + r));
      return {
        consumed: 1 + r,
        result: i
      };
    }
    return {
      consumed: 1,
      result: sO(t[e])
    };
  }
  function df(t) {
    const e = Je(t, "data"), n = wE(e, 0);
    return re(n.consumed === e.length, "unexpected junk after rlp payload", "data", t), n.result;
  }
  function g2(t) {
    const e = [];
    for (; t; ) e.unshift(t & 255), t >>= 8;
    return e;
  }
  function vE(t) {
    if (Array.isArray(t)) {
      let r = [];
      if (t.forEach(function(s) {
        r = r.concat(vE(s));
      }), r.length <= 55) return r.unshift(192 + r.length), r;
      const i = g2(r.length);
      return i.unshift(247 + i.length), i.concat(r);
    }
    const e = Array.prototype.slice.call(Je(t, "object"));
    if (e.length === 1 && e[0] <= 127) return e;
    if (e.length <= 55) return e.unshift(128 + e.length), e;
    const n = g2(e.length);
    return n.unshift(183 + n.length), n.concat(e);
  }
  const m2 = "0123456789abcdef";
  function Oo(t) {
    let e = "0x";
    for (const n of vE(t)) e += m2[n >> 4], e += m2[n & 15];
    return e;
  }
  const oO = [
    "wei",
    "kwei",
    "mwei",
    "gwei",
    "szabo",
    "finney",
    "ether"
  ];
  function aO(t, e) {
    let n = 18;
    return n = Qe(e, "unit"), AE.fromValue(t, n, {
      decimals: n,
      width: 512
    }).toString();
  }
  function EE(t, e) {
    re(typeof t == "string", "value must be a string", "value", t);
    let n = 18;
    if (typeof e == "string") {
      const r = oO.indexOf(e);
      re(r >= 0, "invalid unit", "unit", e), n = 3 * r;
    } else e != null && (n = Qe(e, "unit"));
    return AE.fromString(t, {
      decimals: n,
      width: 512
    }).value;
  }
  function cO(t) {
    return aO(t, 18);
  }
  const ir = 32, lm = new Uint8Array(ir), lO = [
    "then"
  ], Vf = {}, SE = /* @__PURE__ */ new WeakMap();
  function ca(t) {
    return SE.get(t);
  }
  function y2(t, e) {
    SE.set(t, e);
  }
  function Gl(t, e) {
    const n = new Error(`deferred error during ABI decoding triggered accessing ${t}`);
    throw n.error = e, n;
  }
  function um(t, e, n) {
    return t.indexOf(null) >= 0 ? e.map((r, i) => r instanceof _s ? um(ca(r), r, n) : r) : t.reduce((r, i, s) => {
      let o = e.getValue(i);
      return i in r || (n && o instanceof _s && (o = um(ca(o), o, n)), r[i] = o), r;
    }, {});
  }
  const __s = class __s extends Array {
    constructor(...e) {
      const n = e[0];
      let r = e[1], i = (e[2] || []).slice(), s = true;
      n !== Vf && (r = e, i = [], s = false);
      super(r.length);
      __privateAdd(this, _e7);
      r.forEach((c, l) => {
        this[l] = c;
      });
      const o = i.reduce((c, l) => (typeof l == "string" && c.set(l, (c.get(l) || 0) + 1), c), /* @__PURE__ */ new Map());
      if (y2(this, Object.freeze(r.map((c, l) => {
        const u = i[l];
        return u != null && o.get(u) === 1 ? u : null;
      }))), __privateSet(this, _e7, []), __privateGet(this, _e7) == null && __privateGet(this, _e7), !s) return;
      Object.freeze(this);
      const a = new Proxy(this, {
        get: (c, l, u) => {
          if (typeof l == "string") {
            if (l.match(/^[0-9]+$/)) {
              const d = Qe(l, "%index");
              if (d < 0 || d >= this.length) throw new RangeError("out of result range");
              const m = c[d];
              return m instanceof Error && Gl(`index ${d}`, m), m;
            }
            if (lO.indexOf(l) >= 0) return Reflect.get(c, l, u);
            const f = c[l];
            if (f instanceof Function) return function(...d) {
              return f.apply(this === u ? c : this, d);
            };
            if (!(l in c)) return c.getValue.apply(this === u ? c : this, [
              l
            ]);
          }
          return Reflect.get(c, l, u);
        }
      });
      return y2(a, ca(this)), a;
    }
    toArray(e) {
      const n = [];
      return this.forEach((r, i) => {
        r instanceof Error && Gl(`index ${i}`, r), e && r instanceof __s && (r = r.toArray(e)), n.push(r);
      }), n;
    }
    toObject(e) {
      const n = ca(this);
      return n.reduce((r, i, s) => (me(i != null, `value at index ${s} unnamed`, "UNSUPPORTED_OPERATION", {
        operation: "toObject()"
      }), um(n, this, e)), {});
    }
    slice(e, n) {
      e == null && (e = 0), e < 0 && (e += this.length, e < 0 && (e = 0)), n == null && (n = this.length), n < 0 && (n += this.length, n < 0 && (n = 0)), n > this.length && (n = this.length);
      const r = ca(this), i = [], s = [];
      for (let o = e; o < n; o++) i.push(this[o]), s.push(r[o]);
      return new __s(Vf, i, s);
    }
    filter(e, n) {
      const r = ca(this), i = [], s = [];
      for (let o = 0; o < this.length; o++) {
        const a = this[o];
        a instanceof Error && Gl(`index ${o}`, a), e.call(n, a, o, this) && (i.push(a), s.push(r[o]));
      }
      return new __s(Vf, i, s);
    }
    map(e, n) {
      const r = [];
      for (let i = 0; i < this.length; i++) {
        const s = this[i];
        s instanceof Error && Gl(`index ${i}`, s), r.push(e.call(n, s, i, this));
      }
      return r;
    }
    getValue(e) {
      const n = ca(this).indexOf(e);
      if (n === -1) return;
      const r = this[n];
      return r instanceof Error && Gl(`property ${JSON.stringify(e)}`, r.error), r;
    }
    static fromItems(e, n) {
      return new __s(Vf, e, n);
    }
  };
  _e7 = new WeakMap();
  let _s = __s;
  function b2(t) {
    let e = hn(t);
    return me(e.length <= ir, "value out-of-bounds", "BUFFER_OVERRUN", {
      buffer: e,
      length: ir,
      offset: e.length
    }), e.length !== ir && (e = tr(Xt([
      lm.slice(e.length % ir),
      e
    ]))), e;
  }
  let js = class {
    constructor(e, n, r, i) {
      __publicField(this, "name");
      __publicField(this, "type");
      __publicField(this, "localName");
      __publicField(this, "dynamic");
      Me(this, {
        name: e,
        type: n,
        localName: r,
        dynamic: i
      }, {
        name: "string",
        type: "string",
        localName: "string",
        dynamic: "boolean"
      });
    }
    _throwError(e, n) {
      re(false, e, this.localName, n);
    }
  }, fm = (_b2 = class {
    constructor() {
      __privateAdd(this, _fm_instances);
      __privateAdd(this, _e8);
      __privateAdd(this, _t5);
      __privateSet(this, _e8, []), __privateSet(this, _t5, 0);
    }
    get data() {
      return Xt(__privateGet(this, _e8));
    }
    get length() {
      return __privateGet(this, _t5);
    }
    appendWriter(e) {
      return __privateMethod(this, _fm_instances, n_fn).call(this, tr(e.data));
    }
    writeBytes(e) {
      let n = tr(e);
      const r = n.length % ir;
      return r && (n = tr(Xt([
        n,
        lm.slice(r)
      ]))), __privateMethod(this, _fm_instances, n_fn).call(this, n);
    }
    writeValue(e) {
      return __privateMethod(this, _fm_instances, n_fn).call(this, b2(e));
    }
    writeUpdatableValue() {
      const e = __privateGet(this, _e8).length;
      return __privateGet(this, _e8).push(lm), __privateSet(this, _t5, __privateGet(this, _t5) + ir), (n) => {
        __privateGet(this, _e8)[e] = b2(n);
      };
    }
  }, _e8 = new WeakMap(), _t5 = new WeakMap(), _fm_instances = new WeakSet(), n_fn = function(e) {
    return __privateGet(this, _e8).push(e), __privateSet(this, _t5, __privateGet(this, _t5) + e.length), e.length;
  }, _b2), uO = (_c3 = class {
    constructor(e, n, r) {
      __privateAdd(this, _TE_instances);
      __publicField(this, "allowLoose");
      __privateAdd(this, _e9);
      __privateAdd(this, _t6);
      __privateAdd(this, _n5);
      __privateAdd(this, _r4);
      __privateAdd(this, _i4);
      Me(this, {
        allowLoose: !!n
      }), __privateSet(this, _e9, tr(e)), __privateSet(this, _n5, 0), __privateSet(this, _r4, null), __privateSet(this, _i4, r ?? 1024), __privateSet(this, _t6, 0);
    }
    get data() {
      return Se(__privateGet(this, _e9));
    }
    get dataLength() {
      return __privateGet(this, _e9).length;
    }
    get consumed() {
      return __privateGet(this, _t6);
    }
    get bytes() {
      return new Uint8Array(__privateGet(this, _e9));
    }
    subReader(e) {
      const n = new _c3(__privateGet(this, _e9).slice(__privateGet(this, _t6) + e), this.allowLoose, __privateGet(this, _i4));
      return __privateSet(n, _r4, this), n;
    }
    readBytes(e, n) {
      let r = __privateMethod(this, _TE_instances, s_fn2).call(this, 0, e, !!n);
      return __privateMethod(this, _TE_instances, o_fn2).call(this, e), __privateSet(this, _t6, __privateGet(this, _t6) + r.length), r.slice(0, e);
    }
    readValue() {
      return jd(this.readBytes(ir));
    }
    readIndex() {
      return HN(this.readBytes(ir));
    }
  }, _e9 = new WeakMap(), _t6 = new WeakMap(), _n5 = new WeakMap(), _r4 = new WeakMap(), _i4 = new WeakMap(), _TE_instances = new WeakSet(), o_fn2 = function(e) {
    var _a6;
    if (__privateGet(this, _r4)) return __privateMethod(_a6 = __privateGet(this, _r4), _TE_instances, o_fn2).call(_a6, e);
    __privateSet(this, _n5, __privateGet(this, _n5) + e), me(__privateGet(this, _i4) < 1 || __privateGet(this, _n5) <= __privateGet(this, _i4) * this.dataLength, `compressed ABI data exceeds inflation ratio of ${__privateGet(this, _i4)} ( see: https://github.com/ethers-io/ethers.js/issues/4537 )`, "BUFFER_OVERRUN", {
      buffer: tr(__privateGet(this, _e9)),
      offset: __privateGet(this, _t6),
      length: e,
      info: {
        bytesRead: __privateGet(this, _n5),
        dataLength: this.dataLength
      }
    });
  }, s_fn2 = function(e, n, r) {
    let i = Math.ceil(n / ir) * ir;
    return __privateGet(this, _t6) + i > __privateGet(this, _e9).length && (this.allowLoose && r && __privateGet(this, _t6) + n <= __privateGet(this, _e9).length ? i = n : me(false, "data out-of-bounds", "BUFFER_OVERRUN", {
      buffer: tr(__privateGet(this, _e9)),
      length: __privateGet(this, _e9).length,
      offset: __privateGet(this, _t6) + i
    })), __privateGet(this, _e9).slice(__privateGet(this, _t6), __privateGet(this, _t6) + i);
  }, _c3);
  function W0(t) {
    if (!Number.isSafeInteger(t) || t < 0) throw new Error(`Wrong positive integer: ${t}`);
  }
  function $1(t, ...e) {
    if (!(t instanceof Uint8Array)) throw new Error("Expected Uint8Array");
    if (e.length > 0 && !e.includes(t.length)) throw new Error(`Expected Uint8Array of length ${e}, not of length=${t.length}`);
  }
  function fO(t) {
    if (typeof t != "function" || typeof t.create != "function") throw new Error("Hash should be wrapped by utils.wrapConstructor");
    W0(t.outputLen), W0(t.blockLen);
  }
  function Zc(t, e = true) {
    if (t.destroyed) throw new Error("Hash instance has been destroyed");
    if (e && t.finished) throw new Error("Hash#digest() has already been called");
  }
  function CE(t, e) {
    $1(t);
    const n = e.outputLen;
    if (t.length < n) throw new Error(`digestInto() expects output buffer of length at least ${n}`);
  }
  const Cp = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
  const IE = (t) => t instanceof Uint8Array, dO = (t) => new Uint32Array(t.buffer, t.byteOffset, Math.floor(t.byteLength / 4)), Ip = (t) => new DataView(t.buffer, t.byteOffset, t.byteLength), Ii = (t, e) => t << 32 - e | t >>> e, hO = new Uint8Array(new Uint32Array([
    287454020
  ]).buffer)[0] === 68;
  if (!hO) throw new Error("Non little-endian hardware is not supported");
  function pO(t) {
    if (typeof t != "string") throw new Error(`utf8ToBytes expected string, got ${typeof t}`);
    return new Uint8Array(new TextEncoder().encode(t));
  }
  function Jd(t) {
    if (typeof t == "string" && (t = pO(t)), !IE(t)) throw new Error(`expected Uint8Array, got ${typeof t}`);
    return t;
  }
  function gO(...t) {
    const e = new Uint8Array(t.reduce((r, i) => r + i.length, 0));
    let n = 0;
    return t.forEach((r) => {
      if (!IE(r)) throw new Error("Uint8Array expected");
      e.set(r, n), n += r.length;
    }), e;
  }
  class ey {
    clone() {
      return this._cloneInto();
    }
  }
  function ty(t) {
    const e = (r) => t().update(Jd(r)).digest(), n = t();
    return e.outputLen = n.outputLen, e.blockLen = n.blockLen, e.create = () => t(), e;
  }
  function mO(t = 32) {
    if (Cp && typeof Cp.getRandomValues == "function") return Cp.getRandomValues(new Uint8Array(t));
    throw new Error("crypto.getRandomValues must be defined");
  }
  class PE extends ey {
    constructor(e, n) {
      super(), this.finished = false, this.destroyed = false, fO(e);
      const r = Jd(n);
      if (this.iHash = e.create(), typeof this.iHash.update != "function") throw new Error("Expected instance of class which extends utils.Hash");
      this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
      const i = this.blockLen, s = new Uint8Array(i);
      s.set(r.length > i ? e.create().update(r).digest() : r);
      for (let o = 0; o < s.length; o++) s[o] ^= 54;
      this.iHash.update(s), this.oHash = e.create();
      for (let o = 0; o < s.length; o++) s[o] ^= 106;
      this.oHash.update(s), s.fill(0);
    }
    update(e) {
      return Zc(this), this.iHash.update(e), this;
    }
    digestInto(e) {
      Zc(this), $1(e, this.outputLen), this.finished = true, this.iHash.digestInto(e), this.oHash.update(e), this.oHash.digestInto(e), this.destroy();
    }
    digest() {
      const e = new Uint8Array(this.oHash.outputLen);
      return this.digestInto(e), e;
    }
    _cloneInto(e) {
      e || (e = Object.create(Object.getPrototypeOf(this), {}));
      const { oHash: n, iHash: r, finished: i, destroyed: s, blockLen: o, outputLen: a } = this;
      return e = e, e.finished = i, e.destroyed = s, e.blockLen = o, e.outputLen = a, e.oHash = n._cloneInto(e.oHash), e.iHash = r._cloneInto(e.iHash), e;
    }
    destroy() {
      this.destroyed = true, this.oHash.destroy(), this.iHash.destroy();
    }
  }
  const _E = (t, e, n) => new PE(t, e).update(n).digest();
  _E.create = (t, e) => new PE(t, e);
  function yO(t, e, n, r) {
    if (typeof t.setBigUint64 == "function") return t.setBigUint64(e, n, r);
    const i = BigInt(32), s = BigInt(4294967295), o = Number(n >> i & s), a = Number(n & s), c = r ? 4 : 0, l = r ? 0 : 4;
    t.setUint32(e + c, o, r), t.setUint32(e + l, a, r);
  }
  class RE extends ey {
    constructor(e, n, r, i) {
      super(), this.blockLen = e, this.outputLen = n, this.padOffset = r, this.isLE = i, this.finished = false, this.length = 0, this.pos = 0, this.destroyed = false, this.buffer = new Uint8Array(e), this.view = Ip(this.buffer);
    }
    update(e) {
      Zc(this);
      const { view: n, buffer: r, blockLen: i } = this;
      e = Jd(e);
      const s = e.length;
      for (let o = 0; o < s; ) {
        const a = Math.min(i - this.pos, s - o);
        if (a === i) {
          const c = Ip(e);
          for (; i <= s - o; o += i) this.process(c, o);
          continue;
        }
        r.set(e.subarray(o, o + a), this.pos), this.pos += a, o += a, this.pos === i && (this.process(n, 0), this.pos = 0);
      }
      return this.length += e.length, this.roundClean(), this;
    }
    digestInto(e) {
      Zc(this), CE(e, this), this.finished = true;
      const { buffer: n, view: r, blockLen: i, isLE: s } = this;
      let { pos: o } = this;
      n[o++] = 128, this.buffer.subarray(o).fill(0), this.padOffset > i - o && (this.process(r, 0), o = 0);
      for (let f = o; f < i; f++) n[f] = 0;
      yO(r, i - 8, BigInt(this.length * 8), s), this.process(r, 0);
      const a = Ip(e), c = this.outputLen;
      if (c % 4) throw new Error("_sha2: outputLen should be aligned to 32bit");
      const l = c / 4, u = this.get();
      if (l > u.length) throw new Error("_sha2: outputLen bigger than state");
      for (let f = 0; f < l; f++) a.setUint32(4 * f, u[f], s);
    }
    digest() {
      const { buffer: e, outputLen: n } = this;
      this.digestInto(e);
      const r = e.slice(0, n);
      return this.destroy(), r;
    }
    _cloneInto(e) {
      e || (e = new this.constructor()), e.set(...this.get());
      const { blockLen: n, buffer: r, length: i, finished: s, destroyed: o, pos: a } = this;
      return e.length = i, e.pos = a, e.finished = s, e.destroyed = o, i % n && e.buffer.set(r), e;
    }
  }
  const bO = (t, e, n) => t & e ^ ~t & n, xO = (t, e, n) => t & e ^ t & n ^ e & n, AO = new Uint32Array([
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ]), ro = new Uint32Array([
    1779033703,
    3144134277,
    1013904242,
    2773480762,
    1359893119,
    2600822924,
    528734635,
    1541459225
  ]), io = new Uint32Array(64);
  let wO = class extends RE {
    constructor() {
      super(64, 32, 8, false), this.A = ro[0] | 0, this.B = ro[1] | 0, this.C = ro[2] | 0, this.D = ro[3] | 0, this.E = ro[4] | 0, this.F = ro[5] | 0, this.G = ro[6] | 0, this.H = ro[7] | 0;
    }
    get() {
      const { A: e, B: n, C: r, D: i, E: s, F: o, G: a, H: c } = this;
      return [
        e,
        n,
        r,
        i,
        s,
        o,
        a,
        c
      ];
    }
    set(e, n, r, i, s, o, a, c) {
      this.A = e | 0, this.B = n | 0, this.C = r | 0, this.D = i | 0, this.E = s | 0, this.F = o | 0, this.G = a | 0, this.H = c | 0;
    }
    process(e, n) {
      for (let f = 0; f < 16; f++, n += 4) io[f] = e.getUint32(n, false);
      for (let f = 16; f < 64; f++) {
        const d = io[f - 15], m = io[f - 2], y = Ii(d, 7) ^ Ii(d, 18) ^ d >>> 3, x = Ii(m, 17) ^ Ii(m, 19) ^ m >>> 10;
        io[f] = x + io[f - 7] + y + io[f - 16] | 0;
      }
      let { A: r, B: i, C: s, D: o, E: a, F: c, G: l, H: u } = this;
      for (let f = 0; f < 64; f++) {
        const d = Ii(a, 6) ^ Ii(a, 11) ^ Ii(a, 25), m = u + d + bO(a, c, l) + AO[f] + io[f] | 0, x = (Ii(r, 2) ^ Ii(r, 13) ^ Ii(r, 22)) + xO(r, i, s) | 0;
        u = l, l = c, c = a, a = o + m | 0, o = s, s = i, i = r, r = m + x | 0;
      }
      r = r + this.A | 0, i = i + this.B | 0, s = s + this.C | 0, o = o + this.D | 0, a = a + this.E | 0, c = c + this.F | 0, l = l + this.G | 0, u = u + this.H | 0, this.set(r, i, s, o, a, c, l, u);
    }
    roundClean() {
      io.fill(0);
    }
    destroy() {
      this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
    }
  };
  const NE = ty(() => new wO()), zf = BigInt(2 ** 32 - 1), dm = BigInt(32);
  function OE(t, e = false) {
    return e ? {
      h: Number(t & zf),
      l: Number(t >> dm & zf)
    } : {
      h: Number(t >> dm & zf) | 0,
      l: Number(t & zf) | 0
    };
  }
  function BE(t, e = false) {
    let n = new Uint32Array(t.length), r = new Uint32Array(t.length);
    for (let i = 0; i < t.length; i++) {
      const { h: s, l: o } = OE(t[i], e);
      [n[i], r[i]] = [
        s,
        o
      ];
    }
    return [
      n,
      r
    ];
  }
  const vO = (t, e) => BigInt(t >>> 0) << dm | BigInt(e >>> 0), EO = (t, e, n) => t >>> n, SO = (t, e, n) => t << 32 - n | e >>> n, TO = (t, e, n) => t >>> n | e << 32 - n, CO = (t, e, n) => t << 32 - n | e >>> n, IO = (t, e, n) => t << 64 - n | e >>> n - 32, PO = (t, e, n) => t >>> n - 32 | e << 64 - n, _O = (t, e) => e, RO = (t, e) => t, ME = (t, e, n) => t << n | e >>> 32 - n, kE = (t, e, n) => e << n | t >>> 32 - n, FE = (t, e, n) => e << n - 32 | t >>> 64 - n, LE = (t, e, n) => t << n - 32 | e >>> 64 - n;
  function NO(t, e, n, r) {
    const i = (e >>> 0) + (r >>> 0);
    return {
      h: t + n + (i / 2 ** 32 | 0) | 0,
      l: i | 0
    };
  }
  const OO = (t, e, n) => (t >>> 0) + (e >>> 0) + (n >>> 0), BO = (t, e, n, r) => e + n + r + (t / 2 ** 32 | 0) | 0, MO = (t, e, n, r) => (t >>> 0) + (e >>> 0) + (n >>> 0) + (r >>> 0), kO = (t, e, n, r, i) => e + n + r + i + (t / 2 ** 32 | 0) | 0, FO = (t, e, n, r, i) => (t >>> 0) + (e >>> 0) + (n >>> 0) + (r >>> 0) + (i >>> 0), LO = (t, e, n, r, i, s) => e + n + r + i + s + (t / 2 ** 32 | 0) | 0, je = {
    fromBig: OE,
    split: BE,
    toBig: vO,
    shrSH: EO,
    shrSL: SO,
    rotrSH: TO,
    rotrSL: CO,
    rotrBH: IO,
    rotrBL: PO,
    rotr32H: _O,
    rotr32L: RO,
    rotlSH: ME,
    rotlSL: kE,
    rotlBH: FE,
    rotlBL: LE,
    add: NO,
    add3L: OO,
    add3H: BO,
    add4L: MO,
    add4H: kO,
    add5H: LO,
    add5L: FO
  }, [DO, UO] = je.split([
    "0x428a2f98d728ae22",
    "0x7137449123ef65cd",
    "0xb5c0fbcfec4d3b2f",
    "0xe9b5dba58189dbbc",
    "0x3956c25bf348b538",
    "0x59f111f1b605d019",
    "0x923f82a4af194f9b",
    "0xab1c5ed5da6d8118",
    "0xd807aa98a3030242",
    "0x12835b0145706fbe",
    "0x243185be4ee4b28c",
    "0x550c7dc3d5ffb4e2",
    "0x72be5d74f27b896f",
    "0x80deb1fe3b1696b1",
    "0x9bdc06a725c71235",
    "0xc19bf174cf692694",
    "0xe49b69c19ef14ad2",
    "0xefbe4786384f25e3",
    "0x0fc19dc68b8cd5b5",
    "0x240ca1cc77ac9c65",
    "0x2de92c6f592b0275",
    "0x4a7484aa6ea6e483",
    "0x5cb0a9dcbd41fbd4",
    "0x76f988da831153b5",
    "0x983e5152ee66dfab",
    "0xa831c66d2db43210",
    "0xb00327c898fb213f",
    "0xbf597fc7beef0ee4",
    "0xc6e00bf33da88fc2",
    "0xd5a79147930aa725",
    "0x06ca6351e003826f",
    "0x142929670a0e6e70",
    "0x27b70a8546d22ffc",
    "0x2e1b21385c26c926",
    "0x4d2c6dfc5ac42aed",
    "0x53380d139d95b3df",
    "0x650a73548baf63de",
    "0x766a0abb3c77b2a8",
    "0x81c2c92e47edaee6",
    "0x92722c851482353b",
    "0xa2bfe8a14cf10364",
    "0xa81a664bbc423001",
    "0xc24b8b70d0f89791",
    "0xc76c51a30654be30",
    "0xd192e819d6ef5218",
    "0xd69906245565a910",
    "0xf40e35855771202a",
    "0x106aa07032bbd1b8",
    "0x19a4c116b8d2d0c8",
    "0x1e376c085141ab53",
    "0x2748774cdf8eeb99",
    "0x34b0bcb5e19b48a8",
    "0x391c0cb3c5c95a63",
    "0x4ed8aa4ae3418acb",
    "0x5b9cca4f7763e373",
    "0x682e6ff3d6b2b8a3",
    "0x748f82ee5defb2fc",
    "0x78a5636f43172f60",
    "0x84c87814a1f0ab72",
    "0x8cc702081a6439ec",
    "0x90befffa23631e28",
    "0xa4506cebde82bde9",
    "0xbef9a3f7b2c67915",
    "0xc67178f2e372532b",
    "0xca273eceea26619c",
    "0xd186b8c721c0c207",
    "0xeada7dd6cde0eb1e",
    "0xf57d4f7fee6ed178",
    "0x06f067aa72176fba",
    "0x0a637dc5a2c898a6",
    "0x113f9804bef90dae",
    "0x1b710b35131c471b",
    "0x28db77f523047d84",
    "0x32caab7b40c72493",
    "0x3c9ebe0a15c9bebc",
    "0x431d67c49c100d4c",
    "0x4cc5d4becb3e42b6",
    "0x597f299cfc657e2a",
    "0x5fcb6fab3ad6faec",
    "0x6c44198c4a475817"
  ].map((t) => BigInt(t))), so = new Uint32Array(80), oo = new Uint32Array(80);
  let HO = class extends RE {
    constructor() {
      super(128, 64, 16, false), this.Ah = 1779033703, this.Al = -205731576, this.Bh = -1150833019, this.Bl = -2067093701, this.Ch = 1013904242, this.Cl = -23791573, this.Dh = -1521486534, this.Dl = 1595750129, this.Eh = 1359893119, this.El = -1377402159, this.Fh = -1694144372, this.Fl = 725511199, this.Gh = 528734635, this.Gl = -79577749, this.Hh = 1541459225, this.Hl = 327033209;
    }
    get() {
      const { Ah: e, Al: n, Bh: r, Bl: i, Ch: s, Cl: o, Dh: a, Dl: c, Eh: l, El: u, Fh: f, Fl: d, Gh: m, Gl: y, Hh: x, Hl: w } = this;
      return [
        e,
        n,
        r,
        i,
        s,
        o,
        a,
        c,
        l,
        u,
        f,
        d,
        m,
        y,
        x,
        w
      ];
    }
    set(e, n, r, i, s, o, a, c, l, u, f, d, m, y, x, w) {
      this.Ah = e | 0, this.Al = n | 0, this.Bh = r | 0, this.Bl = i | 0, this.Ch = s | 0, this.Cl = o | 0, this.Dh = a | 0, this.Dl = c | 0, this.Eh = l | 0, this.El = u | 0, this.Fh = f | 0, this.Fl = d | 0, this.Gh = m | 0, this.Gl = y | 0, this.Hh = x | 0, this.Hl = w | 0;
    }
    process(e, n) {
      for (let B = 0; B < 16; B++, n += 4) so[B] = e.getUint32(n), oo[B] = e.getUint32(n += 4);
      for (let B = 16; B < 80; B++) {
        const M = so[B - 15] | 0, D = oo[B - 15] | 0, H = je.rotrSH(M, D, 1) ^ je.rotrSH(M, D, 8) ^ je.shrSH(M, D, 7), q = je.rotrSL(M, D, 1) ^ je.rotrSL(M, D, 8) ^ je.shrSL(M, D, 7), S = so[B - 2] | 0, P = oo[B - 2] | 0, L = je.rotrSH(S, P, 19) ^ je.rotrBH(S, P, 61) ^ je.shrSH(S, P, 6), K = je.rotrSL(S, P, 19) ^ je.rotrBL(S, P, 61) ^ je.shrSL(S, P, 6), z = je.add4L(q, K, oo[B - 7], oo[B - 16]), I = je.add4H(z, H, L, so[B - 7], so[B - 16]);
        so[B] = I | 0, oo[B] = z | 0;
      }
      let { Ah: r, Al: i, Bh: s, Bl: o, Ch: a, Cl: c, Dh: l, Dl: u, Eh: f, El: d, Fh: m, Fl: y, Gh: x, Gl: w, Hh: R, Hl: O } = this;
      for (let B = 0; B < 80; B++) {
        const M = je.rotrSH(f, d, 14) ^ je.rotrSH(f, d, 18) ^ je.rotrBH(f, d, 41), D = je.rotrSL(f, d, 14) ^ je.rotrSL(f, d, 18) ^ je.rotrBL(f, d, 41), H = f & m ^ ~f & x, q = d & y ^ ~d & w, S = je.add5L(O, D, q, UO[B], oo[B]), P = je.add5H(S, R, M, H, DO[B], so[B]), L = S | 0, K = je.rotrSH(r, i, 28) ^ je.rotrBH(r, i, 34) ^ je.rotrBH(r, i, 39), z = je.rotrSL(r, i, 28) ^ je.rotrBL(r, i, 34) ^ je.rotrBL(r, i, 39), I = r & s ^ r & a ^ s & a, h = i & o ^ i & c ^ o & c;
        R = x | 0, O = w | 0, x = m | 0, w = y | 0, m = f | 0, y = d | 0, { h: f, l: d } = je.add(l | 0, u | 0, P | 0, L | 0), l = a | 0, u = c | 0, a = s | 0, c = o | 0, s = r | 0, o = i | 0;
        const p = je.add3L(L, z, h);
        r = je.add3H(p, P, K, I), i = p | 0;
      }
      ({ h: r, l: i } = je.add(this.Ah | 0, this.Al | 0, r | 0, i | 0)), { h: s, l: o } = je.add(this.Bh | 0, this.Bl | 0, s | 0, o | 0), { h: a, l: c } = je.add(this.Ch | 0, this.Cl | 0, a | 0, c | 0), { h: l, l: u } = je.add(this.Dh | 0, this.Dl | 0, l | 0, u | 0), { h: f, l: d } = je.add(this.Eh | 0, this.El | 0, f | 0, d | 0), { h: m, l: y } = je.add(this.Fh | 0, this.Fl | 0, m | 0, y | 0), { h: x, l: w } = je.add(this.Gh | 0, this.Gl | 0, x | 0, w | 0), { h: R, l: O } = je.add(this.Hh | 0, this.Hl | 0, R | 0, O | 0), this.set(r, i, s, o, a, c, l, u, f, d, m, y, x, w, R, O);
    }
    roundClean() {
      so.fill(0), oo.fill(0);
    }
    destroy() {
      this.buffer.fill(0), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    }
  };
  const GO = ty(() => new HO());
  function VO() {
    if (typeof self < "u") return self;
    if (typeof window < "u") return window;
    if (typeof global < "u") return global;
    throw new Error("unable to locate global object");
  }
  const x2 = VO();
  x2.crypto || x2.msCrypto;
  function zO(t) {
    switch (t) {
      case "sha256":
        return NE.create();
      case "sha512":
        return GO.create();
    }
    re(false, "invalid hashing algorithm name", "algorithm", t);
  }
  const [DE, UE, HE] = [
    [],
    [],
    []
  ], QO = BigInt(0), Vl = BigInt(1), jO = BigInt(2), JO = BigInt(7), KO = BigInt(256), WO = BigInt(113);
  for (let t = 0, e = Vl, n = 1, r = 0; t < 24; t++) {
    [n, r] = [
      r,
      (2 * n + 3 * r) % 5
    ], DE.push(2 * (5 * r + n)), UE.push((t + 1) * (t + 2) / 2 % 64);
    let i = QO;
    for (let s = 0; s < 7; s++) e = (e << Vl ^ (e >> JO) * WO) % KO, e & jO && (i ^= Vl << (Vl << BigInt(s)) - Vl);
    HE.push(i);
  }
  const [qO, YO] = BE(HE, true), A2 = (t, e, n) => n > 32 ? FE(t, e, n) : ME(t, e, n), w2 = (t, e, n) => n > 32 ? LE(t, e, n) : kE(t, e, n);
  function XO(t, e = 24) {
    const n = new Uint32Array(10);
    for (let r = 24 - e; r < 24; r++) {
      for (let o = 0; o < 10; o++) n[o] = t[o] ^ t[o + 10] ^ t[o + 20] ^ t[o + 30] ^ t[o + 40];
      for (let o = 0; o < 10; o += 2) {
        const a = (o + 8) % 10, c = (o + 2) % 10, l = n[c], u = n[c + 1], f = A2(l, u, 1) ^ n[a], d = w2(l, u, 1) ^ n[a + 1];
        for (let m = 0; m < 50; m += 10) t[o + m] ^= f, t[o + m + 1] ^= d;
      }
      let i = t[2], s = t[3];
      for (let o = 0; o < 24; o++) {
        const a = UE[o], c = A2(i, s, a), l = w2(i, s, a), u = DE[o];
        i = t[u], s = t[u + 1], t[u] = c, t[u + 1] = l;
      }
      for (let o = 0; o < 50; o += 10) {
        for (let a = 0; a < 10; a++) n[a] = t[o + a];
        for (let a = 0; a < 10; a++) t[o + a] ^= ~n[(a + 2) % 10] & n[(a + 4) % 10];
      }
      t[0] ^= qO[r], t[1] ^= YO[r];
    }
    n.fill(0);
  }
  class ny extends ey {
    constructor(e, n, r, i = false, s = 24) {
      if (super(), this.blockLen = e, this.suffix = n, this.outputLen = r, this.enableXOF = i, this.rounds = s, this.pos = 0, this.posOut = 0, this.finished = false, this.destroyed = false, W0(r), 0 >= this.blockLen || this.blockLen >= 200) throw new Error("Sha3 supports only keccak-f1600 function");
      this.state = new Uint8Array(200), this.state32 = dO(this.state);
    }
    keccak() {
      XO(this.state32, this.rounds), this.posOut = 0, this.pos = 0;
    }
    update(e) {
      Zc(this);
      const { blockLen: n, state: r } = this;
      e = Jd(e);
      const i = e.length;
      for (let s = 0; s < i; ) {
        const o = Math.min(n - this.pos, i - s);
        for (let a = 0; a < o; a++) r[this.pos++] ^= e[s++];
        this.pos === n && this.keccak();
      }
      return this;
    }
    finish() {
      if (this.finished) return;
      this.finished = true;
      const { state: e, suffix: n, pos: r, blockLen: i } = this;
      e[r] ^= n, n & 128 && r === i - 1 && this.keccak(), e[i - 1] ^= 128, this.keccak();
    }
    writeInto(e) {
      Zc(this, false), $1(e), this.finish();
      const n = this.state, { blockLen: r } = this;
      for (let i = 0, s = e.length; i < s; ) {
        this.posOut >= r && this.keccak();
        const o = Math.min(r - this.posOut, s - i);
        e.set(n.subarray(this.posOut, this.posOut + o), i), this.posOut += o, i += o;
      }
      return e;
    }
    xofInto(e) {
      if (!this.enableXOF) throw new Error("XOF is not possible for this instance");
      return this.writeInto(e);
    }
    xof(e) {
      return W0(e), this.xofInto(new Uint8Array(e));
    }
    digestInto(e) {
      if (CE(e, this), this.finished) throw new Error("digest() was already called");
      return this.writeInto(e), this.destroy(), e;
    }
    digest() {
      return this.digestInto(new Uint8Array(this.outputLen));
    }
    destroy() {
      this.destroyed = true, this.state.fill(0);
    }
    _cloneInto(e) {
      const { blockLen: n, suffix: r, outputLen: i, rounds: s, enableXOF: o } = this;
      return e || (e = new ny(n, r, i, o, s)), e.state32.set(this.state32), e.pos = this.pos, e.posOut = this.posOut, e.finished = this.finished, e.rounds = s, e.suffix = r, e.outputLen = i, e.enableXOF = o, e.destroyed = this.destroyed, e;
    }
  }
  const ZO = (t, e, n) => ty(() => new ny(e, t, n)), $O = ZO(1, 136, 256 / 8);
  let GE = false;
  const VE = function(t) {
    return $O(t);
  };
  let zE = VE;
  function dn(t) {
    const e = Je(t, "data");
    return Se(zE(e));
  }
  dn._ = VE;
  dn.lock = function() {
    GE = true;
  };
  dn.register = function(t) {
    if (GE) throw new TypeError("keccak256 is locked");
    zE = t;
  };
  Object.freeze(dn);
  const QE = function(t) {
    return zO("sha256").update(t).digest();
  };
  let jE = QE, JE = false;
  function xl(t) {
    const e = Je(t, "data");
    return Se(jE(e));
  }
  xl._ = QE;
  xl.lock = function() {
    JE = true;
  };
  xl.register = function(t) {
    if (JE) throw new Error("sha256 is locked");
    jE = t;
  };
  Object.freeze(xl);
  Object.freeze(xl);
  const KE = BigInt(0), Kd = BigInt(1), eB = BigInt(2), Wd = (t) => t instanceof Uint8Array, tB = Array.from({
    length: 256
  }, (t, e) => e.toString(16).padStart(2, "0"));
  function $c(t) {
    if (!Wd(t)) throw new Error("Uint8Array expected");
    let e = "";
    for (let n = 0; n < t.length; n++) e += tB[t[n]];
    return e;
  }
  function WE(t) {
    const e = t.toString(16);
    return e.length & 1 ? `0${e}` : e;
  }
  function ry(t) {
    if (typeof t != "string") throw new Error("hex string expected, got " + typeof t);
    return BigInt(t === "" ? "0" : `0x${t}`);
  }
  function el(t) {
    if (typeof t != "string") throw new Error("hex string expected, got " + typeof t);
    const e = t.length;
    if (e % 2) throw new Error("padded hex string expected, got unpadded hex of length " + e);
    const n = new Uint8Array(e / 2);
    for (let r = 0; r < n.length; r++) {
      const i = r * 2, s = t.slice(i, i + 2), o = Number.parseInt(s, 16);
      if (Number.isNaN(o) || o < 0) throw new Error("Invalid byte sequence");
      n[r] = o;
    }
    return n;
  }
  function va(t) {
    return ry($c(t));
  }
  function iy(t) {
    if (!Wd(t)) throw new Error("Uint8Array expected");
    return ry($c(Uint8Array.from(t).reverse()));
  }
  function tl(t, e) {
    return el(t.toString(16).padStart(e * 2, "0"));
  }
  function sy(t, e) {
    return tl(t, e).reverse();
  }
  function nB(t) {
    return el(WE(t));
  }
  function ci(t, e, n) {
    let r;
    if (typeof e == "string") try {
      r = el(e);
    } catch (s) {
      throw new Error(`${t} must be valid hex string, got "${e}". Cause: ${s}`);
    }
    else if (Wd(e)) r = Uint8Array.from(e);
    else throw new Error(`${t} must be hex string or Uint8Array`);
    const i = r.length;
    if (typeof n == "number" && i !== n) throw new Error(`${t} expected ${n} bytes, got ${i}`);
    return r;
  }
  function Lu(...t) {
    const e = new Uint8Array(t.reduce((r, i) => r + i.length, 0));
    let n = 0;
    return t.forEach((r) => {
      if (!Wd(r)) throw new Error("Uint8Array expected");
      e.set(r, n), n += r.length;
    }), e;
  }
  function rB(t, e) {
    if (t.length !== e.length) return false;
    for (let n = 0; n < t.length; n++) if (t[n] !== e[n]) return false;
    return true;
  }
  function iB(t) {
    if (typeof t != "string") throw new Error(`utf8ToBytes expected string, got ${typeof t}`);
    return new Uint8Array(new TextEncoder().encode(t));
  }
  function sB(t) {
    let e;
    for (e = 0; t > KE; t >>= Kd, e += 1) ;
    return e;
  }
  function oB(t, e) {
    return t >> BigInt(e) & Kd;
  }
  const aB = (t, e, n) => t | (n ? Kd : KE) << BigInt(e), oy = (t) => (eB << BigInt(t - 1)) - Kd, Pp = (t) => new Uint8Array(t), v2 = (t) => Uint8Array.from(t);
  function qE(t, e, n) {
    if (typeof t != "number" || t < 2) throw new Error("hashLen must be a number");
    if (typeof e != "number" || e < 2) throw new Error("qByteLen must be a number");
    if (typeof n != "function") throw new Error("hmacFn must be a function");
    let r = Pp(t), i = Pp(t), s = 0;
    const o = () => {
      r.fill(1), i.fill(0), s = 0;
    }, a = (...f) => n(i, r, ...f), c = (f = Pp()) => {
      i = a(v2([
        0
      ]), f), r = a(), f.length !== 0 && (i = a(v2([
        1
      ]), f), r = a());
    }, l = () => {
      if (s++ >= 1e3) throw new Error("drbg: tried 1000 values");
      let f = 0;
      const d = [];
      for (; f < e; ) {
        r = a();
        const m = r.slice();
        d.push(m), f += r.length;
      }
      return Lu(...d);
    };
    return (f, d) => {
      o(), c(f);
      let m;
      for (; !(m = d(l())); ) c();
      return o(), m;
    };
  }
  const cB = {
    bigint: (t) => typeof t == "bigint",
    function: (t) => typeof t == "function",
    boolean: (t) => typeof t == "boolean",
    string: (t) => typeof t == "string",
    stringOrUint8Array: (t) => typeof t == "string" || t instanceof Uint8Array,
    isSafeInteger: (t) => Number.isSafeInteger(t),
    array: (t) => Array.isArray(t),
    field: (t, e) => e.Fp.isValid(t),
    hash: (t) => typeof t == "function" && Number.isSafeInteger(t.outputLen)
  };
  function hf(t, e, n = {}) {
    const r = (i, s, o) => {
      const a = cB[s];
      if (typeof a != "function") throw new Error(`Invalid validator "${s}", expected function`);
      const c = t[i];
      if (!(o && c === void 0) && !a(c, t)) throw new Error(`Invalid param ${String(i)}=${c} (${typeof c}), expected ${s}`);
    };
    for (const [i, s] of Object.entries(e)) r(i, s, false);
    for (const [i, s] of Object.entries(n)) r(i, s, true);
    return t;
  }
  const lB = Object.freeze(Object.defineProperty({
    __proto__: null,
    bitGet: oB,
    bitLen: sB,
    bitMask: oy,
    bitSet: aB,
    bytesToHex: $c,
    bytesToNumberBE: va,
    bytesToNumberLE: iy,
    concatBytes: Lu,
    createHmacDrbg: qE,
    ensureBytes: ci,
    equalBytes: rB,
    hexToBytes: el,
    hexToNumber: ry,
    numberToBytesBE: tl,
    numberToBytesLE: sy,
    numberToHexUnpadded: WE,
    numberToVarBytesBE: nB,
    utf8ToBytes: iB,
    validateObject: hf
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  const _n = BigInt(0), un = BigInt(1), la = BigInt(2), uB = BigInt(3), hm = BigInt(4), E2 = BigInt(5), S2 = BigInt(8);
  BigInt(9);
  BigInt(16);
  function pr(t, e) {
    const n = t % e;
    return n >= _n ? n : e + n;
  }
  function fB(t, e, n) {
    if (n <= _n || e < _n) throw new Error("Expected power/modulo > 0");
    if (n === un) return _n;
    let r = un;
    for (; e > _n; ) e & un && (r = r * t % n), t = t * t % n, e >>= un;
    return r;
  }
  function Mr(t, e, n) {
    let r = t;
    for (; e-- > _n; ) r *= r, r %= n;
    return r;
  }
  function pm(t, e) {
    if (t === _n || e <= _n) throw new Error(`invert: expected positive integers, got n=${t} mod=${e}`);
    let n = pr(t, e), r = e, i = _n, s = un;
    for (; n !== _n; ) {
      const a = r / n, c = r % n, l = i - s * a;
      r = n, n = c, i = s, s = l;
    }
    if (r !== un) throw new Error("invert: does not exist");
    return pr(i, e);
  }
  function dB(t) {
    const e = (t - un) / la;
    let n, r, i;
    for (n = t - un, r = 0; n % la === _n; n /= la, r++) ;
    for (i = la; i < t && fB(i, e, t) !== t - un; i++) ;
    if (r === 1) {
      const o = (t + un) / hm;
      return function(c, l) {
        const u = c.pow(l, o);
        if (!c.eql(c.sqr(u), l)) throw new Error("Cannot find square root");
        return u;
      };
    }
    const s = (n + un) / la;
    return function(a, c) {
      if (a.pow(c, e) === a.neg(a.ONE)) throw new Error("Cannot find square root");
      let l = r, u = a.pow(a.mul(a.ONE, i), n), f = a.pow(c, s), d = a.pow(c, n);
      for (; !a.eql(d, a.ONE); ) {
        if (a.eql(d, a.ZERO)) return a.ZERO;
        let m = 1;
        for (let x = a.sqr(d); m < l && !a.eql(x, a.ONE); m++) x = a.sqr(x);
        const y = a.pow(u, un << BigInt(l - m - 1));
        u = a.sqr(y), f = a.mul(f, y), d = a.mul(d, u), l = m;
      }
      return f;
    };
  }
  function hB(t) {
    if (t % hm === uB) {
      const e = (t + un) / hm;
      return function(r, i) {
        const s = r.pow(i, e);
        if (!r.eql(r.sqr(s), i)) throw new Error("Cannot find square root");
        return s;
      };
    }
    if (t % S2 === E2) {
      const e = (t - E2) / S2;
      return function(r, i) {
        const s = r.mul(i, la), o = r.pow(s, e), a = r.mul(i, o), c = r.mul(r.mul(a, la), o), l = r.mul(a, r.sub(c, r.ONE));
        if (!r.eql(r.sqr(l), i)) throw new Error("Cannot find square root");
        return l;
      };
    }
    return dB(t);
  }
  const pB = [
    "create",
    "isValid",
    "is0",
    "neg",
    "inv",
    "sqrt",
    "sqr",
    "eql",
    "add",
    "sub",
    "mul",
    "pow",
    "div",
    "addN",
    "subN",
    "mulN",
    "sqrN"
  ];
  function gB(t) {
    const e = {
      ORDER: "bigint",
      MASK: "bigint",
      BYTES: "isSafeInteger",
      BITS: "isSafeInteger"
    }, n = pB.reduce((r, i) => (r[i] = "function", r), e);
    return hf(t, n);
  }
  function mB(t, e, n) {
    if (n < _n) throw new Error("Expected power > 0");
    if (n === _n) return t.ONE;
    if (n === un) return e;
    let r = t.ONE, i = e;
    for (; n > _n; ) n & un && (r = t.mul(r, i)), i = t.sqr(i), n >>= un;
    return r;
  }
  function yB(t, e) {
    const n = new Array(e.length), r = e.reduce((s, o, a) => t.is0(o) ? s : (n[a] = s, t.mul(s, o)), t.ONE), i = t.inv(r);
    return e.reduceRight((s, o, a) => t.is0(o) ? s : (n[a] = t.mul(s, n[a]), t.mul(s, o)), i), n;
  }
  function YE(t, e) {
    const n = e !== void 0 ? e : t.toString(2).length, r = Math.ceil(n / 8);
    return {
      nBitLength: n,
      nByteLength: r
    };
  }
  function bB(t, e, n = false, r = {}) {
    if (t <= _n) throw new Error(`Expected Field ORDER > 0, got ${t}`);
    const { nBitLength: i, nByteLength: s } = YE(t, e);
    if (s > 2048) throw new Error("Field lengths over 2048 bytes are not supported");
    const o = hB(t), a = Object.freeze({
      ORDER: t,
      BITS: i,
      BYTES: s,
      MASK: oy(i),
      ZERO: _n,
      ONE: un,
      create: (c) => pr(c, t),
      isValid: (c) => {
        if (typeof c != "bigint") throw new Error(`Invalid field element: expected bigint, got ${typeof c}`);
        return _n <= c && c < t;
      },
      is0: (c) => c === _n,
      isOdd: (c) => (c & un) === un,
      neg: (c) => pr(-c, t),
      eql: (c, l) => c === l,
      sqr: (c) => pr(c * c, t),
      add: (c, l) => pr(c + l, t),
      sub: (c, l) => pr(c - l, t),
      mul: (c, l) => pr(c * l, t),
      pow: (c, l) => mB(a, c, l),
      div: (c, l) => pr(c * pm(l, t), t),
      sqrN: (c) => c * c,
      addN: (c, l) => c + l,
      subN: (c, l) => c - l,
      mulN: (c, l) => c * l,
      inv: (c) => pm(c, t),
      sqrt: r.sqrt || ((c) => o(a, c)),
      invertBatch: (c) => yB(a, c),
      cmov: (c, l, u) => u ? l : c,
      toBytes: (c) => n ? sy(c, s) : tl(c, s),
      fromBytes: (c) => {
        if (c.length !== s) throw new Error(`Fp.fromBytes: expected ${s}, got ${c.length}`);
        return n ? iy(c) : va(c);
      }
    });
    return Object.freeze(a);
  }
  function XE(t) {
    if (typeof t != "bigint") throw new Error("field order must be bigint");
    const e = t.toString(2).length;
    return Math.ceil(e / 8);
  }
  function ZE(t) {
    const e = XE(t);
    return e + Math.ceil(e / 2);
  }
  function xB(t, e, n = false) {
    const r = t.length, i = XE(e), s = ZE(e);
    if (r < 16 || r < s || r > 1024) throw new Error(`expected ${s}-1024 bytes of input, got ${r}`);
    const o = n ? va(t) : iy(t), a = pr(o, e - un) + un;
    return n ? sy(a, i) : tl(a, i);
  }
  const AB = BigInt(0), _p = BigInt(1);
  function wB(t, e) {
    const n = (i, s) => {
      const o = s.negate();
      return i ? o : s;
    }, r = (i) => {
      const s = Math.ceil(e / i) + 1, o = 2 ** (i - 1);
      return {
        windows: s,
        windowSize: o
      };
    };
    return {
      constTimeNegate: n,
      unsafeLadder(i, s) {
        let o = t.ZERO, a = i;
        for (; s > AB; ) s & _p && (o = o.add(a)), a = a.double(), s >>= _p;
        return o;
      },
      precomputeWindow(i, s) {
        const { windows: o, windowSize: a } = r(s), c = [];
        let l = i, u = l;
        for (let f = 0; f < o; f++) {
          u = l, c.push(u);
          for (let d = 1; d < a; d++) u = u.add(l), c.push(u);
          l = u.double();
        }
        return c;
      },
      wNAF(i, s, o) {
        const { windows: a, windowSize: c } = r(i);
        let l = t.ZERO, u = t.BASE;
        const f = BigInt(2 ** i - 1), d = 2 ** i, m = BigInt(i);
        for (let y = 0; y < a; y++) {
          const x = y * c;
          let w = Number(o & f);
          o >>= m, w > c && (w -= d, o += _p);
          const R = x, O = x + Math.abs(w) - 1, B = y % 2 !== 0, M = w < 0;
          w === 0 ? u = u.add(n(B, s[R])) : l = l.add(n(M, s[O]));
        }
        return {
          p: l,
          f: u
        };
      },
      wNAFCached(i, s, o, a) {
        const c = i._WINDOW_SIZE || 1;
        let l = s.get(i);
        return l || (l = this.precomputeWindow(i, c), c !== 1 && s.set(i, a(l))), this.wNAF(c, l, o);
      }
    };
  }
  function $E(t) {
    return gB(t.Fp), hf(t, {
      n: "bigint",
      h: "bigint",
      Gx: "field",
      Gy: "field"
    }, {
      nBitLength: "isSafeInteger",
      nByteLength: "isSafeInteger"
    }), Object.freeze({
      ...YE(t.n, t.nBitLength),
      ...t,
      p: t.Fp.ORDER
    });
  }
  function vB(t) {
    const e = $E(t);
    hf(e, {
      a: "field",
      b: "field"
    }, {
      allowedPrivateKeyLengths: "array",
      wrapPrivateKey: "boolean",
      isTorsionFree: "function",
      clearCofactor: "function",
      allowInfinityPoint: "boolean",
      fromBytes: "function",
      toBytes: "function"
    });
    const { endo: n, Fp: r, a: i } = e;
    if (n) {
      if (!r.eql(i, r.ZERO)) throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
      if (typeof n != "object" || typeof n.beta != "bigint" || typeof n.splitScalar != "function") throw new Error("Expected endomorphism with beta: bigint and splitScalar: function");
    }
    return Object.freeze({
      ...e
    });
  }
  const { bytesToNumberBE: EB, hexToBytes: SB } = lB, pa = {
    Err: class extends Error {
      constructor(e = "") {
        super(e);
      }
    },
    _parseInt(t) {
      const { Err: e } = pa;
      if (t.length < 2 || t[0] !== 2) throw new e("Invalid signature integer tag");
      const n = t[1], r = t.subarray(2, n + 2);
      if (!n || r.length !== n) throw new e("Invalid signature integer: wrong length");
      if (r[0] & 128) throw new e("Invalid signature integer: negative");
      if (r[0] === 0 && !(r[1] & 128)) throw new e("Invalid signature integer: unnecessary leading zero");
      return {
        d: EB(r),
        l: t.subarray(n + 2)
      };
    },
    toSig(t) {
      const { Err: e } = pa, n = typeof t == "string" ? SB(t) : t;
      if (!(n instanceof Uint8Array)) throw new Error("ui8a expected");
      let r = n.length;
      if (r < 2 || n[0] != 48) throw new e("Invalid signature tag");
      if (n[1] !== r - 2) throw new e("Invalid signature: incorrect length");
      const { d: i, l: s } = pa._parseInt(n.subarray(2)), { d: o, l: a } = pa._parseInt(s);
      if (a.length) throw new e("Invalid signature: left bytes after parsing");
      return {
        r: i,
        s: o
      };
    },
    hexFromSig(t) {
      const e = (l) => Number.parseInt(l[0], 16) & 8 ? "00" + l : l, n = (l) => {
        const u = l.toString(16);
        return u.length & 1 ? `0${u}` : u;
      }, r = e(n(t.s)), i = e(n(t.r)), s = r.length / 2, o = i.length / 2, a = n(s), c = n(o);
      return `30${n(o + s + 4)}02${c}${i}02${a}${r}`;
    }
  }, Is = BigInt(0), Gr = BigInt(1);
  BigInt(2);
  const T2 = BigInt(3);
  BigInt(4);
  function TB(t) {
    const e = vB(t), { Fp: n } = e, r = e.toBytes || ((y, x, w) => {
      const R = x.toAffine();
      return Lu(Uint8Array.from([
        4
      ]), n.toBytes(R.x), n.toBytes(R.y));
    }), i = e.fromBytes || ((y) => {
      const x = y.subarray(1), w = n.fromBytes(x.subarray(0, n.BYTES)), R = n.fromBytes(x.subarray(n.BYTES, 2 * n.BYTES));
      return {
        x: w,
        y: R
      };
    });
    function s(y) {
      const { a: x, b: w } = e, R = n.sqr(y), O = n.mul(R, y);
      return n.add(n.add(O, n.mul(y, x)), w);
    }
    if (!n.eql(n.sqr(e.Gy), s(e.Gx))) throw new Error("bad generator point: equation left != right");
    function o(y) {
      return typeof y == "bigint" && Is < y && y < e.n;
    }
    function a(y) {
      if (!o(y)) throw new Error("Expected valid bigint: 0 < bigint < curve.n");
    }
    function c(y) {
      const { allowedPrivateKeyLengths: x, nByteLength: w, wrapPrivateKey: R, n: O } = e;
      if (x && typeof y != "bigint") {
        if (y instanceof Uint8Array && (y = $c(y)), typeof y != "string" || !x.includes(y.length)) throw new Error("Invalid key");
        y = y.padStart(w * 2, "0");
      }
      let B;
      try {
        B = typeof y == "bigint" ? y : va(ci("private key", y, w));
      } catch {
        throw new Error(`private key must be ${w} bytes, hex or bigint, not ${typeof y}`);
      }
      return R && (B = pr(B, O)), a(B), B;
    }
    const l = /* @__PURE__ */ new Map();
    function u(y) {
      if (!(y instanceof f)) throw new Error("ProjectivePoint expected");
    }
    class f {
      constructor(x, w, R) {
        if (this.px = x, this.py = w, this.pz = R, x == null || !n.isValid(x)) throw new Error("x required");
        if (w == null || !n.isValid(w)) throw new Error("y required");
        if (R == null || !n.isValid(R)) throw new Error("z required");
      }
      static fromAffine(x) {
        const { x: w, y: R } = x || {};
        if (!x || !n.isValid(w) || !n.isValid(R)) throw new Error("invalid affine point");
        if (x instanceof f) throw new Error("projective point not allowed");
        const O = (B) => n.eql(B, n.ZERO);
        return O(w) && O(R) ? f.ZERO : new f(w, R, n.ONE);
      }
      get x() {
        return this.toAffine().x;
      }
      get y() {
        return this.toAffine().y;
      }
      static normalizeZ(x) {
        const w = n.invertBatch(x.map((R) => R.pz));
        return x.map((R, O) => R.toAffine(w[O])).map(f.fromAffine);
      }
      static fromHex(x) {
        const w = f.fromAffine(i(ci("pointHex", x)));
        return w.assertValidity(), w;
      }
      static fromPrivateKey(x) {
        return f.BASE.multiply(c(x));
      }
      _setWindowSize(x) {
        this._WINDOW_SIZE = x, l.delete(this);
      }
      assertValidity() {
        if (this.is0()) {
          if (e.allowInfinityPoint && !n.is0(this.py)) return;
          throw new Error("bad point: ZERO");
        }
        const { x, y: w } = this.toAffine();
        if (!n.isValid(x) || !n.isValid(w)) throw new Error("bad point: x or y not FE");
        const R = n.sqr(w), O = s(x);
        if (!n.eql(R, O)) throw new Error("bad point: equation left != right");
        if (!this.isTorsionFree()) throw new Error("bad point: not in prime-order subgroup");
      }
      hasEvenY() {
        const { y: x } = this.toAffine();
        if (n.isOdd) return !n.isOdd(x);
        throw new Error("Field doesn't support isOdd");
      }
      equals(x) {
        u(x);
        const { px: w, py: R, pz: O } = this, { px: B, py: M, pz: D } = x, H = n.eql(n.mul(w, D), n.mul(B, O)), q = n.eql(n.mul(R, D), n.mul(M, O));
        return H && q;
      }
      negate() {
        return new f(this.px, n.neg(this.py), this.pz);
      }
      double() {
        const { a: x, b: w } = e, R = n.mul(w, T2), { px: O, py: B, pz: M } = this;
        let D = n.ZERO, H = n.ZERO, q = n.ZERO, S = n.mul(O, O), P = n.mul(B, B), L = n.mul(M, M), K = n.mul(O, B);
        return K = n.add(K, K), q = n.mul(O, M), q = n.add(q, q), D = n.mul(x, q), H = n.mul(R, L), H = n.add(D, H), D = n.sub(P, H), H = n.add(P, H), H = n.mul(D, H), D = n.mul(K, D), q = n.mul(R, q), L = n.mul(x, L), K = n.sub(S, L), K = n.mul(x, K), K = n.add(K, q), q = n.add(S, S), S = n.add(q, S), S = n.add(S, L), S = n.mul(S, K), H = n.add(H, S), L = n.mul(B, M), L = n.add(L, L), S = n.mul(L, K), D = n.sub(D, S), q = n.mul(L, P), q = n.add(q, q), q = n.add(q, q), new f(D, H, q);
      }
      add(x) {
        u(x);
        const { px: w, py: R, pz: O } = this, { px: B, py: M, pz: D } = x;
        let H = n.ZERO, q = n.ZERO, S = n.ZERO;
        const P = e.a, L = n.mul(e.b, T2);
        let K = n.mul(w, B), z = n.mul(R, M), I = n.mul(O, D), h = n.add(w, R), p = n.add(B, M);
        h = n.mul(h, p), p = n.add(K, z), h = n.sub(h, p), p = n.add(w, O);
        let A = n.add(B, D);
        return p = n.mul(p, A), A = n.add(K, I), p = n.sub(p, A), A = n.add(R, O), H = n.add(M, D), A = n.mul(A, H), H = n.add(z, I), A = n.sub(A, H), S = n.mul(P, p), H = n.mul(L, I), S = n.add(H, S), H = n.sub(z, S), S = n.add(z, S), q = n.mul(H, S), z = n.add(K, K), z = n.add(z, K), I = n.mul(P, I), p = n.mul(L, p), z = n.add(z, I), I = n.sub(K, I), I = n.mul(P, I), p = n.add(p, I), K = n.mul(z, p), q = n.add(q, K), K = n.mul(A, p), H = n.mul(h, H), H = n.sub(H, K), K = n.mul(h, z), S = n.mul(A, S), S = n.add(S, K), new f(H, q, S);
      }
      subtract(x) {
        return this.add(x.negate());
      }
      is0() {
        return this.equals(f.ZERO);
      }
      wNAF(x) {
        return m.wNAFCached(this, l, x, (w) => {
          const R = n.invertBatch(w.map((O) => O.pz));
          return w.map((O, B) => O.toAffine(R[B])).map(f.fromAffine);
        });
      }
      multiplyUnsafe(x) {
        const w = f.ZERO;
        if (x === Is) return w;
        if (a(x), x === Gr) return this;
        const { endo: R } = e;
        if (!R) return m.unsafeLadder(this, x);
        let { k1neg: O, k1: B, k2neg: M, k2: D } = R.splitScalar(x), H = w, q = w, S = this;
        for (; B > Is || D > Is; ) B & Gr && (H = H.add(S)), D & Gr && (q = q.add(S)), S = S.double(), B >>= Gr, D >>= Gr;
        return O && (H = H.negate()), M && (q = q.negate()), q = new f(n.mul(q.px, R.beta), q.py, q.pz), H.add(q);
      }
      multiply(x) {
        a(x);
        let w = x, R, O;
        const { endo: B } = e;
        if (B) {
          const { k1neg: M, k1: D, k2neg: H, k2: q } = B.splitScalar(w);
          let { p: S, f: P } = this.wNAF(D), { p: L, f: K } = this.wNAF(q);
          S = m.constTimeNegate(M, S), L = m.constTimeNegate(H, L), L = new f(n.mul(L.px, B.beta), L.py, L.pz), R = S.add(L), O = P.add(K);
        } else {
          const { p: M, f: D } = this.wNAF(w);
          R = M, O = D;
        }
        return f.normalizeZ([
          R,
          O
        ])[0];
      }
      multiplyAndAddUnsafe(x, w, R) {
        const O = f.BASE, B = (D, H) => H === Is || H === Gr || !D.equals(O) ? D.multiplyUnsafe(H) : D.multiply(H), M = B(this, w).add(B(x, R));
        return M.is0() ? void 0 : M;
      }
      toAffine(x) {
        const { px: w, py: R, pz: O } = this, B = this.is0();
        x == null && (x = B ? n.ONE : n.inv(O));
        const M = n.mul(w, x), D = n.mul(R, x), H = n.mul(O, x);
        if (B) return {
          x: n.ZERO,
          y: n.ZERO
        };
        if (!n.eql(H, n.ONE)) throw new Error("invZ was invalid");
        return {
          x: M,
          y: D
        };
      }
      isTorsionFree() {
        const { h: x, isTorsionFree: w } = e;
        if (x === Gr) return true;
        if (w) return w(f, this);
        throw new Error("isTorsionFree() has not been declared for the elliptic curve");
      }
      clearCofactor() {
        const { h: x, clearCofactor: w } = e;
        return x === Gr ? this : w ? w(f, this) : this.multiplyUnsafe(e.h);
      }
      toRawBytes(x = true) {
        return this.assertValidity(), r(f, this, x);
      }
      toHex(x = true) {
        return $c(this.toRawBytes(x));
      }
    }
    f.BASE = new f(e.Gx, e.Gy, n.ONE), f.ZERO = new f(n.ZERO, n.ONE, n.ZERO);
    const d = e.nBitLength, m = wB(f, e.endo ? Math.ceil(d / 2) : d);
    return {
      CURVE: e,
      ProjectivePoint: f,
      normPrivateKeyToScalar: c,
      weierstrassEquation: s,
      isWithinCurveOrder: o
    };
  }
  function CB(t) {
    const e = $E(t);
    return hf(e, {
      hash: "hash",
      hmac: "function",
      randomBytes: "function"
    }, {
      bits2int: "function",
      bits2int_modN: "function",
      lowS: "boolean"
    }), Object.freeze({
      lowS: true,
      ...e
    });
  }
  function IB(t) {
    const e = CB(t), { Fp: n, n: r } = e, i = n.BYTES + 1, s = 2 * n.BYTES + 1;
    function o(p) {
      return Is < p && p < n.ORDER;
    }
    function a(p) {
      return pr(p, r);
    }
    function c(p) {
      return pm(p, r);
    }
    const { ProjectivePoint: l, normPrivateKeyToScalar: u, weierstrassEquation: f, isWithinCurveOrder: d } = TB({
      ...e,
      toBytes(p, A, C) {
        const N = A.toAffine(), U = n.toBytes(N.x), Y = Lu;
        return C ? Y(Uint8Array.from([
          A.hasEvenY() ? 2 : 3
        ]), U) : Y(Uint8Array.from([
          4
        ]), U, n.toBytes(N.y));
      },
      fromBytes(p) {
        const A = p.length, C = p[0], N = p.subarray(1);
        if (A === i && (C === 2 || C === 3)) {
          const U = va(N);
          if (!o(U)) throw new Error("Point is not on curve");
          const Y = f(U);
          let T = n.sqrt(Y);
          const g = (T & Gr) === Gr;
          return (C & 1) === 1 !== g && (T = n.neg(T)), {
            x: U,
            y: T
          };
        } else if (A === s && C === 4) {
          const U = n.fromBytes(N.subarray(0, n.BYTES)), Y = n.fromBytes(N.subarray(n.BYTES, 2 * n.BYTES));
          return {
            x: U,
            y: Y
          };
        } else throw new Error(`Point of length ${A} was invalid. Expected ${i} compressed bytes or ${s} uncompressed bytes`);
      }
    }), m = (p) => $c(tl(p, e.nByteLength));
    function y(p) {
      const A = r >> Gr;
      return p > A;
    }
    function x(p) {
      return y(p) ? a(-p) : p;
    }
    const w = (p, A, C) => va(p.slice(A, C));
    class R {
      constructor(A, C, N) {
        this.r = A, this.s = C, this.recovery = N, this.assertValidity();
      }
      static fromCompact(A) {
        const C = e.nByteLength;
        return A = ci("compactSignature", A, C * 2), new R(w(A, 0, C), w(A, C, 2 * C));
      }
      static fromDER(A) {
        const { r: C, s: N } = pa.toSig(ci("DER", A));
        return new R(C, N);
      }
      assertValidity() {
        if (!d(this.r)) throw new Error("r must be 0 < r < CURVE.n");
        if (!d(this.s)) throw new Error("s must be 0 < s < CURVE.n");
      }
      addRecoveryBit(A) {
        return new R(this.r, this.s, A);
      }
      recoverPublicKey(A) {
        const { r: C, s: N, recovery: U } = this, Y = q(ci("msgHash", A));
        if (U == null || ![
          0,
          1,
          2,
          3
        ].includes(U)) throw new Error("recovery id invalid");
        const T = U === 2 || U === 3 ? C + e.n : C;
        if (T >= n.ORDER) throw new Error("recovery id 2 or 3 invalid");
        const g = U & 1 ? "03" : "02", F = l.fromHex(g + m(T)), ee = c(T), E = a(-Y * ee), Z = a(N * ee), k = l.BASE.multiplyAndAddUnsafe(F, E, Z);
        if (!k) throw new Error("point at infinify");
        return k.assertValidity(), k;
      }
      hasHighS() {
        return y(this.s);
      }
      normalizeS() {
        return this.hasHighS() ? new R(this.r, a(-this.s), this.recovery) : this;
      }
      toDERRawBytes() {
        return el(this.toDERHex());
      }
      toDERHex() {
        return pa.hexFromSig({
          r: this.r,
          s: this.s
        });
      }
      toCompactRawBytes() {
        return el(this.toCompactHex());
      }
      toCompactHex() {
        return m(this.r) + m(this.s);
      }
    }
    const O = {
      isValidPrivateKey(p) {
        try {
          return u(p), true;
        } catch {
          return false;
        }
      },
      normPrivateKeyToScalar: u,
      randomPrivateKey: () => {
        const p = ZE(e.n);
        return xB(e.randomBytes(p), e.n);
      },
      precompute(p = 8, A = l.BASE) {
        return A._setWindowSize(p), A.multiply(BigInt(3)), A;
      }
    };
    function B(p, A = true) {
      return l.fromPrivateKey(p).toRawBytes(A);
    }
    function M(p) {
      const A = p instanceof Uint8Array, C = typeof p == "string", N = (A || C) && p.length;
      return A ? N === i || N === s : C ? N === 2 * i || N === 2 * s : p instanceof l;
    }
    function D(p, A, C = true) {
      if (M(p)) throw new Error("first arg must be private key");
      if (!M(A)) throw new Error("second arg must be public key");
      return l.fromHex(A).multiply(u(p)).toRawBytes(C);
    }
    const H = e.bits2int || function(p) {
      const A = va(p), C = p.length * 8 - e.nBitLength;
      return C > 0 ? A >> BigInt(C) : A;
    }, q = e.bits2int_modN || function(p) {
      return a(H(p));
    }, S = oy(e.nBitLength);
    function P(p) {
      if (typeof p != "bigint") throw new Error("bigint expected");
      if (!(Is <= p && p < S)) throw new Error(`bigint expected < 2^${e.nBitLength}`);
      return tl(p, e.nByteLength);
    }
    function L(p, A, C = K) {
      if ([
        "recovered",
        "canonical"
      ].some(($) => $ in C)) throw new Error("sign() legacy options not supported");
      const { hash: N, randomBytes: U } = e;
      let { lowS: Y, prehash: T, extraEntropy: g } = C;
      Y == null && (Y = true), p = ci("msgHash", p), T && (p = ci("prehashed msgHash", N(p)));
      const F = q(p), ee = u(A), E = [
        P(ee),
        P(F)
      ];
      if (g != null) {
        const $ = g === true ? U(n.BYTES) : g;
        E.push(ci("extraEntropy", $));
      }
      const Z = Lu(...E), k = F;
      function X($) {
        const ce = H($);
        if (!d(ce)) return;
        const fe = c(ce), G = l.BASE.multiply(ce).toAffine(), W = a(G.x);
        if (W === Is) return;
        const V = a(fe * a(k + W * ee));
        if (V === Is) return;
        let te = (G.x === W ? 0 : 2) | Number(G.y & Gr), pe = V;
        return Y && y(V) && (pe = x(V), te ^= 1), new R(W, pe, te);
      }
      return {
        seed: Z,
        k2sig: X
      };
    }
    const K = {
      lowS: e.lowS,
      prehash: false
    }, z = {
      lowS: e.lowS,
      prehash: false
    };
    function I(p, A, C = K) {
      const { seed: N, k2sig: U } = L(p, A, C), Y = e;
      return qE(Y.hash.outputLen, Y.nByteLength, Y.hmac)(N, U);
    }
    l.BASE._setWindowSize(8);
    function h(p, A, C, N = z) {
      var _a6;
      const U = p;
      if (A = ci("msgHash", A), C = ci("publicKey", C), "strict" in N) throw new Error("options.strict was renamed to lowS");
      const { lowS: Y, prehash: T } = N;
      let g, F;
      try {
        if (typeof U == "string" || U instanceof Uint8Array) try {
          g = R.fromDER(U);
        } catch (G) {
          if (!(G instanceof pa.Err)) throw G;
          g = R.fromCompact(U);
        }
        else if (typeof U == "object" && typeof U.r == "bigint" && typeof U.s == "bigint") {
          const { r: G, s: W } = U;
          g = new R(G, W);
        } else throw new Error("PARSE");
        F = l.fromHex(C);
      } catch (G) {
        if (G.message === "PARSE") throw new Error("signature must be Signature instance, Uint8Array or hex string");
        return false;
      }
      if (Y && g.hasHighS()) return false;
      T && (A = e.hash(A));
      const { r: ee, s: E } = g, Z = q(A), k = c(E), X = a(Z * k), $ = a(ee * k), ce = (_a6 = l.BASE.multiplyAndAddUnsafe(F, X, $)) == null ? void 0 : _a6.toAffine();
      return ce ? a(ce.x) === ee : false;
    }
    return {
      CURVE: e,
      getPublicKey: B,
      getSharedSecret: D,
      sign: I,
      verify: h,
      ProjectivePoint: l,
      Signature: R,
      utils: O
    };
  }
  function PB(t) {
    return {
      hash: t,
      hmac: (e, ...n) => _E(t, e, gO(...n)),
      randomBytes: mO
    };
  }
  function _B(t, e) {
    const n = (r) => IB({
      ...t,
      ...PB(r)
    });
    return Object.freeze({
      ...n(e),
      create: n
    });
  }
  const e4 = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"), C2 = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"), RB = BigInt(1), gm = BigInt(2), I2 = (t, e) => (t + e / gm) / e;
  function NB(t) {
    const e = e4, n = BigInt(3), r = BigInt(6), i = BigInt(11), s = BigInt(22), o = BigInt(23), a = BigInt(44), c = BigInt(88), l = t * t * t % e, u = l * l * t % e, f = Mr(u, n, e) * u % e, d = Mr(f, n, e) * u % e, m = Mr(d, gm, e) * l % e, y = Mr(m, i, e) * m % e, x = Mr(y, s, e) * y % e, w = Mr(x, a, e) * x % e, R = Mr(w, c, e) * w % e, O = Mr(R, a, e) * x % e, B = Mr(O, n, e) * u % e, M = Mr(B, o, e) * y % e, D = Mr(M, r, e) * l % e, H = Mr(D, gm, e);
    if (!mm.eql(mm.sqr(H), t)) throw new Error("Cannot find square root");
    return H;
  }
  const mm = bB(e4, void 0, void 0, {
    sqrt: NB
  }), uo = _B({
    a: BigInt(0),
    b: BigInt(7),
    Fp: mm,
    n: C2,
    Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
    Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
    h: BigInt(1),
    lowS: true,
    endo: {
      beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
      splitScalar: (t) => {
        const e = C2, n = BigInt("0x3086d221a7d46bcde86c90e49284eb15"), r = -RB * BigInt("0xe4437ed6010e88286f547fa90abfe4c3"), i = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"), s = n, o = BigInt("0x100000000000000000000000000000000"), a = I2(s * t, e), c = I2(-r * t, e);
        let l = pr(t - a * n - c * i, e), u = pr(-a * r - c * s, e);
        const f = l > o, d = u > o;
        if (f && (l = e - l), d && (u = e - u), l > o || u > o) throw new Error("splitScalar: Endomorphism failed, k=" + t);
        return {
          k1neg: f,
          k1: l,
          k2neg: d,
          k2: u
        };
      }
    }
  }, NE);
  BigInt(0);
  uo.ProjectivePoint;
  const nl = "0x0000000000000000000000000000000000000000", P2 = "0x0000000000000000000000000000000000000000000000000000000000000000", OB = `Ethereum Signed Message:
`, _2 = BigInt(0), R2 = BigInt(1), N2 = BigInt(2), O2 = BigInt(27), B2 = BigInt(28), Qf = BigInt(35), $a = {};
  function M2(t) {
    return Fs(hn(t), 32);
  }
  let Kr = (_d3 = class {
    constructor(e, n, r, i) {
      __privateAdd(this, _e10);
      __privateAdd(this, _t7);
      __privateAdd(this, _n6);
      __privateAdd(this, _r5);
      ff(e, $a, "Signature"), __privateSet(this, _e10, n), __privateSet(this, _t7, r), __privateSet(this, _n6, i), __privateSet(this, _r5, null);
    }
    get r() {
      return __privateGet(this, _e10);
    }
    set r(e) {
      re(Mc(e) === 32, "invalid r", "value", e), __privateSet(this, _e10, Se(e));
    }
    get s() {
      return __privateGet(this, _t7);
    }
    set s(e) {
      re(Mc(e) === 32, "invalid s", "value", e);
      const n = Se(e);
      re(parseInt(n.substring(0, 3)) < 8, "non-canonical s", "value", n), __privateSet(this, _t7, n);
    }
    get v() {
      return __privateGet(this, _n6);
    }
    set v(e) {
      const n = Qe(e, "value");
      re(n === 27 || n === 28, "invalid v", "v", e), __privateSet(this, _n6, n);
    }
    get networkV() {
      return __privateGet(this, _r5);
    }
    get legacyChainId() {
      const e = this.networkV;
      return e == null ? null : _d3.getChainId(e);
    }
    get yParity() {
      return this.v === 27 ? 0 : 1;
    }
    get yParityAndS() {
      const e = Je(this.s);
      return this.yParity && (e[0] |= 128), Se(e);
    }
    get compactSerialized() {
      return Xt([
        this.r,
        this.yParityAndS
      ]);
    }
    get serialized() {
      return Xt([
        this.r,
        this.s,
        this.yParity ? "0x1c" : "0x1b"
      ]);
    }
    [Symbol.for("nodejs.util.inspect.custom")]() {
      return `Signature { r: "${this.r}", s: "${this.s}", yParity: ${this.yParity}, networkV: ${this.networkV} }`;
    }
    clone() {
      const e = new _d3($a, this.r, this.s, this.v);
      return this.networkV && __privateSet(e, _r5, this.networkV), e;
    }
    toJSON() {
      const e = this.networkV;
      return {
        _type: "signature",
        networkV: e != null ? e.toString() : null,
        r: this.r,
        s: this.s,
        v: this.v
      };
    }
    static getChainId(e) {
      const n = Pe(e, "v");
      return n == O2 || n == B2 ? _2 : (re(n >= Qf, "invalid EIP-155 v", "v", e), (n - Qf) / N2);
    }
    static getChainIdV(e, n) {
      return Pe(e) * N2 + BigInt(35 + n - 27);
    }
    static getNormalizedV(e) {
      const n = Pe(e);
      return n === _2 || n === O2 ? 27 : n === R2 || n === B2 ? 28 : (re(n >= Qf, "invalid v", "v", e), n & R2 ? 27 : 28);
    }
    static from(e) {
      function n(l, u) {
        re(l, u, "signature", e);
      }
      if (e == null) return new _d3($a, P2, P2, 27);
      if (typeof e == "string") {
        const l = Je(e, "signature");
        if (l.length === 64) {
          const u = Se(l.slice(0, 32)), f = l.slice(32, 64), d = f[0] & 128 ? 28 : 27;
          return f[0] &= 127, new _d3($a, u, Se(f), d);
        }
        if (l.length === 65) {
          const u = Se(l.slice(0, 32)), f = l.slice(32, 64);
          n((f[0] & 128) === 0, "non-canonical s");
          const d = _d3.getNormalizedV(l[64]);
          return new _d3($a, u, Se(f), d);
        }
        n(false, "invalid raw signature length");
      }
      if (e instanceof _d3) return e.clone();
      const r = e.r;
      n(r != null, "missing r");
      const i = M2(r), s = function(l, u) {
        if (l != null) return M2(l);
        if (u != null) {
          n(vt(u, 32), "invalid yParityAndS");
          const f = Je(u);
          return f[0] &= 127, Se(f);
        }
        n(false, "missing s");
      }(e.s, e.yParityAndS);
      n((Je(s)[0] & 128) == 0, "non-canonical s");
      const { networkV: o, v: a } = function(l, u, f) {
        if (l != null) {
          const d = Pe(l);
          return {
            networkV: d >= Qf ? d : void 0,
            v: _d3.getNormalizedV(d)
          };
        }
        if (u != null) return n(vt(u, 32), "invalid yParityAndS"), {
          v: Je(u)[0] & 128 ? 28 : 27
        };
        if (f != null) {
          switch (Qe(f, "sig.yParity")) {
            case 0:
              return {
                v: 27
              };
            case 1:
              return {
                v: 28
              };
          }
          n(false, "invalid yParity");
        }
        n(false, "missing v");
      }(e.v, e.yParityAndS, e.yParity), c = new _d3($a, i, s, a);
      return o && __privateSet(c, _r5, o), n(e.yParity == null || Qe(e.yParity, "sig.yParity") === c.yParity, "yParity mismatch"), n(e.yParityAndS == null || e.yParityAndS === c.yParityAndS, "yParityAndS mismatch"), c;
    }
  }, _e10 = new WeakMap(), _t7 = new WeakMap(), _n6 = new WeakMap(), _r5 = new WeakMap(), _d3), ay = (_e12 = class {
    constructor(e) {
      __privateAdd(this, _e11);
      re(Mc(e) === 32, "invalid private key", "privateKey", "[REDACTED]"), __privateSet(this, _e11, Se(e));
    }
    get privateKey() {
      return __privateGet(this, _e11);
    }
    get publicKey() {
      return _e12.computePublicKey(__privateGet(this, _e11));
    }
    get compressedPublicKey() {
      return _e12.computePublicKey(__privateGet(this, _e11), true);
    }
    sign(e) {
      re(Mc(e) === 32, "invalid digest length", "digest", e);
      const n = uo.sign(tr(e), tr(__privateGet(this, _e11)), {
        lowS: true
      });
      return Kr.from({
        r: No(n.r, 32),
        s: No(n.s, 32),
        v: n.recovery ? 28 : 27
      });
    }
    computeSharedSecret(e) {
      const n = _e12.computePublicKey(e);
      return Se(uo.getSharedSecret(tr(__privateGet(this, _e11)), Je(n), false));
    }
    static computePublicKey(e, n) {
      let r = Je(e, "key");
      if (r.length === 32) {
        const s = uo.getPublicKey(r, !!n);
        return Se(s);
      }
      if (r.length === 64) {
        const s = new Uint8Array(65);
        s[0] = 4, s.set(r, 1), r = s;
      }
      const i = uo.ProjectivePoint.fromHex(r);
      return Se(i.toRawBytes(n));
    }
    static recoverPublicKey(e, n) {
      re(Mc(e) === 32, "invalid digest length", "digest", e);
      const r = Kr.from(n);
      let i = uo.Signature.fromCompact(tr(Xt([
        r.r,
        r.s
      ])));
      i = i.addRecoveryBit(r.yParity);
      const s = i.recoverPublicKey(tr(e));
      return re(s != null, "invalid signature for digest", "signature", n), "0x" + s.toHex(false);
    }
    static addPoints(e, n, r) {
      const i = uo.ProjectivePoint.fromHex(_e12.computePublicKey(e).substring(2)), s = uo.ProjectivePoint.fromHex(_e12.computePublicKey(n).substring(2));
      return "0x" + i.add(s).toHex(!!r);
    }
  }, _e11 = new WeakMap(), _e12);
  const BB = BigInt(0), MB = BigInt(36);
  function k2(t) {
    t = t.toLowerCase();
    const e = t.substring(2).split(""), n = new Uint8Array(40);
    for (let i = 0; i < 40; i++) n[i] = e[i].charCodeAt(0);
    const r = Je(dn(n));
    for (let i = 0; i < 40; i += 2) r[i >> 1] >> 4 >= 8 && (e[i] = e[i].toUpperCase()), (r[i >> 1] & 15) >= 8 && (e[i + 1] = e[i + 1].toUpperCase());
    return "0x" + e.join("");
  }
  const cy = {};
  for (let t = 0; t < 10; t++) cy[String(t)] = String(t);
  for (let t = 0; t < 26; t++) cy[String.fromCharCode(65 + t)] = String(10 + t);
  const F2 = 15;
  function kB(t) {
    t = t.toUpperCase(), t = t.substring(4) + t.substring(0, 2) + "00";
    let e = t.split("").map((r) => cy[r]).join("");
    for (; e.length >= F2; ) {
      let r = e.substring(0, F2);
      e = parseInt(r, 10) % 97 + e.substring(r.length);
    }
    let n = String(98 - parseInt(e, 10) % 97);
    for (; n.length < 2; ) n = "0" + n;
    return n;
  }
  const FB = function() {
    const t = {};
    for (let e = 0; e < 36; e++) {
      const n = "0123456789abcdefghijklmnopqrstuvwxyz"[e];
      t[n] = BigInt(e);
    }
    return t;
  }();
  function LB(t) {
    t = t.toLowerCase();
    let e = BB;
    for (let n = 0; n < t.length; n++) e = e * MB + FB[t[n]];
    return e;
  }
  function ht(t) {
    if (re(typeof t == "string", "invalid address", "address", t), t.match(/^(0x)?[0-9a-fA-F]{40}$/)) {
      t.startsWith("0x") || (t = "0x" + t);
      const e = k2(t);
      return re(!t.match(/([A-F].*[a-f])|([a-f].*[A-F])/) || e === t, "bad address checksum", "address", t), e;
    }
    if (t.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
      re(t.substring(2, 4) === kB(t), "bad icap checksum", "address", t);
      let e = LB(t.substring(4)).toString(16);
      for (; e.length < 40; ) e = "0" + e;
      return k2("0x" + e);
    }
    re(false, "invalid address", "address", t);
  }
  function DB(t) {
    const e = ht(t.from);
    let r = Pe(t.nonce, "tx.nonce").toString(16);
    return r === "0" ? r = "0x" : r.length % 2 ? r = "0x0" + r : r = "0x" + r, ht(en(dn(Oo([
      e,
      r
    ])), 12));
  }
  function t4(t) {
    return t && typeof t.getAddress == "function";
  }
  async function Rp(t, e) {
    const n = await e;
    return (n == null || n === "0x0000000000000000000000000000000000000000") && (me(typeof t != "string", "unconfigured name", "UNCONFIGURED_NAME", {
      value: t
    }), re(false, "invalid AddressLike value; did not resolve to a value address", "target", t)), ht(n);
  }
  function sr(t, e) {
    if (typeof t == "string") return t.match(/^0x[0-9a-f]{40}$/i) ? ht(t) : (me(e != null, "ENS resolution requires a provider", "UNSUPPORTED_OPERATION", {
      operation: "resolveName"
    }), Rp(t, e.resolveName(t)));
    if (t4(t)) return Rp(t, t.getAddress());
    if (t && typeof t.then == "function") return Rp(t, t);
    re(false, "unsupported addressable value", "target", t);
  }
  const bs = {};
  function Ie(t, e) {
    let n = false;
    return e < 0 && (n = true, e *= -1), new nn(bs, `${n ? "" : "u"}int${e}`, t, {
      signed: n,
      width: e
    });
  }
  function lt(t, e) {
    return new nn(bs, `bytes${e || ""}`, t, {
      size: e
    });
  }
  const L2 = Symbol.for("_ethers_typed");
  const _nn = class _nn {
    constructor(e, n, r, i) {
      __publicField(this, "type");
      __publicField(this, "value");
      __privateAdd(this, _e13);
      __publicField(this, "_typedSymbol");
      i == null && (i = null), ff(bs, e, "Typed"), Me(this, {
        _typedSymbol: L2,
        type: n,
        value: r
      }), __privateSet(this, _e13, i), this.format();
    }
    format() {
      if (this.type === "array") throw new Error("");
      if (this.type === "dynamicArray") throw new Error("");
      return this.type === "tuple" ? `tuple(${this.value.map((e) => e.format()).join(",")})` : this.type;
    }
    defaultValue() {
      return 0;
    }
    minValue() {
      return 0;
    }
    maxValue() {
      return 0;
    }
    isBigInt() {
      return !!this.type.match(/^u?int[0-9]+$/);
    }
    isData() {
      return this.type.startsWith("bytes");
    }
    isString() {
      return this.type === "string";
    }
    get tupleName() {
      if (this.type !== "tuple") throw TypeError("not a tuple");
      return __privateGet(this, _e13);
    }
    get arrayLength() {
      if (this.type !== "array") throw TypeError("not an array");
      return __privateGet(this, _e13) === true ? -1 : __privateGet(this, _e13) === false ? this.value.length : null;
    }
    static from(e, n) {
      return new _nn(bs, e, n);
    }
    static uint8(e) {
      return Ie(e, 8);
    }
    static uint16(e) {
      return Ie(e, 16);
    }
    static uint24(e) {
      return Ie(e, 24);
    }
    static uint32(e) {
      return Ie(e, 32);
    }
    static uint40(e) {
      return Ie(e, 40);
    }
    static uint48(e) {
      return Ie(e, 48);
    }
    static uint56(e) {
      return Ie(e, 56);
    }
    static uint64(e) {
      return Ie(e, 64);
    }
    static uint72(e) {
      return Ie(e, 72);
    }
    static uint80(e) {
      return Ie(e, 80);
    }
    static uint88(e) {
      return Ie(e, 88);
    }
    static uint96(e) {
      return Ie(e, 96);
    }
    static uint104(e) {
      return Ie(e, 104);
    }
    static uint112(e) {
      return Ie(e, 112);
    }
    static uint120(e) {
      return Ie(e, 120);
    }
    static uint128(e) {
      return Ie(e, 128);
    }
    static uint136(e) {
      return Ie(e, 136);
    }
    static uint144(e) {
      return Ie(e, 144);
    }
    static uint152(e) {
      return Ie(e, 152);
    }
    static uint160(e) {
      return Ie(e, 160);
    }
    static uint168(e) {
      return Ie(e, 168);
    }
    static uint176(e) {
      return Ie(e, 176);
    }
    static uint184(e) {
      return Ie(e, 184);
    }
    static uint192(e) {
      return Ie(e, 192);
    }
    static uint200(e) {
      return Ie(e, 200);
    }
    static uint208(e) {
      return Ie(e, 208);
    }
    static uint216(e) {
      return Ie(e, 216);
    }
    static uint224(e) {
      return Ie(e, 224);
    }
    static uint232(e) {
      return Ie(e, 232);
    }
    static uint240(e) {
      return Ie(e, 240);
    }
    static uint248(e) {
      return Ie(e, 248);
    }
    static uint256(e) {
      return Ie(e, 256);
    }
    static uint(e) {
      return Ie(e, 256);
    }
    static int8(e) {
      return Ie(e, -8);
    }
    static int16(e) {
      return Ie(e, -16);
    }
    static int24(e) {
      return Ie(e, -24);
    }
    static int32(e) {
      return Ie(e, -32);
    }
    static int40(e) {
      return Ie(e, -40);
    }
    static int48(e) {
      return Ie(e, -48);
    }
    static int56(e) {
      return Ie(e, -56);
    }
    static int64(e) {
      return Ie(e, -64);
    }
    static int72(e) {
      return Ie(e, -72);
    }
    static int80(e) {
      return Ie(e, -80);
    }
    static int88(e) {
      return Ie(e, -88);
    }
    static int96(e) {
      return Ie(e, -96);
    }
    static int104(e) {
      return Ie(e, -104);
    }
    static int112(e) {
      return Ie(e, -112);
    }
    static int120(e) {
      return Ie(e, -120);
    }
    static int128(e) {
      return Ie(e, -128);
    }
    static int136(e) {
      return Ie(e, -136);
    }
    static int144(e) {
      return Ie(e, -144);
    }
    static int152(e) {
      return Ie(e, -152);
    }
    static int160(e) {
      return Ie(e, -160);
    }
    static int168(e) {
      return Ie(e, -168);
    }
    static int176(e) {
      return Ie(e, -176);
    }
    static int184(e) {
      return Ie(e, -184);
    }
    static int192(e) {
      return Ie(e, -192);
    }
    static int200(e) {
      return Ie(e, -200);
    }
    static int208(e) {
      return Ie(e, -208);
    }
    static int216(e) {
      return Ie(e, -216);
    }
    static int224(e) {
      return Ie(e, -224);
    }
    static int232(e) {
      return Ie(e, -232);
    }
    static int240(e) {
      return Ie(e, -240);
    }
    static int248(e) {
      return Ie(e, -248);
    }
    static int256(e) {
      return Ie(e, -256);
    }
    static int(e) {
      return Ie(e, -256);
    }
    static bytes1(e) {
      return lt(e, 1);
    }
    static bytes2(e) {
      return lt(e, 2);
    }
    static bytes3(e) {
      return lt(e, 3);
    }
    static bytes4(e) {
      return lt(e, 4);
    }
    static bytes5(e) {
      return lt(e, 5);
    }
    static bytes6(e) {
      return lt(e, 6);
    }
    static bytes7(e) {
      return lt(e, 7);
    }
    static bytes8(e) {
      return lt(e, 8);
    }
    static bytes9(e) {
      return lt(e, 9);
    }
    static bytes10(e) {
      return lt(e, 10);
    }
    static bytes11(e) {
      return lt(e, 11);
    }
    static bytes12(e) {
      return lt(e, 12);
    }
    static bytes13(e) {
      return lt(e, 13);
    }
    static bytes14(e) {
      return lt(e, 14);
    }
    static bytes15(e) {
      return lt(e, 15);
    }
    static bytes16(e) {
      return lt(e, 16);
    }
    static bytes17(e) {
      return lt(e, 17);
    }
    static bytes18(e) {
      return lt(e, 18);
    }
    static bytes19(e) {
      return lt(e, 19);
    }
    static bytes20(e) {
      return lt(e, 20);
    }
    static bytes21(e) {
      return lt(e, 21);
    }
    static bytes22(e) {
      return lt(e, 22);
    }
    static bytes23(e) {
      return lt(e, 23);
    }
    static bytes24(e) {
      return lt(e, 24);
    }
    static bytes25(e) {
      return lt(e, 25);
    }
    static bytes26(e) {
      return lt(e, 26);
    }
    static bytes27(e) {
      return lt(e, 27);
    }
    static bytes28(e) {
      return lt(e, 28);
    }
    static bytes29(e) {
      return lt(e, 29);
    }
    static bytes30(e) {
      return lt(e, 30);
    }
    static bytes31(e) {
      return lt(e, 31);
    }
    static bytes32(e) {
      return lt(e, 32);
    }
    static address(e) {
      return new _nn(bs, "address", e);
    }
    static bool(e) {
      return new _nn(bs, "bool", !!e);
    }
    static bytes(e) {
      return new _nn(bs, "bytes", e);
    }
    static string(e) {
      return new _nn(bs, "string", e);
    }
    static array(e, n) {
      throw new Error("not implemented yet");
    }
    static tuple(e, n) {
      throw new Error("not implemented yet");
    }
    static overrides(e) {
      return new _nn(bs, "overrides", Object.assign({}, e));
    }
    static isTyped(e) {
      return e && typeof e == "object" && "_typedSymbol" in e && e._typedSymbol === L2;
    }
    static dereference(e, n) {
      if (_nn.isTyped(e)) {
        if (e.type !== n) throw new Error(`invalid type: expecetd ${n}, got ${e.type}`);
        return e.value;
      }
      return e;
    }
  };
  _e13 = new WeakMap();
  let nn = _nn;
  let UB = class extends js {
    constructor(e) {
      super("address", "address", e, false);
    }
    defaultValue() {
      return "0x0000000000000000000000000000000000000000";
    }
    encode(e, n) {
      let r = nn.dereference(n, "string");
      try {
        r = ht(r);
      } catch (i) {
        return this._throwError(i.message, n);
      }
      return e.writeValue(r);
    }
    decode(e) {
      return ht(No(e.readValue(), 20));
    }
  }, HB = class extends js {
    constructor(e) {
      super(e.name, e.type, "_", e.dynamic);
      __publicField(this, "coder");
      this.coder = e;
    }
    defaultValue() {
      return this.coder.defaultValue();
    }
    encode(e, n) {
      return this.coder.encode(e, n);
    }
    decode(e) {
      return this.coder.decode(e);
    }
  };
  function n4(t, e, n) {
    let r = [];
    if (Array.isArray(n)) r = n;
    else if (n && typeof n == "object") {
      let c = {};
      r = e.map((l) => {
        const u = l.localName;
        return me(u, "cannot encode object for signature with missing names", "INVALID_ARGUMENT", {
          argument: "values",
          info: {
            coder: l
          },
          value: n
        }), me(!c[u], "cannot encode object for signature with duplicate names", "INVALID_ARGUMENT", {
          argument: "values",
          info: {
            coder: l
          },
          value: n
        }), c[u] = true, n[u];
      });
    } else re(false, "invalid tuple value", "tuple", n);
    re(e.length === r.length, "types/value length mismatch", "tuple", n);
    let i = new fm(), s = new fm(), o = [];
    e.forEach((c, l) => {
      let u = r[l];
      if (c.dynamic) {
        let f = s.length;
        c.encode(s, u);
        let d = i.writeUpdatableValue();
        o.push((m) => {
          d(m + f);
        });
      } else c.encode(i, u);
    }), o.forEach((c) => {
      c(i.length);
    });
    let a = t.appendWriter(i);
    return a += t.appendWriter(s), a;
  }
  function r4(t, e) {
    let n = [], r = [], i = t.subReader(0);
    return e.forEach((s) => {
      let o = null;
      if (s.dynamic) {
        let a = t.readIndex(), c = i.subReader(a);
        try {
          o = s.decode(c);
        } catch (l) {
          if (Un(l, "BUFFER_OVERRUN")) throw l;
          o = l, o.baseType = s.name, o.name = s.localName, o.type = s.type;
        }
      } else try {
        o = s.decode(t);
      } catch (a) {
        if (Un(a, "BUFFER_OVERRUN")) throw a;
        o = a, o.baseType = s.name, o.name = s.localName, o.type = s.type;
      }
      if (o == null) throw new Error("investigate");
      n.push(o), r.push(s.localName || null);
    }), _s.fromItems(n, r);
  }
  let GB = class extends js {
    constructor(e, n, r) {
      const i = e.type + "[" + (n >= 0 ? n : "") + "]", s = n === -1 || e.dynamic;
      super("array", i, r, s);
      __publicField(this, "coder");
      __publicField(this, "length");
      Me(this, {
        coder: e,
        length: n
      });
    }
    defaultValue() {
      const e = this.coder.defaultValue(), n = [];
      for (let r = 0; r < this.length; r++) n.push(e);
      return n;
    }
    encode(e, n) {
      const r = nn.dereference(n, "array");
      Array.isArray(r) || this._throwError("expected array value", r);
      let i = this.length;
      i === -1 && (i = r.length, e.writeValue(r.length)), uE(r.length, i, "coder array" + (this.localName ? " " + this.localName : ""));
      let s = [];
      for (let o = 0; o < r.length; o++) s.push(this.coder);
      return n4(e, s, r);
    }
    decode(e) {
      let n = this.length;
      n === -1 && (n = e.readIndex(), me(n * ir <= e.dataLength, "insufficient data length", "BUFFER_OVERRUN", {
        buffer: e.bytes,
        offset: n * ir,
        length: e.dataLength
      }));
      let r = [];
      for (let i = 0; i < n; i++) r.push(new HB(this.coder));
      return r4(e, r);
    }
  }, VB = class extends js {
    constructor(e) {
      super("bool", "bool", e, false);
    }
    defaultValue() {
      return false;
    }
    encode(e, n) {
      const r = nn.dereference(n, "bool");
      return e.writeValue(r ? 1 : 0);
    }
    decode(e) {
      return !!e.readValue();
    }
  }, i4 = class extends js {
    constructor(e, n) {
      super(e, e, n, true);
    }
    defaultValue() {
      return "0x";
    }
    encode(e, n) {
      n = tr(n);
      let r = e.writeValue(n.length);
      return r += e.writeBytes(n), r;
    }
    decode(e) {
      return e.readBytes(e.readIndex(), true);
    }
  }, zB = class extends i4 {
    constructor(e) {
      super("bytes", e);
    }
    decode(e) {
      return Se(super.decode(e));
    }
  }, QB = class extends js {
    constructor(e, n) {
      let r = "bytes" + String(e);
      super(r, r, n, false);
      __publicField(this, "size");
      Me(this, {
        size: e
      }, {
        size: "number"
      });
    }
    defaultValue() {
      return "0x0000000000000000000000000000000000000000000000000000000000000000".substring(0, 2 + this.size * 2);
    }
    encode(e, n) {
      let r = tr(nn.dereference(n, this.type));
      return r.length !== this.size && this._throwError("incorrect data length", n), e.writeBytes(r);
    }
    decode(e) {
      return Se(e.readBytes(this.size));
    }
  };
  const jB = new Uint8Array([]);
  let JB = class extends js {
    constructor(e) {
      super("null", "", e, false);
    }
    defaultValue() {
      return null;
    }
    encode(e, n) {
      return n != null && this._throwError("not null", n), e.writeBytes(jB);
    }
    decode(e) {
      return e.readBytes(0), null;
    }
  };
  const KB = BigInt(0), WB = BigInt(1), qB = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
  let YB = class extends js {
    constructor(e, n, r) {
      const i = (n ? "int" : "uint") + e * 8;
      super(i, i, r, false);
      __publicField(this, "size");
      __publicField(this, "signed");
      Me(this, {
        size: e,
        signed: n
      }, {
        size: "number",
        signed: "boolean"
      });
    }
    defaultValue() {
      return 0;
    }
    encode(e, n) {
      let r = Pe(nn.dereference(n, this.type)), i = ha(qB, ir * 8);
      if (this.signed) {
        let s = ha(i, this.size * 8 - 1);
        (r > s || r < -(s + WB)) && this._throwError("value out-of-bounds", n), r = hE(r, 8 * ir);
      } else (r < KB || r > ha(i, this.size * 8)) && this._throwError("value out-of-bounds", n);
      return e.writeValue(r);
    }
    decode(e) {
      let n = ha(e.readValue(), this.size * 8);
      return this.signed && (n = J0(n, this.size * 8)), n;
    }
  }, XB = class extends i4 {
    constructor(e) {
      super("string", e);
    }
    defaultValue() {
      return "";
    }
    encode(e, n) {
      return super.encode(e, Jr(nn.dereference(n, "string")));
    }
    decode(e) {
      return K0(super.decode(e));
    }
  }, jf = class extends js {
    constructor(e, n) {
      let r = false;
      const i = [];
      e.forEach((o) => {
        o.dynamic && (r = true), i.push(o.type);
      });
      const s = "tuple(" + i.join(",") + ")";
      super("tuple", s, n, r);
      __publicField(this, "coders");
      Me(this, {
        coders: Object.freeze(e.slice())
      });
    }
    defaultValue() {
      const e = [];
      this.coders.forEach((r) => {
        e.push(r.defaultValue());
      });
      const n = this.coders.reduce((r, i) => {
        const s = i.localName;
        return s && (r[s] || (r[s] = 0), r[s]++), r;
      }, {});
      return this.coders.forEach((r, i) => {
        let s = r.localName;
        !s || n[s] !== 1 || (s === "length" && (s = "_length"), e[s] == null && (e[s] = e[i]));
      }), Object.freeze(e);
    }
    encode(e, n) {
      const r = nn.dereference(n, "tuple");
      return n4(e, this.coders, r);
    }
    decode(e) {
      return r4(e, this.coders);
    }
  };
  function Np(t, e) {
    return {
      address: ht(t),
      storageKeys: e.map((n, r) => (re(vt(n, 32), "invalid slot", `storageKeys[${r}]`, n), n.toLowerCase()))
    };
  }
  function Ua(t) {
    if (Array.isArray(t)) return t.map((n, r) => Array.isArray(n) ? (re(n.length === 2, "invalid slot set", `value[${r}]`, n), Np(n[0], n[1])) : (re(n != null && typeof n == "object", "invalid address-slot set", "value", t), Np(n.address, n.storageKeys)));
    re(t != null && typeof t == "object", "invalid access list", "value", t);
    const e = Object.keys(t).map((n) => {
      const r = t[n].reduce((i, s) => (i[s] = true, i), {});
      return Np(n, Object.keys(r).sort());
    });
    return e.sort((n, r) => n.address.localeCompare(r.address)), e;
  }
  function s4(t) {
    return {
      address: ht(t.address),
      nonce: Pe(t.nonce != null ? t.nonce : 0),
      chainId: Pe(t.chainId != null ? t.chainId : 0),
      signature: Kr.from(t.signature)
    };
  }
  function ZB(t) {
    let e;
    return typeof t == "string" ? e = ay.computePublicKey(t, false) : e = t.publicKey, ht(dn("0x" + e.substring(4)).substring(26));
  }
  function $B(t, e) {
    return ZB(ay.recoverPublicKey(t, e));
  }
  const In = BigInt(0), eM = BigInt(2), tM = BigInt(27), nM = BigInt(28), rM = BigInt(35), iM = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"), Op = 4096 * 32;
  function sM(t) {
    return {
      blobToKzgCommitment: (r) => {
        if ("computeBlobProof" in t) {
          if ("blobToKzgCommitment" in t && typeof t.blobToKzgCommitment == "function") return Je(t.blobToKzgCommitment(Se(r)));
        } else if ("blobToKzgCommitment" in t && typeof t.blobToKzgCommitment == "function") return Je(t.blobToKzgCommitment(r));
        if ("blobToKZGCommitment" in t && typeof t.blobToKZGCommitment == "function") return Je(t.blobToKZGCommitment(Se(r)));
        re(false, "unsupported KZG library", "kzg", t);
      },
      computeBlobKzgProof: (r, i) => {
        if ("computeBlobProof" in t && typeof t.computeBlobProof == "function") return Je(t.computeBlobProof(Se(r), Se(i)));
        if ("computeBlobKzgProof" in t && typeof t.computeBlobKzgProof == "function") return t.computeBlobKzgProof(r, i);
        if ("computeBlobKZGProof" in t && typeof t.computeBlobKZGProof == "function") return Je(t.computeBlobKZGProof(Se(r), Se(i)));
        re(false, "unsupported KZG library", "kzg", t);
      }
    };
  }
  function D2(t, e) {
    let n = t.toString(16);
    for (; n.length < 2; ) n = "0" + n;
    return n += xl(e).substring(4), "0x" + n;
  }
  function Al(t) {
    return t === "0x" ? null : ht(t);
  }
  function qd(t, e) {
    try {
      return Ua(t);
    } catch (n) {
      re(false, n.message, e, t);
    }
  }
  function oM(t, e) {
    try {
      if (!Array.isArray(t)) throw new Error("authorizationList: invalid array");
      const n = [];
      for (let r = 0; r < t.length; r++) {
        const i = t[r];
        if (!Array.isArray(i)) throw new Error(`authorization[${r}]: invalid array`);
        if (i.length !== 6) throw new Error(`authorization[${r}]: wrong length`);
        if (!i[1]) throw new Error(`authorization[${r}]: null address`);
        n.push({
          address: Al(i[1]),
          nonce: gt(i[2], "nonce"),
          chainId: gt(i[0], "chainId"),
          signature: Kr.from({
            yParity: Ha(i[3], "yParity"),
            r: Fs(i[4], 32),
            s: Fs(i[5], 32)
          })
        });
      }
      return n;
    } catch (n) {
      re(false, n.message, e, t);
    }
  }
  function Ha(t, e) {
    return t === "0x" ? 0 : Qe(t, e);
  }
  function gt(t, e) {
    if (t === "0x") return In;
    const n = Pe(t, e);
    return re(n <= iM, "value exceeds uint size", e, n), n;
  }
  function nt(t, e) {
    const n = Pe(t, "value"), r = hn(n);
    return re(r.length <= 32, "value too large", `tx.${e}`, n), r;
  }
  function Yd(t) {
    return Ua(t).map((e) => [
      e.address,
      e.storageKeys
    ]);
  }
  function aM(t) {
    return t.map((e) => [
      nt(e.chainId, "chainId"),
      e.address,
      nt(e.nonce, "nonce"),
      nt(e.signature.yParity, "yParity"),
      hn(e.signature.r),
      hn(e.signature.s)
    ]);
  }
  function cM(t, e) {
    re(Array.isArray(t), `invalid ${e}`, "value", t);
    for (let n = 0; n < t.length; n++) re(vt(t[n], 32), "invalid ${ param } hash", `value[${n}]`, t[n]);
    return t;
  }
  function lM(t) {
    const e = df(t);
    re(Array.isArray(e) && (e.length === 9 || e.length === 6), "invalid field count for legacy transaction", "data", t);
    const n = {
      type: 0,
      nonce: Ha(e[0], "nonce"),
      gasPrice: gt(e[1], "gasPrice"),
      gasLimit: gt(e[2], "gasLimit"),
      to: Al(e[3]),
      value: gt(e[4], "value"),
      data: Se(e[5]),
      chainId: In
    };
    if (e.length === 6) return n;
    const r = gt(e[6], "v"), i = gt(e[7], "r"), s = gt(e[8], "s");
    if (i === In && s === In) n.chainId = r;
    else {
      let o = (r - rM) / eM;
      o < In && (o = In), n.chainId = o, re(o !== In || r === tM || r === nM, "non-canonical legacy v", "v", e[6]), n.signature = Kr.from({
        r: Fs(e[7], 32),
        s: Fs(e[8], 32),
        v: r
      });
    }
    return n;
  }
  function uM(t, e) {
    const n = [
      nt(t.nonce, "nonce"),
      nt(t.gasPrice || 0, "gasPrice"),
      nt(t.gasLimit, "gasLimit"),
      t.to || "0x",
      nt(t.value, "value"),
      t.data
    ];
    let r = In;
    if (t.chainId != In) r = Pe(t.chainId, "tx.chainId"), re(!e || e.networkV == null || e.legacyChainId === r, "tx.chainId/sig.v mismatch", "sig", e);
    else if (t.signature) {
      const s = t.signature.legacyChainId;
      s != null && (r = s);
    }
    if (!e) return r !== In && (n.push(hn(r)), n.push("0x"), n.push("0x")), Oo(n);
    let i = BigInt(27 + e.yParity);
    return r !== In ? i = Kr.getChainIdV(r, e.v) : BigInt(e.v) !== i && re(false, "tx.chainId/sig.v mismatch", "sig", e), n.push(hn(i)), n.push(hn(e.r)), n.push(hn(e.s)), Oo(n);
  }
  function Xd(t, e) {
    let n;
    try {
      if (n = Ha(e[0], "yParity"), n !== 0 && n !== 1) throw new Error("bad yParity");
    } catch {
      re(false, "invalid yParity", "yParity", e[0]);
    }
    const r = Fs(e[1], 32), i = Fs(e[2], 32), s = Kr.from({
      r,
      s: i,
      yParity: n
    });
    t.signature = s;
  }
  function fM(t) {
    const e = df(Je(t).slice(1));
    re(Array.isArray(e) && (e.length === 9 || e.length === 12), "invalid field count for transaction type: 2", "data", Se(t));
    const n = {
      type: 2,
      chainId: gt(e[0], "chainId"),
      nonce: Ha(e[1], "nonce"),
      maxPriorityFeePerGas: gt(e[2], "maxPriorityFeePerGas"),
      maxFeePerGas: gt(e[3], "maxFeePerGas"),
      gasPrice: null,
      gasLimit: gt(e[4], "gasLimit"),
      to: Al(e[5]),
      value: gt(e[6], "value"),
      data: Se(e[7]),
      accessList: qd(e[8], "accessList")
    };
    return e.length === 9 || Xd(n, e.slice(9)), n;
  }
  function dM(t, e) {
    const n = [
      nt(t.chainId, "chainId"),
      nt(t.nonce, "nonce"),
      nt(t.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"),
      nt(t.maxFeePerGas || 0, "maxFeePerGas"),
      nt(t.gasLimit, "gasLimit"),
      t.to || "0x",
      nt(t.value, "value"),
      t.data,
      Yd(t.accessList || [])
    ];
    return e && (n.push(nt(e.yParity, "yParity")), n.push(hn(e.r)), n.push(hn(e.s))), Xt([
      "0x02",
      Oo(n)
    ]);
  }
  function hM(t) {
    const e = df(Je(t).slice(1));
    re(Array.isArray(e) && (e.length === 8 || e.length === 11), "invalid field count for transaction type: 1", "data", Se(t));
    const n = {
      type: 1,
      chainId: gt(e[0], "chainId"),
      nonce: Ha(e[1], "nonce"),
      gasPrice: gt(e[2], "gasPrice"),
      gasLimit: gt(e[3], "gasLimit"),
      to: Al(e[4]),
      value: gt(e[5], "value"),
      data: Se(e[6]),
      accessList: qd(e[7], "accessList")
    };
    return e.length === 8 || Xd(n, e.slice(8)), n;
  }
  function pM(t, e) {
    const n = [
      nt(t.chainId, "chainId"),
      nt(t.nonce, "nonce"),
      nt(t.gasPrice || 0, "gasPrice"),
      nt(t.gasLimit, "gasLimit"),
      t.to || "0x",
      nt(t.value, "value"),
      t.data,
      Yd(t.accessList || [])
    ];
    return e && (n.push(nt(e.yParity, "recoveryParam")), n.push(hn(e.r)), n.push(hn(e.s))), Xt([
      "0x01",
      Oo(n)
    ]);
  }
  function gM(t) {
    let e = df(Je(t).slice(1)), n = "3", r = null;
    if (e.length === 4 && Array.isArray(e[0])) {
      n = "3 (network format)";
      const s = e[1], o = e[2], a = e[3];
      re(Array.isArray(s), "invalid network format: blobs not an array", "fields[1]", s), re(Array.isArray(o), "invalid network format: commitments not an array", "fields[2]", o), re(Array.isArray(a), "invalid network format: proofs not an array", "fields[3]", a), re(s.length === o.length, "invalid network format: blobs/commitments length mismatch", "fields", e), re(s.length === a.length, "invalid network format: blobs/proofs length mismatch", "fields", e), r = [];
      for (let c = 0; c < e[1].length; c++) r.push({
        data: s[c],
        commitment: o[c],
        proof: a[c]
      });
      e = e[0];
    }
    re(Array.isArray(e) && (e.length === 11 || e.length === 14), `invalid field count for transaction type: ${n}`, "data", Se(t));
    const i = {
      type: 3,
      chainId: gt(e[0], "chainId"),
      nonce: Ha(e[1], "nonce"),
      maxPriorityFeePerGas: gt(e[2], "maxPriorityFeePerGas"),
      maxFeePerGas: gt(e[3], "maxFeePerGas"),
      gasPrice: null,
      gasLimit: gt(e[4], "gasLimit"),
      to: Al(e[5]),
      value: gt(e[6], "value"),
      data: Se(e[7]),
      accessList: qd(e[8], "accessList"),
      maxFeePerBlobGas: gt(e[9], "maxFeePerBlobGas"),
      blobVersionedHashes: e[10]
    };
    r && (i.blobs = r), re(i.to != null, `invalid address for transaction type: ${n}`, "data", t), re(Array.isArray(i.blobVersionedHashes), "invalid blobVersionedHashes: must be an array", "data", t);
    for (let s = 0; s < i.blobVersionedHashes.length; s++) re(vt(i.blobVersionedHashes[s], 32), `invalid blobVersionedHash at index ${s}: must be length 32`, "data", t);
    return e.length === 11 || Xd(i, e.slice(11)), i;
  }
  function mM(t, e, n) {
    const r = [
      nt(t.chainId, "chainId"),
      nt(t.nonce, "nonce"),
      nt(t.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"),
      nt(t.maxFeePerGas || 0, "maxFeePerGas"),
      nt(t.gasLimit, "gasLimit"),
      t.to || nl,
      nt(t.value, "value"),
      t.data,
      Yd(t.accessList || []),
      nt(t.maxFeePerBlobGas || 0, "maxFeePerBlobGas"),
      cM(t.blobVersionedHashes || [], "blobVersionedHashes")
    ];
    return e && (r.push(nt(e.yParity, "yParity")), r.push(hn(e.r)), r.push(hn(e.s)), n) ? Xt([
      "0x03",
      Oo([
        r,
        n.map((i) => i.data),
        n.map((i) => i.commitment),
        n.map((i) => i.proof)
      ])
    ]) : Xt([
      "0x03",
      Oo(r)
    ]);
  }
  function yM(t) {
    const e = df(Je(t).slice(1));
    re(Array.isArray(e) && (e.length === 10 || e.length === 13), "invalid field count for transaction type: 4", "data", Se(t));
    const n = {
      type: 4,
      chainId: gt(e[0], "chainId"),
      nonce: Ha(e[1], "nonce"),
      maxPriorityFeePerGas: gt(e[2], "maxPriorityFeePerGas"),
      maxFeePerGas: gt(e[3], "maxFeePerGas"),
      gasPrice: null,
      gasLimit: gt(e[4], "gasLimit"),
      to: Al(e[5]),
      value: gt(e[6], "value"),
      data: Se(e[7]),
      accessList: qd(e[8], "accessList"),
      authorizationList: oM(e[9], "authorizationList")
    };
    return e.length === 10 || Xd(n, e.slice(10)), n;
  }
  function bM(t, e) {
    const n = [
      nt(t.chainId, "chainId"),
      nt(t.nonce, "nonce"),
      nt(t.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"),
      nt(t.maxFeePerGas || 0, "maxFeePerGas"),
      nt(t.gasLimit, "gasLimit"),
      t.to || "0x",
      nt(t.value, "value"),
      t.data,
      Yd(t.accessList || []),
      aM(t.authorizationList || [])
    ];
    return e && (n.push(nt(e.yParity, "yParity")), n.push(hn(e.r)), n.push(hn(e.s))), Xt([
      "0x04",
      Oo(n)
    ]);
  }
  const _li = class _li {
    constructor() {
      __privateAdd(this, _li_instances);
      __privateAdd(this, _e14);
      __privateAdd(this, _t8);
      __privateAdd(this, _n7);
      __privateAdd(this, _r6);
      __privateAdd(this, _i5);
      __privateAdd(this, _o4);
      __privateAdd(this, _s3);
      __privateAdd(this, _a4);
      __privateAdd(this, _f3);
      __privateAdd(this, _l3);
      __privateAdd(this, _p3);
      __privateAdd(this, _g3);
      __privateAdd(this, _c4);
      __privateAdd(this, _u3);
      __privateAdd(this, _d4);
      __privateAdd(this, _h2);
      __privateAdd(this, _y2);
      __privateSet(this, _e14, null), __privateSet(this, _t8, null), __privateSet(this, _r6, 0), __privateSet(this, _i5, In), __privateSet(this, _o4, null), __privateSet(this, _s3, null), __privateSet(this, _a4, null), __privateSet(this, _n7, "0x"), __privateSet(this, _f3, In), __privateSet(this, _l3, In), __privateSet(this, _p3, null), __privateSet(this, _g3, null), __privateSet(this, _c4, null), __privateSet(this, _u3, null), __privateSet(this, _d4, null), __privateSet(this, _h2, null), __privateSet(this, _y2, null);
    }
    get type() {
      return __privateGet(this, _e14);
    }
    set type(e) {
      switch (e) {
        case null:
          __privateSet(this, _e14, null);
          break;
        case 0:
        case "legacy":
          __privateSet(this, _e14, 0);
          break;
        case 1:
        case "berlin":
        case "eip-2930":
          __privateSet(this, _e14, 1);
          break;
        case 2:
        case "london":
        case "eip-1559":
          __privateSet(this, _e14, 2);
          break;
        case 3:
        case "cancun":
        case "eip-4844":
          __privateSet(this, _e14, 3);
          break;
        case 4:
        case "pectra":
        case "eip-7702":
          __privateSet(this, _e14, 4);
          break;
        default:
          re(false, "unsupported transaction type", "type", e);
      }
    }
    get typeName() {
      switch (this.type) {
        case 0:
          return "legacy";
        case 1:
          return "eip-2930";
        case 2:
          return "eip-1559";
        case 3:
          return "eip-4844";
        case 4:
          return "eip-7702";
      }
      return null;
    }
    get to() {
      const e = __privateGet(this, _t8);
      return e == null && this.type === 3 ? nl : e;
    }
    set to(e) {
      __privateSet(this, _t8, e == null ? null : ht(e));
    }
    get nonce() {
      return __privateGet(this, _r6);
    }
    set nonce(e) {
      __privateSet(this, _r6, Qe(e, "value"));
    }
    get gasLimit() {
      return __privateGet(this, _i5);
    }
    set gasLimit(e) {
      __privateSet(this, _i5, Pe(e));
    }
    get gasPrice() {
      const e = __privateGet(this, _o4);
      return e == null && (this.type === 0 || this.type === 1) ? In : e;
    }
    set gasPrice(e) {
      __privateSet(this, _o4, e == null ? null : Pe(e, "gasPrice"));
    }
    get maxPriorityFeePerGas() {
      const e = __privateGet(this, _s3);
      return e ?? (this.type === 2 || this.type === 3 ? In : null);
    }
    set maxPriorityFeePerGas(e) {
      __privateSet(this, _s3, e == null ? null : Pe(e, "maxPriorityFeePerGas"));
    }
    get maxFeePerGas() {
      const e = __privateGet(this, _a4);
      return e ?? (this.type === 2 || this.type === 3 ? In : null);
    }
    set maxFeePerGas(e) {
      __privateSet(this, _a4, e == null ? null : Pe(e, "maxFeePerGas"));
    }
    get data() {
      return __privateGet(this, _n7);
    }
    set data(e) {
      __privateSet(this, _n7, Se(e));
    }
    get value() {
      return __privateGet(this, _f3);
    }
    set value(e) {
      __privateSet(this, _f3, Pe(e, "value"));
    }
    get chainId() {
      return __privateGet(this, _l3);
    }
    set chainId(e) {
      __privateSet(this, _l3, Pe(e));
    }
    get signature() {
      return __privateGet(this, _p3) || null;
    }
    set signature(e) {
      __privateSet(this, _p3, e == null ? null : Kr.from(e));
    }
    get accessList() {
      const e = __privateGet(this, _g3) || null;
      return e ?? (this.type === 1 || this.type === 2 || this.type === 3 ? [] : null);
    }
    set accessList(e) {
      __privateSet(this, _g3, e == null ? null : Ua(e));
    }
    get authorizationList() {
      const e = __privateGet(this, _y2) || null;
      return e == null && this.type === 4 ? [] : e;
    }
    set authorizationList(e) {
      __privateSet(this, _y2, e == null ? null : e.map((n) => s4(n)));
    }
    get maxFeePerBlobGas() {
      const e = __privateGet(this, _c4);
      return e == null && this.type === 3 ? In : e;
    }
    set maxFeePerBlobGas(e) {
      __privateSet(this, _c4, e == null ? null : Pe(e, "maxFeePerBlobGas"));
    }
    get blobVersionedHashes() {
      let e = __privateGet(this, _u3);
      return e == null && this.type === 3 ? [] : e;
    }
    set blobVersionedHashes(e) {
      if (e != null) {
        re(Array.isArray(e), "blobVersionedHashes must be an Array", "value", e), e = e.slice();
        for (let n = 0; n < e.length; n++) re(vt(e[n], 32), "invalid blobVersionedHash", `value[${n}]`, e[n]);
      }
      __privateSet(this, _u3, e);
    }
    get blobs() {
      return __privateGet(this, _h2) == null ? null : __privateGet(this, _h2).map((e) => Object.assign({}, e));
    }
    set blobs(e) {
      if (e == null) {
        __privateSet(this, _h2, null);
        return;
      }
      const n = [], r = [];
      for (let i = 0; i < e.length; i++) {
        const s = e[i];
        if (Z1(s)) {
          me(__privateGet(this, _d4), "adding a raw blob requires a KZG library", "UNSUPPORTED_OPERATION", {
            operation: "set blobs()"
          });
          let o = Je(s);
          if (re(o.length <= Op, "blob is too large", `blobs[${i}]`, s), o.length !== Op) {
            const l = new Uint8Array(Op);
            l.set(o), o = l;
          }
          const a = __privateGet(this, _d4).blobToKzgCommitment(o), c = Se(__privateGet(this, _d4).computeBlobKzgProof(o, a));
          n.push({
            data: Se(o),
            commitment: Se(a),
            proof: c
          }), r.push(D2(1, a));
        } else {
          const o = Se(s.commitment);
          n.push({
            data: Se(s.data),
            commitment: o,
            proof: Se(s.proof)
          }), r.push(D2(1, o));
        }
      }
      __privateSet(this, _h2, n), __privateSet(this, _u3, r);
    }
    get kzg() {
      return __privateGet(this, _d4);
    }
    set kzg(e) {
      e == null ? __privateSet(this, _d4, null) : __privateSet(this, _d4, sM(e));
    }
    get hash() {
      return this.signature == null ? null : dn(__privateMethod(this, _li_instances, m_fn).call(this, true, false));
    }
    get unsignedHash() {
      return dn(this.unsignedSerialized);
    }
    get from() {
      return this.signature == null ? null : $B(this.unsignedHash, this.signature);
    }
    get fromPublicKey() {
      return this.signature == null ? null : ay.recoverPublicKey(this.unsignedHash, this.signature);
    }
    isSigned() {
      return this.signature != null;
    }
    get serialized() {
      return __privateMethod(this, _li_instances, m_fn).call(this, true, true);
    }
    get unsignedSerialized() {
      return __privateMethod(this, _li_instances, m_fn).call(this, false, false);
    }
    inferType() {
      const e = this.inferTypes();
      return e.indexOf(2) >= 0 ? 2 : e.pop();
    }
    inferTypes() {
      const e = this.gasPrice != null, n = this.maxFeePerGas != null || this.maxPriorityFeePerGas != null, r = this.accessList != null, i = __privateGet(this, _c4) != null || __privateGet(this, _u3);
      this.maxFeePerGas != null && this.maxPriorityFeePerGas != null && me(this.maxFeePerGas >= this.maxPriorityFeePerGas, "priorityFee cannot be more than maxFee", "BAD_DATA", {
        value: this
      }), me(!n || this.type !== 0 && this.type !== 1, "transaction type cannot have maxFeePerGas or maxPriorityFeePerGas", "BAD_DATA", {
        value: this
      }), me(this.type !== 0 || !r, "legacy transaction cannot have accessList", "BAD_DATA", {
        value: this
      });
      const s = [];
      return this.type != null ? s.push(this.type) : this.authorizationList && this.authorizationList.length ? s.push(4) : n ? s.push(2) : e ? (s.push(1), r || s.push(0)) : r ? (s.push(1), s.push(2)) : (i && this.to || (s.push(0), s.push(1), s.push(2)), s.push(3)), s.sort(), s;
    }
    isLegacy() {
      return this.type === 0;
    }
    isBerlin() {
      return this.type === 1;
    }
    isLondon() {
      return this.type === 2;
    }
    isCancun() {
      return this.type === 3;
    }
    clone() {
      return _li.from(this);
    }
    toJSON() {
      const e = (n) => n == null ? null : n.toString();
      return {
        type: this.type,
        to: this.to,
        data: this.data,
        nonce: this.nonce,
        gasLimit: e(this.gasLimit),
        gasPrice: e(this.gasPrice),
        maxPriorityFeePerGas: e(this.maxPriorityFeePerGas),
        maxFeePerGas: e(this.maxFeePerGas),
        value: e(this.value),
        chainId: e(this.chainId),
        sig: this.signature ? this.signature.toJSON() : null,
        accessList: this.accessList
      };
    }
    static from(e) {
      if (e == null) return new _li();
      if (typeof e == "string") {
        const r = Je(e);
        if (r[0] >= 127) return _li.from(lM(r));
        switch (r[0]) {
          case 1:
            return _li.from(hM(r));
          case 2:
            return _li.from(fM(r));
          case 3:
            return _li.from(gM(r));
          case 4:
            return _li.from(yM(r));
        }
        me(false, "unsupported transaction type", "UNSUPPORTED_OPERATION", {
          operation: "from"
        });
      }
      const n = new _li();
      return e.type != null && (n.type = e.type), e.to != null && (n.to = e.to), e.nonce != null && (n.nonce = e.nonce), e.gasLimit != null && (n.gasLimit = e.gasLimit), e.gasPrice != null && (n.gasPrice = e.gasPrice), e.maxPriorityFeePerGas != null && (n.maxPriorityFeePerGas = e.maxPriorityFeePerGas), e.maxFeePerGas != null && (n.maxFeePerGas = e.maxFeePerGas), e.maxFeePerBlobGas != null && (n.maxFeePerBlobGas = e.maxFeePerBlobGas), e.data != null && (n.data = e.data), e.value != null && (n.value = e.value), e.chainId != null && (n.chainId = e.chainId), e.signature != null && (n.signature = Kr.from(e.signature)), e.accessList != null && (n.accessList = e.accessList), e.authorizationList != null && (n.authorizationList = e.authorizationList), e.blobVersionedHashes != null && (n.blobVersionedHashes = e.blobVersionedHashes), e.kzg != null && (n.kzg = e.kzg), e.blobs != null && (n.blobs = e.blobs), e.hash != null && (re(n.isSigned(), "unsigned transaction cannot define '.hash'", "tx", e), re(n.hash === e.hash, "hash mismatch", "tx", e)), e.from != null && (re(n.isSigned(), "unsigned transaction cannot define '.from'", "tx", e), re(n.from.toLowerCase() === (e.from || "").toLowerCase(), "from mismatch", "tx", e)), n;
    }
  };
  _e14 = new WeakMap();
  _t8 = new WeakMap();
  _n7 = new WeakMap();
  _r6 = new WeakMap();
  _i5 = new WeakMap();
  _o4 = new WeakMap();
  _s3 = new WeakMap();
  _a4 = new WeakMap();
  _f3 = new WeakMap();
  _l3 = new WeakMap();
  _p3 = new WeakMap();
  _g3 = new WeakMap();
  _c4 = new WeakMap();
  _u3 = new WeakMap();
  _d4 = new WeakMap();
  _h2 = new WeakMap();
  _y2 = new WeakMap();
  _li_instances = new WeakSet();
  m_fn = function(e, n) {
    me(!e || this.signature != null, "cannot serialize unsigned transaction; maybe you meant .unsignedSerialized", "UNSUPPORTED_OPERATION", {
      operation: ".serialized"
    });
    const r = e ? this.signature : null;
    switch (this.inferType()) {
      case 0:
        return uM(this, r);
      case 1:
        return pM(this, r);
      case 2:
        return dM(this, r);
      case 3:
        return mM(this, r, n ? this.blobs : null);
      case 4:
        return bM(this, r);
    }
    me(false, "unsupported transaction type", "UNSUPPORTED_OPERATION", {
      operation: ".serialized"
    });
  };
  let li = _li;
  function _a(t) {
    return dn(Jr(t));
  }
  var xM = "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";
  const U2 = /* @__PURE__ */ new Map([
    [
      8217,
      "apostrophe"
    ],
    [
      8260,
      "fraction slash"
    ],
    [
      12539,
      "middle dot"
    ]
  ]), H2 = 4;
  function AM(t) {
    let e = 0;
    function n() {
      return t[e++] << 8 | t[e++];
    }
    let r = n(), i = 1, s = [
      0,
      1
    ];
    for (let D = 1; D < r; D++) s.push(i += n());
    let o = n(), a = e;
    e += o;
    let c = 0, l = 0;
    function u() {
      return c == 0 && (l = l << 8 | t[e++], c = 8), l >> --c & 1;
    }
    const f = 31, d = 2 ** f, m = d >>> 1, y = m >> 1, x = d - 1;
    let w = 0;
    for (let D = 0; D < f; D++) w = w << 1 | u();
    let R = [], O = 0, B = d;
    for (; ; ) {
      let D = Math.floor(((w - O + 1) * i - 1) / B), H = 0, q = r;
      for (; q - H > 1; ) {
        let L = H + q >>> 1;
        D < s[L] ? q = L : H = L;
      }
      if (H == 0) break;
      R.push(H);
      let S = O + Math.floor(B * s[H] / i), P = O + Math.floor(B * s[H + 1] / i) - 1;
      for (; !((S ^ P) & m); ) w = w << 1 & x | u(), S = S << 1 & x, P = P << 1 & x | 1;
      for (; S & ~P & y; ) w = w & m | w << 1 & x >>> 1 | u(), S = S << 1 ^ m, P = (P ^ m) << 1 | m | 1;
      O = S, B = 1 + P - S;
    }
    let M = r - 4;
    return R.map((D) => {
      switch (D - M) {
        case 3:
          return M + 65792 + (t[a++] << 16 | t[a++] << 8 | t[a++]);
        case 2:
          return M + 256 + (t[a++] << 8 | t[a++]);
        case 1:
          return M + t[a++];
        default:
          return D - 1;
      }
    });
  }
  function wM(t) {
    let e = 0;
    return () => t[e++];
  }
  function o4(t) {
    return wM(AM(vM(t)));
  }
  function vM(t) {
    let e = [];
    [
      ..."ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
    ].forEach((i, s) => e[i.charCodeAt(0)] = s);
    let n = t.length, r = new Uint8Array(6 * n >> 3);
    for (let i = 0, s = 0, o = 0, a = 0; i < n; i++) a = a << 6 | e[t.charCodeAt(i)], o += 6, o >= 8 && (r[s++] = a >> (o -= 8));
    return r;
  }
  function EM(t) {
    return t & 1 ? ~t >> 1 : t >> 1;
  }
  function SM(t, e) {
    let n = Array(t);
    for (let r = 0, i = 0; r < t; r++) n[r] = i += EM(e());
    return n;
  }
  function Du(t, e = 0) {
    let n = [];
    for (; ; ) {
      let r = t(), i = t();
      if (!i) break;
      e += r;
      for (let s = 0; s < i; s++) n.push(e + s);
      e += i + 1;
    }
    return n;
  }
  function a4(t) {
    return Uu(() => {
      let e = Du(t);
      if (e.length) return e;
    });
  }
  function c4(t) {
    let e = [];
    for (; ; ) {
      let n = t();
      if (n == 0) break;
      e.push(TM(n, t));
    }
    for (; ; ) {
      let n = t() - 1;
      if (n < 0) break;
      e.push(CM(n, t));
    }
    return e.flat();
  }
  function Uu(t) {
    let e = [];
    for (; ; ) {
      let n = t(e.length);
      if (!n) break;
      e.push(n);
    }
    return e;
  }
  function l4(t, e, n) {
    let r = Array(t).fill().map(() => []);
    for (let i = 0; i < e; i++) SM(t, n).forEach((s, o) => r[o].push(s));
    return r;
  }
  function TM(t, e) {
    let n = 1 + e(), r = e(), i = Uu(e);
    return l4(i.length, 1 + t, e).flatMap((o, a) => {
      let [c, ...l] = o;
      return Array(i[a]).fill().map((u, f) => {
        let d = f * r;
        return [
          c + f * n,
          l.map((m) => m + d)
        ];
      });
    });
  }
  function CM(t, e) {
    let n = 1 + e();
    return l4(n, 1 + t, e).map((i) => [
      i[0],
      i.slice(1)
    ]);
  }
  function IM(t) {
    let e = [], n = Du(t);
    return i(r([]), []), e;
    function r(s) {
      let o = t(), a = Uu(() => {
        let c = Du(t).map((l) => n[l]);
        if (c.length) return r(c);
      });
      return {
        S: o,
        B: a,
        Q: s
      };
    }
    function i({ S: s, B: o }, a, c) {
      if (!(s & 4 && c === a[a.length - 1])) {
        s & 2 && (c = a[a.length - 1]), s & 1 && e.push(a);
        for (let l of o) for (let u of l.Q) i(l, [
          ...a,
          u
        ], c);
      }
    }
  }
  function PM(t) {
    return t.toString(16).toUpperCase().padStart(2, "0");
  }
  function u4(t) {
    return `{${PM(t)}}`;
  }
  function _M(t) {
    let e = [];
    for (let n = 0, r = t.length; n < r; ) {
      let i = t.codePointAt(n);
      n += i < 65536 ? 1 : 2, e.push(i);
    }
    return e;
  }
  function rl(t) {
    let n = t.length;
    if (n < 4096) return String.fromCodePoint(...t);
    let r = [];
    for (let i = 0; i < n; ) r.push(String.fromCodePoint(...t.slice(i, i += 4096)));
    return r.join("");
  }
  function RM(t, e) {
    let n = t.length, r = n - e.length;
    for (let i = 0; r == 0 && i < n; i++) r = t[i] - e[i];
    return r;
  }
  var NM = "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";
  const Hu = 44032, q0 = 4352, Y0 = 4449, X0 = 4519, f4 = 19, d4 = 21, il = 28, Z0 = d4 * il, OM = f4 * Z0, BM = Hu + OM, MM = q0 + f4, kM = Y0 + d4, FM = X0 + il;
  function $l(t) {
    return t >> 24 & 255;
  }
  function h4(t) {
    return t & 16777215;
  }
  let ym, G2, bm, f0;
  function LM() {
    let t = o4(NM);
    ym = new Map(a4(t).flatMap((e, n) => e.map((r) => [
      r,
      n + 1 << 24
    ]))), G2 = new Set(Du(t)), bm = /* @__PURE__ */ new Map(), f0 = /* @__PURE__ */ new Map();
    for (let [e, n] of c4(t)) {
      if (!G2.has(e) && n.length == 2) {
        let [r, i] = n, s = f0.get(r);
        s || (s = /* @__PURE__ */ new Map(), f0.set(r, s)), s.set(i, e);
      }
      bm.set(e, n.reverse());
    }
  }
  function p4(t) {
    return t >= Hu && t < BM;
  }
  function DM(t, e) {
    if (t >= q0 && t < MM && e >= Y0 && e < kM) return Hu + (t - q0) * Z0 + (e - Y0) * il;
    if (p4(t) && e > X0 && e < FM && (t - Hu) % il == 0) return t + (e - X0);
    {
      let n = f0.get(t);
      return n && (n = n.get(e), n) ? n : -1;
    }
  }
  function g4(t) {
    ym || LM();
    let e = [], n = [], r = false;
    function i(s) {
      let o = ym.get(s);
      o && (r = true, s |= o), e.push(s);
    }
    for (let s of t) for (; ; ) {
      if (s < 128) e.push(s);
      else if (p4(s)) {
        let o = s - Hu, a = o / Z0 | 0, c = o % Z0 / il | 0, l = o % il;
        i(q0 + a), i(Y0 + c), l > 0 && i(X0 + l);
      } else {
        let o = bm.get(s);
        o ? n.push(...o) : i(s);
      }
      if (!n.length) break;
      s = n.pop();
    }
    if (r && e.length > 1) {
      let s = $l(e[0]);
      for (let o = 1; o < e.length; o++) {
        let a = $l(e[o]);
        if (a == 0 || s <= a) {
          s = a;
          continue;
        }
        let c = o - 1;
        for (; ; ) {
          let l = e[c + 1];
          if (e[c + 1] = e[c], e[c] = l, !c || (s = $l(e[--c]), s <= a)) break;
        }
        s = $l(e[o]);
      }
    }
    return e;
  }
  function UM(t) {
    let e = [], n = [], r = -1, i = 0;
    for (let s of t) {
      let o = $l(s), a = h4(s);
      if (r == -1) o == 0 ? r = a : e.push(a);
      else if (i > 0 && i >= o) o == 0 ? (e.push(r, ...n), n.length = 0, r = a) : n.push(a), i = o;
      else {
        let c = DM(r, a);
        c >= 0 ? r = c : i == 0 && o == 0 ? (e.push(r), r = a) : (n.push(a), i = o);
      }
    }
    return r >= 0 && e.push(r, ...n), e;
  }
  function m4(t) {
    return g4(t).map(h4);
  }
  function HM(t) {
    return UM(g4(t));
  }
  const V2 = 45, y4 = ".", b4 = 65039, x4 = 1, $0 = (t) => Array.from(t);
  function Gu(t, e) {
    return t.P.has(e) || t.Q.has(e);
  }
  class GM extends Array {
    get is_emoji() {
      return true;
    }
  }
  let xm, A4, ga, Am, w4, Fc, Bp, dc, aa, z2, wm;
  function ly() {
    if (xm) return;
    let t = o4(xM);
    const e = () => Du(t), n = () => new Set(e()), r = (u, f) => f.forEach((d) => u.add(d));
    xm = new Map(c4(t)), A4 = n(), ga = e(), Am = new Set(e().map((u) => ga[u])), ga = new Set(ga), w4 = n(), n();
    let i = a4(t), s = t();
    const o = () => {
      let u = /* @__PURE__ */ new Set();
      return e().forEach((f) => r(u, i[f])), r(u, e()), u;
    };
    Fc = Uu((u) => {
      let f = Uu(t).map((d) => d + 96);
      if (f.length) {
        let d = u >= s;
        f[0] -= 32, f = rl(f), d && (f = `Restricted[${f}]`);
        let m = o(), y = o(), x = !t();
        return {
          N: f,
          P: m,
          Q: y,
          M: x,
          R: d
        };
      }
    }), Bp = n(), dc = /* @__PURE__ */ new Map();
    let a = e().concat($0(Bp)).sort((u, f) => u - f);
    a.forEach((u, f) => {
      let d = t(), m = a[f] = d ? a[f - d] : {
        V: [],
        M: /* @__PURE__ */ new Map()
      };
      m.V.push(u), Bp.has(u) || dc.set(u, m);
    });
    for (let { V: u, M: f } of new Set(dc.values())) {
      let d = [];
      for (let y of u) {
        let x = Fc.filter((R) => Gu(R, y)), w = d.find(({ G: R }) => x.some((O) => R.has(O)));
        w || (w = {
          G: /* @__PURE__ */ new Set(),
          V: []
        }, d.push(w)), w.V.push(y), r(w.G, x);
      }
      let m = d.flatMap((y) => $0(y.G));
      for (let { G: y, V: x } of d) {
        let w = new Set(m.filter((R) => !y.has(R)));
        for (let R of x) f.set(R, w);
      }
    }
    aa = /* @__PURE__ */ new Set();
    let c = /* @__PURE__ */ new Set();
    const l = (u) => aa.has(u) ? c.add(u) : aa.add(u);
    for (let u of Fc) {
      for (let f of u.P) l(f);
      for (let f of u.Q) l(f);
    }
    for (let u of aa) !dc.has(u) && !c.has(u) && dc.set(u, x4);
    r(aa, m4(aa)), z2 = IM(t).map((u) => GM.from(u)).sort(RM), wm = /* @__PURE__ */ new Map();
    for (let u of z2) {
      let f = [
        wm
      ];
      for (let d of u) {
        let m = f.map((y) => {
          let x = y.get(d);
          return x || (x = /* @__PURE__ */ new Map(), y.set(d, x)), x;
        });
        d === b4 ? f.push(...m) : f = m;
      }
      for (let d of f) d.V = u;
    }
  }
  function uy(t) {
    return (v4(t) ? "" : `${fy(Zd([
      t
    ]))} `) + u4(t);
  }
  function fy(t) {
    return `"${t}"\u200E`;
  }
  function VM(t) {
    if (t.length >= 4 && t[2] == V2 && t[3] == V2) throw new Error(`invalid label extension: "${rl(t.slice(0, 4))}"`);
  }
  function zM(t) {
    for (let n = t.lastIndexOf(95); n > 0; ) if (t[--n] !== 95) throw new Error("underscore allowed only at start");
  }
  function QM(t) {
    let e = t[0], n = U2.get(e);
    if (n) throw pu(`leading ${n}`);
    let r = t.length, i = -1;
    for (let s = 1; s < r; s++) {
      e = t[s];
      let o = U2.get(e);
      if (o) {
        if (i == s) throw pu(`${n} + ${o}`);
        i = s + 1, n = o;
      }
    }
    if (i == r) throw pu(`trailing ${n}`);
  }
  function Zd(t, e = 1 / 0, n = u4) {
    let r = [];
    jM(t[0]) && r.push("\u25CC"), t.length > e && (e >>= 1, t = [
      ...t.slice(0, e),
      8230,
      ...t.slice(-e)
    ]);
    let i = 0, s = t.length;
    for (let o = 0; o < s; o++) {
      let a = t[o];
      v4(a) && (r.push(rl(t.slice(i, o))), r.push(n(a)), i = o + 1);
    }
    return r.push(rl(t.slice(i, s))), r.join("");
  }
  function jM(t) {
    return ly(), ga.has(t);
  }
  function v4(t) {
    return ly(), w4.has(t);
  }
  function JM(t) {
    return YM(KM(t, HM, $M));
  }
  function KM(t, e, n) {
    if (!t) return [];
    ly();
    let r = 0;
    return t.split(y4).map((i) => {
      let s = _M(i), o = {
        input: s,
        offset: r
      };
      r += s.length + 1;
      try {
        let a = o.tokens = ZM(s, e, n), c = a.length, l;
        if (!c) throw new Error("empty label");
        let u = o.output = a.flat();
        if (zM(u), !(o.emoji = c > 1 || a[0].is_emoji) && u.every((d) => d < 128)) VM(u), l = "ASCII";
        else {
          let d = a.flatMap((m) => m.is_emoji ? [] : m);
          if (!d.length) l = "Emoji";
          else {
            if (ga.has(u[0])) throw pu("leading combining mark");
            for (let x = 1; x < c; x++) {
              let w = a[x];
              if (!w.is_emoji && ga.has(w[0])) throw pu(`emoji + combining mark: "${rl(a[x - 1])} + ${Zd([
                w[0]
              ])}"`);
            }
            QM(u);
            let m = $0(new Set(d)), [y] = qM(m);
            XM(y, d), WM(y, m), l = y.N;
          }
        }
        o.type = l;
      } catch (a) {
        o.error = a;
      }
      return o;
    });
  }
  function WM(t, e) {
    let n, r = [];
    for (let i of e) {
      let s = dc.get(i);
      if (s === x4) return;
      if (s) {
        let o = s.M.get(i);
        if (n = n ? n.filter((a) => o.has(a)) : $0(o), !n.length) return;
      } else r.push(i);
    }
    if (n) {
      for (let i of n) if (r.every((s) => Gu(i, s))) throw new Error(`whole-script confusable: ${t.N}/${i.N}`);
    }
  }
  function qM(t) {
    let e = Fc;
    for (let n of t) {
      let r = e.filter((i) => Gu(i, n));
      if (!r.length) throw Fc.some((i) => Gu(i, n)) ? S4(e[0], n) : E4(n);
      if (e = r, r.length == 1) break;
    }
    return e;
  }
  function YM(t) {
    return t.map(({ input: e, error: n, output: r }) => {
      if (n) {
        let i = n.message;
        throw new Error(t.length == 1 ? i : `Invalid label ${fy(Zd(e, 63))}: ${i}`);
      }
      return rl(r);
    }).join(y4);
  }
  function E4(t) {
    return new Error(`disallowed character: ${uy(t)}`);
  }
  function S4(t, e) {
    let n = uy(e), r = Fc.find((i) => i.P.has(e));
    return r && (n = `${r.N} ${n}`), new Error(`illegal mixture: ${t.N} + ${n}`);
  }
  function pu(t) {
    return new Error(`illegal placement: ${t}`);
  }
  function XM(t, e) {
    for (let n of e) if (!Gu(t, n)) throw S4(t, n);
    if (t.M) {
      let n = m4(e);
      for (let r = 1, i = n.length; r < i; r++) if (Am.has(n[r])) {
        let s = r + 1;
        for (let o; s < i && Am.has(o = n[s]); s++) for (let a = r; a < s; a++) if (n[a] == o) throw new Error(`duplicate non-spacing marks: ${uy(o)}`);
        if (s - r > H2) throw new Error(`excessive non-spacing marks: ${fy(Zd(n.slice(r - 1, s)))} (${s - r}/${H2})`);
        r = s;
      }
    }
  }
  function ZM(t, e, n) {
    let r = [], i = [];
    for (t = t.slice().reverse(); t.length; ) {
      let s = ek(t);
      if (s) i.length && (r.push(e(i)), i = []), r.push(n(s));
      else {
        let o = t.pop();
        if (aa.has(o)) i.push(o);
        else {
          let a = xm.get(o);
          if (a) i.push(...a);
          else if (!A4.has(o)) throw E4(o);
        }
      }
    }
    return i.length && r.push(e(i)), r;
  }
  function $M(t) {
    return t.filter((e) => e != b4);
  }
  function ek(t, e) {
    let n = wm, r, i = t.length;
    for (; i && (n = n.get(t[--i]), !!n); ) {
      let { V: s } = n;
      s && (r = s, t.length = i);
    }
    return r;
  }
  const T4 = new Uint8Array(32);
  T4.fill(0);
  function Q2(t) {
    return re(t.length !== 0, "invalid ENS name; empty component", "comp", t), t;
  }
  function C4(t) {
    const e = Jr(tk(t)), n = [];
    if (t.length === 0) return n;
    let r = 0;
    for (let i = 0; i < e.length; i++) e[i] === 46 && (n.push(Q2(e.slice(r, i))), r = i + 1);
    return re(r < e.length, "invalid ENS name; empty component", "name", t), n.push(Q2(e.slice(r))), n;
  }
  function tk(t) {
    try {
      if (t.length === 0) throw new Error("empty label");
      return JM(t);
    } catch (e) {
      re(false, `invalid ENS name (${e.message})`, "name", t);
    }
  }
  function vm(t) {
    re(typeof t == "string", "invalid ENS name; not a string", "name", t), re(t.length, "invalid ENS name (empty label)", "name", t);
    let e = T4;
    const n = C4(t);
    for (; n.length; ) e = dn(Xt([
      e,
      dn(n.pop())
    ]));
    return Se(e);
  }
  function nk(t, e) {
    const n = e;
    return re(n <= 255, "DNS encoded label cannot exceed 255", "length", n), Se(Xt(C4(t).map((r) => {
      re(r.length <= n, `label ${JSON.stringify(t)} exceeds ${n} bytes`, "name", t);
      const i = new Uint8Array(r.length + 1);
      return i.set(r, 1), i[0] = i.length - 1, i;
    }))) + "00";
  }
  function rk(t) {
    return typeof t == "string" && (t = Jr(t)), dn(Xt([
      Jr(OB),
      Jr(String(t.length)),
      t
    ]));
  }
  const I4 = new Uint8Array(32);
  I4.fill(0);
  const ik = BigInt(-1), P4 = BigInt(0), _4 = BigInt(1), sk = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
  function ok(t) {
    const e = Je(t), n = e.length % 32;
    return n ? Xt([
      e,
      I4.slice(n)
    ]) : Se(e);
  }
  const ak = No(_4, 32), ck = No(P4, 32), j2 = {
    name: "string",
    version: "string",
    chainId: "uint256",
    verifyingContract: "address",
    salt: "bytes32"
  }, Mp = [
    "name",
    "version",
    "chainId",
    "verifyingContract",
    "salt"
  ];
  function J2(t) {
    return function(e) {
      return re(typeof e == "string", `invalid domain value for ${JSON.stringify(t)}`, `domain.${t}`, e), e;
    };
  }
  const lk = {
    name: J2("name"),
    version: J2("version"),
    chainId: function(t) {
      const e = Pe(t, "domain.chainId");
      return re(e >= 0, "invalid chain ID", "domain.chainId", t), Number.isSafeInteger(e) ? Number(e) : di(e);
    },
    verifyingContract: function(t) {
      try {
        return ht(t).toLowerCase();
      } catch {
      }
      re(false, 'invalid domain value "verifyingContract"', "domain.verifyingContract", t);
    },
    salt: function(t) {
      const e = Je(t, "domain.salt");
      return re(e.length === 32, 'invalid domain value "salt"', "domain.salt", t), Se(e);
    }
  };
  function kp(t) {
    {
      const e = t.match(/^(u?)int(\d+)$/);
      if (e) {
        const n = e[1] === "", r = parseInt(e[2]);
        re(r % 8 === 0 && r !== 0 && r <= 256 && e[2] === String(r), "invalid numeric width", "type", t);
        const i = ha(sk, n ? r - 1 : r), s = n ? (i + _4) * ik : P4;
        return function(o) {
          const a = Pe(o, "value");
          return re(a >= s && a <= i, `value out-of-bounds for ${t}`, "value", a), No(n ? hE(a, 256) : a, 32);
        };
      }
    }
    {
      const e = t.match(/^bytes(\d+)$/);
      if (e) {
        const n = parseInt(e[1]);
        return re(n !== 0 && n <= 32 && e[1] === String(n), "invalid bytes width", "type", t), function(r) {
          const i = Je(r);
          return re(i.length === n, `invalid length for ${t}`, "value", r), ok(r);
        };
      }
    }
    switch (t) {
      case "address":
        return function(e) {
          return Fs(ht(e), 32);
        };
      case "bool":
        return function(e) {
          return e ? ak : ck;
        };
      case "bytes":
        return function(e) {
          return dn(e);
        };
      case "string":
        return function(e) {
          return _a(e);
        };
    }
    return null;
  }
  function K2(t, e) {
    return `${t}(${e.map(({ name: n, type: r }) => r + " " + n).join(",")})`;
  }
  function Jf(t) {
    const e = t.match(/^([^\x5b]*)((\x5b\d*\x5d)*)(\x5b(\d*)\x5d)$/);
    return e ? {
      base: e[1],
      index: e[2] + e[4],
      array: {
        base: e[1],
        prefix: e[1] + e[2],
        count: e[5] ? parseInt(e[5]) : -1
      }
    } : {
      base: t
    };
  }
  let W2 = (_f4 = class {
    constructor(e) {
      __privateAdd(this, _ii_instances);
      __publicField(this, "primaryType");
      __privateAdd(this, _e15);
      __privateAdd(this, _t9);
      __privateAdd(this, _n8);
      __privateSet(this, _t9, /* @__PURE__ */ new Map()), __privateSet(this, _n8, /* @__PURE__ */ new Map());
      const n = /* @__PURE__ */ new Map(), r = /* @__PURE__ */ new Map(), i = /* @__PURE__ */ new Map(), s = {};
      Object.keys(e).forEach((c) => {
        s[c] = e[c].map(({ name: l, type: u }) => {
          let { base: f, index: d } = Jf(u);
          return f === "int" && !e.int && (f = "int256"), f === "uint" && !e.uint && (f = "uint256"), {
            name: l,
            type: f + (d || "")
          };
        }), n.set(c, /* @__PURE__ */ new Set()), r.set(c, []), i.set(c, /* @__PURE__ */ new Set());
      }), __privateSet(this, _e15, JSON.stringify(s));
      for (const c in s) {
        const l = /* @__PURE__ */ new Set();
        for (const u of s[c]) {
          re(!l.has(u.name), `duplicate variable name ${JSON.stringify(u.name)} in ${JSON.stringify(c)}`, "types", e), l.add(u.name);
          const f = Jf(u.type).base;
          re(f !== c, `circular type reference to ${JSON.stringify(f)}`, "types", e), !kp(f) && (re(r.has(f), `unknown type ${JSON.stringify(f)}`, "types", e), r.get(f).push(c), n.get(c).add(f));
        }
      }
      const o = Array.from(r.keys()).filter((c) => r.get(c).length === 0);
      re(o.length !== 0, "missing primary type", "types", e), re(o.length === 1, `ambiguous primary types or unused types: ${o.map((c) => JSON.stringify(c)).join(", ")}`, "types", e), Me(this, {
        primaryType: o[0]
      });
      function a(c, l) {
        re(!l.has(c), `circular type reference to ${JSON.stringify(c)}`, "types", e), l.add(c);
        for (const u of n.get(c)) if (r.has(u)) {
          a(u, l);
          for (const f of l) i.get(f).add(u);
        }
        l.delete(c);
      }
      a(this.primaryType, /* @__PURE__ */ new Set());
      for (const [c, l] of i) {
        const u = Array.from(l);
        u.sort(), __privateGet(this, _t9).set(c, K2(c, s[c]) + u.map((f) => K2(f, s[f])).join(""));
      }
    }
    get types() {
      return JSON.parse(__privateGet(this, _e15));
    }
    getEncoder(e) {
      let n = __privateGet(this, _n8).get(e);
      return n || (n = __privateMethod(this, _ii_instances, r_fn2).call(this, e), __privateGet(this, _n8).set(e, n)), n;
    }
    encodeType(e) {
      const n = __privateGet(this, _t9).get(e);
      return re(n, `unknown type: ${JSON.stringify(e)}`, "name", e), n;
    }
    encodeData(e, n) {
      return this.getEncoder(e)(n);
    }
    hashStruct(e, n) {
      return dn(this.encodeData(e, n));
    }
    encode(e) {
      return this.encodeData(this.primaryType, e);
    }
    hash(e) {
      return this.hashStruct(this.primaryType, e);
    }
    _visit(e, n, r) {
      if (kp(e)) return r(e, n);
      const i = Jf(e).array;
      if (i) return re(i.count === -1 || i.count === n.length, `array length mismatch; expected length ${i.count}`, "value", n), n.map((o) => this._visit(i.prefix, o, r));
      const s = this.types[e];
      if (s) return s.reduce((o, { name: a, type: c }) => (o[a] = this._visit(c, n[a], r), o), {});
      re(false, `unknown type: ${e}`, "type", e);
    }
    visit(e, n) {
      return this._visit(this.primaryType, e, n);
    }
    static from(e) {
      return new _f4(e);
    }
    static getPrimaryType(e) {
      return _f4.from(e).primaryType;
    }
    static hashStruct(e, n, r) {
      return _f4.from(n).hashStruct(e, r);
    }
    static hashDomain(e) {
      const n = [];
      for (const r in e) {
        if (e[r] == null) continue;
        const i = j2[r];
        re(i, `invalid typed-data domain key: ${JSON.stringify(r)}`, "domain", e), n.push({
          name: r,
          type: i
        });
      }
      return n.sort((r, i) => Mp.indexOf(r.name) - Mp.indexOf(i.name)), _f4.hashStruct("EIP712Domain", {
        EIP712Domain: n
      }, e);
    }
    static encode(e, n, r) {
      return Xt([
        "0x1901",
        _f4.hashDomain(e),
        _f4.from(n).hash(r)
      ]);
    }
    static hash(e, n, r) {
      return dn(_f4.encode(e, n, r));
    }
    static async resolveNames(e, n, r, i) {
      e = Object.assign({}, e);
      for (const a in e) e[a] == null && delete e[a];
      const s = {};
      e.verifyingContract && !vt(e.verifyingContract, 20) && (s[e.verifyingContract] = "0x");
      const o = _f4.from(n);
      o.visit(r, (a, c) => (a === "address" && !vt(c, 20) && (s[c] = "0x"), c));
      for (const a in s) s[a] = await i(a);
      return e.verifyingContract && s[e.verifyingContract] && (e.verifyingContract = s[e.verifyingContract]), r = o.visit(r, (a, c) => a === "address" && s[c] ? s[c] : c), {
        domain: e,
        value: r
      };
    }
    static getPayload(e, n, r) {
      _f4.hashDomain(e);
      const i = {}, s = [];
      Mp.forEach((c) => {
        const l = e[c];
        l != null && (i[c] = lk[c](l), s.push({
          name: c,
          type: j2[c]
        }));
      });
      const o = _f4.from(n);
      n = o.types;
      const a = Object.assign({}, n);
      return re(a.EIP712Domain == null, "types must not contain EIP712Domain type", "types.EIP712Domain", n), a.EIP712Domain = s, o.encode(r), {
        types: a,
        domain: i,
        primaryType: o.primaryType,
        message: o.visit(r, (c, l) => {
          if (c.match(/^bytes(\d*)/)) return Se(Je(l));
          if (c.match(/^u?int/)) return Pe(l).toString();
          switch (c) {
            case "address":
              return l.toLowerCase();
            case "bool":
              return !!l;
            case "string":
              return re(typeof l == "string", "invalid string", "value", l), l;
          }
          re(false, "unsupported type", "type", c);
        })
      };
    }
  }, _e15 = new WeakMap(), _t9 = new WeakMap(), _n8 = new WeakMap(), _ii_instances = new WeakSet(), r_fn2 = function(e) {
    {
      const i = kp(e);
      if (i) return i;
    }
    const n = Jf(e).array;
    if (n) {
      const i = n.prefix, s = this.getEncoder(i);
      return (o) => {
        re(n.count === -1 || n.count === o.length, `array length mismatch; expected length ${n.count}`, "value", o);
        let a = o.map(s);
        return __privateGet(this, _t9).has(i) && (a = a.map(dn)), dn(Xt(a));
      };
    }
    const r = this.types[e];
    if (r) {
      const i = _a(__privateGet(this, _t9).get(e));
      return (s) => {
        const o = r.map(({ name: a, type: c }) => {
          const l = this.getEncoder(c)(s[a]);
          return __privateGet(this, _t9).has(c) ? dn(l) : l;
        });
        return o.unshift(i), Xt(o);
      };
    }
    re(false, `unknown type: ${e}`, "type", e);
  }, _f4);
  function or(t) {
    const e = /* @__PURE__ */ new Set();
    return t.forEach((n) => e.add(n)), Object.freeze(e);
  }
  const uk = "external public payable override", fk = or(uk.split(" ")), R4 = "constant external internal payable private public pure view override", dk = or(R4.split(" ")), N4 = "constructor error event fallback function receive struct", O4 = or(N4.split(" ")), B4 = "calldata memory storage payable indexed", hk = or(B4.split(" ")), pk = "tuple returns", gk = [
    N4,
    B4,
    pk,
    R4
  ].join(" "), mk = or(gk.split(" ")), yk = {
    "(": "OPEN_PAREN",
    ")": "CLOSE_PAREN",
    "[": "OPEN_BRACKET",
    "]": "CLOSE_BRACKET",
    ",": "COMMA",
    "@": "AT"
  }, bk = new RegExp("^(\\s*)"), xk = new RegExp("^([0-9]+)"), Ak = new RegExp("^([a-zA-Z$_][a-zA-Z0-9$_]*)"), M4 = new RegExp("^([a-zA-Z$_][a-zA-Z0-9$_]*)$"), k4 = new RegExp("^(address|bool|bytes([0-9]*)|string|u?int([0-9]*))$");
  const _qr = class _qr {
    constructor(e) {
      __privateAdd(this, _qr_instances);
      __privateAdd(this, _e16);
      __privateAdd(this, _t10);
      __privateSet(this, _e16, 0), __privateSet(this, _t10, e.slice());
    }
    get offset() {
      return __privateGet(this, _e16);
    }
    get length() {
      return __privateGet(this, _t10).length - __privateGet(this, _e16);
    }
    clone() {
      return new _qr(__privateGet(this, _t10));
    }
    reset() {
      __privateSet(this, _e16, 0);
    }
    popKeyword(e) {
      const n = this.peek();
      if (n.type !== "KEYWORD" || !e.has(n.text)) throw new Error(`expected keyword ${n.text}`);
      return this.pop().text;
    }
    popType(e) {
      if (this.peek().type !== e) {
        const n = this.peek();
        throw new Error(`expected ${e}; got ${n.type} ${JSON.stringify(n.text)}`);
      }
      return this.pop().text;
    }
    popParen() {
      const e = this.peek();
      if (e.type !== "OPEN_PAREN") throw new Error("bad start");
      const n = __privateMethod(this, _qr_instances, n_fn2).call(this, __privateGet(this, _e16) + 1, e.match + 1);
      return __privateSet(this, _e16, e.match + 1), n;
    }
    popParams() {
      const e = this.peek();
      if (e.type !== "OPEN_PAREN") throw new Error("bad start");
      const n = [];
      for (; __privateGet(this, _e16) < e.match - 1; ) {
        const r = this.peek().linkNext;
        n.push(__privateMethod(this, _qr_instances, n_fn2).call(this, __privateGet(this, _e16) + 1, r)), __privateSet(this, _e16, r);
      }
      return __privateSet(this, _e16, e.match + 1), n;
    }
    peek() {
      if (__privateGet(this, _e16) >= __privateGet(this, _t10).length) throw new Error("out-of-bounds");
      return __privateGet(this, _t10)[__privateGet(this, _e16)];
    }
    peekKeyword(e) {
      const n = this.peekType("KEYWORD");
      return n != null && e.has(n) ? n : null;
    }
    peekType(e) {
      if (this.length === 0) return null;
      const n = this.peek();
      return n.type === e ? n.text : null;
    }
    pop() {
      const e = this.peek();
      return __privateWrapper(this, _e16)._++, e;
    }
    toString() {
      const e = [];
      for (let n = __privateGet(this, _e16); n < __privateGet(this, _t10).length; n++) {
        const r = __privateGet(this, _t10)[n];
        e.push(`${r.type}:${r.text}`);
      }
      return `<TokenString ${e.join(" ")}>`;
    }
  };
  _e16 = new WeakMap();
  _t10 = new WeakMap();
  _qr_instances = new WeakSet();
  n_fn2 = function(e = 0, n = 0) {
    return new _qr(__privateGet(this, _t10).slice(e, n).map((r) => Object.freeze(Object.assign({}, r, {
      match: r.match - e,
      linkBack: r.linkBack - e,
      linkNext: r.linkNext - e
    }))));
  };
  let qr = _qr;
  function Lo(t) {
    const e = [], n = (o) => {
      const a = s < t.length ? JSON.stringify(t[s]) : "$EOI";
      throw new Error(`invalid token ${a} at ${s}: ${o}`);
    };
    let r = [], i = [], s = 0;
    for (; s < t.length; ) {
      let o = t.substring(s), a = o.match(bk);
      a && (s += a[1].length, o = t.substring(s));
      const c = {
        depth: r.length,
        linkBack: -1,
        linkNext: -1,
        match: -1,
        type: "",
        text: "",
        offset: s,
        value: -1
      };
      e.push(c);
      let l = yk[o[0]] || "";
      if (l) {
        if (c.type = l, c.text = o[0], s++, l === "OPEN_PAREN") r.push(e.length - 1), i.push(e.length - 1);
        else if (l == "CLOSE_PAREN") r.length === 0 && n("no matching open bracket"), c.match = r.pop(), e[c.match].match = e.length - 1, c.depth--, c.linkBack = i.pop(), e[c.linkBack].linkNext = e.length - 1;
        else if (l === "COMMA") c.linkBack = i.pop(), e[c.linkBack].linkNext = e.length - 1, i.push(e.length - 1);
        else if (l === "OPEN_BRACKET") c.type = "BRACKET";
        else if (l === "CLOSE_BRACKET") {
          let u = e.pop().text;
          if (e.length > 0 && e[e.length - 1].type === "NUMBER") {
            const f = e.pop().text;
            u = f + u, e[e.length - 1].value = Qe(f);
          }
          if (e.length === 0 || e[e.length - 1].type !== "BRACKET") throw new Error("missing opening bracket");
          e[e.length - 1].text += u;
        }
        continue;
      }
      if (a = o.match(Ak), a) {
        if (c.text = a[1], s += c.text.length, mk.has(c.text)) {
          c.type = "KEYWORD";
          continue;
        }
        if (c.text.match(k4)) {
          c.type = "TYPE";
          continue;
        }
        c.type = "ID";
        continue;
      }
      if (a = o.match(xk), a) {
        c.text = a[1], c.type = "NUMBER", s += c.text.length;
        continue;
      }
      throw new Error(`unexpected token ${JSON.stringify(o[0])} at position ${s}`);
    }
    return new qr(e.map((o) => Object.freeze(o)));
  }
  function q2(t, e) {
    let n = [];
    for (const r in e.keys()) t.has(r) && n.push(r);
    if (n.length > 1) throw new Error(`conflicting types: ${n.join(", ")}`);
  }
  function $d(t, e) {
    if (e.peekKeyword(O4)) {
      const n = e.pop().text;
      if (n !== t) throw new Error(`expected ${t}, got ${n}`);
    }
    return e.popType("ID");
  }
  function Ds(t, e) {
    const n = /* @__PURE__ */ new Set();
    for (; ; ) {
      const r = t.peekType("KEYWORD");
      if (r == null || e && !e.has(r)) break;
      if (t.pop(), n.has(r)) throw new Error(`duplicate keywords: ${JSON.stringify(r)}`);
      n.add(r);
    }
    return Object.freeze(n);
  }
  function F4(t) {
    let e = Ds(t, dk);
    return q2(e, or("constant payable nonpayable".split(" "))), q2(e, or("pure view payable nonpayable".split(" "))), e.has("view") ? "view" : e.has("pure") ? "pure" : e.has("payable") ? "payable" : e.has("nonpayable") ? "nonpayable" : e.has("constant") ? "view" : "nonpayable";
  }
  function Rs(t, e) {
    return t.popParams().map((n) => cr.from(n, e));
  }
  function L4(t) {
    if (t.peekType("AT")) {
      if (t.pop(), t.peekType("NUMBER")) return Pe(t.pop().text);
      throw new Error("invalid gas");
    }
    return null;
  }
  function Ra(t) {
    if (t.length) throw new Error(`unexpected tokens at offset ${t.offset}: ${t.toString()}`);
  }
  const wk = new RegExp(/^(.*)\[([0-9]*)\]$/);
  function Y2(t) {
    const e = t.match(k4);
    if (re(e, "invalid type", "type", t), t === "uint") return "uint256";
    if (t === "int") return "int256";
    if (e[2]) {
      const n = parseInt(e[2]);
      re(n !== 0 && n <= 32, "invalid bytes length", "type", t);
    } else if (e[3]) {
      const n = parseInt(e[3]);
      re(n !== 0 && n <= 256 && n % 8 === 0, "invalid numeric width", "type", t);
    }
    return t;
  }
  const qt = {}, Ar = Symbol.for("_ethers_internal"), X2 = "_ParamTypeInternal", Z2 = "_ErrorInternal", $2 = "_EventInternal", eA = "_ConstructorInternal", tA = "_FallbackInternal", nA = "_FunctionInternal", rA = "_StructInternal";
  let cr = (_g4 = class {
    constructor(e, n, r, i, s, o, a, c) {
      __privateAdd(this, _si_instances);
      __publicField(this, "name");
      __publicField(this, "type");
      __publicField(this, "baseType");
      __publicField(this, "indexed");
      __publicField(this, "components");
      __publicField(this, "arrayLength");
      __publicField(this, "arrayChildren");
      if (ff(e, qt, "ParamType"), Object.defineProperty(this, Ar, {
        value: X2
      }), o && (o = Object.freeze(o.slice())), i === "array") {
        if (a == null || c == null) throw new Error("");
      } else if (a != null || c != null) throw new Error("");
      if (i === "tuple") {
        if (o == null) throw new Error("");
      } else if (o != null) throw new Error("");
      Me(this, {
        name: n,
        type: r,
        baseType: i,
        indexed: s,
        components: o,
        arrayLength: a,
        arrayChildren: c
      });
    }
    format(e) {
      if (e == null && (e = "sighash"), e === "json") {
        const r = this.name || "";
        if (this.isArray()) {
          const s = JSON.parse(this.arrayChildren.format("json"));
          return s.name = r, s.type += `[${this.arrayLength < 0 ? "" : String(this.arrayLength)}]`, JSON.stringify(s);
        }
        const i = {
          type: this.baseType === "tuple" ? "tuple" : this.type,
          name: r
        };
        return typeof this.indexed == "boolean" && (i.indexed = this.indexed), this.isTuple() && (i.components = this.components.map((s) => JSON.parse(s.format(e)))), JSON.stringify(i);
      }
      let n = "";
      return this.isArray() ? (n += this.arrayChildren.format(e), n += `[${this.arrayLength < 0 ? "" : String(this.arrayLength)}]`) : this.isTuple() ? n += "(" + this.components.map((r) => r.format(e)).join(e === "full" ? ", " : ",") + ")" : n += this.type, e !== "sighash" && (this.indexed === true && (n += " indexed"), e === "full" && this.name && (n += " " + this.name)), n;
    }
    isArray() {
      return this.baseType === "array";
    }
    isTuple() {
      return this.baseType === "tuple";
    }
    isIndexable() {
      return this.indexed != null;
    }
    walk(e, n) {
      if (this.isArray()) {
        if (!Array.isArray(e)) throw new Error("invalid array value");
        if (this.arrayLength !== -1 && e.length !== this.arrayLength) throw new Error("array is wrong length");
        const r = this;
        return e.map((i) => r.arrayChildren.walk(i, n));
      }
      if (this.isTuple()) {
        if (!Array.isArray(e)) throw new Error("invalid tuple value");
        if (e.length !== this.components.length) throw new Error("array is wrong length");
        const r = this;
        return e.map((i, s) => r.components[s].walk(i, n));
      }
      return n(this.type, e);
    }
    async walkAsync(e, n) {
      const r = [], i = [
        e
      ];
      return __privateMethod(this, _si_instances, e_fn).call(this, r, e, n, (s) => {
        i[0] = s;
      }), r.length && await Promise.all(r), i[0];
    }
    static from(e, n) {
      if (_g4.isParamType(e)) return e;
      if (typeof e == "string") try {
        return _g4.from(Lo(e), n);
      } catch {
        re(false, "invalid param type", "obj", e);
      }
      else if (e instanceof qr) {
        let a = "", c = "", l = null;
        Ds(e, or([
          "tuple"
        ])).has("tuple") || e.peekType("OPEN_PAREN") ? (c = "tuple", l = e.popParams().map((x) => _g4.from(x)), a = `tuple(${l.map((x) => x.format()).join(",")})`) : (a = Y2(e.popType("TYPE")), c = a);
        let u = null, f = null;
        for (; e.length && e.peekType("BRACKET"); ) {
          const x = e.pop();
          u = new _g4(qt, "", a, c, null, l, f, u), f = x.value, a += x.text, c = "array", l = null;
        }
        let d = null;
        if (Ds(e, hk).has("indexed")) {
          if (!n) throw new Error("");
          d = true;
        }
        const y = e.peekType("ID") ? e.pop().text : "";
        if (e.length) throw new Error("leftover tokens");
        return new _g4(qt, y, a, c, d, l, f, u);
      }
      const r = e.name;
      re(!r || typeof r == "string" && r.match(M4), "invalid name", "obj.name", r);
      let i = e.indexed;
      i != null && (re(n, "parameter cannot be indexed", "obj.indexed", e.indexed), i = !!i);
      let s = e.type, o = s.match(wk);
      if (o) {
        const a = parseInt(o[2] || "-1"), c = _g4.from({
          type: o[1],
          components: e.components
        });
        return new _g4(qt, r || "", s, "array", i, null, a, c);
      }
      if (s === "tuple" || s.startsWith("tuple(") || s.startsWith("(")) {
        const a = e.components != null ? e.components.map((l) => _g4.from(l)) : null;
        return new _g4(qt, r || "", s, "tuple", i, a, null, null);
      }
      return s = Y2(e.type), new _g4(qt, r || "", s, s, i, null, null, null);
    }
    static isParamType(e) {
      return e && e[Ar] === X2;
    }
  }, _si_instances = new WeakSet(), e_fn = function(e, n, r, i) {
    if (this.isArray()) {
      if (!Array.isArray(n)) throw new Error("invalid array value");
      if (this.arrayLength !== -1 && n.length !== this.arrayLength) throw new Error("array is wrong length");
      const o = this.arrayChildren, a = n.slice();
      a.forEach((c, l) => {
        var _a6;
        __privateMethod(_a6 = o, _si_instances, e_fn).call(_a6, e, c, r, (u) => {
          a[l] = u;
        });
      }), i(a);
      return;
    }
    if (this.isTuple()) {
      const o = this.components;
      let a;
      if (Array.isArray(n)) a = n.slice();
      else {
        if (n == null || typeof n != "object") throw new Error("invalid tuple value");
        a = o.map((c) => {
          if (!c.name) throw new Error("cannot use object value with unnamed components");
          if (!(c.name in n)) throw new Error(`missing value for component ${c.name}`);
          return n[c.name];
        });
      }
      if (a.length !== this.components.length) throw new Error("array is wrong length");
      a.forEach((c, l) => {
        var _a6;
        __privateMethod(_a6 = o[l], _si_instances, e_fn).call(_a6, e, c, r, (u) => {
          a[l] = u;
        });
      }), i(a);
      return;
    }
    const s = r(this.type, n);
    s.then ? e.push(async function() {
      i(await s);
    }()) : i(s);
  }, _g4), eh = class Em {
    constructor(e, n, r) {
      __publicField(this, "type");
      __publicField(this, "inputs");
      ff(e, qt, "Fragment"), r = Object.freeze(r.slice()), Me(this, {
        type: n,
        inputs: r
      });
    }
    static from(e) {
      if (typeof e == "string") {
        try {
          Em.from(JSON.parse(e));
        } catch {
        }
        return Em.from(Lo(e));
      }
      if (e instanceof qr) switch (e.peekKeyword(O4)) {
        case "constructor":
          return h0.from(e);
        case "error":
          return vs.from(e);
        case "event":
          return d0.from(e);
        case "fallback":
        case "receive":
          return Es.from(e);
        case "function":
          return p0.from(e);
        case "struct":
          return Ea.from(e);
      }
      else if (typeof e == "object") {
        switch (e.type) {
          case "constructor":
            return h0.from(e);
          case "error":
            return vs.from(e);
          case "event":
            return d0.from(e);
          case "fallback":
          case "receive":
            return Es.from(e);
          case "function":
            return p0.from(e);
          case "struct":
            return Ea.from(e);
        }
        me(false, `unsupported type: ${e.type}`, "UNSUPPORTED_OPERATION", {
          operation: "Fragment.from"
        });
      }
      re(false, "unsupported frgament object", "obj", e);
    }
    static isConstructor(e) {
      return h0.isFragment(e);
    }
    static isError(e) {
      return vs.isFragment(e);
    }
    static isEvent(e) {
      return d0.isFragment(e);
    }
    static isFunction(e) {
      return p0.isFragment(e);
    }
    static isStruct(e) {
      return Ea.isFragment(e);
    }
  };
  class th extends eh {
    constructor(e, n, r, i) {
      super(e, n, i);
      __publicField(this, "name");
      re(typeof r == "string" && r.match(M4), "invalid identifier", "name", r), i = Object.freeze(i.slice()), Me(this, {
        name: r
      });
    }
  }
  function Vu(t, e) {
    return "(" + e.map((n) => n.format(t)).join(t === "full" ? ", " : ",") + ")";
  }
  let vs = class eu extends th {
    constructor(e, n, r) {
      super(e, "error", n, r), Object.defineProperty(this, Ar, {
        value: Z2
      });
    }
    get selector() {
      return _a(this.format("sighash")).substring(0, 10);
    }
    format(e) {
      if (e == null && (e = "sighash"), e === "json") return JSON.stringify({
        type: "error",
        name: this.name,
        inputs: this.inputs.map((r) => JSON.parse(r.format(e)))
      });
      const n = [];
      return e !== "sighash" && n.push("error"), n.push(this.name + Vu(e, this.inputs)), n.join(" ");
    }
    static from(e) {
      if (eu.isFragment(e)) return e;
      if (typeof e == "string") return eu.from(Lo(e));
      if (e instanceof qr) {
        const n = $d("error", e), r = Rs(e);
        return Ra(e), new eu(qt, n, r);
      }
      return new eu(qt, e.name, e.inputs ? e.inputs.map(cr.from) : []);
    }
    static isFragment(e) {
      return e && e[Ar] === Z2;
    }
  }, d0 = class hc extends th {
    constructor(e, n, r, i) {
      super(e, "event", n, r);
      __publicField(this, "anonymous");
      Object.defineProperty(this, Ar, {
        value: $2
      }), Me(this, {
        anonymous: i
      });
    }
    get topicHash() {
      return _a(this.format("sighash"));
    }
    format(e) {
      if (e == null && (e = "sighash"), e === "json") return JSON.stringify({
        type: "event",
        anonymous: this.anonymous,
        name: this.name,
        inputs: this.inputs.map((r) => JSON.parse(r.format(e)))
      });
      const n = [];
      return e !== "sighash" && n.push("event"), n.push(this.name + Vu(e, this.inputs)), e !== "sighash" && this.anonymous && n.push("anonymous"), n.join(" ");
    }
    static getTopicHash(e, n) {
      return n = (n || []).map((i) => cr.from(i)), new hc(qt, e, n, false).topicHash;
    }
    static from(e) {
      if (hc.isFragment(e)) return e;
      if (typeof e == "string") try {
        return hc.from(Lo(e));
      } catch {
        re(false, "invalid event fragment", "obj", e);
      }
      else if (e instanceof qr) {
        const n = $d("event", e), r = Rs(e, true), i = !!Ds(e, or([
          "anonymous"
        ])).has("anonymous");
        return Ra(e), new hc(qt, n, r, i);
      }
      return new hc(qt, e.name, e.inputs ? e.inputs.map((n) => cr.from(n, true)) : [], !!e.anonymous);
    }
    static isFragment(e) {
      return e && e[Ar] === $2;
    }
  }, h0 = class tu extends eh {
    constructor(e, n, r, i, s) {
      super(e, n, r);
      __publicField(this, "payable");
      __publicField(this, "gas");
      Object.defineProperty(this, Ar, {
        value: eA
      }), Me(this, {
        payable: i,
        gas: s
      });
    }
    format(e) {
      if (me(e != null && e !== "sighash", "cannot format a constructor for sighash", "UNSUPPORTED_OPERATION", {
        operation: "format(sighash)"
      }), e === "json") return JSON.stringify({
        type: "constructor",
        stateMutability: this.payable ? "payable" : "undefined",
        payable: this.payable,
        gas: this.gas != null ? this.gas : void 0,
        inputs: this.inputs.map((r) => JSON.parse(r.format(e)))
      });
      const n = [
        `constructor${Vu(e, this.inputs)}`
      ];
      return this.payable && n.push("payable"), this.gas != null && n.push(`@${this.gas.toString()}`), n.join(" ");
    }
    static from(e) {
      if (tu.isFragment(e)) return e;
      if (typeof e == "string") try {
        return tu.from(Lo(e));
      } catch {
        re(false, "invalid constuctor fragment", "obj", e);
      }
      else if (e instanceof qr) {
        Ds(e, or([
          "constructor"
        ]));
        const n = Rs(e), r = !!Ds(e, fk).has("payable"), i = L4(e);
        return Ra(e), new tu(qt, "constructor", n, r, i);
      }
      return new tu(qt, "constructor", e.inputs ? e.inputs.map(cr.from) : [], !!e.payable, e.gas != null ? e.gas : null);
    }
    static isFragment(e) {
      return e && e[Ar] === eA;
    }
  };
  class Es extends eh {
    constructor(e, n, r) {
      super(e, "fallback", n);
      __publicField(this, "payable");
      Object.defineProperty(this, Ar, {
        value: tA
      }), Me(this, {
        payable: r
      });
    }
    format(e) {
      const n = this.inputs.length === 0 ? "receive" : "fallback";
      if (e === "json") {
        const r = this.payable ? "payable" : "nonpayable";
        return JSON.stringify({
          type: n,
          stateMutability: r
        });
      }
      return `${n}()${this.payable ? " payable" : ""}`;
    }
    static from(e) {
      if (Es.isFragment(e)) return e;
      if (typeof e == "string") try {
        return Es.from(Lo(e));
      } catch {
        re(false, "invalid fallback fragment", "obj", e);
      }
      else if (e instanceof qr) {
        const n = e.toString(), r = e.peekKeyword(or([
          "fallback",
          "receive"
        ]));
        if (re(r, "type must be fallback or receive", "obj", n), e.popKeyword(or([
          "fallback",
          "receive"
        ])) === "receive") {
          const a = Rs(e);
          return re(a.length === 0, "receive cannot have arguments", "obj.inputs", a), Ds(e, or([
            "payable"
          ])), Ra(e), new Es(qt, [], true);
        }
        let s = Rs(e);
        s.length ? re(s.length === 1 && s[0].type === "bytes", "invalid fallback inputs", "obj.inputs", s.map((a) => a.format("minimal")).join(", ")) : s = [
          cr.from("bytes")
        ];
        const o = F4(e);
        if (re(o === "nonpayable" || o === "payable", "fallback cannot be constants", "obj.stateMutability", o), Ds(e, or([
          "returns"
        ])).has("returns")) {
          const a = Rs(e);
          re(a.length === 1 && a[0].type === "bytes", "invalid fallback outputs", "obj.outputs", a.map((c) => c.format("minimal")).join(", "));
        }
        return Ra(e), new Es(qt, s, o === "payable");
      }
      if (e.type === "receive") return new Es(qt, [], true);
      if (e.type === "fallback") {
        const n = [
          cr.from("bytes")
        ], r = e.stateMutability === "payable";
        return new Es(qt, n, r);
      }
      re(false, "invalid fallback description", "obj", e);
    }
    static isFragment(e) {
      return e && e[Ar] === tA;
    }
  }
  let p0 = class pc extends th {
    constructor(e, n, r, i, s, o) {
      super(e, "function", n, i);
      __publicField(this, "constant");
      __publicField(this, "outputs");
      __publicField(this, "stateMutability");
      __publicField(this, "payable");
      __publicField(this, "gas");
      Object.defineProperty(this, Ar, {
        value: nA
      }), s = Object.freeze(s.slice()), Me(this, {
        constant: r === "view" || r === "pure",
        gas: o,
        outputs: s,
        payable: r === "payable",
        stateMutability: r
      });
    }
    get selector() {
      return _a(this.format("sighash")).substring(0, 10);
    }
    format(e) {
      if (e == null && (e = "sighash"), e === "json") return JSON.stringify({
        type: "function",
        name: this.name,
        constant: this.constant,
        stateMutability: this.stateMutability !== "nonpayable" ? this.stateMutability : void 0,
        payable: this.payable,
        gas: this.gas != null ? this.gas : void 0,
        inputs: this.inputs.map((r) => JSON.parse(r.format(e))),
        outputs: this.outputs.map((r) => JSON.parse(r.format(e)))
      });
      const n = [];
      return e !== "sighash" && n.push("function"), n.push(this.name + Vu(e, this.inputs)), e !== "sighash" && (this.stateMutability !== "nonpayable" && n.push(this.stateMutability), this.outputs && this.outputs.length && (n.push("returns"), n.push(Vu(e, this.outputs))), this.gas != null && n.push(`@${this.gas.toString()}`)), n.join(" ");
    }
    static getSelector(e, n) {
      return n = (n || []).map((i) => cr.from(i)), new pc(qt, e, "view", n, [], null).selector;
    }
    static from(e) {
      if (pc.isFragment(e)) return e;
      if (typeof e == "string") try {
        return pc.from(Lo(e));
      } catch {
        re(false, "invalid function fragment", "obj", e);
      }
      else if (e instanceof qr) {
        const r = $d("function", e), i = Rs(e), s = F4(e);
        let o = [];
        Ds(e, or([
          "returns"
        ])).has("returns") && (o = Rs(e));
        const a = L4(e);
        return Ra(e), new pc(qt, r, s, i, o, a);
      }
      let n = e.stateMutability;
      return n == null && (n = "payable", typeof e.constant == "boolean" ? (n = "view", e.constant || (n = "payable", typeof e.payable == "boolean" && !e.payable && (n = "nonpayable"))) : typeof e.payable == "boolean" && !e.payable && (n = "nonpayable")), new pc(qt, e.name, n, e.inputs ? e.inputs.map(cr.from) : [], e.outputs ? e.outputs.map(cr.from) : [], e.gas != null ? e.gas : null);
    }
    static isFragment(e) {
      return e && e[Ar] === nA;
    }
  };
  class Ea extends th {
    constructor(e, n, r) {
      super(e, "struct", n, r), Object.defineProperty(this, Ar, {
        value: rA
      });
    }
    format() {
      throw new Error("@TODO");
    }
    static from(e) {
      if (typeof e == "string") try {
        return Ea.from(Lo(e));
      } catch {
        re(false, "invalid struct fragment", "obj", e);
      }
      else if (e instanceof qr) {
        const n = $d("struct", e), r = Rs(e);
        return Ra(e), new Ea(qt, n, r);
      }
      return new Ea(qt, e.name, e.inputs ? e.inputs.map(cr.from) : []);
    }
    static isFragment(e) {
      return e && e[Ar] === rA;
    }
  }
  const Ti = /* @__PURE__ */ new Map();
  Ti.set(0, "GENERIC_PANIC");
  Ti.set(1, "ASSERT_FALSE");
  Ti.set(17, "OVERFLOW");
  Ti.set(18, "DIVIDE_BY_ZERO");
  Ti.set(33, "ENUM_RANGE_ERROR");
  Ti.set(34, "BAD_STORAGE_DATA");
  Ti.set(49, "STACK_UNDERFLOW");
  Ti.set(50, "ARRAY_RANGE_ERROR");
  Ti.set(65, "OUT_OF_MEMORY");
  Ti.set(81, "UNINITIALIZED_FUNCTION_CALL");
  const vk = new RegExp(/^bytes([0-9]*)$/), Ek = new RegExp(/^(u?int)([0-9]*)$/);
  let Fp = null, iA = 1024;
  function Sk(t, e, n, r) {
    let i = "missing revert data", s = null;
    const o = null;
    let a = null;
    if (n) {
      i = "execution reverted";
      const l = Je(n);
      if (n = Se(n), l.length === 0) i += " (no data present; likely require(false) occurred", s = "require(false)";
      else if (l.length % 32 !== 4) i += " (could not decode reason; invalid data length)";
      else if (Se(l.slice(0, 4)) === "0x08c379a0") try {
        s = r.decode([
          "string"
        ], l.slice(4))[0], a = {
          signature: "Error(string)",
          name: "Error",
          args: [
            s
          ]
        }, i += `: ${JSON.stringify(s)}`;
      } catch {
        i += " (could not decode reason; invalid string data)";
      }
      else if (Se(l.slice(0, 4)) === "0x4e487b71") try {
        const u = Number(r.decode([
          "uint256"
        ], l.slice(4))[0]);
        a = {
          signature: "Panic(uint256)",
          name: "Panic",
          args: [
            u
          ]
        }, s = `Panic due to ${Ti.get(u) || "UNKNOWN"}(${u})`, i += `: ${s}`;
      } catch {
        i += " (could not decode panic code)";
      }
      else i += " (unknown custom error)";
    }
    const c = {
      to: e.to ? ht(e.to) : null,
      data: e.data || "0x"
    };
    return e.from && (c.from = ht(e.from)), Qt(i, "CALL_EXCEPTION", {
      action: t,
      data: n,
      reason: s,
      transaction: c,
      invocation: o,
      revert: a
    });
  }
  let Sm = (_h3 = class {
    constructor() {
      __privateAdd(this, _Tm_instances);
    }
    getDefaultValue(e) {
      const n = e.map((i) => __privateMethod(this, _Tm_instances, e_fn2).call(this, cr.from(i)));
      return new jf(n, "_").defaultValue();
    }
    encode(e, n) {
      uE(n.length, e.length, "types/values length mismatch");
      const r = e.map((o) => __privateMethod(this, _Tm_instances, e_fn2).call(this, cr.from(o))), i = new jf(r, "_"), s = new fm();
      return i.encode(s, n), s.data;
    }
    decode(e, n, r) {
      const i = e.map((o) => __privateMethod(this, _Tm_instances, e_fn2).call(this, cr.from(o)));
      return new jf(i, "_").decode(new uO(n, r, iA));
    }
    static _setDefaultMaxInflation(e) {
      re(typeof e == "number" && Number.isInteger(e), "invalid defaultMaxInflation factor", "value", e), iA = e;
    }
    static defaultAbiCoder() {
      return Fp == null && (Fp = new _h3()), Fp;
    }
    static getBuiltinCallException(e, n, r) {
      return Sk(e, n, r, _h3.defaultAbiCoder());
    }
  }, _Tm_instances = new WeakSet(), e_fn2 = function(e) {
    if (e.isArray()) return new GB(__privateMethod(this, _Tm_instances, e_fn2).call(this, e.arrayChildren), e.arrayLength, e.name);
    if (e.isTuple()) return new jf(e.components.map((r) => __privateMethod(this, _Tm_instances, e_fn2).call(this, r)), e.name);
    switch (e.baseType) {
      case "address":
        return new UB(e.name);
      case "bool":
        return new VB(e.name);
      case "string":
        return new XB(e.name);
      case "bytes":
        return new zB(e.name);
      case "":
        return new JB(e.name);
    }
    let n = e.type.match(Ek);
    if (n) {
      let r = parseInt(n[2] || "256");
      return re(r !== 0 && r <= 256 && r % 8 === 0, "invalid " + n[1] + " bit length", "param", e), new YB(r / 8, n[1] === "int", e.name);
    }
    if (n = e.type.match(vk), n) {
      let r = parseInt(n[1]);
      return re(r !== 0 && r <= 32, "invalid bytes length", "param", e), new QB(r, e.name);
    }
    re(false, "invalid type", "type", e.type);
  }, _h3), Tk = class {
    constructor(e, n, r) {
      __publicField(this, "fragment");
      __publicField(this, "name");
      __publicField(this, "signature");
      __publicField(this, "topic");
      __publicField(this, "args");
      const i = e.name, s = e.format();
      Me(this, {
        fragment: e,
        name: i,
        signature: s,
        topic: n,
        args: r
      });
    }
  }, Ck = class {
    constructor(e, n, r, i) {
      __publicField(this, "fragment");
      __publicField(this, "name");
      __publicField(this, "args");
      __publicField(this, "signature");
      __publicField(this, "selector");
      __publicField(this, "value");
      const s = e.name, o = e.format();
      Me(this, {
        fragment: e,
        name: s,
        args: r,
        signature: o,
        selector: n,
        value: i
      });
    }
  }, Ik = class {
    constructor(e, n, r) {
      __publicField(this, "fragment");
      __publicField(this, "name");
      __publicField(this, "args");
      __publicField(this, "signature");
      __publicField(this, "selector");
      const i = e.name, s = e.format();
      Me(this, {
        fragment: e,
        name: i,
        args: r,
        signature: s,
        selector: n
      });
    }
  }, sA = class {
    constructor(e) {
      __publicField(this, "hash");
      __publicField(this, "_isIndexed");
      Me(this, {
        hash: e,
        _isIndexed: true
      });
    }
    static isIndexed(e) {
      return !!(e && e._isIndexed);
    }
  };
  const oA = {
    0: "generic panic",
    1: "assert(false)",
    17: "arithmetic overflow",
    18: "division or modulo by zero",
    33: "enum overflow",
    34: "invalid encoded storage byte array accessed",
    49: "out-of-bounds array access; popping on an empty array",
    50: "out-of-bounds access of an array or bytesN",
    65: "out of memory",
    81: "uninitialized function"
  }, aA = {
    "0x08c379a0": {
      signature: "Error(string)",
      name: "Error",
      inputs: [
        "string"
      ],
      reason: (t) => `reverted with reason string ${JSON.stringify(t)}`
    },
    "0x4e487b71": {
      signature: "Panic(uint256)",
      name: "Panic",
      inputs: [
        "uint256"
      ],
      reason: (t) => {
        let e = "unknown panic code";
        return t >= 0 && t <= 255 && oA[t.toString()] && (e = oA[t.toString()]), `reverted with panic code 0x${t.toString(16)} (${e})`;
      }
    }
  };
  let Pk = (_i6 = class {
    constructor(e) {
      __privateAdd(this, _gc_instances);
      __publicField(this, "fragments");
      __publicField(this, "deploy");
      __publicField(this, "fallback");
      __publicField(this, "receive");
      __privateAdd(this, _e17);
      __privateAdd(this, _t11);
      __privateAdd(this, _n9);
      __privateAdd(this, _r7);
      let n = [];
      typeof e == "string" ? n = JSON.parse(e) : n = e, __privateSet(this, _n9, /* @__PURE__ */ new Map()), __privateSet(this, _e17, /* @__PURE__ */ new Map()), __privateSet(this, _t11, /* @__PURE__ */ new Map());
      const r = [];
      for (const o of n) try {
        r.push(eh.from(o));
      } catch (a) {
        console.log(`[Warning] Invalid Fragment ${JSON.stringify(o)}:`, a.message);
      }
      Me(this, {
        fragments: Object.freeze(r)
      });
      let i = null, s = false;
      __privateSet(this, _r7, this.getAbiCoder()), this.fragments.forEach((o, a) => {
        let c;
        switch (o.type) {
          case "constructor":
            if (this.deploy) {
              console.log("duplicate definition - constructor");
              return;
            }
            Me(this, {
              deploy: o
            });
            return;
          case "fallback":
            o.inputs.length === 0 ? s = true : (re(!i || o.payable !== i.payable, "conflicting fallback fragments", `fragments[${a}]`, o), i = o, s = i.payable);
            return;
          case "function":
            c = __privateGet(this, _n9);
            break;
          case "event":
            c = __privateGet(this, _t11);
            break;
          case "error":
            c = __privateGet(this, _e17);
            break;
          default:
            return;
        }
        const l = o.format();
        c.has(l) || c.set(l, o);
      }), this.deploy || Me(this, {
        deploy: h0.from("constructor()")
      }), Me(this, {
        fallback: i,
        receive: s
      });
    }
    format(e) {
      const n = e ? "minimal" : "full";
      return this.fragments.map((i) => i.format(n));
    }
    formatJson() {
      const e = this.fragments.map((n) => n.format("json"));
      return JSON.stringify(e.map((n) => JSON.parse(n)));
    }
    getAbiCoder() {
      return Sm.defaultAbiCoder();
    }
    getFunctionName(e) {
      const n = __privateMethod(this, _gc_instances, i_fn2).call(this, e, null, false);
      return re(n, "no matching function", "key", e), n.name;
    }
    hasFunction(e) {
      return !!__privateMethod(this, _gc_instances, i_fn2).call(this, e, null, false);
    }
    getFunction(e, n) {
      return __privateMethod(this, _gc_instances, i_fn2).call(this, e, n || null, true);
    }
    forEachFunction(e) {
      const n = Array.from(__privateGet(this, _n9).keys());
      n.sort((r, i) => r.localeCompare(i));
      for (let r = 0; r < n.length; r++) {
        const i = n[r];
        e(__privateGet(this, _n9).get(i), r);
      }
    }
    getEventName(e) {
      const n = __privateMethod(this, _gc_instances, o_fn3).call(this, e, null, false);
      return re(n, "no matching event", "key", e), n.name;
    }
    hasEvent(e) {
      return !!__privateMethod(this, _gc_instances, o_fn3).call(this, e, null, false);
    }
    getEvent(e, n) {
      return __privateMethod(this, _gc_instances, o_fn3).call(this, e, n || null, true);
    }
    forEachEvent(e) {
      const n = Array.from(__privateGet(this, _t11).keys());
      n.sort((r, i) => r.localeCompare(i));
      for (let r = 0; r < n.length; r++) {
        const i = n[r];
        e(__privateGet(this, _t11).get(i), r);
      }
    }
    getError(e, n) {
      if (vt(e)) {
        const i = e.toLowerCase();
        if (aA[i]) return vs.from(aA[i].signature);
        for (const s of __privateGet(this, _e17).values()) if (i === s.selector) return s;
        return null;
      }
      if (e.indexOf("(") === -1) {
        const i = [];
        for (const [s, o] of __privateGet(this, _e17)) s.split("(")[0] === e && i.push(o);
        if (i.length === 0) return e === "Error" ? vs.from("error Error(string)") : e === "Panic" ? vs.from("error Panic(uint256)") : null;
        if (i.length > 1) {
          const s = i.map((o) => JSON.stringify(o.format())).join(", ");
          re(false, `ambiguous error description (i.e. ${s})`, "name", e);
        }
        return i[0];
      }
      if (e = vs.from(e).format(), e === "Error(string)") return vs.from("error Error(string)");
      if (e === "Panic(uint256)") return vs.from("error Panic(uint256)");
      const r = __privateGet(this, _e17).get(e);
      return r || null;
    }
    forEachError(e) {
      const n = Array.from(__privateGet(this, _e17).keys());
      n.sort((r, i) => r.localeCompare(i));
      for (let r = 0; r < n.length; r++) {
        const i = n[r];
        e(__privateGet(this, _e17).get(i), r);
      }
    }
    _decodeParams(e, n) {
      return __privateGet(this, _r7).decode(e, n);
    }
    _encodeParams(e, n) {
      return __privateGet(this, _r7).encode(e, n);
    }
    encodeDeploy(e) {
      return this._encodeParams(this.deploy.inputs, e || []);
    }
    decodeErrorResult(e, n) {
      if (typeof e == "string") {
        const r = this.getError(e);
        re(r, "unknown error", "fragment", e), e = r;
      }
      return re(en(n, 0, 4) === e.selector, `data signature does not match error ${e.name}.`, "data", n), this._decodeParams(e.inputs, en(n, 4));
    }
    encodeErrorResult(e, n) {
      if (typeof e == "string") {
        const r = this.getError(e);
        re(r, "unknown error", "fragment", e), e = r;
      }
      return Xt([
        e.selector,
        this._encodeParams(e.inputs, n || [])
      ]);
    }
    decodeFunctionData(e, n) {
      if (typeof e == "string") {
        const r = this.getFunction(e);
        re(r, "unknown function", "fragment", e), e = r;
      }
      return re(en(n, 0, 4) === e.selector, `data signature does not match function ${e.name}.`, "data", n), this._decodeParams(e.inputs, en(n, 4));
    }
    encodeFunctionData(e, n) {
      if (typeof e == "string") {
        const r = this.getFunction(e);
        re(r, "unknown function", "fragment", e), e = r;
      }
      return Xt([
        e.selector,
        this._encodeParams(e.inputs, n || [])
      ]);
    }
    decodeFunctionResult(e, n) {
      if (typeof e == "string") {
        const s = this.getFunction(e);
        re(s, "unknown function", "fragment", e), e = s;
      }
      let r = "invalid length for result data";
      const i = tr(n);
      if (i.length % 32 === 0) try {
        return __privateGet(this, _r7).decode(e.outputs, i);
      } catch {
        r = "could not decode result data";
      }
      me(false, r, "BAD_DATA", {
        value: Se(i),
        info: {
          method: e.name,
          signature: e.format()
        }
      });
    }
    makeError(e, n) {
      const r = Je(e, "data"), i = Sm.getBuiltinCallException("call", n, r);
      if (i.message.startsWith("execution reverted (unknown custom error)")) {
        const a = Se(r.slice(0, 4)), c = this.getError(a);
        if (c) try {
          const l = __privateGet(this, _r7).decode(c.inputs, r.slice(4));
          i.revert = {
            name: c.name,
            signature: c.format(),
            args: l
          }, i.reason = i.revert.signature, i.message = `execution reverted: ${i.reason}`;
        } catch {
          i.message = "execution reverted (coult not decode custom error)";
        }
      }
      const o = this.parseTransaction(n);
      return o && (i.invocation = {
        method: o.name,
        signature: o.signature,
        args: o.args
      }), i;
    }
    encodeFunctionResult(e, n) {
      if (typeof e == "string") {
        const r = this.getFunction(e);
        re(r, "unknown function", "fragment", e), e = r;
      }
      return Se(__privateGet(this, _r7).encode(e.outputs, n || []));
    }
    encodeFilterTopics(e, n) {
      if (typeof e == "string") {
        const s = this.getEvent(e);
        re(s, "unknown event", "eventFragment", e), e = s;
      }
      me(n.length <= e.inputs.length, `too many arguments for ${e.format()}`, "UNEXPECTED_ARGUMENT", {
        count: n.length,
        expectedCount: e.inputs.length
      });
      const r = [];
      e.anonymous || r.push(e.topicHash);
      const i = (s, o) => s.type === "string" ? _a(o) : s.type === "bytes" ? dn(Se(o)) : (s.type === "bool" && typeof o == "boolean" ? o = o ? "0x01" : "0x00" : s.type.match(/^u?int/) ? o = No(o) : s.type.match(/^bytes/) ? o = UN(o, 32) : s.type === "address" && __privateGet(this, _r7).encode([
        "address"
      ], [
        o
      ]), Fs(Se(o), 32));
      for (n.forEach((s, o) => {
        const a = e.inputs[o];
        if (!a.indexed) {
          re(s == null, "cannot filter non-indexed parameters; must be null", "contract." + a.name, s);
          return;
        }
        s == null ? r.push(null) : a.baseType === "array" || a.baseType === "tuple" ? re(false, "filtering with tuples or arrays not supported", "contract." + a.name, s) : Array.isArray(s) ? r.push(s.map((c) => i(a, c))) : r.push(i(a, s));
      }); r.length && r[r.length - 1] === null; ) r.pop();
      return r;
    }
    encodeEventLog(e, n) {
      if (typeof e == "string") {
        const o = this.getEvent(e);
        re(o, "unknown event", "eventFragment", e), e = o;
      }
      const r = [], i = [], s = [];
      return e.anonymous || r.push(e.topicHash), re(n.length === e.inputs.length, "event arguments/values mismatch", "values", n), e.inputs.forEach((o, a) => {
        const c = n[a];
        if (o.indexed) if (o.type === "string") r.push(_a(c));
        else if (o.type === "bytes") r.push(dn(c));
        else {
          if (o.baseType === "tuple" || o.baseType === "array") throw new Error("not implemented");
          r.push(__privateGet(this, _r7).encode([
            o.type
          ], [
            c
          ]));
        }
        else i.push(o), s.push(c);
      }), {
        data: __privateGet(this, _r7).encode(i, s),
        topics: r
      };
    }
    decodeEventLog(e, n, r) {
      if (typeof e == "string") {
        const m = this.getEvent(e);
        re(m, "unknown event", "eventFragment", e), e = m;
      }
      if (r != null && !e.anonymous) {
        const m = e.topicHash;
        re(vt(r[0], 32) && r[0].toLowerCase() === m, "fragment/topic mismatch", "topics[0]", r[0]), r = r.slice(1);
      }
      const i = [], s = [], o = [];
      e.inputs.forEach((m, y) => {
        m.indexed ? m.type === "string" || m.type === "bytes" || m.baseType === "tuple" || m.baseType === "array" ? (i.push(cr.from({
          type: "bytes32",
          name: m.name
        })), o.push(true)) : (i.push(m), o.push(false)) : (s.push(m), o.push(false));
      });
      const a = r != null ? __privateGet(this, _r7).decode(i, Xt(r)) : null, c = __privateGet(this, _r7).decode(s, n, true), l = [], u = [];
      let f = 0, d = 0;
      return e.inputs.forEach((m, y) => {
        let x = null;
        if (m.indexed) if (a == null) x = new sA(null);
        else if (o[y]) x = new sA(a[d++]);
        else try {
          x = a[d++];
        } catch (w) {
          x = w;
        }
        else try {
          x = c[f++];
        } catch (w) {
          x = w;
        }
        l.push(x), u.push(m.name || null);
      }), _s.fromItems(l, u);
    }
    parseTransaction(e) {
      const n = Je(e.data, "tx.data"), r = Pe(e.value != null ? e.value : 0, "tx.value"), i = this.getFunction(Se(n.slice(0, 4)));
      if (!i) return null;
      const s = __privateGet(this, _r7).decode(i.inputs, n.slice(4));
      return new Ck(i, i.selector, s, r);
    }
    parseCallResult(e) {
      throw new Error("@TODO");
    }
    parseLog(e) {
      const n = this.getEvent(e.topics[0]);
      return !n || n.anonymous ? null : new Tk(n, n.topicHash, this.decodeEventLog(n, e.data, e.topics));
    }
    parseError(e) {
      const n = Se(e), r = this.getError(en(n, 0, 4));
      if (!r) return null;
      const i = __privateGet(this, _r7).decode(r.inputs, en(n, 4));
      return new Ik(r, r.selector, i);
    }
    static from(e) {
      return e instanceof _i6 ? e : typeof e == "string" ? new _i6(JSON.parse(e)) : typeof e.formatJson == "function" ? new _i6(e.formatJson()) : typeof e.format == "function" ? new _i6(e.format("json")) : new _i6(e);
    }
  }, _e17 = new WeakMap(), _t11 = new WeakMap(), _n9 = new WeakMap(), _r7 = new WeakMap(), _gc_instances = new WeakSet(), i_fn2 = function(e, n, r) {
    if (vt(e)) {
      const s = e.toLowerCase();
      for (const o of __privateGet(this, _n9).values()) if (s === o.selector) return o;
      return null;
    }
    if (e.indexOf("(") === -1) {
      const s = [];
      for (const [o, a] of __privateGet(this, _n9)) o.split("(")[0] === e && s.push(a);
      if (n) {
        const o = n.length > 0 ? n[n.length - 1] : null;
        let a = n.length, c = true;
        nn.isTyped(o) && o.type === "overrides" && (c = false, a--);
        for (let l = s.length - 1; l >= 0; l--) {
          const u = s[l].inputs.length;
          u !== a && (!c || u !== a - 1) && s.splice(l, 1);
        }
        for (let l = s.length - 1; l >= 0; l--) {
          const u = s[l].inputs;
          for (let f = 0; f < n.length; f++) if (nn.isTyped(n[f])) {
            if (f >= u.length) {
              if (n[f].type === "overrides") continue;
              s.splice(l, 1);
              break;
            }
            if (n[f].type !== u[f].baseType) {
              s.splice(l, 1);
              break;
            }
          }
        }
      }
      if (s.length === 1 && n && n.length !== s[0].inputs.length) {
        const o = n[n.length - 1];
        (o == null || Array.isArray(o) || typeof o != "object") && s.splice(0, 1);
      }
      if (s.length === 0) return null;
      if (s.length > 1 && r) {
        const o = s.map((a) => JSON.stringify(a.format())).join(", ");
        re(false, `ambiguous function description (i.e. matches ${o})`, "key", e);
      }
      return s[0];
    }
    const i = __privateGet(this, _n9).get(p0.from(e).format());
    return i || null;
  }, o_fn3 = function(e, n, r) {
    if (vt(e)) {
      const s = e.toLowerCase();
      for (const o of __privateGet(this, _t11).values()) if (s === o.topicHash) return o;
      return null;
    }
    if (e.indexOf("(") === -1) {
      const s = [];
      for (const [o, a] of __privateGet(this, _t11)) o.split("(")[0] === e && s.push(a);
      if (n) {
        for (let o = s.length - 1; o >= 0; o--) s[o].inputs.length < n.length && s.splice(o, 1);
        for (let o = s.length - 1; o >= 0; o--) {
          const a = s[o].inputs;
          for (let c = 0; c < n.length; c++) if (nn.isTyped(n[c]) && n[c].type !== a[c].baseType) {
            s.splice(o, 1);
            break;
          }
        }
      }
      if (s.length === 0) return null;
      if (s.length > 1 && r) {
        const o = s.map((a) => JSON.stringify(a.format())).join(", ");
        re(false, `ambiguous event description (i.e. matches ${o})`, "key", e);
      }
      return s[0];
    }
    const i = __privateGet(this, _t11).get(d0.from(e).format());
    return i || null;
  }, _i6);
  const D4 = BigInt(0);
  function Lc(t) {
    return t ?? null;
  }
  function cn(t) {
    return t == null ? null : t.toString();
  }
  class cA {
    constructor(e, n, r) {
      __publicField(this, "gasPrice");
      __publicField(this, "maxFeePerGas");
      __publicField(this, "maxPriorityFeePerGas");
      Me(this, {
        gasPrice: Lc(e),
        maxFeePerGas: Lc(n),
        maxPriorityFeePerGas: Lc(r)
      });
    }
    toJSON() {
      const { gasPrice: e, maxFeePerGas: n, maxPriorityFeePerGas: r } = this;
      return {
        _type: "FeeData",
        gasPrice: cn(e),
        maxFeePerGas: cn(n),
        maxPriorityFeePerGas: cn(r)
      };
    }
  }
  function ed(t) {
    const e = {};
    t.to && (e.to = t.to), t.from && (e.from = t.from), t.data && (e.data = Se(t.data));
    const n = "chainId,gasLimit,gasPrice,maxFeePerBlobGas,maxFeePerGas,maxPriorityFeePerGas,value".split(/,/);
    for (const i of n) !(i in t) || t[i] == null || (e[i] = Pe(t[i], `request.${i}`));
    const r = "type,nonce".split(/,/);
    for (const i of r) !(i in t) || t[i] == null || (e[i] = Qe(t[i], `request.${i}`));
    return t.accessList && (e.accessList = Ua(t.accessList)), t.authorizationList && (e.authorizationList = t.authorizationList.slice()), "blockTag" in t && (e.blockTag = t.blockTag), "enableCcipRead" in t && (e.enableCcipRead = !!t.enableCcipRead), "customData" in t && (e.customData = t.customData), "blobVersionedHashes" in t && t.blobVersionedHashes && (e.blobVersionedHashes = t.blobVersionedHashes.slice()), "kzg" in t && (e.kzg = t.kzg), "blobs" in t && t.blobs && (e.blobs = t.blobs.map((i) => Z1(i) ? Se(i) : Object.assign({}, i))), e;
  }
  class _k {
    constructor(e, n) {
      __publicField(this, "provider");
      __publicField(this, "number");
      __publicField(this, "hash");
      __publicField(this, "timestamp");
      __publicField(this, "parentHash");
      __publicField(this, "parentBeaconBlockRoot");
      __publicField(this, "nonce");
      __publicField(this, "difficulty");
      __publicField(this, "gasLimit");
      __publicField(this, "gasUsed");
      __publicField(this, "stateRoot");
      __publicField(this, "receiptsRoot");
      __publicField(this, "blobGasUsed");
      __publicField(this, "excessBlobGas");
      __publicField(this, "miner");
      __publicField(this, "prevRandao");
      __publicField(this, "extraData");
      __publicField(this, "baseFeePerGas");
      __privateAdd(this, _e18);
      __privateSet(this, _e18, e.transactions.map((r) => typeof r != "string" ? new gf(r, n) : r)), Me(this, {
        provider: n,
        hash: Lc(e.hash),
        number: e.number,
        timestamp: e.timestamp,
        parentHash: e.parentHash,
        parentBeaconBlockRoot: e.parentBeaconBlockRoot,
        nonce: e.nonce,
        difficulty: e.difficulty,
        gasLimit: e.gasLimit,
        gasUsed: e.gasUsed,
        blobGasUsed: e.blobGasUsed,
        excessBlobGas: e.excessBlobGas,
        miner: e.miner,
        prevRandao: Lc(e.prevRandao),
        extraData: e.extraData,
        baseFeePerGas: Lc(e.baseFeePerGas),
        stateRoot: e.stateRoot,
        receiptsRoot: e.receiptsRoot
      });
    }
    get transactions() {
      return __privateGet(this, _e18).map((e) => typeof e == "string" ? e : e.hash);
    }
    get prefetchedTransactions() {
      const e = __privateGet(this, _e18).slice();
      return e.length === 0 ? [] : (me(typeof e[0] == "object", "transactions were not prefetched with block request", "UNSUPPORTED_OPERATION", {
        operation: "transactionResponses()"
      }), e);
    }
    toJSON() {
      const { baseFeePerGas: e, difficulty: n, extraData: r, gasLimit: i, gasUsed: s, hash: o, miner: a, prevRandao: c, nonce: l, number: u, parentHash: f, parentBeaconBlockRoot: d, stateRoot: m, receiptsRoot: y, timestamp: x, transactions: w } = this;
      return {
        _type: "Block",
        baseFeePerGas: cn(e),
        difficulty: cn(n),
        extraData: r,
        gasLimit: cn(i),
        gasUsed: cn(s),
        blobGasUsed: cn(this.blobGasUsed),
        excessBlobGas: cn(this.excessBlobGas),
        hash: o,
        miner: a,
        prevRandao: c,
        nonce: l,
        number: u,
        parentHash: f,
        timestamp: x,
        parentBeaconBlockRoot: d,
        stateRoot: m,
        receiptsRoot: y,
        transactions: w
      };
    }
    [Symbol.iterator]() {
      let e = 0;
      const n = this.transactions;
      return {
        next: () => e < this.length ? {
          value: n[e++],
          done: false
        } : {
          value: void 0,
          done: true
        }
      };
    }
    get length() {
      return __privateGet(this, _e18).length;
    }
    get date() {
      return this.timestamp == null ? null : new Date(this.timestamp * 1e3);
    }
    async getTransaction(e) {
      let n;
      if (typeof e == "number") n = __privateGet(this, _e18)[e];
      else {
        const r = e.toLowerCase();
        for (const i of __privateGet(this, _e18)) if (typeof i == "string") {
          if (i !== r) continue;
          n = i;
          break;
        } else {
          if (i.hash !== r) continue;
          n = i;
          break;
        }
      }
      if (n == null) throw new Error("no such tx");
      return typeof n == "string" ? await this.provider.getTransaction(n) : n;
    }
    getPrefetchedTransaction(e) {
      const n = this.prefetchedTransactions;
      if (typeof e == "number") return n[e];
      e = e.toLowerCase();
      for (const r of n) if (r.hash === e) return r;
      re(false, "no matching transaction", "indexOrHash", e);
    }
    isMined() {
      return !!this.hash;
    }
    isLondon() {
      return !!this.baseFeePerGas;
    }
    orphanedEvent() {
      if (!this.isMined()) throw new Error("");
      return Rk(this);
    }
  }
  _e18 = new WeakMap();
  class pf {
    constructor(e, n) {
      __publicField(this, "provider");
      __publicField(this, "transactionHash");
      __publicField(this, "blockHash");
      __publicField(this, "blockNumber");
      __publicField(this, "removed");
      __publicField(this, "address");
      __publicField(this, "data");
      __publicField(this, "topics");
      __publicField(this, "index");
      __publicField(this, "transactionIndex");
      this.provider = n;
      const r = Object.freeze(e.topics.slice());
      Me(this, {
        transactionHash: e.transactionHash,
        blockHash: e.blockHash,
        blockNumber: e.blockNumber,
        removed: e.removed,
        address: e.address,
        data: e.data,
        topics: r,
        index: e.index,
        transactionIndex: e.transactionIndex
      });
    }
    toJSON() {
      const { address: e, blockHash: n, blockNumber: r, data: i, index: s, removed: o, topics: a, transactionHash: c, transactionIndex: l } = this;
      return {
        _type: "log",
        address: e,
        blockHash: n,
        blockNumber: r,
        data: i,
        index: s,
        removed: o,
        topics: a,
        transactionHash: c,
        transactionIndex: l
      };
    }
    async getBlock() {
      const e = await this.provider.getBlock(this.blockHash);
      return me(!!e, "failed to find transaction", "UNKNOWN_ERROR", {}), e;
    }
    async getTransaction() {
      const e = await this.provider.getTransaction(this.transactionHash);
      return me(!!e, "failed to find transaction", "UNKNOWN_ERROR", {}), e;
    }
    async getTransactionReceipt() {
      const e = await this.provider.getTransactionReceipt(this.transactionHash);
      return me(!!e, "failed to find transaction receipt", "UNKNOWN_ERROR", {}), e;
    }
    removedEvent() {
      return Nk(this);
    }
  }
  class U4 {
    constructor(e, n) {
      __publicField(this, "provider");
      __publicField(this, "to");
      __publicField(this, "from");
      __publicField(this, "contractAddress");
      __publicField(this, "hash");
      __publicField(this, "index");
      __publicField(this, "blockHash");
      __publicField(this, "blockNumber");
      __publicField(this, "logsBloom");
      __publicField(this, "gasUsed");
      __publicField(this, "blobGasUsed");
      __publicField(this, "cumulativeGasUsed");
      __publicField(this, "gasPrice");
      __publicField(this, "blobGasPrice");
      __publicField(this, "type");
      __publicField(this, "status");
      __publicField(this, "root");
      __privateAdd(this, _e19);
      __privateSet(this, _e19, Object.freeze(e.logs.map((i) => new pf(i, n))));
      let r = D4;
      e.effectiveGasPrice != null ? r = e.effectiveGasPrice : e.gasPrice != null && (r = e.gasPrice), Me(this, {
        provider: n,
        to: e.to,
        from: e.from,
        contractAddress: e.contractAddress,
        hash: e.hash,
        index: e.index,
        blockHash: e.blockHash,
        blockNumber: e.blockNumber,
        logsBloom: e.logsBloom,
        gasUsed: e.gasUsed,
        cumulativeGasUsed: e.cumulativeGasUsed,
        blobGasUsed: e.blobGasUsed,
        gasPrice: r,
        blobGasPrice: e.blobGasPrice,
        type: e.type,
        status: e.status,
        root: e.root
      });
    }
    get logs() {
      return __privateGet(this, _e19);
    }
    toJSON() {
      const { to: e, from: n, contractAddress: r, hash: i, index: s, blockHash: o, blockNumber: a, logsBloom: c, logs: l, status: u, root: f } = this;
      return {
        _type: "TransactionReceipt",
        blockHash: o,
        blockNumber: a,
        contractAddress: r,
        cumulativeGasUsed: cn(this.cumulativeGasUsed),
        from: n,
        gasPrice: cn(this.gasPrice),
        blobGasUsed: cn(this.blobGasUsed),
        blobGasPrice: cn(this.blobGasPrice),
        gasUsed: cn(this.gasUsed),
        hash: i,
        index: s,
        logs: l,
        logsBloom: c,
        root: f,
        status: u,
        to: e
      };
    }
    get length() {
      return this.logs.length;
    }
    [Symbol.iterator]() {
      let e = 0;
      return {
        next: () => e < this.length ? {
          value: this.logs[e++],
          done: false
        } : {
          value: void 0,
          done: true
        }
      };
    }
    get fee() {
      return this.gasUsed * this.gasPrice;
    }
    async getBlock() {
      const e = await this.provider.getBlock(this.blockHash);
      if (e == null) throw new Error("TODO");
      return e;
    }
    async getTransaction() {
      const e = await this.provider.getTransaction(this.hash);
      if (e == null) throw new Error("TODO");
      return e;
    }
    async getResult() {
      return await this.provider.getTransactionResult(this.hash);
    }
    async confirmations() {
      return await this.provider.getBlockNumber() - this.blockNumber + 1;
    }
    removedEvent() {
      return G4(this);
    }
    reorderedEvent(e) {
      return me(!e || e.isMined(), "unmined 'other' transction cannot be orphaned", "UNSUPPORTED_OPERATION", {
        operation: "reorderedEvent(other)"
      }), H4(this, e);
    }
  }
  _e19 = new WeakMap();
  const _gf = class _gf {
    constructor(e, n) {
      __publicField(this, "provider");
      __publicField(this, "blockNumber");
      __publicField(this, "blockHash");
      __publicField(this, "index");
      __publicField(this, "hash");
      __publicField(this, "type");
      __publicField(this, "to");
      __publicField(this, "from");
      __publicField(this, "nonce");
      __publicField(this, "gasLimit");
      __publicField(this, "gasPrice");
      __publicField(this, "maxPriorityFeePerGas");
      __publicField(this, "maxFeePerGas");
      __publicField(this, "maxFeePerBlobGas");
      __publicField(this, "data");
      __publicField(this, "value");
      __publicField(this, "chainId");
      __publicField(this, "signature");
      __publicField(this, "accessList");
      __publicField(this, "blobVersionedHashes");
      __publicField(this, "authorizationList");
      __privateAdd(this, _e20);
      this.provider = n, this.blockNumber = e.blockNumber != null ? e.blockNumber : null, this.blockHash = e.blockHash != null ? e.blockHash : null, this.hash = e.hash, this.index = e.index, this.type = e.type, this.from = e.from, this.to = e.to || null, this.gasLimit = e.gasLimit, this.nonce = e.nonce, this.data = e.data, this.value = e.value, this.gasPrice = e.gasPrice, this.maxPriorityFeePerGas = e.maxPriorityFeePerGas != null ? e.maxPriorityFeePerGas : null, this.maxFeePerGas = e.maxFeePerGas != null ? e.maxFeePerGas : null, this.maxFeePerBlobGas = e.maxFeePerBlobGas != null ? e.maxFeePerBlobGas : null, this.chainId = e.chainId, this.signature = e.signature, this.accessList = e.accessList != null ? e.accessList : null, this.blobVersionedHashes = e.blobVersionedHashes != null ? e.blobVersionedHashes : null, this.authorizationList = e.authorizationList != null ? e.authorizationList : null, __privateSet(this, _e20, -1);
    }
    toJSON() {
      const { blockNumber: e, blockHash: n, index: r, hash: i, type: s, to: o, from: a, nonce: c, data: l, signature: u, accessList: f, blobVersionedHashes: d } = this;
      return {
        _type: "TransactionResponse",
        accessList: f,
        blockNumber: e,
        blockHash: n,
        blobVersionedHashes: d,
        chainId: cn(this.chainId),
        data: l,
        from: a,
        gasLimit: cn(this.gasLimit),
        gasPrice: cn(this.gasPrice),
        hash: i,
        maxFeePerGas: cn(this.maxFeePerGas),
        maxPriorityFeePerGas: cn(this.maxPriorityFeePerGas),
        maxFeePerBlobGas: cn(this.maxFeePerBlobGas),
        nonce: c,
        signature: u,
        to: o,
        index: r,
        type: s,
        value: cn(this.value)
      };
    }
    async getBlock() {
      let e = this.blockNumber;
      if (e == null) {
        const r = await this.getTransaction();
        r && (e = r.blockNumber);
      }
      if (e == null) return null;
      const n = this.provider.getBlock(e);
      if (n == null) throw new Error("TODO");
      return n;
    }
    async getTransaction() {
      return this.provider.getTransaction(this.hash);
    }
    async confirmations() {
      if (this.blockNumber == null) {
        const { tx: n, blockNumber: r } = await $n({
          tx: this.getTransaction(),
          blockNumber: this.provider.getBlockNumber()
        });
        return n == null || n.blockNumber == null ? 0 : r - n.blockNumber + 1;
      }
      return await this.provider.getBlockNumber() - this.blockNumber + 1;
    }
    async wait(e, n) {
      const r = e ?? 1, i = n ?? 0;
      let s = __privateGet(this, _e20), o = -1, a = s === -1;
      const c = async () => {
        if (a) return null;
        const { blockNumber: d, nonce: m } = await $n({
          blockNumber: this.provider.getBlockNumber(),
          nonce: this.provider.getTransactionCount(this.from)
        });
        if (m < this.nonce) {
          s = d;
          return;
        }
        if (a) return null;
        const y = await this.getTransaction();
        if (!(y && y.blockNumber != null)) for (o === -1 && (o = s - 3, o < __privateGet(this, _e20) && (o = __privateGet(this, _e20))); o <= d; ) {
          if (a) return null;
          const x = await this.provider.getBlock(o, true);
          if (x == null) return;
          for (const w of x) if (w === this.hash) return;
          for (let w = 0; w < x.length; w++) {
            const R = await x.getTransaction(w);
            if (R.from === this.from && R.nonce === this.nonce) {
              if (a) return null;
              const O = await this.provider.getTransactionReceipt(R.hash);
              if (O == null || d - O.blockNumber + 1 < r) return;
              let B = "replaced";
              R.data === this.data && R.to === this.to && R.value === this.value ? B = "repriced" : R.data === "0x" && R.from === R.to && R.value === D4 && (B = "cancelled"), me(false, "transaction was replaced", "TRANSACTION_REPLACED", {
                cancelled: B === "replaced" || B === "cancelled",
                reason: B,
                replacement: R.replaceableTransaction(s),
                hash: R.hash,
                receipt: O
              });
            }
          }
          o++;
        }
      }, l = (d) => {
        if (d == null || d.status !== 0) return d;
        me(false, "transaction execution reverted", "CALL_EXCEPTION", {
          action: "sendTransaction",
          data: null,
          reason: null,
          invocation: null,
          revert: null,
          transaction: {
            to: d.to,
            from: d.from,
            data: ""
          },
          receipt: d
        });
      }, u = await this.provider.getTransactionReceipt(this.hash);
      if (r === 0) return l(u);
      if (u) {
        if (r === 1 || await u.confirmations() >= r) return l(u);
      } else if (await c(), r === 0) return null;
      return await new Promise((d, m) => {
        const y = [], x = () => {
          y.forEach((R) => R());
        };
        if (y.push(() => {
          a = true;
        }), i > 0) {
          const R = setTimeout(() => {
            x(), m(Qt("wait for transaction timeout", "TIMEOUT"));
          }, i);
          y.push(() => {
            clearTimeout(R);
          });
        }
        const w = async (R) => {
          if (await R.confirmations() >= r) {
            x();
            try {
              d(l(R));
            } catch (O) {
              m(O);
            }
          }
        };
        if (y.push(() => {
          this.provider.off(this.hash, w);
        }), this.provider.on(this.hash, w), s >= 0) {
          const R = async () => {
            try {
              await c();
            } catch (O) {
              if (Un(O, "TRANSACTION_REPLACED")) {
                x(), m(O);
                return;
              }
            }
            a || this.provider.once("block", R);
          };
          y.push(() => {
            this.provider.off("block", R);
          }), this.provider.once("block", R);
        }
      });
    }
    isMined() {
      return this.blockHash != null;
    }
    isLegacy() {
      return this.type === 0;
    }
    isBerlin() {
      return this.type === 1;
    }
    isLondon() {
      return this.type === 2;
    }
    isCancun() {
      return this.type === 3;
    }
    removedEvent() {
      return me(this.isMined(), "unmined transaction canot be orphaned", "UNSUPPORTED_OPERATION", {
        operation: "removeEvent()"
      }), G4(this);
    }
    reorderedEvent(e) {
      return me(this.isMined(), "unmined transaction canot be orphaned", "UNSUPPORTED_OPERATION", {
        operation: "removeEvent()"
      }), me(!e || e.isMined(), "unmined 'other' transaction canot be orphaned", "UNSUPPORTED_OPERATION", {
        operation: "removeEvent()"
      }), H4(this, e);
    }
    replaceableTransaction(e) {
      re(Number.isInteger(e) && e >= 0, "invalid startBlock", "startBlock", e);
      const n = new _gf(this, this.provider);
      return __privateSet(n, _e20, e), n;
    }
  };
  _e20 = new WeakMap();
  let gf = _gf;
  function Rk(t) {
    return {
      orphan: "drop-block",
      hash: t.hash,
      number: t.number
    };
  }
  function H4(t, e) {
    return {
      orphan: "reorder-transaction",
      tx: t,
      other: e
    };
  }
  function G4(t) {
    return {
      orphan: "drop-transaction",
      tx: t
    };
  }
  function Nk(t) {
    return {
      orphan: "drop-log",
      log: {
        transactionHash: t.transactionHash,
        blockHash: t.blockHash,
        blockNumber: t.blockNumber,
        address: t.address,
        data: t.data,
        topics: Object.freeze(t.topics.slice()),
        index: t.index
      }
    };
  }
  class dy extends pf {
    constructor(e, n, r) {
      super(e, e.provider);
      __publicField(this, "interface");
      __publicField(this, "fragment");
      __publicField(this, "args");
      const i = n.decodeEventLog(r, e.data, e.topics);
      Me(this, {
        args: i,
        fragment: r,
        interface: n
      });
    }
    get eventName() {
      return this.fragment.name;
    }
    get eventSignature() {
      return this.fragment.format();
    }
  }
  class V4 extends pf {
    constructor(e, n) {
      super(e, e.provider);
      __publicField(this, "error");
      Me(this, {
        error: n
      });
    }
  }
  class Ok extends U4 {
    constructor(e, n, r) {
      super(r, n);
      __privateAdd(this, _e21);
      __privateSet(this, _e21, e);
    }
    get logs() {
      return super.logs.map((e) => {
        const n = e.topics.length ? __privateGet(this, _e21).getEvent(e.topics[0]) : null;
        if (n) try {
          return new dy(e, __privateGet(this, _e21), n);
        } catch (r) {
          return new V4(e, r);
        }
        return e;
      });
    }
  }
  _e21 = new WeakMap();
  class hy extends gf {
    constructor(e, n, r) {
      super(r, n);
      __privateAdd(this, _e22);
      __privateSet(this, _e22, e);
    }
    async wait(e, n) {
      const r = await super.wait(e, n);
      return r == null ? null : new Ok(__privateGet(this, _e22), this.provider, r);
    }
  }
  _e22 = new WeakMap();
  class z4 extends pE {
    constructor(e, n, r, i) {
      super(e, n, r);
      __publicField(this, "log");
      Me(this, {
        log: i
      });
    }
    async getBlock() {
      return await this.log.getBlock();
    }
    async getTransaction() {
      return await this.log.getTransaction();
    }
    async getTransactionReceipt() {
      return await this.log.getTransactionReceipt();
    }
  }
  class Bk extends z4 {
    constructor(e, n, r, i, s) {
      super(e, n, r, new dy(s, e.interface, i));
      const o = e.interface.decodeEventLog(i, this.log.data, this.log.topics);
      Me(this, {
        args: o,
        fragment: i
      });
    }
    get eventName() {
      return this.fragment.name;
    }
    get eventSignature() {
      return this.fragment.format();
    }
  }
  const lA = BigInt(0);
  function Q4(t) {
    return t && typeof t.call == "function";
  }
  function j4(t) {
    return t && typeof t.estimateGas == "function";
  }
  function nh(t) {
    return t && typeof t.resolveName == "function";
  }
  function J4(t) {
    return t && typeof t.sendTransaction == "function";
  }
  function K4(t) {
    if (t != null) {
      if (nh(t)) return t;
      if (t.provider) return t.provider;
    }
  }
  class Mk {
    constructor(e, n, r) {
      __privateAdd(this, _e23);
      __publicField(this, "fragment");
      if (Me(this, {
        fragment: n
      }), n.inputs.length < r.length) throw new Error("too many arguments");
      const i = Na(e.runner, "resolveName"), s = nh(i) ? i : null;
      __privateSet(this, _e23, async function() {
        const o = await Promise.all(n.inputs.map((a, c) => r[c] == null ? null : a.walkAsync(r[c], (u, f) => u === "address" ? Array.isArray(f) ? Promise.all(f.map((d) => sr(d, s))) : sr(f, s) : f)));
        return e.interface.encodeFilterTopics(n, o);
      }());
    }
    getTopicFilter() {
      return __privateGet(this, _e23);
    }
  }
  _e23 = new WeakMap();
  function Na(t, e) {
    return t == null ? null : typeof t[e] == "function" ? t : t.provider && typeof t.provider[e] == "function" ? t.provider : null;
  }
  function ma(t) {
    return t == null ? null : t.provider || null;
  }
  async function W4(t, e) {
    const n = nn.dereference(t, "overrides");
    re(typeof n == "object", "invalid overrides parameter", "overrides", t);
    const r = ed(n);
    return re(r.to == null || (e || []).indexOf("to") >= 0, "cannot override to", "overrides.to", r.to), re(r.data == null || (e || []).indexOf("data") >= 0, "cannot override data", "overrides.data", r.data), r.from && (r.from = r.from), r;
  }
  async function kk(t, e, n) {
    const r = Na(t, "resolveName"), i = nh(r) ? r : null;
    return await Promise.all(e.map((s, o) => s.walkAsync(n[o], (a, c) => (c = nn.dereference(c, a), a === "address" ? sr(c, i) : c))));
  }
  function Fk(t) {
    const e = async function(o) {
      const a = await W4(o, [
        "data"
      ]);
      a.to = await t.getAddress(), a.from && (a.from = await sr(a.from, K4(t.runner)));
      const c = t.interface, l = Pe(a.value || lA, "overrides.value") === lA, u = (a.data || "0x") === "0x";
      c.fallback && !c.fallback.payable && c.receive && !u && !l && re(false, "cannot send data to receive or send value to non-payable fallback", "overrides", o), re(c.fallback || u, "cannot send data to receive-only contract", "overrides.data", a.data);
      const f = c.receive || c.fallback && c.fallback.payable;
      return re(f || l, "cannot send value to non-payable fallback", "overrides.value", a.value), re(c.fallback || u, "cannot send data to receive-only contract", "overrides.data", a.data), a;
    }, n = async function(o) {
      const a = Na(t.runner, "call");
      me(Q4(a), "contract runner does not support calling", "UNSUPPORTED_OPERATION", {
        operation: "call"
      });
      const c = await e(o);
      try {
        return await a.call(c);
      } catch (l) {
        throw X1(l) && l.data ? t.interface.makeError(l.data, c) : l;
      }
    }, r = async function(o) {
      const a = t.runner;
      me(J4(a), "contract runner does not support sending transactions", "UNSUPPORTED_OPERATION", {
        operation: "sendTransaction"
      });
      const c = await a.sendTransaction(await e(o)), l = ma(t.runner);
      return new hy(t.interface, l, c);
    }, i = async function(o) {
      const a = Na(t.runner, "estimateGas");
      return me(j4(a), "contract runner does not support gas estimation", "UNSUPPORTED_OPERATION", {
        operation: "estimateGas"
      }), await a.estimateGas(await e(o));
    }, s = async (o) => await r(o);
    return Me(s, {
      _contract: t,
      estimateGas: i,
      populateTransaction: e,
      send: r,
      staticCall: n
    }), s;
  }
  function Lk(t, e) {
    const n = function(...l) {
      const u = t.interface.getFunction(e, l);
      return me(u, "no matching fragment", "UNSUPPORTED_OPERATION", {
        operation: "fragment",
        info: {
          key: e,
          args: l
        }
      }), u;
    }, r = async function(...l) {
      const u = n(...l);
      let f = {};
      if (u.inputs.length + 1 === l.length && (f = await W4(l.pop()), f.from && (f.from = await sr(f.from, K4(t.runner)))), u.inputs.length !== l.length) throw new Error("internal error: fragment inputs doesn't match arguments; should not happen");
      const d = await kk(t.runner, u.inputs, l);
      return Object.assign({}, f, await $n({
        to: t.getAddress(),
        data: t.interface.encodeFunctionData(u, d)
      }));
    }, i = async function(...l) {
      const u = await a(...l);
      return u.length === 1 ? u[0] : u;
    }, s = async function(...l) {
      const u = t.runner;
      me(J4(u), "contract runner does not support sending transactions", "UNSUPPORTED_OPERATION", {
        operation: "sendTransaction"
      });
      const f = await u.sendTransaction(await r(...l)), d = ma(t.runner);
      return new hy(t.interface, d, f);
    }, o = async function(...l) {
      const u = Na(t.runner, "estimateGas");
      return me(j4(u), "contract runner does not support gas estimation", "UNSUPPORTED_OPERATION", {
        operation: "estimateGas"
      }), await u.estimateGas(await r(...l));
    }, a = async function(...l) {
      const u = Na(t.runner, "call");
      me(Q4(u), "contract runner does not support calling", "UNSUPPORTED_OPERATION", {
        operation: "call"
      });
      const f = await r(...l);
      let d = "0x";
      try {
        d = await u.call(f);
      } catch (y) {
        throw X1(y) && y.data ? t.interface.makeError(y.data, f) : y;
      }
      const m = n(...l);
      return t.interface.decodeFunctionResult(m, d);
    }, c = async (...l) => n(...l).constant ? await i(...l) : await s(...l);
    return Me(c, {
      name: t.interface.getFunctionName(e),
      _contract: t,
      _key: e,
      getFragment: n,
      estimateGas: o,
      populateTransaction: r,
      send: s,
      staticCall: i,
      staticCallResult: a
    }), Object.defineProperty(c, "fragment", {
      configurable: false,
      enumerable: true,
      get: () => {
        const l = t.interface.getFunction(e);
        return me(l, "no matching fragment", "UNSUPPORTED_OPERATION", {
          operation: "fragment",
          info: {
            key: e
          }
        }), l;
      }
    }), c;
  }
  function Dk(t, e) {
    const n = function(...i) {
      const s = t.interface.getEvent(e, i);
      return me(s, "no matching fragment", "UNSUPPORTED_OPERATION", {
        operation: "fragment",
        info: {
          key: e,
          args: i
        }
      }), s;
    }, r = function(...i) {
      return new Mk(t, n(...i), i);
    };
    return Me(r, {
      name: t.interface.getEventName(e),
      _contract: t,
      _key: e,
      getFragment: n
    }), Object.defineProperty(r, "fragment", {
      configurable: false,
      enumerable: true,
      get: () => {
        const i = t.interface.getEvent(e);
        return me(i, "no matching fragment", "UNSUPPORTED_OPERATION", {
          operation: "fragment",
          info: {
            key: e
          }
        }), i;
      }
    }), r;
  }
  const td = Symbol.for("_ethersInternal_contract"), q4 = /* @__PURE__ */ new WeakMap();
  function Uk(t, e) {
    q4.set(t[td], e);
  }
  function vr(t) {
    return q4.get(t[td]);
  }
  function Hk(t) {
    return t && typeof t == "object" && "getTopicFilter" in t && typeof t.getTopicFilter == "function" && t.fragment;
  }
  async function py(t, e) {
    let n, r = null;
    if (Array.isArray(e)) {
      const s = function(o) {
        if (vt(o, 32)) return o;
        const a = t.interface.getEvent(o);
        return re(a, "unknown fragment", "name", o), a.topicHash;
      };
      n = e.map((o) => o == null ? null : Array.isArray(o) ? o.map(s) : s(o));
    } else e === "*" ? n = [
      null
    ] : typeof e == "string" ? vt(e, 32) ? n = [
      e
    ] : (r = t.interface.getEvent(e), re(r, "unknown fragment", "event", e), n = [
      r.topicHash
    ]) : Hk(e) ? n = await e.getTopicFilter() : "fragment" in e ? (r = e.fragment, n = [
      r.topicHash
    ]) : re(false, "unknown event name", "event", e);
    n = n.map((s) => {
      if (s == null) return null;
      if (Array.isArray(s)) {
        const o = Array.from(new Set(s.map((a) => a.toLowerCase())).values());
        return o.length === 1 ? o[0] : (o.sort(), o);
      }
      return s.toLowerCase();
    });
    const i = n.map((s) => s == null ? "null" : Array.isArray(s) ? s.join("|") : s).join("&");
    return {
      fragment: r,
      tag: i,
      topics: n
    };
  }
  async function nu(t, e) {
    const { subs: n } = vr(t);
    return n.get((await py(t, e)).tag) || null;
  }
  async function uA(t, e, n) {
    const r = ma(t.runner);
    me(r, "contract runner does not support subscribing", "UNSUPPORTED_OPERATION", {
      operation: e
    });
    const { fragment: i, tag: s, topics: o } = await py(t, n), { addr: a, subs: c } = vr(t);
    let l = c.get(s);
    if (!l) {
      const f = {
        address: a || t,
        topics: o
      }, d = (w) => {
        let R = i;
        if (R == null) try {
          R = t.interface.getEvent(w.topics[0]);
        } catch {
        }
        if (R) {
          const O = R, B = i ? t.interface.decodeEventLog(i, w.data, w.topics) : [];
          Im(t, n, B, (M) => new Bk(t, M, n, O, w));
        } else Im(t, n, [], (O) => new z4(t, O, n, w));
      };
      let m = [];
      l = {
        tag: s,
        listeners: [],
        start: () => {
          m.length || m.push(r.on(f, d));
        },
        stop: async () => {
          if (m.length == 0) return;
          let w = m;
          m = [], await Promise.all(w), r.off(f, d);
        }
      }, c.set(s, l);
    }
    return l;
  }
  let Cm = Promise.resolve();
  async function Gk(t, e, n, r) {
    await Cm;
    const i = await nu(t, e);
    if (!i) return false;
    const s = i.listeners.length;
    return i.listeners = i.listeners.filter(({ listener: o, once: a }) => {
      const c = Array.from(n);
      r && c.push(r(a ? null : o));
      try {
        o.call(t, ...c);
      } catch {
      }
      return !a;
    }), i.listeners.length === 0 && (i.stop(), vr(t).subs.delete(i.tag)), s > 0;
  }
  async function Im(t, e, n, r) {
    try {
      await Cm;
    } catch {
    }
    const i = Gk(t, e, n, r);
    return Cm = i, await i;
  }
  const Kf = [
    "then"
  ];
  let Vk = (_j2 = td, _k2 = class {
    constructor(e, n, r, i) {
      __publicField(this, "target");
      __publicField(this, "interface");
      __publicField(this, "runner");
      __publicField(this, "filters");
      __publicField(this, _j2);
      __publicField(this, "fallback");
      re(typeof e == "string" || t4(e), "invalid value for Contract target", "target", e), r == null && (r = null);
      const s = Pk.from(n);
      Me(this, {
        target: e,
        runner: r,
        interface: s
      }), Object.defineProperty(this, td, {
        value: {}
      });
      let o, a = null, c = null;
      if (i) {
        const f = ma(r);
        c = new hy(this.interface, f, i);
      }
      let l = /* @__PURE__ */ new Map();
      if (typeof e == "string") if (vt(e)) a = e, o = Promise.resolve(e);
      else {
        const f = Na(r, "resolveName");
        if (!nh(f)) throw Qt("contract runner does not support name resolution", "UNSUPPORTED_OPERATION", {
          operation: "resolveName"
        });
        o = f.resolveName(e).then((d) => {
          if (d == null) throw Qt("an ENS name used for a contract target must be correctly configured", "UNCONFIGURED_NAME", {
            value: e
          });
          return vr(this).addr = d, d;
        });
      }
      else o = e.getAddress().then((f) => {
        if (f == null) throw new Error("TODO");
        return vr(this).addr = f, f;
      });
      Uk(this, {
        addrPromise: o,
        addr: a,
        deployTx: c,
        subs: l
      });
      const u = new Proxy({}, {
        get: (f, d, m) => {
          if (typeof d == "symbol" || Kf.indexOf(d) >= 0) return Reflect.get(f, d, m);
          try {
            return this.getEvent(d);
          } catch (y) {
            if (!Un(y, "INVALID_ARGUMENT") || y.argument !== "key") throw y;
          }
        },
        has: (f, d) => Kf.indexOf(d) >= 0 ? Reflect.has(f, d) : Reflect.has(f, d) || this.interface.hasEvent(String(d))
      });
      return Me(this, {
        filters: u
      }), Me(this, {
        fallback: s.receive || s.fallback ? Fk(this) : null
      }), new Proxy(this, {
        get: (f, d, m) => {
          if (typeof d == "symbol" || d in f || Kf.indexOf(d) >= 0) return Reflect.get(f, d, m);
          try {
            return f.getFunction(d);
          } catch (y) {
            if (!Un(y, "INVALID_ARGUMENT") || y.argument !== "key") throw y;
          }
        },
        has: (f, d) => typeof d == "symbol" || d in f || Kf.indexOf(d) >= 0 ? Reflect.has(f, d) : f.interface.hasFunction(d)
      });
    }
    connect(e) {
      return new _k2(this.target, this.interface, e);
    }
    attach(e) {
      return new _k2(e, this.interface, this.runner);
    }
    async getAddress() {
      return await vr(this).addrPromise;
    }
    async getDeployedCode() {
      const e = ma(this.runner);
      me(e, "runner does not support .provider", "UNSUPPORTED_OPERATION", {
        operation: "getDeployedCode"
      });
      const n = await e.getCode(await this.getAddress());
      return n === "0x" ? null : n;
    }
    async waitForDeployment() {
      const e = this.deploymentTransaction();
      if (e) return await e.wait(), this;
      if (await this.getDeployedCode() != null) return this;
      const r = ma(this.runner);
      return me(r != null, "contract runner does not support .provider", "UNSUPPORTED_OPERATION", {
        operation: "waitForDeployment"
      }), new Promise((i, s) => {
        const o = async () => {
          try {
            if (await this.getDeployedCode() != null) return i(this);
            r.once("block", o);
          } catch (a) {
            s(a);
          }
        };
        o();
      });
    }
    deploymentTransaction() {
      return vr(this).deployTx;
    }
    getFunction(e) {
      return typeof e != "string" && (e = e.format()), Lk(this, e);
    }
    getEvent(e) {
      return typeof e != "string" && (e = e.format()), Dk(this, e);
    }
    async queryTransaction(e) {
      throw new Error("@TODO");
    }
    async queryFilter(e, n, r) {
      n == null && (n = 0), r == null && (r = "latest");
      const { addr: i, addrPromise: s } = vr(this), o = i || await s, { fragment: a, topics: c } = await py(this, e), l = {
        address: o,
        topics: c,
        fromBlock: n,
        toBlock: r
      }, u = ma(this.runner);
      return me(u, "contract runner does not have a provider", "UNSUPPORTED_OPERATION", {
        operation: "queryFilter"
      }), (await u.getLogs(l)).map((f) => {
        let d = a;
        if (d == null) try {
          d = this.interface.getEvent(f.topics[0]);
        } catch {
        }
        if (d) try {
          return new dy(f, this.interface, d);
        } catch (m) {
          return new V4(f, m);
        }
        return new pf(f, u);
      });
    }
    async on(e, n) {
      const r = await uA(this, "on", e);
      return r.listeners.push({
        listener: n,
        once: false
      }), r.start(), this;
    }
    async once(e, n) {
      const r = await uA(this, "once", e);
      return r.listeners.push({
        listener: n,
        once: true
      }), r.start(), this;
    }
    async emit(e, ...n) {
      return await Im(this, e, n, null);
    }
    async listenerCount(e) {
      if (e) {
        const i = await nu(this, e);
        return i ? i.listeners.length : 0;
      }
      const { subs: n } = vr(this);
      let r = 0;
      for (const { listeners: i } of n.values()) r += i.length;
      return r;
    }
    async listeners(e) {
      if (e) {
        const i = await nu(this, e);
        return i ? i.listeners.map(({ listener: s }) => s) : [];
      }
      const { subs: n } = vr(this);
      let r = [];
      for (const { listeners: i } of n.values()) r = r.concat(i.map(({ listener: s }) => s));
      return r;
    }
    async off(e, n) {
      const r = await nu(this, e);
      if (!r) return this;
      if (n) {
        const i = r.listeners.map(({ listener: s }) => s).indexOf(n);
        i >= 0 && r.listeners.splice(i, 1);
      }
      return (n == null || r.listeners.length === 0) && (r.stop(), vr(this).subs.delete(r.tag)), this;
    }
    async removeAllListeners(e) {
      if (e) {
        const n = await nu(this, e);
        if (!n) return this;
        n.stop(), vr(this).subs.delete(n.tag);
      } else {
        const { subs: n } = vr(this);
        for (const { tag: r, stop: i } of n.values()) i(), n.delete(r);
      }
      return this;
    }
    async addListener(e, n) {
      return await this.on(e, n);
    }
    async removeListener(e, n) {
      return await this.off(e, n);
    }
    static buildClass(e) {
      class n extends _k2 {
        constructor(i, s = null) {
          super(i, e, s);
        }
      }
      return n;
    }
    static from(e, n, r) {
      return r == null && (r = null), new this(e, n, r);
    }
  }, _k2);
  function zk() {
    return Vk;
  }
  let Dc = class extends zk() {
  };
  function Lp(t) {
    return t.match(/^ipfs:\/\/ipfs\//i) ? t = t.substring(12) : t.match(/^ipfs:\/\//i) ? t = t.substring(7) : re(false, "unsupported IPFS format", "link", t), `https://gateway.ipfs.io/ipfs/${t}`;
  }
  class Qk {
    constructor(e) {
      __publicField(this, "name");
      Me(this, {
        name: e
      });
    }
    connect(e) {
      return this;
    }
    supportsCoinType(e) {
      return false;
    }
    async encodeAddress(e, n) {
      throw new Error("unsupported coin");
    }
    async decodeAddress(e, n) {
      throw new Error("unsupported coin");
    }
  }
  const Y4 = new RegExp("^(ipfs)://(.*)$", "i"), fA = [
    new RegExp("^(https)://(.*)$", "i"),
    new RegExp("^(data):(.*)$", "i"),
    Y4,
    new RegExp("^eip155:[0-9]+/(erc[0-9]+):(.*)$", "i")
  ];
  const _Uc = class _Uc {
    constructor(e, n, r) {
      __privateAdd(this, _Uc_instances);
      __publicField(this, "provider");
      __publicField(this, "address");
      __publicField(this, "name");
      __privateAdd(this, _e24);
      __privateAdd(this, _t12);
      Me(this, {
        provider: e,
        address: n,
        name: r
      }), __privateSet(this, _e24, null), __privateSet(this, _t12, new Dc(n, [
        "function supportsInterface(bytes4) view returns (bool)",
        "function resolve(bytes, bytes) view returns (bytes)",
        "function addr(bytes32) view returns (address)",
        "function addr(bytes32, uint) view returns (bytes)",
        "function text(bytes32, string) view returns (string)",
        "function contenthash(bytes32) view returns (bytes)"
      ], e));
    }
    async supportsWildcard() {
      return __privateGet(this, _e24) == null && __privateSet(this, _e24, (async () => {
        try {
          return await __privateGet(this, _t12).supportsInterface("0x9061b923");
        } catch (e) {
          if (Un(e, "CALL_EXCEPTION")) return false;
          throw __privateSet(this, _e24, null), e;
        }
      })()), await __privateGet(this, _e24);
    }
    async getAddress(e) {
      if (e == null && (e = 60), e === 60) try {
        const s = await __privateMethod(this, _Uc_instances, n_fn3).call(this, "addr(bytes32)");
        return s == null || s === nl ? null : s;
      } catch (s) {
        if (Un(s, "CALL_EXCEPTION")) return null;
        throw s;
      }
      if (e >= 0 && e < 2147483648) {
        let s = e + 2147483648;
        const o = await __privateMethod(this, _Uc_instances, n_fn3).call(this, "addr(bytes32,uint)", [
          s
        ]);
        if (vt(o, 20)) return ht(o);
      }
      let n = null;
      for (const s of this.provider.plugins) if (s instanceof Qk && s.supportsCoinType(e)) {
        n = s;
        break;
      }
      if (n == null) return null;
      const r = await __privateMethod(this, _Uc_instances, n_fn3).call(this, "addr(bytes32,uint)", [
        e
      ]);
      if (r == null || r === "0x") return null;
      const i = await n.decodeAddress(e, r);
      if (i != null) return i;
      me(false, "invalid coin data", "UNSUPPORTED_OPERATION", {
        operation: `getAddress(${e})`,
        info: {
          coinType: e,
          data: r
        }
      });
    }
    async getText(e) {
      const n = await __privateMethod(this, _Uc_instances, n_fn3).call(this, "text(bytes32,string)", [
        e
      ]);
      return n == null || n === "0x" ? null : n;
    }
    async getContentHash() {
      const e = await __privateMethod(this, _Uc_instances, n_fn3).call(this, "contenthash(bytes32)");
      if (e == null || e === "0x") return null;
      const n = e.match(/^0x(e3010170|e5010172)(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);
      if (n) {
        const i = n[1] === "e3010170" ? "ipfs" : "ipns", s = parseInt(n[4], 16);
        if (n[5].length === s * 2) return `${i}://${GN("0x" + n[2])}`;
      }
      const r = e.match(/^0xe40101fa011b20([0-9a-f]*)$/);
      if (r && r[1].length === 64) return `bzz://${r[1]}`;
      me(false, "invalid or unsupported content hash data", "UNSUPPORTED_OPERATION", {
        operation: "getContentHash()",
        info: {
          data: e
        }
      });
    }
    async getAvatar() {
      return (await this._getAvatar()).url;
    }
    async _getAvatar() {
      const e = [
        {
          type: "name",
          value: this.name
        }
      ];
      try {
        const n = await this.getText("avatar");
        if (n == null) return e.push({
          type: "!avatar",
          value: ""
        }), {
          url: null,
          linkage: e
        };
        e.push({
          type: "avatar",
          value: n
        });
        for (let r = 0; r < fA.length; r++) {
          const i = n.match(fA[r]);
          if (i == null) continue;
          const s = i[1].toLowerCase();
          switch (s) {
            case "https":
            case "data":
              return e.push({
                type: "url",
                value: n
              }), {
                linkage: e,
                url: n
              };
            case "ipfs": {
              const o = Lp(n);
              return e.push({
                type: "ipfs",
                value: n
              }), e.push({
                type: "url",
                value: o
              }), {
                linkage: e,
                url: o
              };
            }
            case "erc721":
            case "erc1155": {
              const o = s === "erc721" ? "tokenURI(uint256)" : "uri(uint256)";
              e.push({
                type: s,
                value: n
              });
              const a = await this.getAddress();
              if (a == null) return e.push({
                type: "!owner",
                value: ""
              }), {
                url: null,
                linkage: e
              };
              const c = (i[2] || "").split("/");
              if (c.length !== 2) return e.push({
                type: `!${s}caip`,
                value: i[2] || ""
              }), {
                url: null,
                linkage: e
              };
              const l = c[1], u = new Dc(c[0], [
                "function tokenURI(uint) view returns (string)",
                "function ownerOf(uint) view returns (address)",
                "function uri(uint) view returns (string)",
                "function balanceOf(address, uint256) view returns (uint)"
              ], this.provider);
              if (s === "erc721") {
                const x = await u.ownerOf(l);
                if (a !== x) return e.push({
                  type: "!owner",
                  value: x
                }), {
                  url: null,
                  linkage: e
                };
                e.push({
                  type: "owner",
                  value: x
                });
              } else if (s === "erc1155") {
                const x = await u.balanceOf(a, l);
                if (!x) return e.push({
                  type: "!balance",
                  value: "0"
                }), {
                  url: null,
                  linkage: e
                };
                e.push({
                  type: "balance",
                  value: x.toString()
                });
              }
              let f = await u[o](l);
              if (f == null || f === "0x") return e.push({
                type: "!metadata-url",
                value: ""
              }), {
                url: null,
                linkage: e
              };
              e.push({
                type: "metadata-url-base",
                value: f
              }), s === "erc1155" && (f = f.replace("{id}", No(l, 32).substring(2)), e.push({
                type: "metadata-url-expanded",
                value: f
              })), f.match(/^ipfs:/i) && (f = Lp(f)), e.push({
                type: "metadata-url",
                value: f
              });
              let d = {};
              const m = await new Ls(f).send();
              m.assertOk();
              try {
                d = m.bodyJson;
              } catch {
                try {
                  e.push({
                    type: "!metadata",
                    value: m.bodyText
                  });
                } catch {
                  const R = m.body;
                  return R && e.push({
                    type: "!metadata",
                    value: Se(R)
                  }), {
                    url: null,
                    linkage: e
                  };
                }
                return {
                  url: null,
                  linkage: e
                };
              }
              if (!d) return e.push({
                type: "!metadata",
                value: ""
              }), {
                url: null,
                linkage: e
              };
              e.push({
                type: "metadata",
                value: JSON.stringify(d)
              });
              let y = d.image;
              if (typeof y != "string") return e.push({
                type: "!imageUrl",
                value: ""
              }), {
                url: null,
                linkage: e
              };
              if (!y.match(/^(https:\/\/|data:)/i)) {
                if (y.match(Y4) == null) return e.push({
                  type: "!imageUrl-ipfs",
                  value: y
                }), {
                  url: null,
                  linkage: e
                };
                e.push({
                  type: "imageUrl-ipfs",
                  value: y
                }), y = Lp(y);
              }
              return e.push({
                type: "url",
                value: y
              }), {
                linkage: e,
                url: y
              };
            }
          }
        }
      } catch {
      }
      return {
        linkage: e,
        url: null
      };
    }
    static async getEnsAddress(e) {
      const n = await e.getNetwork(), r = n.getPlugin("org.ethers.plugins.network.Ens");
      return me(r, "network does not support ENS", "UNSUPPORTED_OPERATION", {
        operation: "getEnsAddress",
        info: {
          network: n
        }
      }), r.address;
    }
    static async fromName(e, n) {
      var _a6;
      let r = n;
      for (; ; ) {
        if (r === "" || r === "." || n !== "eth" && r === "eth") return null;
        const i = await __privateMethod(_a6 = _Uc, _Uc_static, r_fn3).call(_a6, e, r);
        if (i != null) {
          const s = new _Uc(e, i, n);
          return r !== n && !await s.supportsWildcard() ? null : s;
        }
        r = r.split(".").slice(1).join(".");
      }
    }
  };
  _e24 = new WeakMap();
  _t12 = new WeakMap();
  _Uc_instances = new WeakSet();
  n_fn3 = async function(e, n) {
    n = (n || []).slice();
    const r = __privateGet(this, _t12).interface;
    n.unshift(vm(this.name));
    let i = null;
    await this.supportsWildcard() && (i = r.getFunction(e), me(i, "missing fragment", "UNKNOWN_ERROR", {
      info: {
        funcName: e
      }
    }), n = [
      nk(this.name, 255),
      r.encodeFunctionData(i, n)
    ], e = "resolve(bytes,bytes)"), n.push({
      enableCcipRead: true
    });
    try {
      const s = await __privateGet(this, _t12)[e](...n);
      return i ? r.decodeFunctionResult(i, s)[0] : s;
    } catch (s) {
      if (!Un(s, "CALL_EXCEPTION")) throw s;
    }
    return null;
  };
  _Uc_static = new WeakSet();
  r_fn3 = async function(e, n) {
    const r = await _Uc.getEnsAddress(e);
    try {
      const s = await new Dc(r, [
        "function resolver(bytes32) view returns (address)"
      ], e).resolver(vm(n), {
        enableCcipRead: true
      });
      return s === nl ? null : s;
    } catch (i) {
      throw i;
    }
    return null;
  };
  __privateAdd(_Uc, _Uc_static);
  let Uc = _Uc;
  const dA = BigInt(0);
  function tt(t, e) {
    return function(n) {
      return n == null ? e : t(n);
    };
  }
  function zu(t, e) {
    return (n) => {
      if (e && n == null) return null;
      if (!Array.isArray(n)) throw new Error("not an array");
      return n.map((r) => t(r));
    };
  }
  function mf(t, e) {
    return (n) => {
      const r = {};
      for (const i in t) {
        let s = i;
        if (e && i in e && !(s in n)) {
          for (const o of e[i]) if (o in n) {
            s = o;
            break;
          }
        }
        try {
          const o = t[i](n[s]);
          o !== void 0 && (r[i] = o);
        } catch (o) {
          const a = o instanceof Error ? o.message : "not-an-error";
          me(false, `invalid value for value.${i} (${a})`, "BAD_DATA", {
            value: n
          });
        }
      }
      return r;
    };
  }
  function jk(t) {
    switch (t) {
      case true:
      case "true":
        return true;
      case false:
      case "false":
        return false;
    }
    re(false, `invalid boolean; ${JSON.stringify(t)}`, "value", t);
  }
  function sl(t) {
    return re(vt(t, true), "invalid data", "value", t), t;
  }
  function Ln(t) {
    return re(vt(t, 32), "invalid hash", "value", t), t;
  }
  const Jk = mf({
    address: ht,
    blockHash: Ln,
    blockNumber: Qe,
    data: sl,
    index: Qe,
    removed: tt(jk, false),
    topics: zu(Ln),
    transactionHash: Ln,
    transactionIndex: Qe
  }, {
    index: [
      "logIndex"
    ]
  });
  function Kk(t) {
    return Jk(t);
  }
  const Wk = mf({
    hash: tt(Ln),
    parentHash: Ln,
    parentBeaconBlockRoot: tt(Ln, null),
    number: Qe,
    timestamp: Qe,
    nonce: tt(sl),
    difficulty: Pe,
    gasLimit: Pe,
    gasUsed: Pe,
    stateRoot: tt(Ln, null),
    receiptsRoot: tt(Ln, null),
    blobGasUsed: tt(Pe, null),
    excessBlobGas: tt(Pe, null),
    miner: tt(ht),
    prevRandao: tt(Ln, null),
    extraData: sl,
    baseFeePerGas: tt(Pe)
  }, {
    prevRandao: [
      "mixHash"
    ]
  });
  function qk(t) {
    const e = Wk(t);
    return e.transactions = t.transactions.map((n) => typeof n == "string" ? n : X4(n)), e;
  }
  const Yk = mf({
    transactionIndex: Qe,
    blockNumber: Qe,
    transactionHash: Ln,
    address: ht,
    topics: zu(Ln),
    data: sl,
    index: Qe,
    blockHash: Ln
  }, {
    index: [
      "logIndex"
    ]
  });
  function Xk(t) {
    return Yk(t);
  }
  const Zk = mf({
    to: tt(ht, null),
    from: tt(ht, null),
    contractAddress: tt(ht, null),
    index: Qe,
    root: tt(Se),
    gasUsed: Pe,
    blobGasUsed: tt(Pe, null),
    logsBloom: tt(sl),
    blockHash: Ln,
    hash: Ln,
    logs: zu(Xk),
    blockNumber: Qe,
    cumulativeGasUsed: Pe,
    effectiveGasPrice: tt(Pe),
    blobGasPrice: tt(Pe, null),
    status: tt(Qe),
    type: tt(Qe, 0)
  }, {
    effectiveGasPrice: [
      "gasPrice"
    ],
    hash: [
      "transactionHash"
    ],
    index: [
      "transactionIndex"
    ]
  });
  function $k(t) {
    return Zk(t);
  }
  function X4(t) {
    t.to && Pe(t.to) === dA && (t.to = "0x0000000000000000000000000000000000000000");
    const e = mf({
      hash: Ln,
      index: tt(Qe, void 0),
      type: (n) => n === "0x" || n == null ? 0 : Qe(n),
      accessList: tt(Ua, null),
      blobVersionedHashes: tt(zu(Ln, true), null),
      authorizationList: tt(zu((n) => {
        let r;
        if (n.signature) r = n.signature;
        else {
          let i = n.yParity;
          i === "0x1b" ? i = 0 : i === "0x1c" && (i = 1), r = Object.assign({}, n, {
            yParity: i
          });
        }
        return {
          address: ht(n.address),
          chainId: Pe(n.chainId),
          nonce: Pe(n.nonce),
          signature: Kr.from(r)
        };
      }, false), null),
      blockHash: tt(Ln, null),
      blockNumber: tt(Qe, null),
      transactionIndex: tt(Qe, null),
      from: ht,
      gasPrice: tt(Pe),
      maxPriorityFeePerGas: tt(Pe),
      maxFeePerGas: tt(Pe),
      maxFeePerBlobGas: tt(Pe, null),
      gasLimit: Pe,
      to: tt(ht, null),
      value: Pe,
      nonce: Qe,
      data: sl,
      creates: tt(ht, null),
      chainId: tt(Pe, null)
    }, {
      data: [
        "input"
      ],
      gasLimit: [
        "gas"
      ],
      index: [
        "transactionIndex"
      ]
    })(t);
    if (e.to == null && e.creates == null && (e.creates = DB(e)), (t.type === 1 || t.type === 2) && t.accessList == null && (e.accessList = []), t.signature ? e.signature = Kr.from(t.signature) : e.signature = Kr.from(t), e.chainId == null) {
      const n = e.signature.legacyChainId;
      n != null && (e.chainId = n);
    }
    return e.blockHash && Pe(e.blockHash) === dA && (e.blockHash = null), e;
  }
  const eF = "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e";
  class yf {
    constructor(e) {
      __publicField(this, "name");
      Me(this, {
        name: e
      });
    }
    clone() {
      return new yf(this.name);
    }
  }
  class rh extends yf {
    constructor(e, n) {
      e == null && (e = 0);
      super(`org.ethers.network.plugins.GasCost#${e || 0}`);
      __publicField(this, "effectiveBlock");
      __publicField(this, "txBase");
      __publicField(this, "txCreate");
      __publicField(this, "txDataZero");
      __publicField(this, "txDataNonzero");
      __publicField(this, "txAccessListStorageKey");
      __publicField(this, "txAccessListAddress");
      const r = {
        effectiveBlock: e
      };
      function i(s, o) {
        let a = (n || {})[s];
        a == null && (a = o), re(typeof a == "number", `invalud value for ${s}`, "costs", n), r[s] = a;
      }
      i("txBase", 21e3), i("txCreate", 32e3), i("txDataZero", 4), i("txDataNonzero", 16), i("txAccessListStorageKey", 1900), i("txAccessListAddress", 2400), Me(this, r);
    }
    clone() {
      return new rh(this.effectiveBlock, this);
    }
  }
  class ih extends yf {
    constructor(e, n) {
      super("org.ethers.plugins.network.Ens");
      __publicField(this, "address");
      __publicField(this, "targetNetwork");
      Me(this, {
        address: e || eF,
        targetNetwork: n ?? 1
      });
    }
    clone() {
      return new ih(this.address, this.targetNetwork);
    }
  }
  class tF extends yf {
    constructor(e, n) {
      super("org.ethers.plugins.network.FetchUrlFeeDataPlugin");
      __privateAdd(this, _e25);
      __privateAdd(this, _t13);
      __privateSet(this, _e25, e), __privateSet(this, _t13, n);
    }
    get url() {
      return __privateGet(this, _e25);
    }
    get processFunc() {
      return __privateGet(this, _t13);
    }
    clone() {
      return this;
    }
  }
  _e25 = new WeakMap();
  _t13 = new WeakMap();
  const Dp = /* @__PURE__ */ new Map();
  const _Pr = class _Pr {
    constructor(e, n) {
      __privateAdd(this, _e26);
      __privateAdd(this, _t14);
      __privateAdd(this, _n10);
      __privateSet(this, _e26, e), __privateSet(this, _t14, Pe(n)), __privateSet(this, _n10, /* @__PURE__ */ new Map());
    }
    toJSON() {
      return {
        name: this.name,
        chainId: String(this.chainId)
      };
    }
    get name() {
      return __privateGet(this, _e26);
    }
    set name(e) {
      __privateSet(this, _e26, e);
    }
    get chainId() {
      return __privateGet(this, _t14);
    }
    set chainId(e) {
      __privateSet(this, _t14, Pe(e, "chainId"));
    }
    matches(e) {
      if (e == null) return false;
      if (typeof e == "string") {
        try {
          return this.chainId === Pe(e);
        } catch {
        }
        return this.name === e;
      }
      if (typeof e == "number" || typeof e == "bigint") {
        try {
          return this.chainId === Pe(e);
        } catch {
        }
        return false;
      }
      if (typeof e == "object") {
        if (e.chainId != null) {
          try {
            return this.chainId === Pe(e.chainId);
          } catch {
          }
          return false;
        }
        return e.name != null ? this.name === e.name : false;
      }
      return false;
    }
    get plugins() {
      return Array.from(__privateGet(this, _n10).values());
    }
    attachPlugin(e) {
      if (__privateGet(this, _n10).get(e.name)) throw new Error(`cannot replace existing plugin: ${e.name} `);
      return __privateGet(this, _n10).set(e.name, e.clone()), this;
    }
    getPlugin(e) {
      return __privateGet(this, _n10).get(e) || null;
    }
    getPlugins(e) {
      return this.plugins.filter((n) => n.name.split("#")[0] === e);
    }
    clone() {
      const e = new _Pr(this.name, this.chainId);
      return this.plugins.forEach((n) => {
        e.attachPlugin(n.clone());
      }), e;
    }
    computeIntrinsicGas(e) {
      const n = this.getPlugin("org.ethers.plugins.network.GasCost") || new rh();
      let r = n.txBase;
      if (e.to == null && (r += n.txCreate), e.data) for (let i = 2; i < e.data.length; i += 2) e.data.substring(i, i + 2) === "00" ? r += n.txDataZero : r += n.txDataNonzero;
      if (e.accessList) {
        const i = Ua(e.accessList);
        for (const s in i) r += n.txAccessListAddress + n.txAccessListStorageKey * i[s].storageKeys.length;
      }
      return r;
    }
    static from(e) {
      if (nF(), e == null) return _Pr.from("mainnet");
      if (typeof e == "number" && (e = BigInt(e)), typeof e == "string" || typeof e == "bigint") {
        const n = Dp.get(e);
        if (n) return n();
        if (typeof e == "bigint") return new _Pr("unknown", e);
        re(false, "unknown network", "network", e);
      }
      if (typeof e.clone == "function") return e.clone();
      if (typeof e == "object") {
        re(typeof e.name == "string" && typeof e.chainId == "number", "invalid network object name or chainId", "network", e);
        const n = new _Pr(e.name, e.chainId);
        return (e.ensAddress || e.ensNetwork != null) && n.attachPlugin(new ih(e.ensAddress, e.ensNetwork)), n;
      }
      re(false, "invalid network", "network", e);
    }
    static register(e, n) {
      typeof e == "number" && (e = BigInt(e));
      const r = Dp.get(e);
      r && re(false, `conflicting network for ${JSON.stringify(r.name)}`, "nameOrChainId", e), Dp.set(e, n);
    }
  };
  _e26 = new WeakMap();
  _t14 = new WeakMap();
  _n10 = new WeakMap();
  let Pr = _Pr;
  function hA(t, e) {
    const n = String(t);
    if (!n.match(/^[0-9.]+$/)) throw new Error(`invalid gwei value: ${t}`);
    const r = n.split(".");
    if (r.length === 1 && r.push(""), r.length !== 2) throw new Error(`invalid gwei value: ${t}`);
    for (; r[1].length < e; ) r[1] += "0";
    if (r[1].length > 9) {
      let i = BigInt(r[1].substring(0, 9));
      r[1].substring(9).match(/^0+$/) || i++, r[1] = i.toString();
    }
    return BigInt(r[0] + r[1]);
  }
  function pA(t) {
    return new tF(t, async (e, n, r) => {
      r.setHeader("User-Agent", "ethers");
      let i;
      try {
        const [s, o] = await Promise.all([
          r.send(),
          e()
        ]);
        i = s;
        const a = i.bodyJson.standard;
        return {
          gasPrice: o.gasPrice,
          maxFeePerGas: hA(a.maxFee, 9),
          maxPriorityFeePerGas: hA(a.maxPriorityFee, 9)
        };
      } catch (s) {
        me(false, `error encountered with polygon gas station (${JSON.stringify(r.url)})`, "SERVER_ERROR", {
          request: r,
          response: i,
          error: s
        });
      }
    });
  }
  let gA = false;
  function nF() {
    if (gA) return;
    gA = true;
    function t(e, n, r) {
      const i = function() {
        const s = new Pr(e, n);
        return r.ensNetwork != null && s.attachPlugin(new ih(null, r.ensNetwork)), s.attachPlugin(new rh()), (r.plugins || []).forEach((o) => {
          s.attachPlugin(o);
        }), s;
      };
      Pr.register(e, i), Pr.register(n, i), r.altNames && r.altNames.forEach((s) => {
        Pr.register(s, i);
      });
    }
    t("mainnet", 1, {
      ensNetwork: 1,
      altNames: [
        "homestead"
      ]
    }), t("ropsten", 3, {
      ensNetwork: 3
    }), t("rinkeby", 4, {
      ensNetwork: 4
    }), t("goerli", 5, {
      ensNetwork: 5
    }), t("kovan", 42, {
      ensNetwork: 42
    }), t("sepolia", 11155111, {
      ensNetwork: 11155111
    }), t("holesky", 17e3, {
      ensNetwork: 17e3
    }), t("classic", 61, {}), t("classicKotti", 6, {}), t("arbitrum", 42161, {
      ensNetwork: 1
    }), t("arbitrum-goerli", 421613, {}), t("arbitrum-sepolia", 421614, {}), t("base", 8453, {
      ensNetwork: 1
    }), t("base-goerli", 84531, {}), t("base-sepolia", 84532, {}), t("bnb", 56, {
      ensNetwork: 1
    }), t("bnbt", 97, {}), t("linea", 59144, {
      ensNetwork: 1
    }), t("linea-goerli", 59140, {}), t("linea-sepolia", 59141, {}), t("matic", 137, {
      ensNetwork: 1,
      plugins: [
        pA("https://gasstation.polygon.technology/v2")
      ]
    }), t("matic-amoy", 80002, {}), t("matic-mumbai", 80001, {
      altNames: [
        "maticMumbai",
        "maticmum"
      ],
      plugins: [
        pA("https://gasstation-testnet.polygon.technology/v2")
      ]
    }), t("optimism", 10, {
      ensNetwork: 1,
      plugins: []
    }), t("optimism-goerli", 420, {}), t("optimism-sepolia", 11155420, {}), t("xdai", 100, {
      ensNetwork: 1
    });
  }
  function Pm(t) {
    return JSON.parse(JSON.stringify(t));
  }
  class rF {
    constructor(e) {
      __privateAdd(this, _rF_instances);
      __privateAdd(this, _e27);
      __privateAdd(this, _t15);
      __privateAdd(this, _n11);
      __privateAdd(this, _r8);
      __privateSet(this, _e27, e), __privateSet(this, _t15, null), __privateSet(this, _n11, 4e3), __privateSet(this, _r8, -2);
    }
    get pollingInterval() {
      return __privateGet(this, _n11);
    }
    set pollingInterval(e) {
      __privateSet(this, _n11, e);
    }
    start() {
      __privateGet(this, _t15) || (__privateSet(this, _t15, __privateGet(this, _e27)._setTimeout(__privateMethod(this, _rF_instances, i_fn3).bind(this), __privateGet(this, _n11))), __privateMethod(this, _rF_instances, i_fn3).call(this));
    }
    stop() {
      __privateGet(this, _t15) && (__privateGet(this, _e27)._clearTimeout(__privateGet(this, _t15)), __privateSet(this, _t15, null));
    }
    pause(e) {
      this.stop(), e && __privateSet(this, _r8, -2);
    }
    resume() {
      this.start();
    }
  }
  _e27 = new WeakMap();
  _t15 = new WeakMap();
  _n11 = new WeakMap();
  _r8 = new WeakMap();
  _rF_instances = new WeakSet();
  i_fn3 = async function() {
    try {
      const e = await __privateGet(this, _e27).getBlockNumber();
      if (__privateGet(this, _r8) === -2) {
        __privateSet(this, _r8, e);
        return;
      }
      if (e !== __privateGet(this, _r8)) {
        for (let n = __privateGet(this, _r8) + 1; n <= e; n++) {
          if (__privateGet(this, _t15) == null) return;
          await __privateGet(this, _e27).emit("block", n);
        }
        __privateSet(this, _r8, e);
      }
    } catch {
    }
    __privateGet(this, _t15) != null && __privateSet(this, _t15, __privateGet(this, _e27)._setTimeout(__privateMethod(this, _rF_instances, i_fn3).bind(this), __privateGet(this, _n11)));
  };
  class gy {
    constructor(e) {
      __privateAdd(this, _e28);
      __privateAdd(this, _t16);
      __privateAdd(this, _n12);
      __privateSet(this, _e28, e), __privateSet(this, _n12, false), __privateSet(this, _t16, (n) => {
        this._poll(n, __privateGet(this, _e28));
      });
    }
    async _poll(e, n) {
      throw new Error("sub-classes must override this");
    }
    start() {
      __privateGet(this, _n12) || (__privateSet(this, _n12, true), __privateGet(this, _t16).call(this, -2), __privateGet(this, _e28).on("block", __privateGet(this, _t16)));
    }
    stop() {
      __privateGet(this, _n12) && (__privateSet(this, _n12, false), __privateGet(this, _e28).off("block", __privateGet(this, _t16)));
    }
    pause(e) {
      this.stop();
    }
    resume() {
      this.start();
    }
  }
  _e28 = new WeakMap();
  _t16 = new WeakMap();
  _n12 = new WeakMap();
  class iF extends gy {
    constructor(e, n) {
      super(e);
      __privateAdd(this, _e29);
      __privateAdd(this, _t17);
      __privateSet(this, _e29, n), __privateSet(this, _t17, -2);
    }
    pause(e) {
      e && __privateSet(this, _t17, -2), super.pause(e);
    }
    async _poll(e, n) {
      const r = await n.getBlock(__privateGet(this, _e29));
      r != null && (__privateGet(this, _t17) === -2 ? __privateSet(this, _t17, r.number) : r.number > __privateGet(this, _t17) && (n.emit(__privateGet(this, _e29), r.number), __privateSet(this, _t17, r.number)));
    }
  }
  _e29 = new WeakMap();
  _t17 = new WeakMap();
  class sF extends gy {
    constructor(e, n) {
      super(e);
      __privateAdd(this, _e30);
      __privateSet(this, _e30, Pm(n));
    }
    async _poll(e, n) {
      throw new Error("@TODO");
    }
  }
  _e30 = new WeakMap();
  class oF extends gy {
    constructor(e, n) {
      super(e);
      __privateAdd(this, _e31);
      __privateSet(this, _e31, n);
    }
    async _poll(e, n) {
      const r = await n.getTransactionReceipt(__privateGet(this, _e31));
      r && n.emit(__privateGet(this, _e31), r);
    }
  }
  _e31 = new WeakMap();
  class my {
    constructor(e, n) {
      __privateAdd(this, _my_instances);
      __privateAdd(this, _e32);
      __privateAdd(this, _t18);
      __privateAdd(this, _n13);
      __privateAdd(this, _r9);
      __privateAdd(this, _i7);
      __privateSet(this, _e32, e), __privateSet(this, _t18, Pm(n)), __privateSet(this, _n13, __privateMethod(this, _my_instances, o_fn4).bind(this)), __privateSet(this, _r9, false), __privateSet(this, _i7, -2);
    }
    start() {
      __privateGet(this, _r9) || (__privateSet(this, _r9, true), __privateGet(this, _i7) === -2 && __privateGet(this, _e32).getBlockNumber().then((e) => {
        __privateSet(this, _i7, e);
      }), __privateGet(this, _e32).on("block", __privateGet(this, _n13)));
    }
    stop() {
      __privateGet(this, _r9) && (__privateSet(this, _r9, false), __privateGet(this, _e32).off("block", __privateGet(this, _n13)));
    }
    pause(e) {
      this.stop(), e && __privateSet(this, _i7, -2);
    }
    resume() {
      this.start();
    }
  }
  _e32 = new WeakMap();
  _t18 = new WeakMap();
  _n13 = new WeakMap();
  _r9 = new WeakMap();
  _i7 = new WeakMap();
  _my_instances = new WeakSet();
  o_fn4 = async function(e) {
    if (__privateGet(this, _i7) === -2) return;
    const n = Pm(__privateGet(this, _t18));
    n.fromBlock = __privateGet(this, _i7) + 1, n.toBlock = e;
    const r = await __privateGet(this, _e32).getLogs(n);
    if (r.length === 0) {
      __privateGet(this, _i7) < e - 60 && __privateSet(this, _i7, e - 60);
      return;
    }
    for (const i of r) __privateGet(this, _e32).emit(__privateGet(this, _t18), i), __privateSet(this, _i7, i.blockNumber);
  };
  const aF = BigInt(2), cF = 10;
  function Wf(t) {
    return t && typeof t.then == "function";
  }
  function m0(t, e) {
    return t + ":" + JSON.stringify(e, (n, r) => {
      if (r == null) return "null";
      if (typeof r == "bigint") return `bigint:${r.toString()}`;
      if (typeof r == "string") return r.toLowerCase();
      if (typeof r == "object" && !Array.isArray(r)) {
        const i = Object.keys(r);
        return i.sort(), i.reduce((s, o) => (s[o] = r[o], s), {});
      }
      return r;
    });
  }
  class Z4 {
    constructor(e) {
      __publicField(this, "name");
      Me(this, {
        name: e
      });
    }
    start() {
    }
    stop() {
    }
    pause(e) {
    }
    resume() {
    }
  }
  function lF(t) {
    return JSON.parse(JSON.stringify(t));
  }
  function _m(t) {
    return t = Array.from(new Set(t).values()), t.sort(), t;
  }
  async function Up(t, e) {
    if (t == null) throw new Error("invalid event");
    if (Array.isArray(t) && (t = {
      topics: t
    }), typeof t == "string") switch (t) {
      case "block":
      case "debug":
      case "error":
      case "finalized":
      case "network":
      case "pending":
      case "safe":
        return {
          type: t,
          tag: t
        };
    }
    if (vt(t, 32)) {
      const n = t.toLowerCase();
      return {
        type: "transaction",
        tag: m0("tx", {
          hash: n
        }),
        hash: n
      };
    }
    if (t.orphan) {
      const n = t;
      return {
        type: "orphan",
        tag: m0("orphan", n),
        filter: lF(n)
      };
    }
    if (t.address || t.topics) {
      const n = t, r = {
        topics: (n.topics || []).map((i) => i == null ? null : Array.isArray(i) ? _m(i.map((s) => s.toLowerCase())) : i.toLowerCase())
      };
      if (n.address) {
        const i = [], s = [], o = (a) => {
          vt(a) ? i.push(a) : s.push((async () => {
            i.push(await sr(a, e));
          })());
        };
        Array.isArray(n.address) ? n.address.forEach(o) : o(n.address), s.length && await Promise.all(s), r.address = _m(i.map((a) => a.toLowerCase()));
      }
      return {
        filter: r,
        tag: m0("event", r),
        type: "event"
      };
    }
    re(false, "unknown ProviderEvent", "event", t);
  }
  function Hp() {
    return (/* @__PURE__ */ new Date()).getTime();
  }
  const uF = {
    cacheTimeout: 250,
    pollingInterval: 4e3
  };
  class fF {
    constructor(e, n) {
      __privateAdd(this, _fF_instances);
      __privateAdd(this, _e33);
      __privateAdd(this, _t19);
      __privateAdd(this, _n14);
      __privateAdd(this, _r10);
      __privateAdd(this, _i8);
      __privateAdd(this, _o5);
      __privateAdd(this, _s4);
      __privateAdd(this, _a5);
      __privateAdd(this, _f5);
      __privateAdd(this, _l4);
      __privateAdd(this, _p4);
      __privateAdd(this, _g5);
      if (__privateSet(this, _g5, Object.assign({}, uF, n || {})), e === "any") __privateSet(this, _o5, true), __privateSet(this, _i8, null);
      else if (e) {
        const r = Pr.from(e);
        __privateSet(this, _o5, false), __privateSet(this, _i8, Promise.resolve(r)), setTimeout(() => {
          this.emit("network", r, null);
        }, 0);
      } else __privateSet(this, _o5, false), __privateSet(this, _i8, null);
      __privateSet(this, _a5, -1), __privateSet(this, _s4, /* @__PURE__ */ new Map()), __privateSet(this, _e33, /* @__PURE__ */ new Map()), __privateSet(this, _t19, /* @__PURE__ */ new Map()), __privateSet(this, _n14, null), __privateSet(this, _r10, false), __privateSet(this, _f5, 1), __privateSet(this, _l4, /* @__PURE__ */ new Map()), __privateSet(this, _p4, false);
    }
    get pollingInterval() {
      return __privateGet(this, _g5).pollingInterval;
    }
    get provider() {
      return this;
    }
    get plugins() {
      return Array.from(__privateGet(this, _t19).values());
    }
    attachPlugin(e) {
      if (__privateGet(this, _t19).get(e.name)) throw new Error(`cannot replace existing plugin: ${e.name} `);
      return __privateGet(this, _t19).set(e.name, e.connect(this)), this;
    }
    getPlugin(e) {
      return __privateGet(this, _t19).get(e) || null;
    }
    get disableCcipRead() {
      return __privateGet(this, _p4);
    }
    set disableCcipRead(e) {
      __privateSet(this, _p4, !!e);
    }
    async ccipReadFetch(e, n, r) {
      if (this.disableCcipRead || r.length === 0 || e.to == null) return null;
      const i = e.to.toLowerCase(), s = n.toLowerCase(), o = [];
      for (let a = 0; a < r.length; a++) {
        const c = r[a], l = c.replace("{sender}", i).replace("{data}", s), u = new Ls(l);
        c.indexOf("{data}") === -1 && (u.body = {
          data: s,
          sender: i
        }), this.emit("debug", {
          action: "sendCcipReadFetchRequest",
          request: u,
          index: a,
          urls: r
        });
        let f = "unknown error", d;
        try {
          d = await u.send();
        } catch (m) {
          o.push(m.message), this.emit("debug", {
            action: "receiveCcipReadFetchError",
            request: u,
            result: {
              error: m
            }
          });
          continue;
        }
        try {
          const m = d.bodyJson;
          if (m.data) return this.emit("debug", {
            action: "receiveCcipReadFetchResult",
            request: u,
            result: m
          }), m.data;
          m.message && (f = m.message), this.emit("debug", {
            action: "receiveCcipReadFetchError",
            request: u,
            result: m
          });
        } catch {
        }
        me(d.statusCode < 400 || d.statusCode >= 500, `response not found during CCIP fetch: ${f}`, "OFFCHAIN_FAULT", {
          reason: "404_MISSING_RESOURCE",
          transaction: e,
          info: {
            url: c,
            errorMessage: f
          }
        }), o.push(f);
      }
      me(false, `error encountered during CCIP fetch: ${o.map((a) => JSON.stringify(a)).join(", ")}`, "OFFCHAIN_FAULT", {
        reason: "500_SERVER_ERROR",
        transaction: e,
        info: {
          urls: r,
          errorMessages: o
        }
      });
    }
    _wrapBlock(e, n) {
      return new _k(qk(e), this);
    }
    _wrapLog(e, n) {
      return new pf(Kk(e), this);
    }
    _wrapTransactionReceipt(e, n) {
      return new U4($k(e), this);
    }
    _wrapTransactionResponse(e, n) {
      return new gf(X4(e), this);
    }
    _detectNetwork() {
      me(false, "sub-classes must implement this", "UNSUPPORTED_OPERATION", {
        operation: "_detectNetwork"
      });
    }
    async _perform(e) {
      me(false, `unsupported method: ${e.method}`, "UNSUPPORTED_OPERATION", {
        operation: e.method,
        info: e
      });
    }
    async getBlockNumber() {
      const e = Qe(await __privateMethod(this, _fF_instances, c_fn).call(this, {
        method: "getBlockNumber"
      }), "%response");
      return __privateGet(this, _a5) >= 0 && __privateSet(this, _a5, e), e;
    }
    _getAddress(e) {
      return sr(e, this);
    }
    _getBlockTag(e) {
      if (e == null) return "latest";
      switch (e) {
        case "earliest":
          return "0x0";
        case "finalized":
        case "latest":
        case "pending":
        case "safe":
          return e;
      }
      if (vt(e)) return vt(e, 32) ? e : di(e);
      if (typeof e == "bigint" && (e = Qe(e, "blockTag")), typeof e == "number") return e >= 0 ? di(e) : __privateGet(this, _a5) >= 0 ? di(__privateGet(this, _a5) + e) : this.getBlockNumber().then((n) => di(n + e));
      re(false, "invalid blockTag", "blockTag", e);
    }
    _getFilter(e) {
      const n = (e.topics || []).map((c) => c == null ? null : Array.isArray(c) ? _m(c.map((l) => l.toLowerCase())) : c.toLowerCase()), r = "blockHash" in e ? e.blockHash : void 0, i = (c, l, u) => {
        let f;
        switch (c.length) {
          case 0:
            break;
          case 1:
            f = c[0];
            break;
          default:
            c.sort(), f = c;
        }
        if (r && (l != null || u != null)) throw new Error("invalid filter");
        const d = {};
        return f && (d.address = f), n.length && (d.topics = n), l && (d.fromBlock = l), u && (d.toBlock = u), r && (d.blockHash = r), d;
      };
      let s = [];
      if (e.address) if (Array.isArray(e.address)) for (const c of e.address) s.push(this._getAddress(c));
      else s.push(this._getAddress(e.address));
      let o;
      "fromBlock" in e && (o = this._getBlockTag(e.fromBlock));
      let a;
      return "toBlock" in e && (a = this._getBlockTag(e.toBlock)), s.filter((c) => typeof c != "string").length || o != null && typeof o != "string" || a != null && typeof a != "string" ? Promise.all([
        Promise.all(s),
        o,
        a
      ]).then((c) => i(c[0], c[1], c[2])) : i(s, o, a);
    }
    _getTransactionRequest(e) {
      const n = ed(e), r = [];
      if ([
        "to",
        "from"
      ].forEach((i) => {
        if (n[i] == null) return;
        const s = sr(n[i], this);
        Wf(s) ? r.push(async function() {
          n[i] = await s;
        }()) : n[i] = s;
      }), n.blockTag != null) {
        const i = this._getBlockTag(n.blockTag);
        Wf(i) ? r.push(async function() {
          n.blockTag = await i;
        }()) : n.blockTag = i;
      }
      return r.length ? async function() {
        return await Promise.all(r), n;
      }() : n;
    }
    async getNetwork() {
      if (__privateGet(this, _i8) == null) {
        const i = (async () => {
          try {
            const s = await this._detectNetwork();
            return this.emit("network", s, null), s;
          } catch (s) {
            throw __privateGet(this, _i8) === i && __privateSet(this, _i8, null), s;
          }
        })();
        return __privateSet(this, _i8, i), (await i).clone();
      }
      const e = __privateGet(this, _i8), [n, r] = await Promise.all([
        e,
        this._detectNetwork()
      ]);
      return n.chainId !== r.chainId && (__privateGet(this, _o5) ? (this.emit("network", r, n), __privateGet(this, _i8) === e && __privateSet(this, _i8, Promise.resolve(r))) : me(false, `network changed: ${n.chainId} => ${r.chainId} `, "NETWORK_ERROR", {
        event: "changed"
      })), n.clone();
    }
    async getFeeData() {
      const e = await this.getNetwork(), n = async () => {
        const { _block: i, gasPrice: s, priorityFee: o } = await $n({
          _block: __privateMethod(this, _fF_instances, y_fn).call(this, "latest", false),
          gasPrice: (async () => {
            try {
              const u = await __privateMethod(this, _fF_instances, c_fn).call(this, {
                method: "getGasPrice"
              });
              return Pe(u, "%response");
            } catch {
            }
            return null;
          })(),
          priorityFee: (async () => {
            try {
              const u = await __privateMethod(this, _fF_instances, c_fn).call(this, {
                method: "getPriorityFee"
              });
              return Pe(u, "%response");
            } catch {
            }
            return null;
          })()
        });
        let a = null, c = null;
        const l = this._wrapBlock(i, e);
        return l && l.baseFeePerGas && (c = o ?? BigInt("1000000000"), a = l.baseFeePerGas * aF + c), new cA(s, a, c);
      }, r = e.getPlugin("org.ethers.plugins.network.FetchUrlFeeDataPlugin");
      if (r) {
        const i = new Ls(r.url), s = await r.processFunc(n, this, i);
        return new cA(s.gasPrice, s.maxFeePerGas, s.maxPriorityFeePerGas);
      }
      return await n();
    }
    async estimateGas(e) {
      let n = this._getTransactionRequest(e);
      return Wf(n) && (n = await n), Pe(await __privateMethod(this, _fF_instances, c_fn).call(this, {
        method: "estimateGas",
        transaction: n
      }), "%response");
    }
    async call(e) {
      const { tx: n, blockTag: r } = await $n({
        tx: this._getTransactionRequest(e),
        blockTag: this._getBlockTag(e.blockTag)
      });
      return await __privateMethod(this, _fF_instances, d_fn).call(this, __privateMethod(this, _fF_instances, u_fn).call(this, n, r, e.enableCcipRead ? 0 : -1));
    }
    async getBalance(e, n) {
      return Pe(await __privateMethod(this, _fF_instances, h_fn2).call(this, {
        method: "getBalance"
      }, e, n), "%response");
    }
    async getTransactionCount(e, n) {
      return Qe(await __privateMethod(this, _fF_instances, h_fn2).call(this, {
        method: "getTransactionCount"
      }, e, n), "%response");
    }
    async getCode(e, n) {
      return Se(await __privateMethod(this, _fF_instances, h_fn2).call(this, {
        method: "getCode"
      }, e, n));
    }
    async getStorage(e, n, r) {
      const i = Pe(n, "position");
      return Se(await __privateMethod(this, _fF_instances, h_fn2).call(this, {
        method: "getStorage",
        position: i
      }, e, r));
    }
    async broadcastTransaction(e) {
      const { blockNumber: n, hash: r, network: i } = await $n({
        blockNumber: this.getBlockNumber(),
        hash: this._perform({
          method: "broadcastTransaction",
          signedTransaction: e
        }),
        network: this.getNetwork()
      }), s = li.from(e);
      if (s.hash !== r) throw new Error("@TODO: the returned hash did not match");
      return this._wrapTransactionResponse(s, i).replaceableTransaction(n);
    }
    async getBlock(e, n) {
      const { network: r, params: i } = await $n({
        network: this.getNetwork(),
        params: __privateMethod(this, _fF_instances, y_fn).call(this, e, !!n)
      });
      return i == null ? null : this._wrapBlock(i, r);
    }
    async getTransaction(e) {
      const { network: n, params: r } = await $n({
        network: this.getNetwork(),
        params: __privateMethod(this, _fF_instances, c_fn).call(this, {
          method: "getTransaction",
          hash: e
        })
      });
      return r == null ? null : this._wrapTransactionResponse(r, n);
    }
    async getTransactionReceipt(e) {
      const { network: n, params: r } = await $n({
        network: this.getNetwork(),
        params: __privateMethod(this, _fF_instances, c_fn).call(this, {
          method: "getTransactionReceipt",
          hash: e
        })
      });
      if (r == null) return null;
      if (r.gasPrice == null && r.effectiveGasPrice == null) {
        const i = await __privateMethod(this, _fF_instances, c_fn).call(this, {
          method: "getTransaction",
          hash: e
        });
        if (i == null) throw new Error("report this; could not find tx or effectiveGasPrice");
        r.effectiveGasPrice = i.gasPrice;
      }
      return this._wrapTransactionReceipt(r, n);
    }
    async getTransactionResult(e) {
      const { result: n } = await $n({
        network: this.getNetwork(),
        result: __privateMethod(this, _fF_instances, c_fn).call(this, {
          method: "getTransactionResult",
          hash: e
        })
      });
      return n == null ? null : Se(n);
    }
    async getLogs(e) {
      let n = this._getFilter(e);
      Wf(n) && (n = await n);
      const { network: r, params: i } = await $n({
        network: this.getNetwork(),
        params: __privateMethod(this, _fF_instances, c_fn).call(this, {
          method: "getLogs",
          filter: n
        })
      });
      return i.map((s) => this._wrapLog(s, r));
    }
    _getProvider(e) {
      me(false, "provider cannot connect to target network", "UNSUPPORTED_OPERATION", {
        operation: "_getProvider()"
      });
    }
    async getResolver(e) {
      return await Uc.fromName(this, e);
    }
    async getAvatar(e) {
      const n = await this.getResolver(e);
      return n ? await n.getAvatar() : null;
    }
    async resolveName(e) {
      const n = await this.getResolver(e);
      return n ? await n.getAddress() : null;
    }
    async lookupAddress(e) {
      e = ht(e);
      const n = vm(e.substring(2).toLowerCase() + ".addr.reverse");
      try {
        const r = await Uc.getEnsAddress(this), s = await new Dc(r, [
          "function resolver(bytes32) view returns (address)"
        ], this).resolver(n);
        if (s == null || s === nl) return null;
        const a = await new Dc(s, [
          "function name(bytes32) view returns (string)"
        ], this).name(n);
        return await this.resolveName(a) !== e ? null : a;
      } catch (r) {
        if (Un(r, "BAD_DATA") && r.value === "0x" || Un(r, "CALL_EXCEPTION")) return null;
        throw r;
      }
      return null;
    }
    async waitForTransaction(e, n, r) {
      const i = n ?? 1;
      return i === 0 ? this.getTransactionReceipt(e) : new Promise(async (s, o) => {
        let a = null;
        const c = async (l) => {
          try {
            const u = await this.getTransactionReceipt(e);
            if (u != null && l - u.blockNumber + 1 >= i) {
              s(u), a && (clearTimeout(a), a = null);
              return;
            }
          } catch (u) {
            console.log("EEE", u);
          }
          this.once("block", c);
        };
        r != null && (a = setTimeout(() => {
          a != null && (a = null, this.off("block", c), o(Qt("timeout", "TIMEOUT", {
            reason: "timeout"
          })));
        }, r)), c(await this.getBlockNumber());
      });
    }
    async waitForBlock(e) {
      me(false, "not implemented yet", "NOT_IMPLEMENTED", {
        operation: "waitForBlock"
      });
    }
    _clearTimeout(e) {
      const n = __privateGet(this, _l4).get(e);
      n && (n.timer && clearTimeout(n.timer), __privateGet(this, _l4).delete(e));
    }
    _setTimeout(e, n) {
      n == null && (n = 0);
      const r = __privateWrapper(this, _f5)._++, i = () => {
        __privateGet(this, _l4).delete(r), e();
      };
      if (this.paused) __privateGet(this, _l4).set(r, {
        timer: null,
        func: i,
        time: n
      });
      else {
        const s = setTimeout(i, n);
        __privateGet(this, _l4).set(r, {
          timer: s,
          func: i,
          time: Hp()
        });
      }
      return r;
    }
    _forEachSubscriber(e) {
      for (const n of __privateGet(this, _e33).values()) e(n.subscriber);
    }
    _getSubscriber(e) {
      switch (e.type) {
        case "debug":
        case "error":
        case "network":
          return new Z4(e.type);
        case "block": {
          const n = new rF(this);
          return n.pollingInterval = this.pollingInterval, n;
        }
        case "safe":
        case "finalized":
          return new iF(this, e.type);
        case "event":
          return new my(this, e.filter);
        case "transaction":
          return new oF(this, e.hash);
        case "orphan":
          return new sF(this, e.filter);
      }
      throw new Error(`unsupported event: ${e.type}`);
    }
    _recoverSubscriber(e, n) {
      for (const r of __privateGet(this, _e33).values()) if (r.subscriber === e) {
        r.started && r.subscriber.stop(), r.subscriber = n, r.started && n.start(), __privateGet(this, _n14) != null && n.pause(__privateGet(this, _n14));
        break;
      }
    }
    async on(e, n) {
      const r = await __privateMethod(this, _fF_instances, b_fn).call(this, e);
      return r.listeners.push({
        listener: n,
        once: false
      }), r.started || (r.subscriber.start(), r.started = true, __privateGet(this, _n14) != null && r.subscriber.pause(__privateGet(this, _n14))), this;
    }
    async once(e, n) {
      const r = await __privateMethod(this, _fF_instances, b_fn).call(this, e);
      return r.listeners.push({
        listener: n,
        once: true
      }), r.started || (r.subscriber.start(), r.started = true, __privateGet(this, _n14) != null && r.subscriber.pause(__privateGet(this, _n14))), this;
    }
    async emit(e, ...n) {
      const r = await __privateMethod(this, _fF_instances, m_fn2).call(this, e, n);
      if (!r || r.listeners.length === 0) return false;
      const i = r.listeners.length;
      return r.listeners = r.listeners.filter(({ listener: s, once: o }) => {
        const a = new pE(this, o ? null : s, e);
        try {
          s.call(this, ...n, a);
        } catch {
        }
        return !o;
      }), r.listeners.length === 0 && (r.started && r.subscriber.stop(), __privateGet(this, _e33).delete(r.tag)), i > 0;
    }
    async listenerCount(e) {
      if (e) {
        const r = await __privateMethod(this, _fF_instances, m_fn2).call(this, e);
        return r ? r.listeners.length : 0;
      }
      let n = 0;
      for (const { listeners: r } of __privateGet(this, _e33).values()) n += r.length;
      return n;
    }
    async listeners(e) {
      if (e) {
        const r = await __privateMethod(this, _fF_instances, m_fn2).call(this, e);
        return r ? r.listeners.map(({ listener: i }) => i) : [];
      }
      let n = [];
      for (const { listeners: r } of __privateGet(this, _e33).values()) n = n.concat(r.map(({ listener: i }) => i));
      return n;
    }
    async off(e, n) {
      const r = await __privateMethod(this, _fF_instances, m_fn2).call(this, e);
      if (!r) return this;
      if (n) {
        const i = r.listeners.map(({ listener: s }) => s).indexOf(n);
        i >= 0 && r.listeners.splice(i, 1);
      }
      return (!n || r.listeners.length === 0) && (r.started && r.subscriber.stop(), __privateGet(this, _e33).delete(r.tag)), this;
    }
    async removeAllListeners(e) {
      if (e) {
        const { tag: n, started: r, subscriber: i } = await __privateMethod(this, _fF_instances, b_fn).call(this, e);
        r && i.stop(), __privateGet(this, _e33).delete(n);
      } else for (const [n, { started: r, subscriber: i }] of __privateGet(this, _e33)) r && i.stop(), __privateGet(this, _e33).delete(n);
      return this;
    }
    async addListener(e, n) {
      return await this.on(e, n);
    }
    async removeListener(e, n) {
      return this.off(e, n);
    }
    get destroyed() {
      return __privateGet(this, _r10);
    }
    destroy() {
      this.removeAllListeners();
      for (const e of __privateGet(this, _l4).keys()) this._clearTimeout(e);
      __privateSet(this, _r10, true);
    }
    get paused() {
      return __privateGet(this, _n14) != null;
    }
    set paused(e) {
      !!e !== this.paused && (this.paused ? this.resume() : this.pause(false));
    }
    pause(e) {
      if (__privateSet(this, _a5, -1), __privateGet(this, _n14) != null) {
        if (__privateGet(this, _n14) == !!e) return;
        me(false, "cannot change pause type; resume first", "UNSUPPORTED_OPERATION", {
          operation: "pause"
        });
      }
      this._forEachSubscriber((n) => n.pause(e)), __privateSet(this, _n14, !!e);
      for (const n of __privateGet(this, _l4).values()) n.timer && clearTimeout(n.timer), n.time = Hp() - n.time;
    }
    resume() {
      if (__privateGet(this, _n14) != null) {
        this._forEachSubscriber((e) => e.resume()), __privateSet(this, _n14, null);
        for (const e of __privateGet(this, _l4).values()) {
          let n = e.time;
          n < 0 && (n = 0), e.time = Hp(), setTimeout(e.func, n);
        }
      }
    }
  }
  _e33 = new WeakMap();
  _t19 = new WeakMap();
  _n14 = new WeakMap();
  _r10 = new WeakMap();
  _i8 = new WeakMap();
  _o5 = new WeakMap();
  _s4 = new WeakMap();
  _a5 = new WeakMap();
  _f5 = new WeakMap();
  _l4 = new WeakMap();
  _p4 = new WeakMap();
  _g5 = new WeakMap();
  _fF_instances = new WeakSet();
  c_fn = async function(e) {
    const n = __privateGet(this, _g5).cacheTimeout;
    if (n < 0) return await this._perform(e);
    const r = m0(e.method, e);
    let i = __privateGet(this, _s4).get(r);
    return i || (i = this._perform(e), __privateGet(this, _s4).set(r, i), setTimeout(() => {
      __privateGet(this, _s4).get(r) === i && __privateGet(this, _s4).delete(r);
    }, n)), await i;
  };
  u_fn = async function(e, n, r) {
    me(r < cF, "CCIP read exceeded maximum redirections", "OFFCHAIN_FAULT", {
      reason: "TOO_MANY_REDIRECTS",
      transaction: Object.assign({}, e, {
        blockTag: n,
        enableCcipRead: true
      })
    });
    const i = ed(e);
    try {
      return Se(await this._perform({
        method: "call",
        transaction: i,
        blockTag: n
      }));
    } catch (s) {
      if (!this.disableCcipRead && X1(s) && s.data && r >= 0 && n === "latest" && i.to != null && en(s.data, 0, 4) === "0x556f1830") {
        const o = s.data, a = await sr(i.to, this);
        let c;
        try {
          c = mF(en(s.data, 4));
        } catch (f) {
          me(false, f.message, "OFFCHAIN_FAULT", {
            reason: "BAD_DATA",
            transaction: i,
            info: {
              data: o
            }
          });
        }
        me(c.sender.toLowerCase() === a.toLowerCase(), "CCIP Read sender mismatch", "CALL_EXCEPTION", {
          action: "call",
          data: o,
          reason: "OffchainLookup",
          transaction: i,
          invocation: null,
          revert: {
            signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
            name: "OffchainLookup",
            args: c.errorArgs
          }
        });
        const l = await this.ccipReadFetch(i, c.calldata, c.urls);
        me(l != null, "CCIP Read failed to fetch data", "OFFCHAIN_FAULT", {
          reason: "FETCH_FAILED",
          transaction: i,
          info: {
            data: s.data,
            errorArgs: c.errorArgs
          }
        });
        const u = {
          to: a,
          data: Xt([
            c.selector,
            gF([
              l,
              c.extraData
            ])
          ])
        };
        this.emit("debug", {
          action: "sendCcipReadCall",
          transaction: u
        });
        try {
          const f = await __privateMethod(this, _fF_instances, u_fn).call(this, u, n, r + 1);
          return this.emit("debug", {
            action: "receiveCcipReadCallResult",
            transaction: Object.assign({}, u),
            result: f
          }), f;
        } catch (f) {
          throw this.emit("debug", {
            action: "receiveCcipReadCallError",
            transaction: Object.assign({}, u),
            error: f
          }), f;
        }
      }
      throw s;
    }
  };
  d_fn = async function(e) {
    const { value: n } = await $n({
      network: this.getNetwork(),
      value: e
    });
    return n;
  };
  h_fn2 = async function(e, n, r) {
    let i = this._getAddress(n), s = this._getBlockTag(r);
    return (typeof i != "string" || typeof s != "string") && ([i, s] = await Promise.all([
      i,
      s
    ])), await __privateMethod(this, _fF_instances, d_fn).call(this, __privateMethod(this, _fF_instances, c_fn).call(this, Object.assign(e, {
      address: i,
      blockTag: s
    })));
  };
  y_fn = async function(e, n) {
    if (vt(e, 32)) return await __privateMethod(this, _fF_instances, c_fn).call(this, {
      method: "getBlock",
      blockHash: e,
      includeTransactions: n
    });
    let r = this._getBlockTag(e);
    return typeof r != "string" && (r = await r), await __privateMethod(this, _fF_instances, c_fn).call(this, {
      method: "getBlock",
      blockTag: r,
      includeTransactions: n
    });
  };
  m_fn2 = async function(e, n) {
    let r = await Up(e, this);
    return r.type === "event" && n && n.length > 0 && n[0].removed === true && (r = await Up({
      orphan: "drop-log",
      log: n[0]
    }, this)), __privateGet(this, _e33).get(r.tag) || null;
  };
  b_fn = async function(e) {
    const n = await Up(e, this), r = n.tag;
    let i = __privateGet(this, _e33).get(r);
    return i || (i = {
      subscriber: this._getSubscriber(n),
      tag: r,
      addressableMap: /* @__PURE__ */ new WeakMap(),
      nameMap: /* @__PURE__ */ new Map(),
      started: false,
      listeners: []
    }, __privateGet(this, _e33).set(r, i)), i;
  };
  function dF(t, e) {
    try {
      const n = Rm(t, e);
      if (n) return K0(n);
    } catch {
    }
    return null;
  }
  function Rm(t, e) {
    if (t === "0x") return null;
    try {
      const n = Qe(en(t, e, e + 32)), r = Qe(en(t, n, n + 32));
      return en(t, n + 32, n + 32 + r);
    } catch {
    }
    return null;
  }
  function mA(t) {
    const e = hn(t);
    if (e.length > 32) throw new Error("internal; should not happen");
    const n = new Uint8Array(32);
    return n.set(e, 32 - e.length), n;
  }
  function hF(t) {
    if (t.length % 32 === 0) return t;
    const e = new Uint8Array(Math.ceil(t.length / 32) * 32);
    return e.set(t), e;
  }
  const pF = new Uint8Array([]);
  function gF(t) {
    const e = [];
    let n = 0;
    for (let r = 0; r < t.length; r++) e.push(pF), n += 32;
    for (let r = 0; r < t.length; r++) {
      const i = Je(t[r]);
      e[r] = mA(n), e.push(mA(i.length)), e.push(hF(i)), n += 32 + Math.ceil(i.length / 32) * 32;
    }
    return Xt(e);
  }
  const yA = "0x0000000000000000000000000000000000000000000000000000000000000000";
  function mF(t) {
    const e = {
      sender: "",
      urls: [],
      calldata: "",
      selector: "",
      extraData: "",
      errorArgs: []
    };
    me(Mc(t) >= 5 * 32, "insufficient OffchainLookup data", "OFFCHAIN_FAULT", {
      reason: "insufficient OffchainLookup data"
    });
    const n = en(t, 0, 32);
    me(en(n, 0, 12) === en(yA, 0, 12), "corrupt OffchainLookup sender", "OFFCHAIN_FAULT", {
      reason: "corrupt OffchainLookup sender"
    }), e.sender = en(n, 12);
    try {
      const r = [], i = Qe(en(t, 32, 64)), s = Qe(en(t, i, i + 32)), o = en(t, i + 32);
      for (let a = 0; a < s; a++) {
        const c = dF(o, a * 32);
        if (c == null) throw new Error("abort");
        r.push(c);
      }
      e.urls = r;
    } catch {
      me(false, "corrupt OffchainLookup urls", "OFFCHAIN_FAULT", {
        reason: "corrupt OffchainLookup urls"
      });
    }
    try {
      const r = Rm(t, 64);
      if (r == null) throw new Error("abort");
      e.calldata = r;
    } catch {
      me(false, "corrupt OffchainLookup calldata", "OFFCHAIN_FAULT", {
        reason: "corrupt OffchainLookup calldata"
      });
    }
    me(en(t, 100, 128) === en(yA, 0, 28), "corrupt OffchainLookup callbaackSelector", "OFFCHAIN_FAULT", {
      reason: "corrupt OffchainLookup callbaackSelector"
    }), e.selector = en(t, 96, 100);
    try {
      const r = Rm(t, 128);
      if (r == null) throw new Error("abort");
      e.extraData = r;
    } catch {
      me(false, "corrupt OffchainLookup extraData", "OFFCHAIN_FAULT", {
        reason: "corrupt OffchainLookup extraData"
      });
    }
    return e.errorArgs = "sender,urls,calldata,selector,extraData".split(/,/).map((r) => e[r]), e;
  }
  function ia(t, e) {
    if (t.provider) return t.provider;
    me(false, "missing provider", "UNSUPPORTED_OPERATION", {
      operation: e
    });
  }
  async function bA(t, e) {
    let n = ed(e);
    if (n.to != null && (n.to = sr(n.to, t)), n.from != null) {
      const r = n.from;
      n.from = Promise.all([
        t.getAddress(),
        sr(r, t)
      ]).then(([i, s]) => (re(i.toLowerCase() === s.toLowerCase(), "transaction from mismatch", "tx.from", s), i));
    } else n.from = t.getAddress();
    return await $n(n);
  }
  class yF {
    constructor(e) {
      __publicField(this, "provider");
      Me(this, {
        provider: e || null
      });
    }
    async getNonce(e) {
      return ia(this, "getTransactionCount").getTransactionCount(await this.getAddress(), e);
    }
    async populateCall(e) {
      return await bA(this, e);
    }
    async populateTransaction(e) {
      const n = ia(this, "populateTransaction"), r = await bA(this, e);
      r.nonce == null && (r.nonce = await this.getNonce("pending")), r.gasLimit == null && (r.gasLimit = await this.estimateGas(r));
      const i = await this.provider.getNetwork();
      if (r.chainId != null) {
        const o = Pe(r.chainId);
        re(o === i.chainId, "transaction chainId mismatch", "tx.chainId", e.chainId);
      } else r.chainId = i.chainId;
      const s = r.maxFeePerGas != null || r.maxPriorityFeePerGas != null;
      if (r.gasPrice != null && (r.type === 2 || s) ? re(false, "eip-1559 transaction do not support gasPrice", "tx", e) : (r.type === 0 || r.type === 1) && s && re(false, "pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas", "tx", e), (r.type === 2 || r.type == null) && r.maxFeePerGas != null && r.maxPriorityFeePerGas != null) r.type = 2;
      else if (r.type === 0 || r.type === 1) {
        const o = await n.getFeeData();
        me(o.gasPrice != null, "network does not support gasPrice", "UNSUPPORTED_OPERATION", {
          operation: "getGasPrice"
        }), r.gasPrice == null && (r.gasPrice = o.gasPrice);
      } else {
        const o = await n.getFeeData();
        if (r.type == null) if (o.maxFeePerGas != null && o.maxPriorityFeePerGas != null) if (r.authorizationList && r.authorizationList.length ? r.type = 4 : r.type = 2, r.gasPrice != null) {
          const a = r.gasPrice;
          delete r.gasPrice, r.maxFeePerGas = a, r.maxPriorityFeePerGas = a;
        } else r.maxFeePerGas == null && (r.maxFeePerGas = o.maxFeePerGas), r.maxPriorityFeePerGas == null && (r.maxPriorityFeePerGas = o.maxPriorityFeePerGas);
        else o.gasPrice != null ? (me(!s, "network does not support EIP-1559", "UNSUPPORTED_OPERATION", {
          operation: "populateTransaction"
        }), r.gasPrice == null && (r.gasPrice = o.gasPrice), r.type = 0) : me(false, "failed to get consistent fee data", "UNSUPPORTED_OPERATION", {
          operation: "signer.getFeeData"
        });
        else (r.type === 2 || r.type === 3 || r.type === 4) && (r.maxFeePerGas == null && (r.maxFeePerGas = o.maxFeePerGas), r.maxPriorityFeePerGas == null && (r.maxPriorityFeePerGas = o.maxPriorityFeePerGas));
      }
      return await $n(r);
    }
    async populateAuthorization(e) {
      const n = Object.assign({}, e);
      return n.chainId == null && (n.chainId = (await ia(this, "getNetwork").getNetwork()).chainId), n.nonce == null && (n.nonce = await this.getNonce()), n;
    }
    async estimateGas(e) {
      return ia(this, "estimateGas").estimateGas(await this.populateCall(e));
    }
    async call(e) {
      return ia(this, "call").call(await this.populateCall(e));
    }
    async resolveName(e) {
      return await ia(this, "resolveName").resolveName(e);
    }
    async sendTransaction(e) {
      const n = ia(this, "sendTransaction"), r = await this.populateTransaction(e);
      delete r.from;
      const i = li.from(r);
      return await n.broadcastTransaction(await this.signTransaction(i));
    }
    authorize(e) {
      me(false, "authorization not implemented for this signer", "UNSUPPORTED_OPERATION", {
        operation: "authorize"
      });
    }
  }
  function bF(t) {
    return JSON.parse(JSON.stringify(t));
  }
  class $4 {
    constructor(e) {
      __privateAdd(this, _$4_instances);
      __privateAdd(this, _e34);
      __privateAdd(this, _t20);
      __privateAdd(this, _n15);
      __privateAdd(this, _r11);
      __privateAdd(this, _i9);
      __privateAdd(this, _o6);
      __privateSet(this, _e34, e), __privateSet(this, _t20, null), __privateSet(this, _n15, __privateMethod(this, _$4_instances, s_fn3).bind(this)), __privateSet(this, _r11, false), __privateSet(this, _i9, null), __privateSet(this, _o6, false);
    }
    _subscribe(e) {
      throw new Error("subclasses must override this");
    }
    _emitResults(e, n) {
      throw new Error("subclasses must override this");
    }
    _recover(e) {
      throw new Error("subclasses must override this");
    }
    start() {
      __privateGet(this, _r11) || (__privateSet(this, _r11, true), __privateMethod(this, _$4_instances, s_fn3).call(this, -2));
    }
    stop() {
      __privateGet(this, _r11) && (__privateSet(this, _r11, false), __privateSet(this, _o6, true), __privateMethod(this, _$4_instances, a_fn2).call(this), __privateGet(this, _e34).off("block", __privateGet(this, _n15)));
    }
    pause(e) {
      e && __privateMethod(this, _$4_instances, a_fn2).call(this), __privateGet(this, _e34).off("block", __privateGet(this, _n15));
    }
    resume() {
      this.start();
    }
  }
  _e34 = new WeakMap();
  _t20 = new WeakMap();
  _n15 = new WeakMap();
  _r11 = new WeakMap();
  _i9 = new WeakMap();
  _o6 = new WeakMap();
  _$4_instances = new WeakSet();
  s_fn3 = async function(e) {
    try {
      __privateGet(this, _t20) == null && __privateSet(this, _t20, this._subscribe(__privateGet(this, _e34)));
      let n = null;
      try {
        n = await __privateGet(this, _t20);
      } catch (s) {
        if (!Un(s, "UNSUPPORTED_OPERATION") || s.operation !== "eth_newFilter") throw s;
      }
      if (n == null) {
        __privateSet(this, _t20, null), __privateGet(this, _e34)._recoverSubscriber(this, this._recover(__privateGet(this, _e34)));
        return;
      }
      const r = await __privateGet(this, _e34).getNetwork();
      if (__privateGet(this, _i9) || __privateSet(this, _i9, r), __privateGet(this, _i9).chainId !== r.chainId) throw new Error("chaid changed");
      if (__privateGet(this, _o6)) return;
      const i = await __privateGet(this, _e34).send("eth_getFilterChanges", [
        n
      ]);
      await this._emitResults(__privateGet(this, _e34), i);
    } catch (n) {
      console.log("@TODO", n);
    }
    __privateGet(this, _e34).once("block", __privateGet(this, _n15));
  };
  a_fn2 = function() {
    const e = __privateGet(this, _t20);
    e && (__privateSet(this, _t20, null), e.then((n) => {
      __privateGet(this, _e34).destroyed || __privateGet(this, _e34).send("eth_uninstallFilter", [
        n
      ]);
    }));
  };
  class xF extends $4 {
    constructor(e, n) {
      super(e);
      __privateAdd(this, _e35);
      __privateSet(this, _e35, bF(n));
    }
    _recover(e) {
      return new my(e, __privateGet(this, _e35));
    }
    async _subscribe(e) {
      return await e.send("eth_newFilter", [
        __privateGet(this, _e35)
      ]);
    }
    async _emitResults(e, n) {
      for (const r of n) e.emit(__privateGet(this, _e35), e._wrapLog(r, e._network));
    }
  }
  _e35 = new WeakMap();
  class AF extends $4 {
    async _subscribe(e) {
      return await e.send("eth_newPendingTransactionFilter", []);
    }
    async _emitResults(e, n) {
      for (const r of n) e.emit("pending", r);
    }
  }
  const wF = "bigint,boolean,function,number,string,symbol".split(/,/g);
  function y0(t) {
    if (t == null || wF.indexOf(typeof t) >= 0 || typeof t.getAddress == "function") return t;
    if (Array.isArray(t)) return t.map(y0);
    if (typeof t == "object") return Object.keys(t).reduce((e, n) => (e[n] = t[n], e), {});
    throw new Error(`should not happen: ${t} (${typeof t})`);
  }
  function vF(t) {
    return new Promise((e) => {
      setTimeout(e, t);
    });
  }
  function ec(t) {
    return t && t.toLowerCase();
  }
  function xA(t) {
    return t && typeof t.pollingInterval == "number";
  }
  const e5 = {
    polling: false,
    staticNetwork: null,
    batchStallTime: 10,
    batchMaxSize: 1 << 20,
    batchMaxCount: 100,
    cacheTimeout: 250,
    pollingInterval: 4e3
  };
  let Gp = class extends yF {
    constructor(e, n) {
      super(e);
      __publicField(this, "address");
      n = ht(n), Me(this, {
        address: n
      });
    }
    connect(e) {
      me(false, "cannot reconnect JsonRpcSigner", "UNSUPPORTED_OPERATION", {
        operation: "signer.connect"
      });
    }
    async getAddress() {
      return this.address;
    }
    async populateTransaction(e) {
      return await this.populateCall(e);
    }
    async sendUncheckedTransaction(e) {
      const n = y0(e), r = [];
      if (n.from) {
        const s = n.from;
        r.push((async () => {
          const o = await sr(s, this.provider);
          re(o != null && o.toLowerCase() === this.address.toLowerCase(), "from address mismatch", "transaction", e), n.from = o;
        })());
      } else n.from = this.address;
      if (n.gasLimit == null && r.push((async () => {
        n.gasLimit = await this.provider.estimateGas({
          ...n,
          from: this.address
        });
      })()), n.to != null) {
        const s = n.to;
        r.push((async () => {
          n.to = await sr(s, this.provider);
        })());
      }
      r.length && await Promise.all(r);
      const i = this.provider.getRpcTransaction(n);
      return this.provider.send("eth_sendTransaction", [
        i
      ]);
    }
    async sendTransaction(e) {
      const n = await this.provider.getBlockNumber(), r = await this.sendUncheckedTransaction(e);
      return await new Promise((i, s) => {
        const o = [
          1e3,
          100
        ];
        let a = 0;
        const c = async () => {
          try {
            const l = await this.provider.getTransaction(r);
            if (l != null) {
              i(l.replaceableTransaction(n));
              return;
            }
          } catch (l) {
            if (Un(l, "CANCELLED") || Un(l, "BAD_DATA") || Un(l, "NETWORK_ERROR") || Un(l, "UNSUPPORTED_OPERATION")) {
              l.info == null && (l.info = {}), l.info.sendTransactionHash = r, s(l);
              return;
            }
            if (Un(l, "INVALID_ARGUMENT") && (a++, l.info == null && (l.info = {}), l.info.sendTransactionHash = r, a > 10)) {
              s(l);
              return;
            }
            this.provider.emit("error", Qt("failed to fetch transation after sending (will try again)", "UNKNOWN_ERROR", {
              error: l
            }));
          }
          this.provider._setTimeout(() => {
            c();
          }, o.pop() || 4e3);
        };
        c();
      });
    }
    async signTransaction(e) {
      const n = y0(e);
      if (n.from) {
        const i = await sr(n.from, this.provider);
        re(i != null && i.toLowerCase() === this.address.toLowerCase(), "from address mismatch", "transaction", e), n.from = i;
      } else n.from = this.address;
      const r = this.provider.getRpcTransaction(n);
      return await this.provider.send("eth_signTransaction", [
        r
      ]);
    }
    async signMessage(e) {
      const n = typeof e == "string" ? Jr(e) : e;
      return await this.provider.send("personal_sign", [
        Se(n),
        this.address.toLowerCase()
      ]);
    }
    async signTypedData(e, n, r) {
      const i = y0(r), s = await W2.resolveNames(e, n, i, async (o) => {
        const a = await sr(o);
        return re(a != null, "TypedData does not support null address", "value", o), a;
      });
      return await this.provider.send("eth_signTypedData_v4", [
        this.address.toLowerCase(),
        JSON.stringify(W2.getPayload(s.domain, n, s.value))
      ]);
    }
    async unlock(e) {
      return this.provider.send("personal_unlockAccount", [
        this.address.toLowerCase(),
        e,
        null
      ]);
    }
    async _legacySignMessage(e) {
      const n = typeof e == "string" ? Jr(e) : e;
      return await this.provider.send("eth_sign", [
        this.address.toLowerCase(),
        Se(n)
      ]);
    }
  };
  class EF extends fF {
    constructor(e, n) {
      super(e, n);
      __privateAdd(this, _EF_instances);
      __privateAdd(this, _e36);
      __privateAdd(this, _t21);
      __privateAdd(this, _n16);
      __privateAdd(this, _r12);
      __privateAdd(this, _i10);
      __privateAdd(this, _o7);
      __privateAdd(this, _s5);
      __privateSet(this, _t21, 1), __privateSet(this, _e36, Object.assign({}, e5, n || {})), __privateSet(this, _n16, []), __privateSet(this, _r12, null), __privateSet(this, _o7, null), __privateSet(this, _s5, null);
      {
        let i = null;
        const s = new Promise((o) => {
          i = o;
        });
        __privateSet(this, _i10, {
          promise: s,
          resolve: i
        });
      }
      const r = this._getOption("staticNetwork");
      typeof r == "boolean" ? (re(!r || e !== "any", "staticNetwork cannot be used on special network 'any'", "options", n), r && e != null && __privateSet(this, _o7, Pr.from(e))) : r && (re(e == null || r.matches(e), "staticNetwork MUST match network object", "options", n), __privateSet(this, _o7, r));
    }
    _getOption(e) {
      return __privateGet(this, _e36)[e];
    }
    get _network() {
      return me(__privateGet(this, _o7), "network is not available yet", "NETWORK_ERROR"), __privateGet(this, _o7);
    }
    async _perform(e) {
      if (e.method === "call" || e.method === "estimateGas") {
        let r = e.transaction;
        if (r && r.type != null && Pe(r.type) && r.maxFeePerGas == null && r.maxPriorityFeePerGas == null) {
          const i = await this.getFeeData();
          i.maxFeePerGas == null && i.maxPriorityFeePerGas == null && (e = Object.assign({}, e, {
            transaction: Object.assign({}, r, {
              type: void 0
            })
          }));
        }
      }
      const n = this.getRpcRequest(e);
      return n != null ? await this.send(n.method, n.args) : super._perform(e);
    }
    async _detectNetwork() {
      const e = this._getOption("staticNetwork");
      if (e) if (e === true) {
        if (__privateGet(this, _o7)) return __privateGet(this, _o7);
      } else return e;
      return __privateGet(this, _s5) ? await __privateGet(this, _s5) : this.ready ? (__privateSet(this, _s5, (async () => {
        try {
          const n = Pr.from(Pe(await this.send("eth_chainId", [])));
          return __privateSet(this, _s5, null), n;
        } catch (n) {
          throw __privateSet(this, _s5, null), n;
        }
      })()), await __privateGet(this, _s5)) : (__privateSet(this, _s5, (async () => {
        const n = {
          id: __privateWrapper(this, _t21)._++,
          method: "eth_chainId",
          params: [],
          jsonrpc: "2.0"
        };
        this.emit("debug", {
          action: "sendRpcPayload",
          payload: n
        });
        let r;
        try {
          r = (await this._send(n))[0], __privateSet(this, _s5, null);
        } catch (i) {
          throw __privateSet(this, _s5, null), this.emit("debug", {
            action: "receiveRpcError",
            error: i
          }), i;
        }
        if (this.emit("debug", {
          action: "receiveRpcResult",
          result: r
        }), "result" in r) return Pr.from(Pe(r.result));
        throw this.getRpcError(n, r);
      })()), await __privateGet(this, _s5));
    }
    _start() {
      __privateGet(this, _i10) == null || __privateGet(this, _i10).resolve == null || (__privateGet(this, _i10).resolve(), __privateSet(this, _i10, null), (async () => {
        for (; __privateGet(this, _o7) == null && !this.destroyed; ) try {
          __privateSet(this, _o7, await this._detectNetwork());
        } catch (e) {
          if (this.destroyed) break;
          console.log("JsonRpcProvider failed to detect network and cannot start up; retry in 1s (perhaps the URL is wrong or the node is not started)"), this.emit("error", Qt("failed to bootstrap network detection", "NETWORK_ERROR", {
            event: "initial-network-discovery",
            info: {
              error: e
            }
          })), await vF(1e3);
        }
        __privateMethod(this, _EF_instances, a_fn3).call(this);
      })());
    }
    async _waitUntilReady() {
      if (__privateGet(this, _i10) != null) return await __privateGet(this, _i10).promise;
    }
    _getSubscriber(e) {
      return e.type === "pending" ? new AF(this) : e.type === "event" ? this._getOption("polling") ? new my(this, e.filter) : new xF(this, e.filter) : e.type === "orphan" && e.filter.orphan === "drop-log" ? new Z4("orphan") : super._getSubscriber(e);
    }
    get ready() {
      return __privateGet(this, _i10) == null;
    }
    getRpcTransaction(e) {
      const n = {};
      return [
        "chainId",
        "gasLimit",
        "gasPrice",
        "type",
        "maxFeePerGas",
        "maxPriorityFeePerGas",
        "nonce",
        "value"
      ].forEach((r) => {
        if (e[r] == null) return;
        let i = r;
        r === "gasLimit" && (i = "gas"), n[i] = di(Pe(e[r], `tx.${r}`));
      }), [
        "from",
        "to",
        "data"
      ].forEach((r) => {
        e[r] != null && (n[r] = Se(e[r]));
      }), e.accessList && (n.accessList = Ua(e.accessList)), e.blobVersionedHashes && (n.blobVersionedHashes = e.blobVersionedHashes.map((r) => r.toLowerCase())), e.authorizationList && (n.authorizationList = e.authorizationList.map((r) => {
        const i = s4(r);
        return {
          address: i.address,
          nonce: di(i.nonce),
          chainId: di(i.chainId),
          yParity: di(i.signature.yParity),
          r: di(i.signature.r),
          s: di(i.signature.s)
        };
      })), n;
    }
    getRpcRequest(e) {
      switch (e.method) {
        case "chainId":
          return {
            method: "eth_chainId",
            args: []
          };
        case "getBlockNumber":
          return {
            method: "eth_blockNumber",
            args: []
          };
        case "getGasPrice":
          return {
            method: "eth_gasPrice",
            args: []
          };
        case "getPriorityFee":
          return {
            method: "eth_maxPriorityFeePerGas",
            args: []
          };
        case "getBalance":
          return {
            method: "eth_getBalance",
            args: [
              ec(e.address),
              e.blockTag
            ]
          };
        case "getTransactionCount":
          return {
            method: "eth_getTransactionCount",
            args: [
              ec(e.address),
              e.blockTag
            ]
          };
        case "getCode":
          return {
            method: "eth_getCode",
            args: [
              ec(e.address),
              e.blockTag
            ]
          };
        case "getStorage":
          return {
            method: "eth_getStorageAt",
            args: [
              ec(e.address),
              "0x" + e.position.toString(16),
              e.blockTag
            ]
          };
        case "broadcastTransaction":
          return {
            method: "eth_sendRawTransaction",
            args: [
              e.signedTransaction
            ]
          };
        case "getBlock":
          if ("blockTag" in e) return {
            method: "eth_getBlockByNumber",
            args: [
              e.blockTag,
              !!e.includeTransactions
            ]
          };
          if ("blockHash" in e) return {
            method: "eth_getBlockByHash",
            args: [
              e.blockHash,
              !!e.includeTransactions
            ]
          };
          break;
        case "getTransaction":
          return {
            method: "eth_getTransactionByHash",
            args: [
              e.hash
            ]
          };
        case "getTransactionReceipt":
          return {
            method: "eth_getTransactionReceipt",
            args: [
              e.hash
            ]
          };
        case "call":
          return {
            method: "eth_call",
            args: [
              this.getRpcTransaction(e.transaction),
              e.blockTag
            ]
          };
        case "estimateGas":
          return {
            method: "eth_estimateGas",
            args: [
              this.getRpcTransaction(e.transaction)
            ]
          };
        case "getLogs":
          return e.filter && e.filter.address != null && (Array.isArray(e.filter.address) ? e.filter.address = e.filter.address.map(ec) : e.filter.address = ec(e.filter.address)), {
            method: "eth_getLogs",
            args: [
              e.filter
            ]
          };
      }
      return null;
    }
    getRpcError(e, n) {
      const { method: r } = e, { error: i } = n;
      if (r === "eth_estimateGas" && i.message) {
        const a = i.message;
        if (!a.match(/revert/i) && a.match(/insufficient funds/i)) return Qt("insufficient funds", "INSUFFICIENT_FUNDS", {
          transaction: e.params[0],
          info: {
            payload: e,
            error: i
          }
        });
        if (a.match(/nonce/i) && a.match(/too low/i)) return Qt("nonce has already been used", "NONCE_EXPIRED", {
          transaction: e.params[0],
          info: {
            payload: e,
            error: i
          }
        });
      }
      if (r === "eth_call" || r === "eth_estimateGas") {
        const a = Nm(i), c = Sm.getBuiltinCallException(r === "eth_call" ? "call" : "estimateGas", e.params[0], a ? a.data : null);
        return c.info = {
          error: i,
          payload: e
        }, c;
      }
      const s = JSON.stringify(TF(i));
      if (typeof i.message == "string" && i.message.match(/user denied|ethers-user-denied/i)) return Qt("user rejected action", "ACTION_REJECTED", {
        action: {
          eth_sign: "signMessage",
          personal_sign: "signMessage",
          eth_signTypedData_v4: "signTypedData",
          eth_signTransaction: "signTransaction",
          eth_sendTransaction: "sendTransaction",
          eth_requestAccounts: "requestAccess",
          wallet_requestAccounts: "requestAccess"
        }[r] || "unknown",
        reason: "rejected",
        info: {
          payload: e,
          error: i
        }
      });
      if (r === "eth_sendRawTransaction" || r === "eth_sendTransaction") {
        const a = e.params[0];
        if (s.match(/insufficient funds|base fee exceeds gas limit/i)) return Qt("insufficient funds for intrinsic transaction cost", "INSUFFICIENT_FUNDS", {
          transaction: a,
          info: {
            error: i
          }
        });
        if (s.match(/nonce/i) && s.match(/too low/i)) return Qt("nonce has already been used", "NONCE_EXPIRED", {
          transaction: a,
          info: {
            error: i
          }
        });
        if (s.match(/replacement transaction/i) && s.match(/underpriced/i)) return Qt("replacement fee too low", "REPLACEMENT_UNDERPRICED", {
          transaction: a,
          info: {
            error: i
          }
        });
        if (s.match(/only replay-protected/i)) return Qt("legacy pre-eip-155 transactions not supported", "UNSUPPORTED_OPERATION", {
          operation: r,
          info: {
            transaction: a,
            info: {
              error: i
            }
          }
        });
      }
      let o = !!s.match(/the method .* does not exist/i);
      return o || i && i.details && i.details.startsWith("Unauthorized method:") && (o = true), o ? Qt("unsupported operation", "UNSUPPORTED_OPERATION", {
        operation: e.method,
        info: {
          error: i,
          payload: e
        }
      }) : Qt("could not coalesce error", "UNKNOWN_ERROR", {
        error: i,
        payload: e
      });
    }
    send(e, n) {
      if (this.destroyed) return Promise.reject(Qt("provider destroyed; cancelled request", "UNSUPPORTED_OPERATION", {
        operation: e
      }));
      const r = __privateWrapper(this, _t21)._++, i = new Promise((s, o) => {
        __privateGet(this, _n16).push({
          resolve: s,
          reject: o,
          payload: {
            method: e,
            params: n,
            id: r,
            jsonrpc: "2.0"
          }
        });
      });
      return __privateMethod(this, _EF_instances, a_fn3).call(this), i;
    }
    async getSigner(e) {
      e == null && (e = 0);
      const n = this.send("eth_accounts", []);
      if (typeof e == "number") {
        const i = await n;
        if (e >= i.length) throw new Error("no such account");
        return new Gp(this, i[e]);
      }
      const { accounts: r } = await $n({
        network: this.getNetwork(),
        accounts: n
      });
      e = ht(e);
      for (const i of r) if (ht(i) === e) return new Gp(this, e);
      throw new Error("invalid account");
    }
    async listAccounts() {
      return (await this.send("eth_accounts", [])).map((n) => new Gp(this, n));
    }
    destroy() {
      __privateGet(this, _r12) && (clearTimeout(__privateGet(this, _r12)), __privateSet(this, _r12, null));
      for (const { payload: e, reject: n } of __privateGet(this, _n16)) n(Qt("provider destroyed; cancelled request", "UNSUPPORTED_OPERATION", {
        operation: e.method
      }));
      __privateSet(this, _n16, []), super.destroy();
    }
  }
  _e36 = new WeakMap();
  _t21 = new WeakMap();
  _n16 = new WeakMap();
  _r12 = new WeakMap();
  _i10 = new WeakMap();
  _o7 = new WeakMap();
  _s5 = new WeakMap();
  _EF_instances = new WeakSet();
  a_fn3 = function() {
    if (__privateGet(this, _r12)) return;
    const e = this._getOption("batchMaxCount") === 1 ? 0 : this._getOption("batchStallTime");
    __privateSet(this, _r12, setTimeout(() => {
      __privateSet(this, _r12, null);
      const n = __privateGet(this, _n16);
      for (__privateSet(this, _n16, []); n.length; ) {
        const r = [
          n.shift()
        ];
        for (; n.length && r.length !== __privateGet(this, _e36).batchMaxCount; ) if (r.push(n.shift()), JSON.stringify(r.map((s) => s.payload)).length > __privateGet(this, _e36).batchMaxSize) {
          n.unshift(r.pop());
          break;
        }
        (async () => {
          const i = r.length === 1 ? r[0].payload : r.map((s) => s.payload);
          this.emit("debug", {
            action: "sendRpcPayload",
            payload: i
          });
          try {
            const s = await this._send(i);
            this.emit("debug", {
              action: "receiveRpcResult",
              result: s
            });
            for (const { resolve: o, reject: a, payload: c } of r) {
              if (this.destroyed) {
                a(Qt("provider destroyed; cancelled request", "UNSUPPORTED_OPERATION", {
                  operation: c.method
                }));
                continue;
              }
              const l = s.filter((u) => u.id === c.id)[0];
              if (l == null) {
                const u = Qt("missing response for request", "BAD_DATA", {
                  value: s,
                  info: {
                    payload: c
                  }
                });
                this.emit("error", u), a(u);
                continue;
              }
              if ("error" in l) {
                a(this.getRpcError(c, l));
                continue;
              }
              o(l.result);
            }
          } catch (s) {
            this.emit("debug", {
              action: "receiveRpcError",
              error: s
            });
            for (const { reject: o } of r) o(s);
          }
        })();
      }
    }, e));
  };
  class SF extends EF {
    constructor(e, n) {
      super(e, n);
      __privateAdd(this, _e37);
      let r = this._getOption("pollingInterval");
      r == null && (r = e5.pollingInterval), __privateSet(this, _e37, r);
    }
    _getSubscriber(e) {
      const n = super._getSubscriber(e);
      return xA(n) && (n.pollingInterval = __privateGet(this, _e37)), n;
    }
    get pollingInterval() {
      return __privateGet(this, _e37);
    }
    set pollingInterval(e) {
      if (!Number.isInteger(e) || e < 0) throw new Error("invalid interval");
      __privateSet(this, _e37, e), this._forEachSubscriber((n) => {
        xA(n) && (n.pollingInterval = __privateGet(this, _e37));
      });
    }
  }
  _e37 = new WeakMap();
  function Nm(t) {
    if (t == null) return null;
    if (typeof t.message == "string" && t.message.match(/revert/i) && vt(t.data)) return {
      message: t.message,
      data: t.data
    };
    if (typeof t == "object") {
      for (const e in t) {
        const n = Nm(t[e]);
        if (n) return n;
      }
      return null;
    }
    if (typeof t == "string") try {
      return Nm(JSON.parse(t));
    } catch {
    }
    return null;
  }
  function Om(t, e) {
    if (t != null) {
      if (typeof t.message == "string" && e.push(t.message), typeof t == "object") for (const n in t) Om(t[n], e);
      if (typeof t == "string") try {
        return Om(JSON.parse(t), e);
      } catch {
      }
    }
  }
  function TF(t) {
    const e = [];
    return Om(t, e), e;
  }
  const _yo = class _yo extends SF {
    constructor(e, n, r) {
      const i = Object.assign({}, r ?? {}, {
        batchMaxCount: 1
      });
      re(e && e.request, "invalid EIP-1193 provider", "ethereum", e);
      super(n, i);
      __privateAdd(this, _e38);
      __privateAdd(this, _t22);
      __privateSet(this, _t22, null), r && r.providerInfo && __privateSet(this, _t22, r.providerInfo), __privateSet(this, _e38, async (s, o) => {
        const a = {
          method: s,
          params: o
        };
        this.emit("debug", {
          action: "sendEip1193Request",
          payload: a
        });
        try {
          const c = await e.request(a);
          return this.emit("debug", {
            action: "receiveEip1193Result",
            result: c
          }), c;
        } catch (c) {
          const l = new Error(c.message);
          throw l.code = c.code, l.data = c.data, l.payload = a, this.emit("debug", {
            action: "receiveEip1193Error",
            error: l
          }), l;
        }
      });
    }
    get providerInfo() {
      return __privateGet(this, _t22);
    }
    async send(e, n) {
      return await this._start(), await super.send(e, n);
    }
    async _send(e) {
      re(!Array.isArray(e), "EIP-1193 does not support batch request", "payload", e);
      try {
        const n = await __privateGet(this, _e38).call(this, e.method, e.params || []);
        return [
          {
            id: e.id,
            result: n
          }
        ];
      } catch (n) {
        return [
          {
            id: e.id,
            error: {
              code: n.code,
              data: n.data,
              message: n.message
            }
          }
        ];
      }
    }
    getRpcError(e, n) {
      switch (n = JSON.parse(JSON.stringify(n)), n.error.code || -1) {
        case 4001:
          n.error.message = `ethers-user-denied: ${n.error.message}`;
          break;
        case 4200:
          n.error.message = `ethers-unsupported: ${n.error.message}`;
          break;
      }
      return super.getRpcError(e, n);
    }
    async hasSigner(e) {
      e == null && (e = 0);
      const n = await this.send("eth_accounts", []);
      return typeof e == "number" ? n.length > e : (e = e.toLowerCase(), n.filter((r) => r.toLowerCase() === e).length !== 0);
    }
    async getSigner(e) {
      if (e == null && (e = 0), !await this.hasSigner(e)) try {
        await __privateGet(this, _e38).call(this, "eth_requestAccounts", []);
      } catch (n) {
        const r = n.payload;
        throw this.getRpcError(r, {
          id: r.id,
          error: n
        });
      }
      return await super.getSigner(e);
    }
    static async discover(e) {
      if (e == null && (e = {}), e.provider) return new _yo(e.provider);
      const n = e.window ? e.window : typeof window < "u" ? window : null;
      if (n == null) return null;
      const r = e.anyProvider;
      if (r && n.ethereum) return new _yo(n.ethereum);
      if (!("addEventListener" in n && "dispatchEvent" in n && "removeEventListener" in n)) return null;
      const i = e.timeout ? e.timeout : 300;
      return i === 0 ? null : await new Promise((s, o) => {
        let a = [];
        const c = (f) => {
          a.push(f.detail), r && l();
        }, l = () => {
          if (clearTimeout(u), a.length) if (e && e.filter) {
            const f = e.filter(a.map((d) => Object.assign({}, d.info)));
            if (f == null) s(null);
            else if (f instanceof _yo) s(f);
            else {
              let d = null;
              if (f.uuid && (d = a.filter((y) => f.uuid === y.info.uuid)[0]), d) {
                const { provider: m, info: y } = d;
                s(new _yo(m, void 0, {
                  providerInfo: y
                }));
              } else o(Qt("filter returned unknown info", "UNSUPPORTED_OPERATION", {
                value: f
              }));
            }
          } else {
            const { provider: f, info: d } = a[0];
            s(new _yo(f, void 0, {
              providerInfo: d
            }));
          }
          else s(null);
          n.removeEventListener("eip6963:announceProvider", c);
        }, u = setTimeout(() => {
          l();
        }, i);
        n.addEventListener("eip6963:announceProvider", c), n.dispatchEvent(new Event("eip6963:requestProvider"));
      });
    }
  };
  _e38 = new WeakMap();
  _t22 = new WeakMap();
  let yo = _yo;
  let CF, IF, PF, _F, RF, NF, n5, OF;
  t5 = (t) => {
    var _a6;
    try {
      const { t: e } = uf.global;
      t = JSON.parse(JSON.stringify(t)).reason || ((_a6 = JSON.parse(JSON.stringify(t))) == null ? void 0 : _a6.message) || t || "error";
      const n = t.lastIndexOf(":");
      let r = t.substring(n + 1, t.length);
      r = r.replace(" ", "").replace(/(.*)\./, "$1"), t = e(`errorMsg.${r}`).indexOf("errorMsg.") !== -1 ? r : e(`errorMsg.${r}`), Kc(t);
    } finally {
      console.error(t);
    }
  };
  CF = {
    env: "development",
    baseUrl: "https://fm-test-api-lightsail.metabills.finance",
    imgUrl: "",
    provider: "https://data-seed-prebsc-1-s2.bnbchain.org:8545",
    ethChainNumberId: 97,
    chainConfig: {
      chainId: "0x61",
      chainName: "BNB Smart Chain Testnet",
      rpcUrls: [
        "https://data-seed-prebsc-1-s2.bnbchain.org:8545"
      ],
      nativeCurrency: {
        name: "tBNB",
        symbol: "tBNB",
        decimals: 18
      },
      blockExplorerUrls: [
        "https://testnet.bscscan.com"
      ]
    },
    datePeriod: 60,
    beiDatePeriod: 86400,
    BNB: "0x094616F0BdFB0b526bD735Bf66Eca0Ad254ca81F",
    USDT: "0x56BB60cf0B3E21003097F1c348FFc4f58f42Ec04",
    MAI: "0xC42F240C256F5FB97346b9d69d10E2e1D77b2EBa",
    MUSD: "0x755e19FF2945572993dedef5A8C96C4cE73349E4",
    MCOIN: "0xb09053a2bB04bF463CBf18eddc60c30E8d5f0869",
    WMAI: "0xA6d25E813f821ed854ABc776f694ee6EBA1E901E",
    FMCP: "0xD5116405dA98490520cD7e54FeE47c80250B71e4",
    flashMall: "0x382Dca6Ab0eed3C0cE5e01423331221aaA190AAD",
    order: "0xc911B2AE1043abFE2735A284EA1baa287dc3b326",
    swapPool: "0x492c31646a3ff2b65e34435169e8f25227EDcdaC",
    lendingPool: "0x666b5914b24Df348399D8B3D7fAd6032A2a377bB",
    maiExchange: "0x5dceDa97Cc7e66CC22180ce137890c92Cb30EBa6",
    otcOld: "0x0858f11B8Be3387D7fD1F3056A718e97Cc9E6d02",
    otc: "0x0fdb71896dcd14296Cfdc3C8e1bbDfE4C8a11429",
    matrix: "0x1f7aF457a2ECFc472AFa722EF1A20178271A6223",
    gold: "0x11562F76a579b1B52b0481c5c19D9902491FE41a",
    activity: "0x013cf205b8384A6338935710a91BEfe3FCB08437",
    luckyShop: "0x07E318d72bE172A8A8EC839b1316Aa581609427F",
    otcAgent: "0x1F7E069Aa7E8FF1c6EF5D26711A9fC54C7bd04D3",
    otcAgentFreeFee: "0xA72b566c58Bc5C0FC8D1CB426C02A4FBA845F424",
    piggyBank: "0x853aB2a0E5cAfEdfa1A9fc8df3154cBE9213136C",
    storedValue: "0x6c7FE425A50F776971893e25c74b4a3f07071290",
    storedValueProportion: 0.8,
    bei: "0x52e508BBf5469804fE45c24C97288C0773d28cAb",
    LP: "0xA80321257f43c3652b074e552a76579D66Ef71bf",
    loan: "0xB71eb924AfBbbA8ED658D23389ff936280c6564F",
    voucherGrow: "0x9f102475944559f2d89b683f8e4b9bb0bbaf3eda1247d0fe4acc2900fb369725",
    voucherBack: "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef"
  };
  IF = Object.freeze(Object.defineProperty({
    __proto__: null,
    default: CF
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  PF = {
    env: "production",
    baseUrl: "https://fmprodapi8.flashmall.app",
    imgUrl: "",
    provider: "https://bsc-dataseed1.ninicoin.io",
    ethChainNumberId: 56,
    chainConfig: {
      chainId: "0x38",
      chainName: "BSC Main",
      rpcUrls: [
        "https://bsc-dataseed1.binance.org/"
      ],
      nativeCurrency: {
        name: "BNB",
        symbol: "BNB",
        decimals: 18
      },
      blockExplorerUrls: [
        "https://bscscan.com/"
      ]
    },
    datePeriod: 86400,
    beiDatePeriod: 86400,
    BNB: "0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c",
    USDT: "0x55d398326f99059fF775485246999027B3197955",
    MAI: "0x35803e77c3163FEd8A942536C1c8e0d5bF90f906",
    MUSD: "0x22a2C54b15287472F4aDBe7587226E3c998CdD96",
    MCOIN: "0x826923122A8521Be36358Bdc53d3B4362B6f46E5",
    WMAI: "0x1B282603099647E2Ec3461B2714ACf38009D66b6",
    FMCP: "0xe9aCD9896DD9F4a0F5B93C53fE61f1cE1F0464Bb",
    LP: "0x583788e138DEB72D674c96DD220566e28355b569",
    flashMall: "0x1f40465Dce9a07A5273b4b63F5f9C31ff2bcBD9a",
    order: "0xF04b637966926c757ca4cA9D602814B8ed7BD873",
    swapPool: "0x71fa9ccd90af89D9D87bfD4D01BF263DFC70580C",
    lendingPool: "0xa6433855524027709FDfCA15937d9443d7989928",
    maiExchange: "0x0663C4b19D139b9582539f6053a9C69a2bCEBC9f",
    otcOld: "0x89ffE796c387F41354e97aF91f563798Db847aA3",
    otc: "0x54B04768a7f0a9cB797e4Ee1b33403488cE81B34",
    matrix: "0xB6D2B04befd1475975c3608ed839fBf26E45d6f4",
    gold: "0xDCe13DBA9C3F8A789D39dC5944709735C139A73c",
    activity: "0xe9Fa67363b56d2167C13f9BAF042B975539B47f5",
    luckyShop: "0xfcaEeE3B7E7318E31C94818F928Bac378D13f6c5",
    otcAgent: "0x97aC2A1d0bcD6AAC0Fa0a98C710F2cf9149c53b1",
    otcAgentFreeFee: "0xBEC9F485060652f3482D0ecb2FF2568Cf8b8d2c6",
    piggyBank: "0xE2abeebEc12e82De4432dA0A2045391242Bd1684",
    storedValue: "0x58165f52D47e320D25759D6fbb46D43a7E2A0F4e",
    storedValueProportion: 0.8,
    bei: "0x12F2fBC79A16337043E2597f8F086A42F987af1F",
    loan: "0x98456b6ed30cE03904F8424F304164dbBb3C1E2f",
    voucherGrow: "0x9f102475944559f2d89b683f8e4b9bb0bbaf3eda1247d0fe4acc2900fb369725",
    voucherBack: "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef"
  };
  _F = Object.freeze(Object.defineProperty({
    __proto__: null,
    default: PF
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  RF = {
    env: "development",
    baseUrl: "https://fmprodapi.flashmall.app/",
    imgUrl: "",
    provider: "https://data-seed-prebsc-1-s2.bnbchain.org:8545",
    ethChainNumberId: 97,
    chainConfig: {
      chainId: "0x61",
      chainName: "BNB Smart Chain Testnet",
      rpcUrls: [
        "https://data-seed-prebsc-1-s2.bnbchain.org:8545"
      ],
      nativeCurrency: {
        name: "tBNB",
        symbol: "tBNB",
        decimals: 18
      },
      blockExplorerUrls: [
        "https://testnet.bscscan.com"
      ]
    },
    datePeriod: 60,
    beiDatePeriod: 86400,
    BNB: "0x094616F0BdFB0b526bD735Bf66Eca0Ad254ca81F",
    USDT: "0x56BB60cf0B3E21003097F1c348FFc4f58f42Ec04",
    MAI: "0xC42F240C256F5FB97346b9d69d10E2e1D77b2EBa",
    MUSD: "0x755e19FF2945572993dedef5A8C96C4cE73349E4",
    MCOIN: "0xb09053a2bB04bF463CBf18eddc60c30E8d5f0869",
    WMAI: "0xA6d25E813f821ed854ABc776f694ee6EBA1E901E",
    FMCP: "0xD5116405dA98490520cD7e54FeE47c80250B71e4",
    flashMall: "0x382Dca6Ab0eed3C0cE5e01423331221aaA190AAD",
    order: "0xc911B2AE1043abFE2735A284EA1baa287dc3b326",
    swapPool: "0x492c31646a3ff2b65e34435169e8f25227EDcdaC",
    lendingPool: "0x666b5914b24Df348399D8B3D7fAd6032A2a377bB",
    maiExchange: "0x5dceDa97Cc7e66CC22180ce137890c92Cb30EBa6",
    otcOld: "0x0858f11B8Be3387D7fD1F3056A718e97Cc9E6d02",
    otc: "0x0fdb71896dcd14296Cfdc3C8e1bbDfE4C8a11429",
    matrix: "0x1f7aF457a2ECFc472AFa722EF1A20178271A6223",
    gold: "0x11562F76a579b1B52b0481c5c19D9902491FE41a",
    activity: "0x013cf205b8384A6338935710a91BEfe3FCB08437",
    luckyShop: "0x07E318d72bE172A8A8EC839b1316Aa581609427F",
    otcAgent: "0x1F7E069Aa7E8FF1c6EF5D26711A9fC54C7bd04D3",
    otcAgentFreeFee: "0xA72b566c58Bc5C0FC8D1CB426C02A4FBA845F424",
    piggyBank: "0x853aB2a0E5cAfEdfa1A9fc8df3154cBE9213136C",
    storedValue: "0x6c7FE425A50F776971893e25c74b4a3f07071290",
    storedValueProportion: 0.8,
    bei: "0x52e508BBf5469804fE45c24C97288C0773d28cAb",
    LP: "0xA80321257f43c3652b074e552a76579D66Ef71bf",
    loan: "0xB71eb924AfBbbA8ED658D23389ff936280c6564F",
    voucherGrow: "0x9f102475944559f2d89b683f8e4b9bb0bbaf3eda1247d0fe4acc2900fb369725",
    voucherBack: "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef"
  };
  NF = Object.freeze(Object.defineProperty({
    __proto__: null,
    default: RF
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  n5 = {};
  OF = Object.assign({
    "./env.development.ts": IF,
    "./env.prod.ts": _F,
    "./env.test.ts": NF
  });
  Object.entries(OF).forEach(([t, e]) => {
    const n = t.replace(/\.\/env\.(.*)\.ts$/, "$1");
    n5[n] = e;
  });
  let BF, MF;
  ts = n5.development.default;
  BF = new k1(10);
  MF = (t, e = 18) => new k1(t).dividedBy(BF.pow(e));
  vq = (t, e = 18) => MF(t, e).toNumber();
  Eq = (t) => cO(t);
  Sq = function(t, e = 18) {
    return typeof t == "number" && (t = t + ""), EE(t, e);
  };
  const _Tc = class _Tc {
    constructor() {
      __publicField(this, "provider", null);
    }
    static getInstance() {
      return _Tc.instance || (_Tc.instance = new _Tc()), _Tc.instance;
    }
    getProvider() {
      return this.provider ? this.provider : (typeof window < "u" && window.ethereum && (this.provider = new yo(window.ethereum)), this.provider);
    }
    clearProvider() {
      this.provider = null;
    }
  };
  __publicField(_Tc, "instance");
  let Tc = _Tc;
  const yy = () => Tc.getInstance().getProvider();
  var Cr = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
  function Js(t) {
    return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
  }
  function sn(t) {
    if (t.__esModule) return t;
    var e = t.default;
    if (typeof e == "function") {
      var n = function r() {
        return this instanceof r ? Reflect.construct(e, arguments, this.constructor) : e.apply(this, arguments);
      };
      n.prototype = e.prototype;
    } else n = {};
    return Object.defineProperty(n, "__esModule", {
      value: true
    }), Object.keys(t).forEach(function(r) {
      var i = Object.getOwnPropertyDescriptor(t, r);
      Object.defineProperty(n, r, i.get ? i : {
        enumerable: true,
        get: function() {
          return t[r];
        }
      });
    }), n;
  }
  var r5 = by;
  function by(t) {
    Mi.length || nd(), Mi[Mi.length] = t;
  }
  var Mi = [], nd, Pi = 0, kF = 1024;
  function AA() {
    for (; Pi < Mi.length; ) {
      var t = Pi;
      if (Pi = Pi + 1, Mi[t].call(), Pi > kF) {
        for (var e = 0, n = Mi.length - Pi; e < n; e++) Mi[e] = Mi[e + Pi];
        Mi.length -= Pi, Pi = 0;
      }
    }
    Mi.length = 0, Pi = 0;
  }
  var wA = typeof Cr < "u" ? Cr : self, i5 = wA.MutationObserver || wA.WebKitMutationObserver;
  typeof i5 == "function" ? nd = FF(AA) : nd = s5(AA);
  by.requestFlush = nd;
  function FF(t) {
    var e = 1, n = new i5(t), r = document.createTextNode("");
    return n.observe(r, {
      characterData: true
    }), function() {
      e = -e, r.data = e;
    };
  }
  function s5(t) {
    return function() {
      var n = setTimeout(i, 0), r = setInterval(i, 50);
      function i() {
        clearTimeout(n), clearInterval(r), t();
      }
    };
  }
  by.makeRequestCallFromTimer = s5;
  var LF = r5;
  function sh() {
  }
  var wl = null, vl = {};
  function DF(t) {
    try {
      return t.then;
    } catch (e) {
      return wl = e, vl;
    }
  }
  function UF(t, e) {
    try {
      return t(e);
    } catch (n) {
      return wl = n, vl;
    }
  }
  function HF(t, e, n) {
    try {
      t(e, n);
    } catch (r) {
      return wl = r, vl;
    }
  }
  var El = _r;
  function _r(t) {
    if (typeof this != "object") throw new TypeError("Promises must be constructed via new");
    if (typeof t != "function") throw new TypeError("Promise constructor's argument is not a function");
    this._x = 0, this._y = 0, this._z = null, this._A = null, t !== sh && a5(t, this);
  }
  _r._B = null;
  _r._C = null;
  _r._D = sh;
  _r.prototype.then = function(t, e) {
    if (this.constructor !== _r) return GF(this, t, e);
    var n = new _r(sh);
    return rd(this, new o5(t, e, n)), n;
  };
  function GF(t, e, n) {
    return new t.constructor(function(r, i) {
      var s = new _r(sh);
      s.then(r, i), rd(t, new o5(e, n, s));
    });
  }
  function rd(t, e) {
    for (; t._y === 3; ) t = t._z;
    if (_r._B && _r._B(t), t._y === 0) {
      if (t._x === 0) {
        t._x = 1, t._A = e;
        return;
      }
      if (t._x === 1) {
        t._x = 2, t._A = [
          t._A,
          e
        ];
        return;
      }
      t._A.push(e);
      return;
    }
    VF(t, e);
  }
  function VF(t, e) {
    LF(function() {
      var n = t._y === 1 ? e.onFulfilled : e.onRejected;
      if (n === null) {
        t._y === 1 ? Bm(e.promise, t._z) : ol(e.promise, t._z);
        return;
      }
      var r = UF(n, t._z);
      r === vl ? ol(e.promise, wl) : Bm(e.promise, r);
    });
  }
  function Bm(t, e) {
    if (e === t) return ol(t, new TypeError("A promise cannot be resolved with itself."));
    if (e && (typeof e == "object" || typeof e == "function")) {
      var n = DF(e);
      if (n === vl) return ol(t, wl);
      if (n === t.then && e instanceof _r) {
        t._y = 3, t._z = e, Mm(t);
        return;
      } else if (typeof n == "function") {
        a5(n.bind(e), t);
        return;
      }
    }
    t._y = 1, t._z = e, Mm(t);
  }
  function ol(t, e) {
    t._y = 2, t._z = e, _r._C && _r._C(t, e), Mm(t);
  }
  function Mm(t) {
    if (t._x === 1 && (rd(t, t._A), t._A = null), t._x === 2) {
      for (var e = 0; e < t._A.length; e++) rd(t, t._A[e]);
      t._A = null;
    }
  }
  function o5(t, e, n) {
    this.onFulfilled = typeof t == "function" ? t : null, this.onRejected = typeof e == "function" ? e : null, this.promise = n;
  }
  function a5(t, e) {
    var n = false, r = HF(t, function(i) {
      n || (n = true, Bm(e, i));
    }, function(i) {
      n || (n = true, ol(e, i));
    });
    !n && r === vl && (n = true, ol(e, wl));
  }
  var zF = El;
  zF.prototype.done = function(t, e) {
    var n = arguments.length ? this.then.apply(this, arguments) : this;
    n.then(null, function(r) {
      setTimeout(function() {
        throw r;
      }, 0);
    });
  };
  var Vp = El;
  Vp.prototype.finally = function(t) {
    return this.then(function(e) {
      return Vp.resolve(t()).then(function() {
        return e;
      });
    }, function(e) {
      return Vp.resolve(t()).then(function() {
        throw e;
      });
    });
  };
  var Gt = El, QF = Ga(true), jF = Ga(false), JF = Ga(null), KF = Ga(void 0), WF = Ga(0), qF = Ga("");
  function Ga(t) {
    var e = new Gt(Gt._D);
    return e._y = 1, e._z = t, e;
  }
  Gt.resolve = function(t) {
    if (t instanceof Gt) return t;
    if (t === null) return JF;
    if (t === void 0) return KF;
    if (t === true) return QF;
    if (t === false) return jF;
    if (t === 0) return WF;
    if (t === "") return qF;
    if (typeof t == "object" || typeof t == "function") try {
      var e = t.then;
      if (typeof e == "function") return new Gt(e.bind(t));
    } catch (n) {
      return new Gt(function(r, i) {
        i(n);
      });
    }
    return Ga(t);
  };
  var al = function(t) {
    return typeof Array.from == "function" ? (al = Array.from, Array.from(t)) : (al = function(e) {
      return Array.prototype.slice.call(e);
    }, Array.prototype.slice.call(t));
  };
  Gt.all = function(t) {
    var e = al(t);
    return new Gt(function(n, r) {
      if (e.length === 0) return n([]);
      var i = e.length;
      function s(a, c) {
        if (c && (typeof c == "object" || typeof c == "function")) if (c instanceof Gt && c.then === Gt.prototype.then) {
          for (; c._y === 3; ) c = c._z;
          if (c._y === 1) return s(a, c._z);
          c._y === 2 && r(c._z), c.then(function(f) {
            s(a, f);
          }, r);
          return;
        } else {
          var l = c.then;
          if (typeof l == "function") {
            var u = new Gt(l.bind(c));
            u.then(function(f) {
              s(a, f);
            }, r);
            return;
          }
        }
        e[a] = c, --i === 0 && n(e);
      }
      for (var o = 0; o < e.length; o++) s(o, e[o]);
    });
  };
  function zp(t) {
    return {
      status: "fulfilled",
      value: t
    };
  }
  function vA(t) {
    return {
      status: "rejected",
      reason: t
    };
  }
  function YF(t) {
    if (t && (typeof t == "object" || typeof t == "function")) {
      if (t instanceof Gt && t.then === Gt.prototype.then) return t.then(zp, vA);
      var e = t.then;
      if (typeof e == "function") return new Gt(e.bind(t)).then(zp, vA);
    }
    return zp(t);
  }
  Gt.allSettled = function(t) {
    return Gt.all(al(t).map(YF));
  };
  Gt.reject = function(t) {
    return new Gt(function(e, n) {
      n(t);
    });
  };
  Gt.race = function(t) {
    return new Gt(function(e, n) {
      al(t).forEach(function(r) {
        Gt.resolve(r).then(e, n);
      });
    });
  };
  Gt.prototype.catch = function(t) {
    return this.then(null, t);
  };
  function EA(t) {
    if (typeof AggregateError == "function") return new AggregateError(t, "All promises were rejected");
    var e = new Error("All promises were rejected");
    return e.name = "AggregateError", e.errors = t, e;
  }
  Gt.any = function(e) {
    return new Gt(function(n, r) {
      var i = al(e), s = false, o = [];
      function a(l) {
        s || (s = true, n(l));
      }
      function c(l) {
        o.push(l), o.length === i.length && r(EA(o));
      }
      i.length === 0 ? r(EA(o)) : i.forEach(function(l) {
        Gt.resolve(l).then(a, c);
      });
    });
  };
  var c5 = r5, id = [], km = [], XF = c5.makeRequestCallFromTimer(ZF);
  function ZF() {
    if (km.length) throw km.shift();
  }
  var $F = Fm;
  function Fm(t) {
    var e;
    id.length ? e = id.pop() : e = new l5(), e.task = t, c5(e);
  }
  function l5() {
    this.task = null;
  }
  l5.prototype.call = function() {
    try {
      this.task.call();
    } catch (t) {
      Fm.onerror ? Fm.onerror(t) : (km.push(t), XF());
    } finally {
      this.task = null, id[id.length] = this;
    }
  };
  var cl = El, Lm = $F;
  cl.denodeify = function(t, e) {
    return typeof e == "number" && e !== 1 / 0 ? eL(t, e) : tL(t);
  };
  var u5 = "function (err, res) {if (err) { rj(err); } else { rs(res); }}";
  function eL(t, e) {
    for (var n = [], r = 0; r < e; r++) n.push("a" + r);
    var i = [
      "return function (" + n.join(",") + ") {",
      "var self = this;",
      "return new Promise(function (rs, rj) {",
      "var res = fn.call(",
      [
        "self"
      ].concat(n).concat([
        u5
      ]).join(","),
      ");",
      "if (res &&",
      '(typeof res === "object" || typeof res === "function") &&',
      'typeof res.then === "function"',
      ") {rs(res);}",
      "});",
      "};"
    ].join("");
    return Function([
      "Promise",
      "fn"
    ], i)(cl, t);
  }
  function tL(t) {
    for (var e = Math.max(t.length - 1, 3), n = [], r = 0; r < e; r++) n.push("a" + r);
    var i = [
      "return function (" + n.join(",") + ") {",
      "var self = this;",
      "var args;",
      "var argLength = arguments.length;",
      "if (arguments.length > " + e + ") {",
      "args = new Array(arguments.length + 1);",
      "for (var i = 0; i < arguments.length; i++) {",
      "args[i] = arguments[i];",
      "}",
      "}",
      "return new Promise(function (rs, rj) {",
      "var cb = " + u5 + ";",
      "var res;",
      "switch (argLength) {",
      n.concat([
        "extra"
      ]).map(function(s, o) {
        return "case " + o + ":res = fn.call(" + [
          "self"
        ].concat(n.slice(0, o)).concat("cb").join(",") + ");break;";
      }).join(""),
      "default:",
      "args[argLength] = cb;",
      "res = fn.apply(self, args);",
      "}",
      "if (res &&",
      '(typeof res === "object" || typeof res === "function") &&',
      'typeof res.then === "function"',
      ") {rs(res);}",
      "});",
      "};"
    ].join("");
    return Function([
      "Promise",
      "fn"
    ], i)(cl, t);
  }
  cl.nodeify = function(t) {
    return function() {
      var e = Array.prototype.slice.call(arguments), n = typeof e[e.length - 1] == "function" ? e.pop() : null, r = this;
      try {
        return t.apply(this, arguments).nodeify(n, r);
      } catch (i) {
        if (n === null || typeof n > "u") return new cl(function(s, o) {
          o(i);
        });
        Lm(function() {
          n.call(r, i);
        });
      }
    };
  };
  cl.prototype.nodeify = function(t, e) {
    if (typeof t != "function") return this;
    this.then(function(n) {
      Lm(function() {
        t.call(e, null, n);
      });
    }, function(n) {
      Lm(function() {
        t.call(e, n);
      });
    });
  };
  var gr = El;
  gr.enableSynchronous = function() {
    gr.prototype.isPending = function() {
      return this.getState() == 0;
    }, gr.prototype.isFulfilled = function() {
      return this.getState() == 1;
    }, gr.prototype.isRejected = function() {
      return this.getState() == 2;
    }, gr.prototype.getValue = function() {
      if (this._y === 3) return this._z.getValue();
      if (!this.isFulfilled()) throw new Error("Cannot get a value of an unfulfilled promise.");
      return this._z;
    }, gr.prototype.getReason = function() {
      if (this._y === 3) return this._z.getReason();
      if (!this.isRejected()) throw new Error("Cannot get a rejection reason of a non-rejected promise.");
      return this._z;
    }, gr.prototype.getState = function() {
      return this._y === 3 ? this._z.getState() : this._y === -1 || this._y === -2 ? 0 : this._y;
    };
  };
  gr.disableSynchronous = function() {
    gr.prototype.isPending = void 0, gr.prototype.isFulfilled = void 0, gr.prototype.isRejected = void 0, gr.prototype.getValue = void 0, gr.prototype.getReason = void 0, gr.prototype.getState = void 0;
  };
  var nL = El, rL = nL, f5 = {}, oh = {};
  oh.byteLength = oL;
  oh.toByteArray = cL;
  oh.fromByteArray = fL;
  var Gi = [], Hr = [], iL = typeof Uint8Array < "u" ? Uint8Array : Array, Qp = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  for (var tc = 0, sL = Qp.length; tc < sL; ++tc) Gi[tc] = Qp[tc], Hr[Qp.charCodeAt(tc)] = tc;
  Hr[45] = 62;
  Hr[95] = 63;
  function d5(t) {
    var e = t.length;
    if (e % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
    var n = t.indexOf("=");
    n === -1 && (n = e);
    var r = n === e ? 0 : 4 - n % 4;
    return [
      n,
      r
    ];
  }
  function oL(t) {
    var e = d5(t), n = e[0], r = e[1];
    return (n + r) * 3 / 4 - r;
  }
  function aL(t, e, n) {
    return (e + n) * 3 / 4 - n;
  }
  function cL(t) {
    var e, n = d5(t), r = n[0], i = n[1], s = new iL(aL(t, r, i)), o = 0, a = i > 0 ? r - 4 : r, c;
    for (c = 0; c < a; c += 4) e = Hr[t.charCodeAt(c)] << 18 | Hr[t.charCodeAt(c + 1)] << 12 | Hr[t.charCodeAt(c + 2)] << 6 | Hr[t.charCodeAt(c + 3)], s[o++] = e >> 16 & 255, s[o++] = e >> 8 & 255, s[o++] = e & 255;
    return i === 2 && (e = Hr[t.charCodeAt(c)] << 2 | Hr[t.charCodeAt(c + 1)] >> 4, s[o++] = e & 255), i === 1 && (e = Hr[t.charCodeAt(c)] << 10 | Hr[t.charCodeAt(c + 1)] << 4 | Hr[t.charCodeAt(c + 2)] >> 2, s[o++] = e >> 8 & 255, s[o++] = e & 255), s;
  }
  function lL(t) {
    return Gi[t >> 18 & 63] + Gi[t >> 12 & 63] + Gi[t >> 6 & 63] + Gi[t & 63];
  }
  function uL(t, e, n) {
    for (var r, i = [], s = e; s < n; s += 3) r = (t[s] << 16 & 16711680) + (t[s + 1] << 8 & 65280) + (t[s + 2] & 255), i.push(lL(r));
    return i.join("");
  }
  function fL(t) {
    for (var e, n = t.length, r = n % 3, i = [], s = 16383, o = 0, a = n - r; o < a; o += s) i.push(uL(t, o, o + s > a ? a : o + s));
    return r === 1 ? (e = t[n - 1], i.push(Gi[e >> 2] + Gi[e << 4 & 63] + "==")) : r === 2 && (e = (t[n - 2] << 8) + t[n - 1], i.push(Gi[e >> 10] + Gi[e >> 4 & 63] + Gi[e << 2 & 63] + "=")), i.join("");
  }
  var xy = {};
  xy.read = function(t, e, n, r, i) {
    var s, o, a = i * 8 - r - 1, c = (1 << a) - 1, l = c >> 1, u = -7, f = n ? i - 1 : 0, d = n ? -1 : 1, m = t[e + f];
    for (f += d, s = m & (1 << -u) - 1, m >>= -u, u += a; u > 0; s = s * 256 + t[e + f], f += d, u -= 8) ;
    for (o = s & (1 << -u) - 1, s >>= -u, u += r; u > 0; o = o * 256 + t[e + f], f += d, u -= 8) ;
    if (s === 0) s = 1 - l;
    else {
      if (s === c) return o ? NaN : (m ? -1 : 1) * (1 / 0);
      o = o + Math.pow(2, r), s = s - l;
    }
    return (m ? -1 : 1) * o * Math.pow(2, s - r);
  };
  xy.write = function(t, e, n, r, i, s) {
    var o, a, c, l = s * 8 - i - 1, u = (1 << l) - 1, f = u >> 1, d = i === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, m = r ? 0 : s - 1, y = r ? 1 : -1, x = e < 0 || e === 0 && 1 / e < 0 ? 1 : 0;
    for (e = Math.abs(e), isNaN(e) || e === 1 / 0 ? (a = isNaN(e) ? 1 : 0, o = u) : (o = Math.floor(Math.log(e) / Math.LN2), e * (c = Math.pow(2, -o)) < 1 && (o--, c *= 2), o + f >= 1 ? e += d / c : e += d * Math.pow(2, 1 - f), e * c >= 2 && (o++, c /= 2), o + f >= u ? (a = 0, o = u) : o + f >= 1 ? (a = (e * c - 1) * Math.pow(2, i), o = o + f) : (a = e * Math.pow(2, f - 1) * Math.pow(2, i), o = 0)); i >= 8; t[n + m] = a & 255, m += y, a /= 256, i -= 8) ;
    for (o = o << i | a, l += i; l > 0; t[n + m] = o & 255, m += y, o /= 256, l -= 8) ;
    t[n + m - y] |= x * 128;
  };
  (function(t) {
    const e = oh, n = xy, r = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
    t.Buffer = a, t.SlowBuffer = O, t.INSPECT_MAX_BYTES = 50;
    const i = 2147483647;
    t.kMaxLength = i, a.TYPED_ARRAY_SUPPORT = s(), !a.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
    function s() {
      try {
        const _ = new Uint8Array(1), b = {
          foo: function() {
            return 42;
          }
        };
        return Object.setPrototypeOf(b, Uint8Array.prototype), Object.setPrototypeOf(_, b), _.foo() === 42;
      } catch {
        return false;
      }
    }
    Object.defineProperty(a.prototype, "parent", {
      enumerable: true,
      get: function() {
        if (a.isBuffer(this)) return this.buffer;
      }
    }), Object.defineProperty(a.prototype, "offset", {
      enumerable: true,
      get: function() {
        if (a.isBuffer(this)) return this.byteOffset;
      }
    });
    function o(_) {
      if (_ > i) throw new RangeError('The value "' + _ + '" is invalid for option "size"');
      const b = new Uint8Array(_);
      return Object.setPrototypeOf(b, a.prototype), b;
    }
    function a(_, b, v) {
      if (typeof _ == "number") {
        if (typeof b == "string") throw new TypeError('The "string" argument must be of type string. Received type number');
        return f(_);
      }
      return c(_, b, v);
    }
    a.poolSize = 8192;
    function c(_, b, v) {
      if (typeof _ == "string") return d(_, b);
      if (ArrayBuffer.isView(_)) return y(_);
      if (_ == null) throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof _);
      if (ae(_, ArrayBuffer) || _ && ae(_.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (ae(_, SharedArrayBuffer) || _ && ae(_.buffer, SharedArrayBuffer))) return x(_, b, v);
      if (typeof _ == "number") throw new TypeError('The "value" argument must not be of type number. Received type number');
      const J = _.valueOf && _.valueOf();
      if (J != null && J !== _) return a.from(J, b, v);
      const ne = w(_);
      if (ne) return ne;
      if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof _[Symbol.toPrimitive] == "function") return a.from(_[Symbol.toPrimitive]("string"), b, v);
      throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof _);
    }
    a.from = function(_, b, v) {
      return c(_, b, v);
    }, Object.setPrototypeOf(a.prototype, Uint8Array.prototype), Object.setPrototypeOf(a, Uint8Array);
    function l(_) {
      if (typeof _ != "number") throw new TypeError('"size" argument must be of type number');
      if (_ < 0) throw new RangeError('The value "' + _ + '" is invalid for option "size"');
    }
    function u(_, b, v) {
      return l(_), _ <= 0 ? o(_) : b !== void 0 ? typeof v == "string" ? o(_).fill(b, v) : o(_).fill(b) : o(_);
    }
    a.alloc = function(_, b, v) {
      return u(_, b, v);
    };
    function f(_) {
      return l(_), o(_ < 0 ? 0 : R(_) | 0);
    }
    a.allocUnsafe = function(_) {
      return f(_);
    }, a.allocUnsafeSlow = function(_) {
      return f(_);
    };
    function d(_, b) {
      if ((typeof b != "string" || b === "") && (b = "utf8"), !a.isEncoding(b)) throw new TypeError("Unknown encoding: " + b);
      const v = B(_, b) | 0;
      let J = o(v);
      const ne = J.write(_, b);
      return ne !== v && (J = J.slice(0, ne)), J;
    }
    function m(_) {
      const b = _.length < 0 ? 0 : R(_.length) | 0, v = o(b);
      for (let J = 0; J < b; J += 1) v[J] = _[J] & 255;
      return v;
    }
    function y(_) {
      if (ae(_, Uint8Array)) {
        const b = new Uint8Array(_);
        return x(b.buffer, b.byteOffset, b.byteLength);
      }
      return m(_);
    }
    function x(_, b, v) {
      if (b < 0 || _.byteLength < b) throw new RangeError('"offset" is outside of buffer bounds');
      if (_.byteLength < b + (v || 0)) throw new RangeError('"length" is outside of buffer bounds');
      let J;
      return b === void 0 && v === void 0 ? J = new Uint8Array(_) : v === void 0 ? J = new Uint8Array(_, b) : J = new Uint8Array(_, b, v), Object.setPrototypeOf(J, a.prototype), J;
    }
    function w(_) {
      if (a.isBuffer(_)) {
        const b = R(_.length) | 0, v = o(b);
        return v.length === 0 || _.copy(v, 0, 0, b), v;
      }
      if (_.length !== void 0) return typeof _.length != "number" || le(_.length) ? o(0) : m(_);
      if (_.type === "Buffer" && Array.isArray(_.data)) return m(_.data);
    }
    function R(_) {
      if (_ >= i) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + i.toString(16) + " bytes");
      return _ | 0;
    }
    function O(_) {
      return +_ != _ && (_ = 0), a.alloc(+_);
    }
    a.isBuffer = function(b) {
      return b != null && b._isBuffer === true && b !== a.prototype;
    }, a.compare = function(b, v) {
      if (ae(b, Uint8Array) && (b = a.from(b, b.offset, b.byteLength)), ae(v, Uint8Array) && (v = a.from(v, v.offset, v.byteLength)), !a.isBuffer(b) || !a.isBuffer(v)) throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
      if (b === v) return 0;
      let J = b.length, ne = v.length;
      for (let se = 0, de = Math.min(J, ne); se < de; ++se) if (b[se] !== v[se]) {
        J = b[se], ne = v[se];
        break;
      }
      return J < ne ? -1 : ne < J ? 1 : 0;
    }, a.isEncoding = function(b) {
      switch (String(b).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    }, a.concat = function(b, v) {
      if (!Array.isArray(b)) throw new TypeError('"list" argument must be an Array of Buffers');
      if (b.length === 0) return a.alloc(0);
      let J;
      if (v === void 0) for (v = 0, J = 0; J < b.length; ++J) v += b[J].length;
      const ne = a.allocUnsafe(v);
      let se = 0;
      for (J = 0; J < b.length; ++J) {
        let de = b[J];
        if (ae(de, Uint8Array)) se + de.length > ne.length ? (a.isBuffer(de) || (de = a.from(de)), de.copy(ne, se)) : Uint8Array.prototype.set.call(ne, de, se);
        else if (a.isBuffer(de)) de.copy(ne, se);
        else throw new TypeError('"list" argument must be an Array of Buffers');
        se += de.length;
      }
      return ne;
    };
    function B(_, b) {
      if (a.isBuffer(_)) return _.length;
      if (ArrayBuffer.isView(_) || ae(_, ArrayBuffer)) return _.byteLength;
      if (typeof _ != "string") throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof _);
      const v = _.length, J = arguments.length > 2 && arguments[2] === true;
      if (!J && v === 0) return 0;
      let ne = false;
      for (; ; ) switch (b) {
        case "ascii":
        case "latin1":
        case "binary":
          return v;
        case "utf8":
        case "utf-8":
          return ue(_).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return v * 2;
        case "hex":
          return v >>> 1;
        case "base64":
          return Q(_).length;
        default:
          if (ne) return J ? -1 : ue(_).length;
          b = ("" + b).toLowerCase(), ne = true;
      }
    }
    a.byteLength = B;
    function M(_, b, v) {
      let J = false;
      if ((b === void 0 || b < 0) && (b = 0), b > this.length || ((v === void 0 || v > this.length) && (v = this.length), v <= 0) || (v >>>= 0, b >>>= 0, v <= b)) return "";
      for (_ || (_ = "utf8"); ; ) switch (_) {
        case "hex":
          return U(this, b, v);
        case "utf8":
        case "utf-8":
          return h(this, b, v);
        case "ascii":
          return C(this, b, v);
        case "latin1":
        case "binary":
          return N(this, b, v);
        case "base64":
          return I(this, b, v);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return Y(this, b, v);
        default:
          if (J) throw new TypeError("Unknown encoding: " + _);
          _ = (_ + "").toLowerCase(), J = true;
      }
    }
    a.prototype._isBuffer = true;
    function D(_, b, v) {
      const J = _[b];
      _[b] = _[v], _[v] = J;
    }
    a.prototype.swap16 = function() {
      const b = this.length;
      if (b % 2 !== 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
      for (let v = 0; v < b; v += 2) D(this, v, v + 1);
      return this;
    }, a.prototype.swap32 = function() {
      const b = this.length;
      if (b % 4 !== 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
      for (let v = 0; v < b; v += 4) D(this, v, v + 3), D(this, v + 1, v + 2);
      return this;
    }, a.prototype.swap64 = function() {
      const b = this.length;
      if (b % 8 !== 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
      for (let v = 0; v < b; v += 8) D(this, v, v + 7), D(this, v + 1, v + 6), D(this, v + 2, v + 5), D(this, v + 3, v + 4);
      return this;
    }, a.prototype.toString = function() {
      const b = this.length;
      return b === 0 ? "" : arguments.length === 0 ? h(this, 0, b) : M.apply(this, arguments);
    }, a.prototype.toLocaleString = a.prototype.toString, a.prototype.equals = function(b) {
      if (!a.isBuffer(b)) throw new TypeError("Argument must be a Buffer");
      return this === b ? true : a.compare(this, b) === 0;
    }, a.prototype.inspect = function() {
      let b = "";
      const v = t.INSPECT_MAX_BYTES;
      return b = this.toString("hex", 0, v).replace(/(.{2})/g, "$1 ").trim(), this.length > v && (b += " ... "), "<Buffer " + b + ">";
    }, r && (a.prototype[r] = a.prototype.inspect), a.prototype.compare = function(b, v, J, ne, se) {
      if (ae(b, Uint8Array) && (b = a.from(b, b.offset, b.byteLength)), !a.isBuffer(b)) throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof b);
      if (v === void 0 && (v = 0), J === void 0 && (J = b ? b.length : 0), ne === void 0 && (ne = 0), se === void 0 && (se = this.length), v < 0 || J > b.length || ne < 0 || se > this.length) throw new RangeError("out of range index");
      if (ne >= se && v >= J) return 0;
      if (ne >= se) return -1;
      if (v >= J) return 1;
      if (v >>>= 0, J >>>= 0, ne >>>= 0, se >>>= 0, this === b) return 0;
      let de = se - ne, Fe = J - v;
      const Re = Math.min(de, Fe), Ne = this.slice(ne, se), ot = b.slice(v, J);
      for (let Oe = 0; Oe < Re; ++Oe) if (Ne[Oe] !== ot[Oe]) {
        de = Ne[Oe], Fe = ot[Oe];
        break;
      }
      return de < Fe ? -1 : Fe < de ? 1 : 0;
    };
    function H(_, b, v, J, ne) {
      if (_.length === 0) return -1;
      if (typeof v == "string" ? (J = v, v = 0) : v > 2147483647 ? v = 2147483647 : v < -2147483648 && (v = -2147483648), v = +v, le(v) && (v = ne ? 0 : _.length - 1), v < 0 && (v = _.length + v), v >= _.length) {
        if (ne) return -1;
        v = _.length - 1;
      } else if (v < 0) if (ne) v = 0;
      else return -1;
      if (typeof b == "string" && (b = a.from(b, J)), a.isBuffer(b)) return b.length === 0 ? -1 : q(_, b, v, J, ne);
      if (typeof b == "number") return b = b & 255, typeof Uint8Array.prototype.indexOf == "function" ? ne ? Uint8Array.prototype.indexOf.call(_, b, v) : Uint8Array.prototype.lastIndexOf.call(_, b, v) : q(_, [
        b
      ], v, J, ne);
      throw new TypeError("val must be string, number or Buffer");
    }
    function q(_, b, v, J, ne) {
      let se = 1, de = _.length, Fe = b.length;
      if (J !== void 0 && (J = String(J).toLowerCase(), J === "ucs2" || J === "ucs-2" || J === "utf16le" || J === "utf-16le")) {
        if (_.length < 2 || b.length < 2) return -1;
        se = 2, de /= 2, Fe /= 2, v /= 2;
      }
      function Re(ot, Oe) {
        return se === 1 ? ot[Oe] : ot.readUInt16BE(Oe * se);
      }
      let Ne;
      if (ne) {
        let ot = -1;
        for (Ne = v; Ne < de; Ne++) if (Re(_, Ne) === Re(b, ot === -1 ? 0 : Ne - ot)) {
          if (ot === -1 && (ot = Ne), Ne - ot + 1 === Fe) return ot * se;
        } else ot !== -1 && (Ne -= Ne - ot), ot = -1;
      } else for (v + Fe > de && (v = de - Fe), Ne = v; Ne >= 0; Ne--) {
        let ot = true;
        for (let Oe = 0; Oe < Fe; Oe++) if (Re(_, Ne + Oe) !== Re(b, Oe)) {
          ot = false;
          break;
        }
        if (ot) return Ne;
      }
      return -1;
    }
    a.prototype.includes = function(b, v, J) {
      return this.indexOf(b, v, J) !== -1;
    }, a.prototype.indexOf = function(b, v, J) {
      return H(this, b, v, J, true);
    }, a.prototype.lastIndexOf = function(b, v, J) {
      return H(this, b, v, J, false);
    };
    function S(_, b, v, J) {
      v = Number(v) || 0;
      const ne = _.length - v;
      J ? (J = Number(J), J > ne && (J = ne)) : J = ne;
      const se = b.length;
      J > se / 2 && (J = se / 2);
      let de;
      for (de = 0; de < J; ++de) {
        const Fe = parseInt(b.substr(de * 2, 2), 16);
        if (le(Fe)) return de;
        _[v + de] = Fe;
      }
      return de;
    }
    function P(_, b, v, J) {
      return j(ue(b, _.length - v), _, v, J);
    }
    function L(_, b, v, J) {
      return j(ye(b), _, v, J);
    }
    function K(_, b, v, J) {
      return j(Q(b), _, v, J);
    }
    function z(_, b, v, J) {
      return j(we(b, _.length - v), _, v, J);
    }
    a.prototype.write = function(b, v, J, ne) {
      if (v === void 0) ne = "utf8", J = this.length, v = 0;
      else if (J === void 0 && typeof v == "string") ne = v, J = this.length, v = 0;
      else if (isFinite(v)) v = v >>> 0, isFinite(J) ? (J = J >>> 0, ne === void 0 && (ne = "utf8")) : (ne = J, J = void 0);
      else throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
      const se = this.length - v;
      if ((J === void 0 || J > se) && (J = se), b.length > 0 && (J < 0 || v < 0) || v > this.length) throw new RangeError("Attempt to write outside buffer bounds");
      ne || (ne = "utf8");
      let de = false;
      for (; ; ) switch (ne) {
        case "hex":
          return S(this, b, v, J);
        case "utf8":
        case "utf-8":
          return P(this, b, v, J);
        case "ascii":
        case "latin1":
        case "binary":
          return L(this, b, v, J);
        case "base64":
          return K(this, b, v, J);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return z(this, b, v, J);
        default:
          if (de) throw new TypeError("Unknown encoding: " + ne);
          ne = ("" + ne).toLowerCase(), de = true;
      }
    }, a.prototype.toJSON = function() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };
    function I(_, b, v) {
      return b === 0 && v === _.length ? e.fromByteArray(_) : e.fromByteArray(_.slice(b, v));
    }
    function h(_, b, v) {
      v = Math.min(_.length, v);
      const J = [];
      let ne = b;
      for (; ne < v; ) {
        const se = _[ne];
        let de = null, Fe = se > 239 ? 4 : se > 223 ? 3 : se > 191 ? 2 : 1;
        if (ne + Fe <= v) {
          let Re, Ne, ot, Oe;
          switch (Fe) {
            case 1:
              se < 128 && (de = se);
              break;
            case 2:
              Re = _[ne + 1], (Re & 192) === 128 && (Oe = (se & 31) << 6 | Re & 63, Oe > 127 && (de = Oe));
              break;
            case 3:
              Re = _[ne + 1], Ne = _[ne + 2], (Re & 192) === 128 && (Ne & 192) === 128 && (Oe = (se & 15) << 12 | (Re & 63) << 6 | Ne & 63, Oe > 2047 && (Oe < 55296 || Oe > 57343) && (de = Oe));
              break;
            case 4:
              Re = _[ne + 1], Ne = _[ne + 2], ot = _[ne + 3], (Re & 192) === 128 && (Ne & 192) === 128 && (ot & 192) === 128 && (Oe = (se & 15) << 18 | (Re & 63) << 12 | (Ne & 63) << 6 | ot & 63, Oe > 65535 && Oe < 1114112 && (de = Oe));
          }
        }
        de === null ? (de = 65533, Fe = 1) : de > 65535 && (de -= 65536, J.push(de >>> 10 & 1023 | 55296), de = 56320 | de & 1023), J.push(de), ne += Fe;
      }
      return A(J);
    }
    const p = 4096;
    function A(_) {
      const b = _.length;
      if (b <= p) return String.fromCharCode.apply(String, _);
      let v = "", J = 0;
      for (; J < b; ) v += String.fromCharCode.apply(String, _.slice(J, J += p));
      return v;
    }
    function C(_, b, v) {
      let J = "";
      v = Math.min(_.length, v);
      for (let ne = b; ne < v; ++ne) J += String.fromCharCode(_[ne] & 127);
      return J;
    }
    function N(_, b, v) {
      let J = "";
      v = Math.min(_.length, v);
      for (let ne = b; ne < v; ++ne) J += String.fromCharCode(_[ne]);
      return J;
    }
    function U(_, b, v) {
      const J = _.length;
      (!b || b < 0) && (b = 0), (!v || v < 0 || v > J) && (v = J);
      let ne = "";
      for (let se = b; se < v; ++se) ne += be[_[se]];
      return ne;
    }
    function Y(_, b, v) {
      const J = _.slice(b, v);
      let ne = "";
      for (let se = 0; se < J.length - 1; se += 2) ne += String.fromCharCode(J[se] + J[se + 1] * 256);
      return ne;
    }
    a.prototype.slice = function(b, v) {
      const J = this.length;
      b = ~~b, v = v === void 0 ? J : ~~v, b < 0 ? (b += J, b < 0 && (b = 0)) : b > J && (b = J), v < 0 ? (v += J, v < 0 && (v = 0)) : v > J && (v = J), v < b && (v = b);
      const ne = this.subarray(b, v);
      return Object.setPrototypeOf(ne, a.prototype), ne;
    };
    function T(_, b, v) {
      if (_ % 1 !== 0 || _ < 0) throw new RangeError("offset is not uint");
      if (_ + b > v) throw new RangeError("Trying to access beyond buffer length");
    }
    a.prototype.readUintLE = a.prototype.readUIntLE = function(b, v, J) {
      b = b >>> 0, v = v >>> 0, J || T(b, v, this.length);
      let ne = this[b], se = 1, de = 0;
      for (; ++de < v && (se *= 256); ) ne += this[b + de] * se;
      return ne;
    }, a.prototype.readUintBE = a.prototype.readUIntBE = function(b, v, J) {
      b = b >>> 0, v = v >>> 0, J || T(b, v, this.length);
      let ne = this[b + --v], se = 1;
      for (; v > 0 && (se *= 256); ) ne += this[b + --v] * se;
      return ne;
    }, a.prototype.readUint8 = a.prototype.readUInt8 = function(b, v) {
      return b = b >>> 0, v || T(b, 1, this.length), this[b];
    }, a.prototype.readUint16LE = a.prototype.readUInt16LE = function(b, v) {
      return b = b >>> 0, v || T(b, 2, this.length), this[b] | this[b + 1] << 8;
    }, a.prototype.readUint16BE = a.prototype.readUInt16BE = function(b, v) {
      return b = b >>> 0, v || T(b, 2, this.length), this[b] << 8 | this[b + 1];
    }, a.prototype.readUint32LE = a.prototype.readUInt32LE = function(b, v) {
      return b = b >>> 0, v || T(b, 4, this.length), (this[b] | this[b + 1] << 8 | this[b + 2] << 16) + this[b + 3] * 16777216;
    }, a.prototype.readUint32BE = a.prototype.readUInt32BE = function(b, v) {
      return b = b >>> 0, v || T(b, 4, this.length), this[b] * 16777216 + (this[b + 1] << 16 | this[b + 2] << 8 | this[b + 3]);
    }, a.prototype.readBigUInt64LE = xe(function(b) {
      b = b >>> 0, W(b, "offset");
      const v = this[b], J = this[b + 7];
      (v === void 0 || J === void 0) && V(b, this.length - 8);
      const ne = v + this[++b] * 2 ** 8 + this[++b] * 2 ** 16 + this[++b] * 2 ** 24, se = this[++b] + this[++b] * 2 ** 8 + this[++b] * 2 ** 16 + J * 2 ** 24;
      return BigInt(ne) + (BigInt(se) << BigInt(32));
    }), a.prototype.readBigUInt64BE = xe(function(b) {
      b = b >>> 0, W(b, "offset");
      const v = this[b], J = this[b + 7];
      (v === void 0 || J === void 0) && V(b, this.length - 8);
      const ne = v * 2 ** 24 + this[++b] * 2 ** 16 + this[++b] * 2 ** 8 + this[++b], se = this[++b] * 2 ** 24 + this[++b] * 2 ** 16 + this[++b] * 2 ** 8 + J;
      return (BigInt(ne) << BigInt(32)) + BigInt(se);
    }), a.prototype.readIntLE = function(b, v, J) {
      b = b >>> 0, v = v >>> 0, J || T(b, v, this.length);
      let ne = this[b], se = 1, de = 0;
      for (; ++de < v && (se *= 256); ) ne += this[b + de] * se;
      return se *= 128, ne >= se && (ne -= Math.pow(2, 8 * v)), ne;
    }, a.prototype.readIntBE = function(b, v, J) {
      b = b >>> 0, v = v >>> 0, J || T(b, v, this.length);
      let ne = v, se = 1, de = this[b + --ne];
      for (; ne > 0 && (se *= 256); ) de += this[b + --ne] * se;
      return se *= 128, de >= se && (de -= Math.pow(2, 8 * v)), de;
    }, a.prototype.readInt8 = function(b, v) {
      return b = b >>> 0, v || T(b, 1, this.length), this[b] & 128 ? (255 - this[b] + 1) * -1 : this[b];
    }, a.prototype.readInt16LE = function(b, v) {
      b = b >>> 0, v || T(b, 2, this.length);
      const J = this[b] | this[b + 1] << 8;
      return J & 32768 ? J | 4294901760 : J;
    }, a.prototype.readInt16BE = function(b, v) {
      b = b >>> 0, v || T(b, 2, this.length);
      const J = this[b + 1] | this[b] << 8;
      return J & 32768 ? J | 4294901760 : J;
    }, a.prototype.readInt32LE = function(b, v) {
      return b = b >>> 0, v || T(b, 4, this.length), this[b] | this[b + 1] << 8 | this[b + 2] << 16 | this[b + 3] << 24;
    }, a.prototype.readInt32BE = function(b, v) {
      return b = b >>> 0, v || T(b, 4, this.length), this[b] << 24 | this[b + 1] << 16 | this[b + 2] << 8 | this[b + 3];
    }, a.prototype.readBigInt64LE = xe(function(b) {
      b = b >>> 0, W(b, "offset");
      const v = this[b], J = this[b + 7];
      (v === void 0 || J === void 0) && V(b, this.length - 8);
      const ne = this[b + 4] + this[b + 5] * 2 ** 8 + this[b + 6] * 2 ** 16 + (J << 24);
      return (BigInt(ne) << BigInt(32)) + BigInt(v + this[++b] * 2 ** 8 + this[++b] * 2 ** 16 + this[++b] * 2 ** 24);
    }), a.prototype.readBigInt64BE = xe(function(b) {
      b = b >>> 0, W(b, "offset");
      const v = this[b], J = this[b + 7];
      (v === void 0 || J === void 0) && V(b, this.length - 8);
      const ne = (v << 24) + this[++b] * 2 ** 16 + this[++b] * 2 ** 8 + this[++b];
      return (BigInt(ne) << BigInt(32)) + BigInt(this[++b] * 2 ** 24 + this[++b] * 2 ** 16 + this[++b] * 2 ** 8 + J);
    }), a.prototype.readFloatLE = function(b, v) {
      return b = b >>> 0, v || T(b, 4, this.length), n.read(this, b, true, 23, 4);
    }, a.prototype.readFloatBE = function(b, v) {
      return b = b >>> 0, v || T(b, 4, this.length), n.read(this, b, false, 23, 4);
    }, a.prototype.readDoubleLE = function(b, v) {
      return b = b >>> 0, v || T(b, 8, this.length), n.read(this, b, true, 52, 8);
    }, a.prototype.readDoubleBE = function(b, v) {
      return b = b >>> 0, v || T(b, 8, this.length), n.read(this, b, false, 52, 8);
    };
    function g(_, b, v, J, ne, se) {
      if (!a.isBuffer(_)) throw new TypeError('"buffer" argument must be a Buffer instance');
      if (b > ne || b < se) throw new RangeError('"value" argument is out of bounds');
      if (v + J > _.length) throw new RangeError("Index out of range");
    }
    a.prototype.writeUintLE = a.prototype.writeUIntLE = function(b, v, J, ne) {
      if (b = +b, v = v >>> 0, J = J >>> 0, !ne) {
        const Fe = Math.pow(2, 8 * J) - 1;
        g(this, b, v, J, Fe, 0);
      }
      let se = 1, de = 0;
      for (this[v] = b & 255; ++de < J && (se *= 256); ) this[v + de] = b / se & 255;
      return v + J;
    }, a.prototype.writeUintBE = a.prototype.writeUIntBE = function(b, v, J, ne) {
      if (b = +b, v = v >>> 0, J = J >>> 0, !ne) {
        const Fe = Math.pow(2, 8 * J) - 1;
        g(this, b, v, J, Fe, 0);
      }
      let se = J - 1, de = 1;
      for (this[v + se] = b & 255; --se >= 0 && (de *= 256); ) this[v + se] = b / de & 255;
      return v + J;
    }, a.prototype.writeUint8 = a.prototype.writeUInt8 = function(b, v, J) {
      return b = +b, v = v >>> 0, J || g(this, b, v, 1, 255, 0), this[v] = b & 255, v + 1;
    }, a.prototype.writeUint16LE = a.prototype.writeUInt16LE = function(b, v, J) {
      return b = +b, v = v >>> 0, J || g(this, b, v, 2, 65535, 0), this[v] = b & 255, this[v + 1] = b >>> 8, v + 2;
    }, a.prototype.writeUint16BE = a.prototype.writeUInt16BE = function(b, v, J) {
      return b = +b, v = v >>> 0, J || g(this, b, v, 2, 65535, 0), this[v] = b >>> 8, this[v + 1] = b & 255, v + 2;
    }, a.prototype.writeUint32LE = a.prototype.writeUInt32LE = function(b, v, J) {
      return b = +b, v = v >>> 0, J || g(this, b, v, 4, 4294967295, 0), this[v + 3] = b >>> 24, this[v + 2] = b >>> 16, this[v + 1] = b >>> 8, this[v] = b & 255, v + 4;
    }, a.prototype.writeUint32BE = a.prototype.writeUInt32BE = function(b, v, J) {
      return b = +b, v = v >>> 0, J || g(this, b, v, 4, 4294967295, 0), this[v] = b >>> 24, this[v + 1] = b >>> 16, this[v + 2] = b >>> 8, this[v + 3] = b & 255, v + 4;
    };
    function F(_, b, v, J, ne) {
      G(b, J, ne, _, v, 7);
      let se = Number(b & BigInt(4294967295));
      _[v++] = se, se = se >> 8, _[v++] = se, se = se >> 8, _[v++] = se, se = se >> 8, _[v++] = se;
      let de = Number(b >> BigInt(32) & BigInt(4294967295));
      return _[v++] = de, de = de >> 8, _[v++] = de, de = de >> 8, _[v++] = de, de = de >> 8, _[v++] = de, v;
    }
    function ee(_, b, v, J, ne) {
      G(b, J, ne, _, v, 7);
      let se = Number(b & BigInt(4294967295));
      _[v + 7] = se, se = se >> 8, _[v + 6] = se, se = se >> 8, _[v + 5] = se, se = se >> 8, _[v + 4] = se;
      let de = Number(b >> BigInt(32) & BigInt(4294967295));
      return _[v + 3] = de, de = de >> 8, _[v + 2] = de, de = de >> 8, _[v + 1] = de, de = de >> 8, _[v] = de, v + 8;
    }
    a.prototype.writeBigUInt64LE = xe(function(b, v = 0) {
      return F(this, b, v, BigInt(0), BigInt("0xffffffffffffffff"));
    }), a.prototype.writeBigUInt64BE = xe(function(b, v = 0) {
      return ee(this, b, v, BigInt(0), BigInt("0xffffffffffffffff"));
    }), a.prototype.writeIntLE = function(b, v, J, ne) {
      if (b = +b, v = v >>> 0, !ne) {
        const Re = Math.pow(2, 8 * J - 1);
        g(this, b, v, J, Re - 1, -Re);
      }
      let se = 0, de = 1, Fe = 0;
      for (this[v] = b & 255; ++se < J && (de *= 256); ) b < 0 && Fe === 0 && this[v + se - 1] !== 0 && (Fe = 1), this[v + se] = (b / de >> 0) - Fe & 255;
      return v + J;
    }, a.prototype.writeIntBE = function(b, v, J, ne) {
      if (b = +b, v = v >>> 0, !ne) {
        const Re = Math.pow(2, 8 * J - 1);
        g(this, b, v, J, Re - 1, -Re);
      }
      let se = J - 1, de = 1, Fe = 0;
      for (this[v + se] = b & 255; --se >= 0 && (de *= 256); ) b < 0 && Fe === 0 && this[v + se + 1] !== 0 && (Fe = 1), this[v + se] = (b / de >> 0) - Fe & 255;
      return v + J;
    }, a.prototype.writeInt8 = function(b, v, J) {
      return b = +b, v = v >>> 0, J || g(this, b, v, 1, 127, -128), b < 0 && (b = 255 + b + 1), this[v] = b & 255, v + 1;
    }, a.prototype.writeInt16LE = function(b, v, J) {
      return b = +b, v = v >>> 0, J || g(this, b, v, 2, 32767, -32768), this[v] = b & 255, this[v + 1] = b >>> 8, v + 2;
    }, a.prototype.writeInt16BE = function(b, v, J) {
      return b = +b, v = v >>> 0, J || g(this, b, v, 2, 32767, -32768), this[v] = b >>> 8, this[v + 1] = b & 255, v + 2;
    }, a.prototype.writeInt32LE = function(b, v, J) {
      return b = +b, v = v >>> 0, J || g(this, b, v, 4, 2147483647, -2147483648), this[v] = b & 255, this[v + 1] = b >>> 8, this[v + 2] = b >>> 16, this[v + 3] = b >>> 24, v + 4;
    }, a.prototype.writeInt32BE = function(b, v, J) {
      return b = +b, v = v >>> 0, J || g(this, b, v, 4, 2147483647, -2147483648), b < 0 && (b = 4294967295 + b + 1), this[v] = b >>> 24, this[v + 1] = b >>> 16, this[v + 2] = b >>> 8, this[v + 3] = b & 255, v + 4;
    }, a.prototype.writeBigInt64LE = xe(function(b, v = 0) {
      return F(this, b, v, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    }), a.prototype.writeBigInt64BE = xe(function(b, v = 0) {
      return ee(this, b, v, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    function E(_, b, v, J, ne, se) {
      if (v + J > _.length) throw new RangeError("Index out of range");
      if (v < 0) throw new RangeError("Index out of range");
    }
    function Z(_, b, v, J, ne) {
      return b = +b, v = v >>> 0, ne || E(_, b, v, 4), n.write(_, b, v, J, 23, 4), v + 4;
    }
    a.prototype.writeFloatLE = function(b, v, J) {
      return Z(this, b, v, true, J);
    }, a.prototype.writeFloatBE = function(b, v, J) {
      return Z(this, b, v, false, J);
    };
    function k(_, b, v, J, ne) {
      return b = +b, v = v >>> 0, ne || E(_, b, v, 8), n.write(_, b, v, J, 52, 8), v + 8;
    }
    a.prototype.writeDoubleLE = function(b, v, J) {
      return k(this, b, v, true, J);
    }, a.prototype.writeDoubleBE = function(b, v, J) {
      return k(this, b, v, false, J);
    }, a.prototype.copy = function(b, v, J, ne) {
      if (!a.isBuffer(b)) throw new TypeError("argument should be a Buffer");
      if (J || (J = 0), !ne && ne !== 0 && (ne = this.length), v >= b.length && (v = b.length), v || (v = 0), ne > 0 && ne < J && (ne = J), ne === J || b.length === 0 || this.length === 0) return 0;
      if (v < 0) throw new RangeError("targetStart out of bounds");
      if (J < 0 || J >= this.length) throw new RangeError("Index out of range");
      if (ne < 0) throw new RangeError("sourceEnd out of bounds");
      ne > this.length && (ne = this.length), b.length - v < ne - J && (ne = b.length - v + J);
      const se = ne - J;
      return this === b && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(v, J, ne) : Uint8Array.prototype.set.call(b, this.subarray(J, ne), v), se;
    }, a.prototype.fill = function(b, v, J, ne) {
      if (typeof b == "string") {
        if (typeof v == "string" ? (ne = v, v = 0, J = this.length) : typeof J == "string" && (ne = J, J = this.length), ne !== void 0 && typeof ne != "string") throw new TypeError("encoding must be a string");
        if (typeof ne == "string" && !a.isEncoding(ne)) throw new TypeError("Unknown encoding: " + ne);
        if (b.length === 1) {
          const de = b.charCodeAt(0);
          (ne === "utf8" && de < 128 || ne === "latin1") && (b = de);
        }
      } else typeof b == "number" ? b = b & 255 : typeof b == "boolean" && (b = Number(b));
      if (v < 0 || this.length < v || this.length < J) throw new RangeError("Out of range index");
      if (J <= v) return this;
      v = v >>> 0, J = J === void 0 ? this.length : J >>> 0, b || (b = 0);
      let se;
      if (typeof b == "number") for (se = v; se < J; ++se) this[se] = b;
      else {
        const de = a.isBuffer(b) ? b : a.from(b, ne), Fe = de.length;
        if (Fe === 0) throw new TypeError('The value "' + b + '" is invalid for argument "value"');
        for (se = 0; se < J - v; ++se) this[se + v] = de[se % Fe];
      }
      return this;
    };
    const X = {};
    function $(_, b, v) {
      X[_] = class extends v {
        constructor() {
          super(), Object.defineProperty(this, "message", {
            value: b.apply(this, arguments),
            writable: true,
            configurable: true
          }), this.name = `${this.name} [${_}]`, this.stack, delete this.name;
        }
        get code() {
          return _;
        }
        set code(ne) {
          Object.defineProperty(this, "code", {
            configurable: true,
            enumerable: true,
            value: ne,
            writable: true
          });
        }
        toString() {
          return `${this.name} [${_}]: ${this.message}`;
        }
      };
    }
    $("ERR_BUFFER_OUT_OF_BOUNDS", function(_) {
      return _ ? `${_} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
    }, RangeError), $("ERR_INVALID_ARG_TYPE", function(_, b) {
      return `The "${_}" argument must be of type number. Received type ${typeof b}`;
    }, TypeError), $("ERR_OUT_OF_RANGE", function(_, b, v) {
      let J = `The value of "${_}" is out of range.`, ne = v;
      return Number.isInteger(v) && Math.abs(v) > 2 ** 32 ? ne = ce(String(v)) : typeof v == "bigint" && (ne = String(v), (v > BigInt(2) ** BigInt(32) || v < -(BigInt(2) ** BigInt(32))) && (ne = ce(ne)), ne += "n"), J += ` It must be ${b}. Received ${ne}`, J;
    }, RangeError);
    function ce(_) {
      let b = "", v = _.length;
      const J = _[0] === "-" ? 1 : 0;
      for (; v >= J + 4; v -= 3) b = `_${_.slice(v - 3, v)}${b}`;
      return `${_.slice(0, v)}${b}`;
    }
    function fe(_, b, v) {
      W(b, "offset"), (_[b] === void 0 || _[b + v] === void 0) && V(b, _.length - (v + 1));
    }
    function G(_, b, v, J, ne, se) {
      if (_ > v || _ < b) {
        const de = typeof b == "bigint" ? "n" : "";
        let Fe;
        throw b === 0 || b === BigInt(0) ? Fe = `>= 0${de} and < 2${de} ** ${(se + 1) * 8}${de}` : Fe = `>= -(2${de} ** ${(se + 1) * 8 - 1}${de}) and < 2 ** ${(se + 1) * 8 - 1}${de}`, new X.ERR_OUT_OF_RANGE("value", Fe, _);
      }
      fe(J, ne, se);
    }
    function W(_, b) {
      if (typeof _ != "number") throw new X.ERR_INVALID_ARG_TYPE(b, "number", _);
    }
    function V(_, b, v) {
      throw Math.floor(_) !== _ ? (W(_, v), new X.ERR_OUT_OF_RANGE("offset", "an integer", _)) : b < 0 ? new X.ERR_BUFFER_OUT_OF_BOUNDS() : new X.ERR_OUT_OF_RANGE("offset", `>= 0 and <= ${b}`, _);
    }
    const te = /[^+/0-9A-Za-z-_]/g;
    function pe(_) {
      if (_ = _.split("=")[0], _ = _.trim().replace(te, ""), _.length < 2) return "";
      for (; _.length % 4 !== 0; ) _ = _ + "=";
      return _;
    }
    function ue(_, b) {
      b = b || 1 / 0;
      let v;
      const J = _.length;
      let ne = null;
      const se = [];
      for (let de = 0; de < J; ++de) {
        if (v = _.charCodeAt(de), v > 55295 && v < 57344) {
          if (!ne) {
            if (v > 56319) {
              (b -= 3) > -1 && se.push(239, 191, 189);
              continue;
            } else if (de + 1 === J) {
              (b -= 3) > -1 && se.push(239, 191, 189);
              continue;
            }
            ne = v;
            continue;
          }
          if (v < 56320) {
            (b -= 3) > -1 && se.push(239, 191, 189), ne = v;
            continue;
          }
          v = (ne - 55296 << 10 | v - 56320) + 65536;
        } else ne && (b -= 3) > -1 && se.push(239, 191, 189);
        if (ne = null, v < 128) {
          if ((b -= 1) < 0) break;
          se.push(v);
        } else if (v < 2048) {
          if ((b -= 2) < 0) break;
          se.push(v >> 6 | 192, v & 63 | 128);
        } else if (v < 65536) {
          if ((b -= 3) < 0) break;
          se.push(v >> 12 | 224, v >> 6 & 63 | 128, v & 63 | 128);
        } else if (v < 1114112) {
          if ((b -= 4) < 0) break;
          se.push(v >> 18 | 240, v >> 12 & 63 | 128, v >> 6 & 63 | 128, v & 63 | 128);
        } else throw new Error("Invalid code point");
      }
      return se;
    }
    function ye(_) {
      const b = [];
      for (let v = 0; v < _.length; ++v) b.push(_.charCodeAt(v) & 255);
      return b;
    }
    function we(_, b) {
      let v, J, ne;
      const se = [];
      for (let de = 0; de < _.length && !((b -= 2) < 0); ++de) v = _.charCodeAt(de), J = v >> 8, ne = v % 256, se.push(ne), se.push(J);
      return se;
    }
    function Q(_) {
      return e.toByteArray(pe(_));
    }
    function j(_, b, v, J) {
      let ne;
      for (ne = 0; ne < J && !(ne + v >= b.length || ne >= _.length); ++ne) b[ne + v] = _[ne];
      return ne;
    }
    function ae(_, b) {
      return _ instanceof b || _ != null && _.constructor != null && _.constructor.name != null && _.constructor.name === b.name;
    }
    function le(_) {
      return _ !== _;
    }
    const be = function() {
      const _ = "0123456789abcdef", b = new Array(256);
      for (let v = 0; v < 16; ++v) {
        const J = v * 16;
        for (let ne = 0; ne < 16; ++ne) b[J + ne] = _[v] + _[ne];
      }
      return b;
    }();
    function xe(_) {
      return typeof BigInt > "u" ? ie : _;
    }
    function ie() {
      throw new Error("BigInt not supported");
    }
  })(f5);
  var Ke = rL, SA = f5, h5 = {
    eth: "1",
    jingtum: "2",
    moac: "3",
    eos: "4",
    enu: "5",
    bos: "6",
    iost: "7",
    cosmos: "8",
    binance: "9",
    tron: "10",
    trx: "10",
    btc: "11",
    bsc: "12",
    dot: "13",
    kusama: "14",
    heco: "15",
    okexchain: "16",
    oktest: "17",
    matic: "18",
    polygon: "18",
    hsc: "19",
    oec: "20",
    subgame: "21",
    klaytn: "22",
    avax: "23",
    arb: "24",
    ftm: "25",
    op: "26",
    solana: "27",
    gnosis: "28",
    wax: "29",
    moonbeam: "31",
    aurora: "32",
    harmony: "33",
    kcc: "35",
    cfxevm: "36",
    planton: "37",
    bttc: "38",
    gt: "39",
    halo: "40",
    etc: "41",
    arbnova: "42",
    aptos: "43",
    doge: "44",
    fvm: "45",
    zksync: "46",
    eosevm: "47",
    sui: "48",
    mantle: "49",
    linea: "50",
    base: "51",
    opbnb: "52",
    polygonzkevm: "53",
    core: "54",
    happ: "55",
    scroll: "56",
    zkfair: "57",
    manta: "58",
    bevm: "59",
    metis: "60",
    zeta: "62",
    kroma: "63",
    merlin: "64",
    blast: "65",
    bitlayer: "66",
    xlayer: "67",
    rgbln: "69",
    mint: "70",
    ton: "71"
  }, qf = {
    1: "eth",
    2: "jingtum",
    3: "moac",
    4: "eos",
    5: "enu",
    6: "bos",
    7: "iost",
    8: "cosmos",
    9: "binance",
    10: "tron",
    11: "btc",
    12: "bsc",
    13: "dot",
    14: "kusama",
    15: "heco",
    16: "okexchain",
    17: "oktest",
    18: "matic",
    19: "hsc",
    20: "oec",
    21: "subgame",
    22: "klaytn",
    23: "avax",
    24: "arb",
    25: "ftm",
    26: "op",
    27: "solana",
    28: "gnosis",
    29: "wax",
    31: "moonbeam",
    32: "aurora",
    33: "harmony",
    35: "kcc",
    36: "cfxevm",
    37: "planton",
    38: "bttc",
    39: "gt",
    40: "halo",
    41: "etc",
    42: "arbnova",
    43: "aptos",
    44: "doge",
    45: "fvm",
    46: "zksync",
    47: "eosevm",
    48: "sui",
    49: "mantle",
    50: "linea",
    51: "base",
    52: "opbnb",
    53: "polygonzkevm",
    54: "core",
    55: "happ",
    56: "scroll",
    57: "zkfair",
    58: "manta",
    59: "bevm",
    60: "metis",
    62: "zeta",
    63: "kroma",
    64: "merlin",
    65: "blast",
    66: "bitlayer",
    67: "xlayer",
    69: "rgbln",
    70: "mint",
    71: "ton"
  }, Yf = function(t) {
    var e = /^\s+|\s+$/g;
    return t += "", t = t.replace(e, "").toLowerCase(), h5[t] || t;
  }, We = function() {
    var t = parseInt(Math.random() * 1e5);
    return "tp_callback_" + (/* @__PURE__ */ new Date()).getTime() + t;
  }, ke = function(t, e, n) {
    window.TPJSBrigeClient && window.TPJSBrigeClient.callMessage(t, e, n), window.webkit && window.webkit.messageHandlers && window.webkit.messageHandlers[t] && window.webkit.messageHandlers[t].postMessage({
      body: {
        params: e,
        callback: n
      }
    });
  }, dL = {
    version: "3.7.13",
    isConnected: function() {
      return !!(window.TPJSBrigeClient || window.webkit && window.webkit.messageHandlers && window.webkit.messageHandlers.getNodeUrl);
    },
    invokeQRScanner: function() {
      return new Ke(function(t, e) {
        var n = We();
        window[n] = function(r) {
          r = r.replace(/\r/ig, "").replace(/\n/ig, "");
          try {
            var i = JSON.parse(r), s = i.qrResult || "";
            t(s);
          } catch (o) {
            e(o);
          }
        }, ke("invokeQRScanner", "", n);
      });
    },
    shareNewsToSNS: function(t) {
      var e = t.title || "TokenPocket \u4F60\u7684\u901A\u7528\u6570\u5B57\u94B1\u5305", n = t.desc || "", r = t.url || "https://www.mytokenpocket.vip/", i = t.previewImage || "", s = {
        title: e,
        description: n,
        url: r,
        previewImage: i
      };
      ke("shareNewsToSNS", JSON.stringify(s), "");
    },
    getAppInfo: function() {
      return new Ke(function(t, e) {
        var n = We();
        window[n] = function(r) {
          r = r.replace(/\r/ig, "").replace(/\n/ig, "");
          try {
            var i = JSON.parse(r);
            t(i);
          } catch (s) {
            e(s);
          }
        }, ke("getAppInfo", "", n);
      });
    },
    getDeviceId: function() {
      return new Ke(function(t, e) {
        var n = We();
        window[n] = function(r) {
          r = r.replace(/\r/ig, "").replace(/\n/ig, "");
          try {
            var i = JSON.parse(r);
            i.device_id && (i.data = i.device_id), t(i);
          } catch (s) {
            e(s);
          }
        }, ke("getDeviceId", "", n);
      });
    },
    getWalletList: function(t) {
      if (t = Yf(t), !t) throw new Error("type invalid");
      var e = {
        type: t
      };
      return new Ke(function(n, r) {
        var i = We();
        window[i] = function(s) {
          s = s.replace(/\r/ig, "").replace(/\n/ig, "");
          try {
            var o = JSON.parse(s);
            n(o);
          } catch (a) {
            r(a);
          }
        }, ke("getWalletList", JSON.stringify(e), i);
      });
    },
    getWallets: function() {
      return new Ke(function(t, e) {
        var n = We();
        window[n] = function(r) {
          r = r.replace(/\r/ig, "").replace(/\n/ig, "");
          try {
            var i = JSON.parse(r);
            if (i.data && i.data.length) for (var s = 0; s < i.data.length; s++) i.data[s].blockchain = qf[i.data[s].blockchain_id + ""] || i.data[s].blockchain_id;
            t(i);
          } catch (o) {
            e(o);
          }
        }, ke("getWallets", "", n);
      });
    },
    getCurrentWallet: function() {
      return new Ke(function(t, e) {
        var n = We();
        window[n] = function(r) {
          r = r.replace(/\r/ig, "").replace(/\n/ig, "");
          try {
            var i = JSON.parse(r);
            i.rawTransaction && (i.data = i.rawTransaction), i.data && i.data.blockchain_id && (i.data.blockchain = qf[i.data.blockchain_id + ""] || i.data.blockchain_id), t(i);
          } catch (s) {
            e(s);
          }
        }, ke("getCurrentWallet", "", n);
      });
    },
    sign: function(t) {
      return new Ke(function(e, n) {
        var r = We();
        window[r] = function(i) {
          i = i.replace(/\r/ig, "").replace(/\n/ig, "");
          try {
            var s = JSON.parse(i);
            e(s);
          } catch (o) {
            n(o);
          }
        }, ke("sign", JSON.stringify(t), r);
      });
    },
    back: function() {
      ke("back", "", "");
    },
    fullScreen: function(t) {
      ke("fullScreen", JSON.stringify(t), "");
    },
    setMenubar: function(t) {
      ke("setMenubar", JSON.stringify(t), "");
    },
    close: function() {
      ke("close", "", "");
    },
    importWallet: function(t) {
      if (t = Yf(t), !t) throw new Error("type invalid");
      var e = {
        blockChainId: t
      };
      ke("importWallet", JSON.stringify(e), "");
    },
    startChat: function(t) {
      t.blockchain && (t.blockChainId = Yf(t.blockchain), delete t.blockchain), ke("startChat", JSON.stringify(t), "");
    },
    getNodeUrl: function(t) {
      return t.blockchain && (t.blockChainId = Yf(t.blockchain), delete t.blockchain), new Ke(function(e, n) {
        var r = We();
        window[r] = function(i) {
          i = i.replace(/\r/ig, "").replace(/\n/ig, "");
          try {
            var s = JSON.parse(i);
            s.data && s.data.blockChainId && (s.blockchain = qf[s.data.blockChainId + ""] || s.data.blockChainId), e(s);
          } catch (o) {
            n(o);
          }
        }, ke("getNodeUrl", JSON.stringify(t), r);
      });
    },
    saveImage: function(t) {
      ke("saveImage", JSON.stringify(t), "");
    },
    rollHorizontal: function(t) {
      ke("rollHorizontal", JSON.stringify(t), "");
    },
    popGestureRecognizerEnable: function(t) {
      ke("popGestureRecognizerEnable", JSON.stringify(t), "");
    },
    forwardNavigationGesturesEnable: function(t) {
      ke("forwardNavigationGesturesEnable", JSON.stringify(t), "");
    },
    isDarkMode: function() {
      return new Ke(function(t, e) {
        var n = We();
        window[n] = function(r) {
          r = r.replace(/\r/ig, "").replace(/\n/ig, "");
          try {
            var i = JSON.parse(r);
            t(i);
          } catch (s) {
            e(s);
          }
        }, ke("isDarkMode", "", n);
      });
    },
    eosTokenTransfer: function(t) {
      if (!t.from || !t.to || !t.amount || !t.contract || !t.precision) throw new Error('missing params; "from", "to", "amount", "contract", "precision" is required ');
      return t.amount = "" + t.amount, new Ke(function(e, n) {
        var r = We();
        window[r] = function(i) {
          i = i.replace(/\r/ig, "").replace(/\n/ig, "");
          try {
            var s = JSON.parse(i);
            s.result && !s.data.transactionId && (s.data = {
              transactionId: s.data
            }), e(s);
          } catch (o) {
            n(o);
          }
        }, ke("eosTokenTransfer", JSON.stringify(t), r);
      });
    },
    pushEosAction: function(t) {
      return new Ke(function(e, n) {
        var r = We();
        window[r] = function(i) {
          i = i.replace(/\r/ig, "").replace(/\n/ig, "");
          try {
            var s = JSON.parse(i);
            s.result && !s.data.transactionId && (s.data = {
              transactionId: s.data
            }), e(s);
          } catch (o) {
            n(o);
          }
        }, ke("pushEosAction", JSON.stringify(t), r);
      });
    },
    getEosBalance: function(t) {
      if (!t.account || !t.contract || !t.symbol) throw new Error('missing params; "account", "contract", "symbol" is required ');
      return new Ke(function(e, n) {
        var r = We();
        window[r] = function(i) {
          i = i.replace(/\r/ig, "").replace(/\n/ig, "");
          try {
            var s = JSON.parse(i);
            e(s);
          } catch (o) {
            n(o);
          }
        }, ke("getEosBalance", JSON.stringify(t), r);
      });
    },
    getTableRows: function(t) {
      return new Ke(function(e, n) {
        var r = We();
        window[r] = function(i) {
          i = i.replace(/\r/ig, "").replace(/\n/ig, "");
          try {
            var s = JSON.parse(i);
            e(s);
          } catch (o) {
            n(o);
          }
        }, ke("getTableRows", JSON.stringify(t), r);
      });
    },
    getEosTableRows: function(t) {
      return new Ke(function(e, n) {
        var r = We();
        window[r] = function(i) {
          i = i.replace(/\r/ig, "").replace(/\n/ig, "");
          try {
            var s = JSON.parse(i);
            e(s);
          } catch (o) {
            n(o);
          }
        }, ke("getEosTableRows", JSON.stringify(t), r);
      });
    },
    getEosAccountInfo: function(t) {
      if (!t.account) throw new Error('missing params; "account" is required ');
      return new Ke(function(e, n) {
        var r = We();
        window[r] = function(i) {
          i = i.replace(/\r/ig, "").replace(/\n/ig, "");
          try {
            var s = JSON.parse(i);
            e(s);
          } catch (o) {
            n(o);
          }
        }, ke("getEosAccountInfo", JSON.stringify(t), r);
      });
    },
    getEosTransactionRecord: function(t) {
      if (!t.account) throw new Error('missing params; "account" is required ');
      return t.count = t.count ? +t.count : 10, t.start = t.start ? +t.start : 0, new Ke(function(e, n) {
        var r = We();
        window[r] = function(i) {
          i = i.replace(/\r/ig, "").replace(/\n/ig, "");
          try {
            var s = JSON.parse(i);
            e(s);
          } catch (o) {
            n(o);
          }
        }, ke("getEosTransactionRecord", JSON.stringify(t), r);
      });
    },
    eosAuthSign: function(t) {
      return new Ke(function(e, n) {
        var r = We();
        window[r] = function(i) {
          i = i.replace(/\r/ig, "").replace(/\n/ig, "");
          try {
            var s = JSON.parse(i);
            e(s);
          } catch (o) {
            n(o);
          }
        }, ke("eosAuthSign", JSON.stringify(t), r);
      });
    },
    enuTokenTransfer: function(t) {
      if (!t.from || !t.to || !t.amount || !t.tokenName || !t.contract || !t.precision) throw new Error('missing params; "from", "to", "amount", "tokenName","contract", "precision" is required ');
      return t.amount = "" + t.amount, new Ke(function(e, n) {
        var r = We();
        window[r] = function(i) {
          i = i.replace(/\r/ig, "").replace(/\n/ig, "");
          try {
            var s = JSON.parse(i);
            s.result && !s.data.transactionId && (s.data = {
              transactionId: s.data
            }), e(s);
          } catch (o) {
            n(o);
          }
        }, ke("enuTokenTransfer", JSON.stringify(t), r);
      });
    },
    pushEnuAction: function(t) {
      return new Ke(function(e, n) {
        var r = We();
        window[r] = function(i) {
          i = i.replace(/\r/ig, "").replace(/\n/ig, "");
          try {
            var s = JSON.parse(i);
            s.result && !s.data.transactionId && (s.data = {
              transactionId: s.data
            }), e(s);
          } catch (o) {
            n(o);
          }
        }, ke("pushEnuAction", JSON.stringify(t), r);
      });
    },
    getEnuBalance: function(t) {
      if (!t.account || !t.contract || !t.symbol) throw new Error('missing params; "account", "contract", "symbol" is required ');
      return new Ke(function(e, n) {
        var r = We();
        window[r] = function(i) {
          i = i.replace(/\r/ig, "").replace(/\n/ig, "");
          try {
            var s = JSON.parse(i);
            e(s);
          } catch (o) {
            n(o);
          }
        }, ke("getEnuBalance", JSON.stringify(t), r);
      });
    },
    getEnuTableRows: function(t) {
      return new Ke(function(e, n) {
        var r = We();
        window[r] = function(i) {
          i = i.replace(/\r/ig, "").replace(/\n/ig, "");
          try {
            var s = JSON.parse(i);
            e(s);
          } catch (o) {
            n(o);
          }
        }, ke("getEnuTableRows", JSON.stringify(t), r);
      });
    },
    getEnuAccountInfo: function(t) {
      if (!t.account) throw new Error('missing params; "account" is required ');
      return new Ke(function(e, n) {
        var r = We();
        window[r] = function(i) {
          i = i.replace(/\r/ig, "").replace(/\n/ig, "");
          try {
            var s = JSON.parse(i);
            e(s);
          } catch (o) {
            n(o);
          }
        }, ke("getEnuAccountInfo", JSON.stringify(t), r);
      });
    },
    getEnuTransactionRecord: function(t) {
      if (!t.account) throw new Error('missing params; "account" is required ');
      return t.count = t.count ? +t.count : 10, t.start = t.start ? +t.start : 0, new Ke(function(e, n) {
        var r = We();
        window[r] = function(i) {
          i = i.replace(/\r/ig, "").replace(/\n/ig, "");
          try {
            var s = JSON.parse(i);
            e(s);
          } catch (o) {
            n(o);
          }
        }, ke("getEnuTransactionRecord", JSON.stringify(t), r);
      });
    },
    pushMoacTransaction: function(t) {
      return new Ke(function(e, n) {
        var r = We();
        window[r] = function(i) {
          i = i.replace(/\r/ig, "").replace(/\n/ig, "");
          try {
            var s = JSON.parse(i);
            e(s);
          } catch (o) {
            n(o);
          }
        }, ke("pushMoacTransaction", JSON.stringify(t), r);
      });
    },
    moacTokenTransfer: function(t) {
      if (!t.from || !t.to || !t.amount || !t.gasLimit || !t.tokenName) throw new Error('missing params; "from", "to", "amount", "gasLimit", "tokenName" is required ');
      if (t.contract && !t.decimal) throw new Error('missing params; "decimal" is required ');
      return new Ke(function(e, n) {
        var r = We();
        window[r] = function(i) {
          i = i.replace(/\r/ig, "").replace(/\n/ig, "");
          try {
            var s = JSON.parse(i);
            e(s);
          } catch (o) {
            n(o);
          }
        }, ke("moacTokenTransfer", JSON.stringify(t), r);
      });
    },
    sendMoacTransaction: function(t) {
      return new Ke(function(e, n) {
        var r = We();
        window[r] = function(i) {
          i = i.replace(/\r/ig, "").replace(/\n/ig, "");
          try {
            var s = JSON.parse(i);
            e(s);
          } catch (o) {
            n(o);
          }
        }, ke("sendMoacTransaction", JSON.stringify(t), r);
      });
    },
    sendEthTransaction: function(t) {
      return new Ke(function(e, n) {
        var r = We();
        window[r] = function(i) {
          i = i.replace(/\r/ig, "").replace(/\n/ig, "");
          try {
            var s = JSON.parse(i);
            e(s);
          } catch (o) {
            n(o);
          }
        }, ke("sendEthTransaction", JSON.stringify(t), r);
      });
    },
    signMoacTransaction: function(t) {
      return new Ke(function(e, n) {
        var r = We();
        window[r] = function(i) {
          i = i.replace(/\r/ig, "").replace(/\n/ig, "");
          try {
            var s = JSON.parse(i);
            e(s);
          } catch (o) {
            n(o);
          }
        }, ke("signMoacTransaction", JSON.stringify(t), r);
      });
    },
    signEthTransaction: function(t) {
      return new Ke(function(e, n) {
        var r = We();
        window[r] = function(i) {
          i = i.replace(/\r/ig, "").replace(/\n/ig, "");
          try {
            var s = JSON.parse(i);
            e(s);
          } catch (o) {
            n(o);
          }
        }, ke("signEthTransaction", JSON.stringify(t), r);
      });
    },
    signCosmosTransaction: function(t) {
      return new Ke(function(e, n) {
        var r = We();
        window[r] = function(i) {
          i = i.replace(/\r/ig, "").replace(/\n/ig, "");
          try {
            var s = JSON.parse(i);
            e(s);
          } catch (o) {
            n(o);
          }
        }, ke("signCosmosTransaction", JSON.stringify(t), r);
      });
    },
    cosmosArbitrarySignature: function(t, e) {
      var n = {
        address: t,
        data: e
      };
      return new Ke(function(r, i) {
        var s = We();
        window[s] = function(o) {
          o = o.replace(/\r/ig, "").replace(/\n/ig, "");
          try {
            var a = JSON.parse(o);
            r(a);
          } catch (c) {
            i(c);
          }
        }, ke("cosmosArbitrarySignature", JSON.stringify(n), s);
      });
    },
    signJingtumTransaction: function(t) {
      return new Ke(function(e, n) {
        var r = We();
        window[r] = function(i) {
          i = i.replace(/\r/ig, "").replace(/\n/ig, "");
          try {
            var s = JSON.parse(i);
            e(s);
          } catch (o) {
            n(o);
          }
        }, ke("signJingtumTransaction", JSON.stringify(t), r);
      });
    },
    signOkexchainTransaction: function(t, e) {
      return new Ke(function(n, r) {
        var i = We();
        window[i] = function(o) {
          o = o.replace(/\r/ig, "").replace(/\n/ig, "");
          try {
            var a = JSON.parse(o);
            a.result && a.data && a.data.signatures && es.data.signatures.forEach(function(c) {
              c.signature = c.signature && SA.from(c.signature), c.pub_key.value = c.pub_key.value && SA.from(c.pub_key.value);
            }), n(a);
          } catch (c) {
            r(c);
          }
        };
        var s = {
          tx: t,
          from: e
        };
        ke("signOkexchainTransaction", JSON.stringify(s), i);
      });
    },
    getCurrentBalance: function() {
      return new Ke(function(t, e) {
        var n = We();
        window[n] = function(r) {
          r = r.replace(/\r/ig, "").replace(/\n/ig, "");
          try {
            var i = JSON.parse(r);
            t(i);
          } catch (s) {
            e(s);
          }
        }, ke("getCurrentBalance", "", n);
      });
    },
    btcTokenTransfer: function(t) {
      if (!t.from || !t.to || !t.amount) throw new Error('missing params; "from", "to", "amount" is required ');
      return new Ke(function(e, n) {
        var r = We();
        window[r] = function(i) {
          i = i.replace(/\r/ig, "").replace(/\n/ig, "");
          try {
            var s = JSON.parse(i);
            e(s);
          } catch (o) {
            n(o);
          }
        }, ke("btcTokenTransfer", JSON.stringify(t), r);
      });
    },
    usdtTokenTransfer: function(t) {
      if (!t.from || !t.to || !t.amount) throw new Error('missing params; "from", "to", "amount" is required ');
      return new Ke(function(e, n) {
        var r = We();
        window[r] = function(i) {
          i = i.replace(/\r/ig, "").replace(/\n/ig, "");
          try {
            var s = JSON.parse(i);
            e(s);
          } catch (o) {
            n(o);
          }
        }, ke("usdtTokenTransfer", JSON.stringify(t), r);
      });
    },
    getUsdtAddress: function() {
      return new Ke(function(t, e) {
        var n = We();
        window[n] = function(r) {
          r = r.replace(/\r/ig, "").replace(/\n/ig, "");
          try {
            var i = JSON.parse(r);
            t(i);
          } catch (s) {
            e(s);
          }
        }, ke("getUsdtAddress", "", n);
      });
    },
    getWallet: function(t) {
      return t.walletTypes && t.walletTypes.length ? t.walletTypes = t.walletTypes.map(function(e) {
        return h5[e.toLowerCase()] || e;
      }) : t.walletTypes = [], t.switch === void 0 && (t.switch = true), new Ke(function(e, n) {
        var r = We();
        window[r] = function(i) {
          i = i.replace(/\r/ig, "").replace(/\n/ig, "");
          try {
            var s = JSON.parse(i);
            s.data && s.data.blockchain_id && (s.data.blockchain = qf[s.data.blockchain_id + ""] || s.data.blockchain_id), e(s);
          } catch (o) {
            n(o);
          }
        }, ke("getWallet", JSON.stringify(t), r);
      });
    },
    addDAppToDiscover: function(t) {
      return new Ke(function(e, n) {
        var r = We();
        window[r] = function(i) {
          i = i.replace(/\r/ig, "").replace(/\n/ig, "");
          try {
            var s = JSON.parse(i);
            e(s);
          } catch (o) {
            n(o);
          }
        }, ke("addDAppToDiscover", JSON.stringify(t), r);
      });
    }
  }, hL = dL, p5 = hL;
  typeof window < "u" && typeof window.tp > "u" && (window.tp = p5);
  var pL = p5;
  let jp, gL, b0, TA, CA;
  jp = Js(pL);
  gL = yy();
  Hc = (t) => ({
    success: false,
    result: t
  });
  ah = (t) => ({
    success: true,
    result: t
  });
  b0 = async () => {
    var _a6, _b3, _c5, _d5, _e39, _f6, _g6, _h4;
    const { accountStore: t } = ks();
    let e = false;
    try {
      const n = yy();
      await n.send("eth_requestAccounts", []);
      const r = await n.getSigner();
      let i;
      if (jp && (jp == null ? void 0 : jp.isConnected())) try {
        const { msg: a, result: c, data: l } = await jp.getCurrentWallet();
        if (c) i = l.address;
        else return Hc(a);
      } catch (a) {
        return t5(a), Hc(a);
      }
      else i = await r.getAddress();
      i && xo(i) === xo(t.account) ? e = false : (t.changeAccount(i), e = true), ((_a6 = t == null ? void 0 : t.users) == null ? void 0 : _a6[i]) && ((_c5 = (_b3 = t == null ? void 0 : t.users) == null ? void 0 : _b3[i]) == null ? void 0 : _c5.address) && ((_e39 = (_d5 = t == null ? void 0 : t.users) == null ? void 0 : _d5[i]) == null ? void 0 : _e39.message) && ((_g6 = (_f6 = t == null ? void 0 : t.users) == null ? void 0 : _f6[i]) == null ? void 0 : _g6.signature) && t.changeSign(t.users[i]), xo(t == null ? void 0 : t.account) !== xo((_h4 = t.store) == null ? void 0 : _h4.merchant) && t.changeStore({});
      const s = Se(hn((await n.getNetwork()).chainId)), o = Se(hn(ts.ethChainNumberId));
      return s !== o && window.ethereum.request({
        method: "wallet_addEthereumChain",
        params: [
          ts.chainConfig
        ]
      }).then(() => {
        location.reload();
      }), t.changeLinked(true), ah(e);
    } catch (n) {
      return Hc(n);
    }
  };
  TA = async (t) => {
    const { accountStore: e } = ks();
    e.account || await b0();
    const n = await gL.getSigner();
    try {
      const r = await n.signMessage(t);
      return ah(r);
    } catch (r) {
      return Kc(r), Hc(r);
    }
  };
  CA = async (t) => {
    try {
      const e = await rk(t);
      return ah(e);
    } catch (e) {
      return console.error(e), Hc(e);
    }
  };
  let Dm = Ze(null), mL = Ze(1);
  const yL = () => ({
    loadingToggle: (e, n = 1, r = false) => {
      mL.value = n, e && n === 1 ? cP({
        duration: 0,
        forbidClick: r,
        className: "loadingClass"
      }) : Dm.value && Yg(), Dm.value = e;
    }
  });
  function g5(t, e) {
    return function() {
      return t.apply(e, arguments);
    };
  }
  const { toString: bL } = Object.prototype, { getPrototypeOf: Ay } = Object, { iterator: ch, toStringTag: m5 } = Symbol, lh = /* @__PURE__ */ ((t) => (e) => {
    const n = bL.call(e);
    return t[n] || (t[n] = n.slice(8, -1).toLowerCase());
  })(/* @__PURE__ */ Object.create(null)), Ci = (t) => (t = t.toLowerCase(), (e) => lh(e) === t), uh = (t) => (e) => typeof e === t, { isArray: Sl } = Array, Qu = uh("undefined");
  function xL(t) {
    return t !== null && !Qu(t) && t.constructor !== null && !Qu(t.constructor) && yr(t.constructor.isBuffer) && t.constructor.isBuffer(t);
  }
  const y5 = Ci("ArrayBuffer");
  function AL(t) {
    let e;
    return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? e = ArrayBuffer.isView(t) : e = t && t.buffer && y5(t.buffer), e;
  }
  const wL = uh("string"), yr = uh("function"), b5 = uh("number"), fh = (t) => t !== null && typeof t == "object", vL = (t) => t === true || t === false, x0 = (t) => {
    if (lh(t) !== "object") return false;
    const e = Ay(t);
    return (e === null || e === Object.prototype || Object.getPrototypeOf(e) === null) && !(m5 in t) && !(ch in t);
  }, EL = Ci("Date"), SL = Ci("File"), TL = Ci("Blob"), CL = Ci("FileList"), IL = (t) => fh(t) && yr(t.pipe), PL = (t) => {
    let e;
    return t && (typeof FormData == "function" && t instanceof FormData || yr(t.append) && ((e = lh(t)) === "formdata" || e === "object" && yr(t.toString) && t.toString() === "[object FormData]"));
  }, _L = Ci("URLSearchParams"), [RL, NL, OL, BL] = [
    "ReadableStream",
    "Request",
    "Response",
    "Headers"
  ].map(Ci), ML = (t) => t.trim ? t.trim() : t.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
  function bf(t, e, { allOwnKeys: n = false } = {}) {
    if (t === null || typeof t > "u") return;
    let r, i;
    if (typeof t != "object" && (t = [
      t
    ]), Sl(t)) for (r = 0, i = t.length; r < i; r++) e.call(null, t[r], r, t);
    else {
      const s = n ? Object.getOwnPropertyNames(t) : Object.keys(t), o = s.length;
      let a;
      for (r = 0; r < o; r++) a = s[r], e.call(null, t[a], a, t);
    }
  }
  function x5(t, e) {
    e = e.toLowerCase();
    const n = Object.keys(t);
    let r = n.length, i;
    for (; r-- > 0; ) if (i = n[r], e === i.toLowerCase()) return i;
    return null;
  }
  const ya = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : global, A5 = (t) => !Qu(t) && t !== ya;
  function Um() {
    const { caseless: t } = A5(this) && this || {}, e = {}, n = (r, i) => {
      const s = t && x5(e, i) || i;
      x0(e[s]) && x0(r) ? e[s] = Um(e[s], r) : x0(r) ? e[s] = Um({}, r) : Sl(r) ? e[s] = r.slice() : e[s] = r;
    };
    for (let r = 0, i = arguments.length; r < i; r++) arguments[r] && bf(arguments[r], n);
    return e;
  }
  const kL = (t, e, n, { allOwnKeys: r } = {}) => (bf(e, (i, s) => {
    n && yr(i) ? t[s] = g5(i, n) : t[s] = i;
  }, {
    allOwnKeys: r
  }), t), FL = (t) => (t.charCodeAt(0) === 65279 && (t = t.slice(1)), t), LL = (t, e, n, r) => {
    t.prototype = Object.create(e.prototype, r), t.prototype.constructor = t, Object.defineProperty(t, "super", {
      value: e.prototype
    }), n && Object.assign(t.prototype, n);
  }, DL = (t, e, n, r) => {
    let i, s, o;
    const a = {};
    if (e = e || {}, t == null) return e;
    do {
      for (i = Object.getOwnPropertyNames(t), s = i.length; s-- > 0; ) o = i[s], (!r || r(o, t, e)) && !a[o] && (e[o] = t[o], a[o] = true);
      t = n !== false && Ay(t);
    } while (t && (!n || n(t, e)) && t !== Object.prototype);
    return e;
  }, UL = (t, e, n) => {
    t = String(t), (n === void 0 || n > t.length) && (n = t.length), n -= e.length;
    const r = t.indexOf(e, n);
    return r !== -1 && r === n;
  }, HL = (t) => {
    if (!t) return null;
    if (Sl(t)) return t;
    let e = t.length;
    if (!b5(e)) return null;
    const n = new Array(e);
    for (; e-- > 0; ) n[e] = t[e];
    return n;
  }, GL = /* @__PURE__ */ ((t) => (e) => t && e instanceof t)(typeof Uint8Array < "u" && Ay(Uint8Array)), VL = (t, e) => {
    const r = (t && t[ch]).call(t);
    let i;
    for (; (i = r.next()) && !i.done; ) {
      const s = i.value;
      e.call(t, s[0], s[1]);
    }
  }, zL = (t, e) => {
    let n;
    const r = [];
    for (; (n = t.exec(e)) !== null; ) r.push(n);
    return r;
  }, QL = Ci("HTMLFormElement"), jL = (t) => t.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g, function(n, r, i) {
    return r.toUpperCase() + i;
  }), IA = (({ hasOwnProperty: t }) => (e, n) => t.call(e, n))(Object.prototype), JL = Ci("RegExp"), w5 = (t, e) => {
    const n = Object.getOwnPropertyDescriptors(t), r = {};
    bf(n, (i, s) => {
      let o;
      (o = e(i, s, t)) !== false && (r[s] = o || i);
    }), Object.defineProperties(t, r);
  }, KL = (t) => {
    w5(t, (e, n) => {
      if (yr(t) && [
        "arguments",
        "caller",
        "callee"
      ].indexOf(n) !== -1) return false;
      const r = t[n];
      if (yr(r)) {
        if (e.enumerable = false, "writable" in e) {
          e.writable = false;
          return;
        }
        e.set || (e.set = () => {
          throw Error("Can not rewrite read-only method '" + n + "'");
        });
      }
    });
  }, WL = (t, e) => {
    const n = {}, r = (i) => {
      i.forEach((s) => {
        n[s] = true;
      });
    };
    return Sl(t) ? r(t) : r(String(t).split(e)), n;
  }, qL = () => {
  }, YL = (t, e) => t != null && Number.isFinite(t = +t) ? t : e;
  function XL(t) {
    return !!(t && yr(t.append) && t[m5] === "FormData" && t[ch]);
  }
  const ZL = (t) => {
    const e = new Array(10), n = (r, i) => {
      if (fh(r)) {
        if (e.indexOf(r) >= 0) return;
        if (!("toJSON" in r)) {
          e[i] = r;
          const s = Sl(r) ? [] : {};
          return bf(r, (o, a) => {
            const c = n(o, i + 1);
            !Qu(c) && (s[a] = c);
          }), e[i] = void 0, s;
        }
      }
      return r;
    };
    return n(t, 0);
  }, $L = Ci("AsyncFunction"), eD = (t) => t && (fh(t) || yr(t)) && yr(t.then) && yr(t.catch), v5 = ((t, e) => t ? setImmediate : e ? ((n, r) => (ya.addEventListener("message", ({ source: i, data: s }) => {
    i === ya && s === n && r.length && r.shift()();
  }, false), (i) => {
    r.push(i), ya.postMessage(n, "*");
  }))(`axios@${Math.random()}`, []) : (n) => setTimeout(n))(typeof setImmediate == "function", yr(ya.postMessage)), tD = typeof queueMicrotask < "u" ? queueMicrotask.bind(ya) : typeof process < "u" && process.nextTick || v5, nD = (t) => t != null && yr(t[ch]), he = {
    isArray: Sl,
    isArrayBuffer: y5,
    isBuffer: xL,
    isFormData: PL,
    isArrayBufferView: AL,
    isString: wL,
    isNumber: b5,
    isBoolean: vL,
    isObject: fh,
    isPlainObject: x0,
    isReadableStream: RL,
    isRequest: NL,
    isResponse: OL,
    isHeaders: BL,
    isUndefined: Qu,
    isDate: EL,
    isFile: SL,
    isBlob: TL,
    isRegExp: JL,
    isFunction: yr,
    isStream: IL,
    isURLSearchParams: _L,
    isTypedArray: GL,
    isFileList: CL,
    forEach: bf,
    merge: Um,
    extend: kL,
    trim: ML,
    stripBOM: FL,
    inherits: LL,
    toFlatObject: DL,
    kindOf: lh,
    kindOfTest: Ci,
    endsWith: UL,
    toArray: HL,
    forEachEntry: VL,
    matchAll: zL,
    isHTMLForm: QL,
    hasOwnProperty: IA,
    hasOwnProp: IA,
    reduceDescriptors: w5,
    freezeMethods: KL,
    toObjectSet: WL,
    toCamelCase: jL,
    noop: qL,
    toFiniteNumber: YL,
    findKey: x5,
    global: ya,
    isContextDefined: A5,
    isSpecCompliantForm: XL,
    toJSONObject: ZL,
    isAsyncFn: $L,
    isThenable: eD,
    setImmediate: v5,
    asap: tD,
    isIterable: nD
  };
  function ze(t, e, n, r, i) {
    Error.call(this), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack, this.message = t, this.name = "AxiosError", e && (this.code = e), n && (this.config = n), r && (this.request = r), i && (this.response = i, this.status = i.status ? i.status : null);
  }
  he.inherits(ze, Error, {
    toJSON: function() {
      return {
        message: this.message,
        name: this.name,
        description: this.description,
        number: this.number,
        fileName: this.fileName,
        lineNumber: this.lineNumber,
        columnNumber: this.columnNumber,
        stack: this.stack,
        config: he.toJSONObject(this.config),
        code: this.code,
        status: this.status
      };
    }
  });
  const E5 = ze.prototype, S5 = {};
  [
    "ERR_BAD_OPTION_VALUE",
    "ERR_BAD_OPTION",
    "ECONNABORTED",
    "ETIMEDOUT",
    "ERR_NETWORK",
    "ERR_FR_TOO_MANY_REDIRECTS",
    "ERR_DEPRECATED",
    "ERR_BAD_RESPONSE",
    "ERR_BAD_REQUEST",
    "ERR_CANCELED",
    "ERR_NOT_SUPPORT",
    "ERR_INVALID_URL"
  ].forEach((t) => {
    S5[t] = {
      value: t
    };
  });
  Object.defineProperties(ze, S5);
  Object.defineProperty(E5, "isAxiosError", {
    value: true
  });
  ze.from = (t, e, n, r, i, s) => {
    const o = Object.create(E5);
    return he.toFlatObject(t, o, function(c) {
      return c !== Error.prototype;
    }, (a) => a !== "isAxiosError"), ze.call(o, t.message, e, n, r, i), o.cause = t, o.name = t.name, s && Object.assign(o, s), o;
  };
  const rD = null;
  function Hm(t) {
    return he.isPlainObject(t) || he.isArray(t);
  }
  function T5(t) {
    return he.endsWith(t, "[]") ? t.slice(0, -2) : t;
  }
  function PA(t, e, n) {
    return t ? t.concat(e).map(function(i, s) {
      return i = T5(i), !n && s ? "[" + i + "]" : i;
    }).join(n ? "." : "") : e;
  }
  function iD(t) {
    return he.isArray(t) && !t.some(Hm);
  }
  const sD = he.toFlatObject(he, {}, null, function(e) {
    return /^is[A-Z]/.test(e);
  });
  function dh(t, e, n) {
    if (!he.isObject(t)) throw new TypeError("target must be an object");
    e = e || new FormData(), n = he.toFlatObject(n, {
      metaTokens: true,
      dots: false,
      indexes: false
    }, false, function(x, w) {
      return !he.isUndefined(w[x]);
    });
    const r = n.metaTokens, i = n.visitor || u, s = n.dots, o = n.indexes, c = (n.Blob || typeof Blob < "u" && Blob) && he.isSpecCompliantForm(e);
    if (!he.isFunction(i)) throw new TypeError("visitor must be a function");
    function l(y) {
      if (y === null) return "";
      if (he.isDate(y)) return y.toISOString();
      if (he.isBoolean(y)) return y.toString();
      if (!c && he.isBlob(y)) throw new ze("Blob is not supported. Use a Buffer instead.");
      return he.isArrayBuffer(y) || he.isTypedArray(y) ? c && typeof Blob == "function" ? new Blob([
        y
      ]) : Buffer.from(y) : y;
    }
    function u(y, x, w) {
      let R = y;
      if (y && !w && typeof y == "object") {
        if (he.endsWith(x, "{}")) x = r ? x : x.slice(0, -2), y = JSON.stringify(y);
        else if (he.isArray(y) && iD(y) || (he.isFileList(y) || he.endsWith(x, "[]")) && (R = he.toArray(y))) return x = T5(x), R.forEach(function(B, M) {
          !(he.isUndefined(B) || B === null) && e.append(o === true ? PA([
            x
          ], M, s) : o === null ? x : x + "[]", l(B));
        }), false;
      }
      return Hm(y) ? true : (e.append(PA(w, x, s), l(y)), false);
    }
    const f = [], d = Object.assign(sD, {
      defaultVisitor: u,
      convertValue: l,
      isVisitable: Hm
    });
    function m(y, x) {
      if (!he.isUndefined(y)) {
        if (f.indexOf(y) !== -1) throw Error("Circular reference detected in " + x.join("."));
        f.push(y), he.forEach(y, function(R, O) {
          (!(he.isUndefined(R) || R === null) && i.call(e, R, he.isString(O) ? O.trim() : O, x, d)) === true && m(R, x ? x.concat(O) : [
            O
          ]);
        }), f.pop();
      }
    }
    if (!he.isObject(t)) throw new TypeError("data must be an object");
    return m(t), e;
  }
  function _A(t) {
    const e = {
      "!": "%21",
      "'": "%27",
      "(": "%28",
      ")": "%29",
      "~": "%7E",
      "%20": "+",
      "%00": "\0"
    };
    return encodeURIComponent(t).replace(/[!'()~]|%20|%00/g, function(r) {
      return e[r];
    });
  }
  function wy(t, e) {
    this._pairs = [], t && dh(t, this, e);
  }
  const C5 = wy.prototype;
  C5.append = function(e, n) {
    this._pairs.push([
      e,
      n
    ]);
  };
  C5.toString = function(e) {
    const n = e ? function(r) {
      return e.call(this, r, _A);
    } : _A;
    return this._pairs.map(function(i) {
      return n(i[0]) + "=" + n(i[1]);
    }, "").join("&");
  };
  function oD(t) {
    return encodeURIComponent(t).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
  }
  function I5(t, e, n) {
    if (!e) return t;
    const r = n && n.encode || oD;
    he.isFunction(n) && (n = {
      serialize: n
    });
    const i = n && n.serialize;
    let s;
    if (i ? s = i(e, n) : s = he.isURLSearchParams(e) ? e.toString() : new wy(e, n).toString(r), s) {
      const o = t.indexOf("#");
      o !== -1 && (t = t.slice(0, o)), t += (t.indexOf("?") === -1 ? "?" : "&") + s;
    }
    return t;
  }
  class RA {
    constructor() {
      this.handlers = [];
    }
    use(e, n, r) {
      return this.handlers.push({
        fulfilled: e,
        rejected: n,
        synchronous: r ? r.synchronous : false,
        runWhen: r ? r.runWhen : null
      }), this.handlers.length - 1;
    }
    eject(e) {
      this.handlers[e] && (this.handlers[e] = null);
    }
    clear() {
      this.handlers && (this.handlers = []);
    }
    forEach(e) {
      he.forEach(this.handlers, function(r) {
        r !== null && e(r);
      });
    }
  }
  const P5 = {
    silentJSONParsing: true,
    forcedJSONParsing: true,
    clarifyTimeoutError: false
  }, aD = typeof URLSearchParams < "u" ? URLSearchParams : wy, cD = typeof FormData < "u" ? FormData : null, lD = typeof Blob < "u" ? Blob : null, uD = {
    isBrowser: true,
    classes: {
      URLSearchParams: aD,
      FormData: cD,
      Blob: lD
    },
    protocols: [
      "http",
      "https",
      "file",
      "blob",
      "url",
      "data"
    ]
  }, vy = typeof window < "u" && typeof document < "u", Gm = typeof navigator == "object" && navigator || void 0, fD = vy && (!Gm || [
    "ReactNative",
    "NativeScript",
    "NS"
  ].indexOf(Gm.product) < 0), dD = typeof WorkerGlobalScope < "u" && self instanceof WorkerGlobalScope && typeof self.importScripts == "function", hD = vy && window.location.href || "http://localhost", pD = Object.freeze(Object.defineProperty({
    __proto__: null,
    hasBrowserEnv: vy,
    hasStandardBrowserEnv: fD,
    hasStandardBrowserWebWorkerEnv: dD,
    navigator: Gm,
    origin: hD
  }, Symbol.toStringTag, {
    value: "Module"
  })), Kn = {
    ...pD,
    ...uD
  };
  function gD(t, e) {
    return dh(t, new Kn.classes.URLSearchParams(), Object.assign({
      visitor: function(n, r, i, s) {
        return Kn.isNode && he.isBuffer(n) ? (this.append(r, n.toString("base64")), false) : s.defaultVisitor.apply(this, arguments);
      }
    }, e));
  }
  function mD(t) {
    return he.matchAll(/\w+|\[(\w*)]/g, t).map((e) => e[0] === "[]" ? "" : e[1] || e[0]);
  }
  function yD(t) {
    const e = {}, n = Object.keys(t);
    let r;
    const i = n.length;
    let s;
    for (r = 0; r < i; r++) s = n[r], e[s] = t[s];
    return e;
  }
  function _5(t) {
    function e(n, r, i, s) {
      let o = n[s++];
      if (o === "__proto__") return true;
      const a = Number.isFinite(+o), c = s >= n.length;
      return o = !o && he.isArray(i) ? i.length : o, c ? (he.hasOwnProp(i, o) ? i[o] = [
        i[o],
        r
      ] : i[o] = r, !a) : ((!i[o] || !he.isObject(i[o])) && (i[o] = []), e(n, r, i[o], s) && he.isArray(i[o]) && (i[o] = yD(i[o])), !a);
    }
    if (he.isFormData(t) && he.isFunction(t.entries)) {
      const n = {};
      return he.forEachEntry(t, (r, i) => {
        e(mD(r), i, n, 0);
      }), n;
    }
    return null;
  }
  function bD(t, e, n) {
    if (he.isString(t)) try {
      return (e || JSON.parse)(t), he.trim(t);
    } catch (r) {
      if (r.name !== "SyntaxError") throw r;
    }
    return (n || JSON.stringify)(t);
  }
  const xf = {
    transitional: P5,
    adapter: [
      "xhr",
      "http",
      "fetch"
    ],
    transformRequest: [
      function(e, n) {
        const r = n.getContentType() || "", i = r.indexOf("application/json") > -1, s = he.isObject(e);
        if (s && he.isHTMLForm(e) && (e = new FormData(e)), he.isFormData(e)) return i ? JSON.stringify(_5(e)) : e;
        if (he.isArrayBuffer(e) || he.isBuffer(e) || he.isStream(e) || he.isFile(e) || he.isBlob(e) || he.isReadableStream(e)) return e;
        if (he.isArrayBufferView(e)) return e.buffer;
        if (he.isURLSearchParams(e)) return n.setContentType("application/x-www-form-urlencoded;charset=utf-8", false), e.toString();
        let a;
        if (s) {
          if (r.indexOf("application/x-www-form-urlencoded") > -1) return gD(e, this.formSerializer).toString();
          if ((a = he.isFileList(e)) || r.indexOf("multipart/form-data") > -1) {
            const c = this.env && this.env.FormData;
            return dh(a ? {
              "files[]": e
            } : e, c && new c(), this.formSerializer);
          }
        }
        return s || i ? (n.setContentType("application/json", false), bD(e)) : e;
      }
    ],
    transformResponse: [
      function(e) {
        const n = this.transitional || xf.transitional, r = n && n.forcedJSONParsing, i = this.responseType === "json";
        if (he.isResponse(e) || he.isReadableStream(e)) return e;
        if (e && he.isString(e) && (r && !this.responseType || i)) {
          const o = !(n && n.silentJSONParsing) && i;
          try {
            return JSON.parse(e);
          } catch (a) {
            if (o) throw a.name === "SyntaxError" ? ze.from(a, ze.ERR_BAD_RESPONSE, this, null, this.response) : a;
          }
        }
        return e;
      }
    ],
    timeout: 0,
    xsrfCookieName: "XSRF-TOKEN",
    xsrfHeaderName: "X-XSRF-TOKEN",
    maxContentLength: -1,
    maxBodyLength: -1,
    env: {
      FormData: Kn.classes.FormData,
      Blob: Kn.classes.Blob
    },
    validateStatus: function(e) {
      return e >= 200 && e < 300;
    },
    headers: {
      common: {
        Accept: "application/json, text/plain, */*",
        "Content-Type": void 0
      }
    }
  };
  he.forEach([
    "delete",
    "get",
    "head",
    "post",
    "put",
    "patch"
  ], (t) => {
    xf.headers[t] = {};
  });
  const xD = he.toObjectSet([
    "age",
    "authorization",
    "content-length",
    "content-type",
    "etag",
    "expires",
    "from",
    "host",
    "if-modified-since",
    "if-unmodified-since",
    "last-modified",
    "location",
    "max-forwards",
    "proxy-authorization",
    "referer",
    "retry-after",
    "user-agent"
  ]), AD = (t) => {
    const e = {};
    let n, r, i;
    return t && t.split(`
`).forEach(function(o) {
      i = o.indexOf(":"), n = o.substring(0, i).trim().toLowerCase(), r = o.substring(i + 1).trim(), !(!n || e[n] && xD[n]) && (n === "set-cookie" ? e[n] ? e[n].push(r) : e[n] = [
        r
      ] : e[n] = e[n] ? e[n] + ", " + r : r);
    }), e;
  }, NA = Symbol("internals");
  function zl(t) {
    return t && String(t).trim().toLowerCase();
  }
  function A0(t) {
    return t === false || t == null ? t : he.isArray(t) ? t.map(A0) : String(t);
  }
  function wD(t) {
    const e = /* @__PURE__ */ Object.create(null), n = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
    let r;
    for (; r = n.exec(t); ) e[r[1]] = r[2];
    return e;
  }
  const vD = (t) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(t.trim());
  function Jp(t, e, n, r, i) {
    if (he.isFunction(r)) return r.call(this, e, n);
    if (i && (e = n), !!he.isString(e)) {
      if (he.isString(r)) return e.indexOf(r) !== -1;
      if (he.isRegExp(r)) return r.test(e);
    }
  }
  function ED(t) {
    return t.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (e, n, r) => n.toUpperCase() + r);
  }
  function SD(t, e) {
    const n = he.toCamelCase(" " + e);
    [
      "get",
      "set",
      "has"
    ].forEach((r) => {
      Object.defineProperty(t, r + n, {
        value: function(i, s, o) {
          return this[r].call(this, e, i, s, o);
        },
        configurable: true
      });
    });
  }
  let br = class {
    constructor(e) {
      e && this.set(e);
    }
    set(e, n, r) {
      const i = this;
      function s(a, c, l) {
        const u = zl(c);
        if (!u) throw new Error("header name must be a non-empty string");
        const f = he.findKey(i, u);
        (!f || i[f] === void 0 || l === true || l === void 0 && i[f] !== false) && (i[f || c] = A0(a));
      }
      const o = (a, c) => he.forEach(a, (l, u) => s(l, u, c));
      if (he.isPlainObject(e) || e instanceof this.constructor) o(e, n);
      else if (he.isString(e) && (e = e.trim()) && !vD(e)) o(AD(e), n);
      else if (he.isObject(e) && he.isIterable(e)) {
        let a = {}, c, l;
        for (const u of e) {
          if (!he.isArray(u)) throw TypeError("Object iterator must return a key-value pair");
          a[l = u[0]] = (c = a[l]) ? he.isArray(c) ? [
            ...c,
            u[1]
          ] : [
            c,
            u[1]
          ] : u[1];
        }
        o(a, n);
      } else e != null && s(n, e, r);
      return this;
    }
    get(e, n) {
      if (e = zl(e), e) {
        const r = he.findKey(this, e);
        if (r) {
          const i = this[r];
          if (!n) return i;
          if (n === true) return wD(i);
          if (he.isFunction(n)) return n.call(this, i, r);
          if (he.isRegExp(n)) return n.exec(i);
          throw new TypeError("parser must be boolean|regexp|function");
        }
      }
    }
    has(e, n) {
      if (e = zl(e), e) {
        const r = he.findKey(this, e);
        return !!(r && this[r] !== void 0 && (!n || Jp(this, this[r], r, n)));
      }
      return false;
    }
    delete(e, n) {
      const r = this;
      let i = false;
      function s(o) {
        if (o = zl(o), o) {
          const a = he.findKey(r, o);
          a && (!n || Jp(r, r[a], a, n)) && (delete r[a], i = true);
        }
      }
      return he.isArray(e) ? e.forEach(s) : s(e), i;
    }
    clear(e) {
      const n = Object.keys(this);
      let r = n.length, i = false;
      for (; r--; ) {
        const s = n[r];
        (!e || Jp(this, this[s], s, e, true)) && (delete this[s], i = true);
      }
      return i;
    }
    normalize(e) {
      const n = this, r = {};
      return he.forEach(this, (i, s) => {
        const o = he.findKey(r, s);
        if (o) {
          n[o] = A0(i), delete n[s];
          return;
        }
        const a = e ? ED(s) : String(s).trim();
        a !== s && delete n[s], n[a] = A0(i), r[a] = true;
      }), this;
    }
    concat(...e) {
      return this.constructor.concat(this, ...e);
    }
    toJSON(e) {
      const n = /* @__PURE__ */ Object.create(null);
      return he.forEach(this, (r, i) => {
        r != null && r !== false && (n[i] = e && he.isArray(r) ? r.join(", ") : r);
      }), n;
    }
    [Symbol.iterator]() {
      return Object.entries(this.toJSON())[Symbol.iterator]();
    }
    toString() {
      return Object.entries(this.toJSON()).map(([e, n]) => e + ": " + n).join(`
`);
    }
    getSetCookie() {
      return this.get("set-cookie") || [];
    }
    get [Symbol.toStringTag]() {
      return "AxiosHeaders";
    }
    static from(e) {
      return e instanceof this ? e : new this(e);
    }
    static concat(e, ...n) {
      const r = new this(e);
      return n.forEach((i) => r.set(i)), r;
    }
    static accessor(e) {
      const r = (this[NA] = this[NA] = {
        accessors: {}
      }).accessors, i = this.prototype;
      function s(o) {
        const a = zl(o);
        r[a] || (SD(i, o), r[a] = true);
      }
      return he.isArray(e) ? e.forEach(s) : s(e), this;
    }
  };
  br.accessor([
    "Content-Type",
    "Content-Length",
    "Accept",
    "Accept-Encoding",
    "User-Agent",
    "Authorization"
  ]);
  he.reduceDescriptors(br.prototype, ({ value: t }, e) => {
    let n = e[0].toUpperCase() + e.slice(1);
    return {
      get: () => t,
      set(r) {
        this[n] = r;
      }
    };
  });
  he.freezeMethods(br);
  function Kp(t, e) {
    const n = this || xf, r = e || n, i = br.from(r.headers);
    let s = r.data;
    return he.forEach(t, function(a) {
      s = a.call(n, s, i.normalize(), e ? e.status : void 0);
    }), i.normalize(), s;
  }
  function R5(t) {
    return !!(t && t.__CANCEL__);
  }
  function Tl(t, e, n) {
    ze.call(this, t ?? "canceled", ze.ERR_CANCELED, e, n), this.name = "CanceledError";
  }
  he.inherits(Tl, ze, {
    __CANCEL__: true
  });
  function N5(t, e, n) {
    const r = n.config.validateStatus;
    !n.status || !r || r(n.status) ? t(n) : e(new ze("Request failed with status code " + n.status, [
      ze.ERR_BAD_REQUEST,
      ze.ERR_BAD_RESPONSE
    ][Math.floor(n.status / 100) - 4], n.config, n.request, n));
  }
  function TD(t) {
    const e = /^([-+\w]{1,25})(:?\/\/|:)/.exec(t);
    return e && e[1] || "";
  }
  function CD(t, e) {
    t = t || 10;
    const n = new Array(t), r = new Array(t);
    let i = 0, s = 0, o;
    return e = e !== void 0 ? e : 1e3, function(c) {
      const l = Date.now(), u = r[s];
      o || (o = l), n[i] = c, r[i] = l;
      let f = s, d = 0;
      for (; f !== i; ) d += n[f++], f = f % t;
      if (i = (i + 1) % t, i === s && (s = (s + 1) % t), l - o < e) return;
      const m = u && l - u;
      return m ? Math.round(d * 1e3 / m) : void 0;
    };
  }
  function ID(t, e) {
    let n = 0, r = 1e3 / e, i, s;
    const o = (l, u = Date.now()) => {
      n = u, i = null, s && (clearTimeout(s), s = null), t.apply(null, l);
    };
    return [
      (...l) => {
        const u = Date.now(), f = u - n;
        f >= r ? o(l, u) : (i = l, s || (s = setTimeout(() => {
          s = null, o(i);
        }, r - f)));
      },
      () => i && o(i)
    ];
  }
  const sd = (t, e, n = 3) => {
    let r = 0;
    const i = CD(50, 250);
    return ID((s) => {
      const o = s.loaded, a = s.lengthComputable ? s.total : void 0, c = o - r, l = i(c), u = o <= a;
      r = o;
      const f = {
        loaded: o,
        total: a,
        progress: a ? o / a : void 0,
        bytes: c,
        rate: l || void 0,
        estimated: l && a && u ? (a - o) / l : void 0,
        event: s,
        lengthComputable: a != null,
        [e ? "download" : "upload"]: true
      };
      t(f);
    }, n);
  }, OA = (t, e) => {
    const n = t != null;
    return [
      (r) => e[0]({
        lengthComputable: n,
        total: t,
        loaded: r
      }),
      e[1]
    ];
  }, BA = (t) => (...e) => he.asap(() => t(...e)), PD = Kn.hasStandardBrowserEnv ? /* @__PURE__ */ ((t, e) => (n) => (n = new URL(n, Kn.origin), t.protocol === n.protocol && t.host === n.host && (e || t.port === n.port)))(new URL(Kn.origin), Kn.navigator && /(msie|trident)/i.test(Kn.navigator.userAgent)) : () => true, _D = Kn.hasStandardBrowserEnv ? {
    write(t, e, n, r, i, s) {
      const o = [
        t + "=" + encodeURIComponent(e)
      ];
      he.isNumber(n) && o.push("expires=" + new Date(n).toGMTString()), he.isString(r) && o.push("path=" + r), he.isString(i) && o.push("domain=" + i), s === true && o.push("secure"), document.cookie = o.join("; ");
    },
    read(t) {
      const e = document.cookie.match(new RegExp("(^|;\\s*)(" + t + ")=([^;]*)"));
      return e ? decodeURIComponent(e[3]) : null;
    },
    remove(t) {
      this.write(t, "", Date.now() - 864e5);
    }
  } : {
    write() {
    },
    read() {
      return null;
    },
    remove() {
    }
  };
  function RD(t) {
    return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(t);
  }
  function ND(t, e) {
    return e ? t.replace(/\/?\/$/, "") + "/" + e.replace(/^\/+/, "") : t;
  }
  function O5(t, e, n) {
    let r = !RD(e);
    return t && (r || n == false) ? ND(t, e) : e;
  }
  const MA = (t) => t instanceof br ? {
    ...t
  } : t;
  function Oa(t, e) {
    e = e || {};
    const n = {};
    function r(l, u, f, d) {
      return he.isPlainObject(l) && he.isPlainObject(u) ? he.merge.call({
        caseless: d
      }, l, u) : he.isPlainObject(u) ? he.merge({}, u) : he.isArray(u) ? u.slice() : u;
    }
    function i(l, u, f, d) {
      if (he.isUndefined(u)) {
        if (!he.isUndefined(l)) return r(void 0, l, f, d);
      } else return r(l, u, f, d);
    }
    function s(l, u) {
      if (!he.isUndefined(u)) return r(void 0, u);
    }
    function o(l, u) {
      if (he.isUndefined(u)) {
        if (!he.isUndefined(l)) return r(void 0, l);
      } else return r(void 0, u);
    }
    function a(l, u, f) {
      if (f in e) return r(l, u);
      if (f in t) return r(void 0, l);
    }
    const c = {
      url: s,
      method: s,
      data: s,
      baseURL: o,
      transformRequest: o,
      transformResponse: o,
      paramsSerializer: o,
      timeout: o,
      timeoutMessage: o,
      withCredentials: o,
      withXSRFToken: o,
      adapter: o,
      responseType: o,
      xsrfCookieName: o,
      xsrfHeaderName: o,
      onUploadProgress: o,
      onDownloadProgress: o,
      decompress: o,
      maxContentLength: o,
      maxBodyLength: o,
      beforeRedirect: o,
      transport: o,
      httpAgent: o,
      httpsAgent: o,
      cancelToken: o,
      socketPath: o,
      responseEncoding: o,
      validateStatus: a,
      headers: (l, u, f) => i(MA(l), MA(u), f, true)
    };
    return he.forEach(Object.keys(Object.assign({}, t, e)), function(u) {
      const f = c[u] || i, d = f(t[u], e[u], u);
      he.isUndefined(d) && f !== a || (n[u] = d);
    }), n;
  }
  const B5 = (t) => {
    const e = Oa({}, t);
    let { data: n, withXSRFToken: r, xsrfHeaderName: i, xsrfCookieName: s, headers: o, auth: a } = e;
    e.headers = o = br.from(o), e.url = I5(O5(e.baseURL, e.url, e.allowAbsoluteUrls), t.params, t.paramsSerializer), a && o.set("Authorization", "Basic " + btoa((a.username || "") + ":" + (a.password ? unescape(encodeURIComponent(a.password)) : "")));
    let c;
    if (he.isFormData(n)) {
      if (Kn.hasStandardBrowserEnv || Kn.hasStandardBrowserWebWorkerEnv) o.setContentType(void 0);
      else if ((c = o.getContentType()) !== false) {
        const [l, ...u] = c ? c.split(";").map((f) => f.trim()).filter(Boolean) : [];
        o.setContentType([
          l || "multipart/form-data",
          ...u
        ].join("; "));
      }
    }
    if (Kn.hasStandardBrowserEnv && (r && he.isFunction(r) && (r = r(e)), r || r !== false && PD(e.url))) {
      const l = i && s && _D.read(s);
      l && o.set(i, l);
    }
    return e;
  }, OD = typeof XMLHttpRequest < "u", BD = OD && function(t) {
    return new Promise(function(n, r) {
      const i = B5(t);
      let s = i.data;
      const o = br.from(i.headers).normalize();
      let { responseType: a, onUploadProgress: c, onDownloadProgress: l } = i, u, f, d, m, y;
      function x() {
        m && m(), y && y(), i.cancelToken && i.cancelToken.unsubscribe(u), i.signal && i.signal.removeEventListener("abort", u);
      }
      let w = new XMLHttpRequest();
      w.open(i.method.toUpperCase(), i.url, true), w.timeout = i.timeout;
      function R() {
        if (!w) return;
        const B = br.from("getAllResponseHeaders" in w && w.getAllResponseHeaders()), D = {
          data: !a || a === "text" || a === "json" ? w.responseText : w.response,
          status: w.status,
          statusText: w.statusText,
          headers: B,
          config: t,
          request: w
        };
        N5(function(q) {
          n(q), x();
        }, function(q) {
          r(q), x();
        }, D), w = null;
      }
      "onloadend" in w ? w.onloadend = R : w.onreadystatechange = function() {
        !w || w.readyState !== 4 || w.status === 0 && !(w.responseURL && w.responseURL.indexOf("file:") === 0) || setTimeout(R);
      }, w.onabort = function() {
        w && (r(new ze("Request aborted", ze.ECONNABORTED, t, w)), w = null);
      }, w.onerror = function() {
        r(new ze("Network Error", ze.ERR_NETWORK, t, w)), w = null;
      }, w.ontimeout = function() {
        let M = i.timeout ? "timeout of " + i.timeout + "ms exceeded" : "timeout exceeded";
        const D = i.transitional || P5;
        i.timeoutErrorMessage && (M = i.timeoutErrorMessage), r(new ze(M, D.clarifyTimeoutError ? ze.ETIMEDOUT : ze.ECONNABORTED, t, w)), w = null;
      }, s === void 0 && o.setContentType(null), "setRequestHeader" in w && he.forEach(o.toJSON(), function(M, D) {
        w.setRequestHeader(D, M);
      }), he.isUndefined(i.withCredentials) || (w.withCredentials = !!i.withCredentials), a && a !== "json" && (w.responseType = i.responseType), l && ([d, y] = sd(l, true), w.addEventListener("progress", d)), c && w.upload && ([f, m] = sd(c), w.upload.addEventListener("progress", f), w.upload.addEventListener("loadend", m)), (i.cancelToken || i.signal) && (u = (B) => {
        w && (r(!B || B.type ? new Tl(null, t, w) : B), w.abort(), w = null);
      }, i.cancelToken && i.cancelToken.subscribe(u), i.signal && (i.signal.aborted ? u() : i.signal.addEventListener("abort", u)));
      const O = TD(i.url);
      if (O && Kn.protocols.indexOf(O) === -1) {
        r(new ze("Unsupported protocol " + O + ":", ze.ERR_BAD_REQUEST, t));
        return;
      }
      w.send(s || null);
    });
  }, MD = (t, e) => {
    const { length: n } = t = t ? t.filter(Boolean) : [];
    if (e || n) {
      let r = new AbortController(), i;
      const s = function(l) {
        if (!i) {
          i = true, a();
          const u = l instanceof Error ? l : this.reason;
          r.abort(u instanceof ze ? u : new Tl(u instanceof Error ? u.message : u));
        }
      };
      let o = e && setTimeout(() => {
        o = null, s(new ze(`timeout ${e} of ms exceeded`, ze.ETIMEDOUT));
      }, e);
      const a = () => {
        t && (o && clearTimeout(o), o = null, t.forEach((l) => {
          l.unsubscribe ? l.unsubscribe(s) : l.removeEventListener("abort", s);
        }), t = null);
      };
      t.forEach((l) => l.addEventListener("abort", s));
      const { signal: c } = r;
      return c.unsubscribe = () => he.asap(a), c;
    }
  }, kD = function* (t, e) {
    let n = t.byteLength;
    if (n < e) {
      yield t;
      return;
    }
    let r = 0, i;
    for (; r < n; ) i = r + e, yield t.slice(r, i), r = i;
  }, FD = async function* (t, e) {
    for await (const n of LD(t)) yield* kD(n, e);
  }, LD = async function* (t) {
    if (t[Symbol.asyncIterator]) {
      yield* t;
      return;
    }
    const e = t.getReader();
    try {
      for (; ; ) {
        const { done: n, value: r } = await e.read();
        if (n) break;
        yield r;
      }
    } finally {
      await e.cancel();
    }
  }, kA = (t, e, n, r) => {
    const i = FD(t, e);
    let s = 0, o, a = (c) => {
      o || (o = true, r && r(c));
    };
    return new ReadableStream({
      async pull(c) {
        try {
          const { done: l, value: u } = await i.next();
          if (l) {
            a(), c.close();
            return;
          }
          let f = u.byteLength;
          if (n) {
            let d = s += f;
            n(d);
          }
          c.enqueue(new Uint8Array(u));
        } catch (l) {
          throw a(l), l;
        }
      },
      cancel(c) {
        return a(c), i.return();
      }
    }, {
      highWaterMark: 2
    });
  }, hh = typeof fetch == "function" && typeof Request == "function" && typeof Response == "function", M5 = hh && typeof ReadableStream == "function", DD = hh && (typeof TextEncoder == "function" ? /* @__PURE__ */ ((t) => (e) => t.encode(e))(new TextEncoder()) : async (t) => new Uint8Array(await new Response(t).arrayBuffer())), k5 = (t, ...e) => {
    try {
      return !!t(...e);
    } catch {
      return false;
    }
  }, UD = M5 && k5(() => {
    let t = false;
    const e = new Request(Kn.origin, {
      body: new ReadableStream(),
      method: "POST",
      get duplex() {
        return t = true, "half";
      }
    }).headers.has("Content-Type");
    return t && !e;
  }), FA = 64 * 1024, Vm = M5 && k5(() => he.isReadableStream(new Response("").body)), od = {
    stream: Vm && ((t) => t.body)
  };
  hh && ((t) => {
    [
      "text",
      "arrayBuffer",
      "blob",
      "formData",
      "stream"
    ].forEach((e) => {
      !od[e] && (od[e] = he.isFunction(t[e]) ? (n) => n[e]() : (n, r) => {
        throw new ze(`Response type '${e}' is not supported`, ze.ERR_NOT_SUPPORT, r);
      });
    });
  })(new Response());
  const HD = async (t) => {
    if (t == null) return 0;
    if (he.isBlob(t)) return t.size;
    if (he.isSpecCompliantForm(t)) return (await new Request(Kn.origin, {
      method: "POST",
      body: t
    }).arrayBuffer()).byteLength;
    if (he.isArrayBufferView(t) || he.isArrayBuffer(t)) return t.byteLength;
    if (he.isURLSearchParams(t) && (t = t + ""), he.isString(t)) return (await DD(t)).byteLength;
  }, GD = async (t, e) => {
    const n = he.toFiniteNumber(t.getContentLength());
    return n ?? HD(e);
  }, VD = hh && (async (t) => {
    let { url: e, method: n, data: r, signal: i, cancelToken: s, timeout: o, onDownloadProgress: a, onUploadProgress: c, responseType: l, headers: u, withCredentials: f = "same-origin", fetchOptions: d } = B5(t);
    l = l ? (l + "").toLowerCase() : "text";
    let m = MD([
      i,
      s && s.toAbortSignal()
    ], o), y;
    const x = m && m.unsubscribe && (() => {
      m.unsubscribe();
    });
    let w;
    try {
      if (c && UD && n !== "get" && n !== "head" && (w = await GD(u, r)) !== 0) {
        let D = new Request(e, {
          method: "POST",
          body: r,
          duplex: "half"
        }), H;
        if (he.isFormData(r) && (H = D.headers.get("content-type")) && u.setContentType(H), D.body) {
          const [q, S] = OA(w, sd(BA(c)));
          r = kA(D.body, FA, q, S);
        }
      }
      he.isString(f) || (f = f ? "include" : "omit");
      const R = "credentials" in Request.prototype;
      y = new Request(e, {
        ...d,
        signal: m,
        method: n.toUpperCase(),
        headers: u.normalize().toJSON(),
        body: r,
        duplex: "half",
        credentials: R ? f : void 0
      });
      let O = await fetch(y, d);
      const B = Vm && (l === "stream" || l === "response");
      if (Vm && (a || B && x)) {
        const D = {};
        [
          "status",
          "statusText",
          "headers"
        ].forEach((P) => {
          D[P] = O[P];
        });
        const H = he.toFiniteNumber(O.headers.get("content-length")), [q, S] = a && OA(H, sd(BA(a), true)) || [];
        O = new Response(kA(O.body, FA, q, () => {
          S && S(), x && x();
        }), D);
      }
      l = l || "text";
      let M = await od[he.findKey(od, l) || "text"](O, t);
      return !B && x && x(), await new Promise((D, H) => {
        N5(D, H, {
          data: M,
          headers: br.from(O.headers),
          status: O.status,
          statusText: O.statusText,
          config: t,
          request: y
        });
      });
    } catch (R) {
      throw x && x(), R && R.name === "TypeError" && /Load failed|fetch/i.test(R.message) ? Object.assign(new ze("Network Error", ze.ERR_NETWORK, t, y), {
        cause: R.cause || R
      }) : ze.from(R, R && R.code, t, y);
    }
  }), zm = {
    http: rD,
    xhr: BD,
    fetch: VD
  };
  he.forEach(zm, (t, e) => {
    if (t) {
      try {
        Object.defineProperty(t, "name", {
          value: e
        });
      } catch {
      }
      Object.defineProperty(t, "adapterName", {
        value: e
      });
    }
  });
  const LA = (t) => `- ${t}`, zD = (t) => he.isFunction(t) || t === null || t === false, F5 = {
    getAdapter: (t) => {
      t = he.isArray(t) ? t : [
        t
      ];
      const { length: e } = t;
      let n, r;
      const i = {};
      for (let s = 0; s < e; s++) {
        n = t[s];
        let o;
        if (r = n, !zD(n) && (r = zm[(o = String(n)).toLowerCase()], r === void 0)) throw new ze(`Unknown adapter '${o}'`);
        if (r) break;
        i[o || "#" + s] = r;
      }
      if (!r) {
        const s = Object.entries(i).map(([a, c]) => `adapter ${a} ` + (c === false ? "is not supported by the environment" : "is not available in the build"));
        let o = e ? s.length > 1 ? `since :
` + s.map(LA).join(`
`) : " " + LA(s[0]) : "as no adapter specified";
        throw new ze("There is no suitable adapter to dispatch the request " + o, "ERR_NOT_SUPPORT");
      }
      return r;
    },
    adapters: zm
  };
  function Wp(t) {
    if (t.cancelToken && t.cancelToken.throwIfRequested(), t.signal && t.signal.aborted) throw new Tl(null, t);
  }
  function DA(t) {
    return Wp(t), t.headers = br.from(t.headers), t.data = Kp.call(t, t.transformRequest), [
      "post",
      "put",
      "patch"
    ].indexOf(t.method) !== -1 && t.headers.setContentType("application/x-www-form-urlencoded", false), F5.getAdapter(t.adapter || xf.adapter)(t).then(function(r) {
      return Wp(t), r.data = Kp.call(t, t.transformResponse, r), r.headers = br.from(r.headers), r;
    }, function(r) {
      return R5(r) || (Wp(t), r && r.response && (r.response.data = Kp.call(t, t.transformResponse, r.response), r.response.headers = br.from(r.response.headers))), Promise.reject(r);
    });
  }
  const L5 = "1.10.0", ph = {};
  [
    "object",
    "boolean",
    "number",
    "function",
    "string",
    "symbol"
  ].forEach((t, e) => {
    ph[t] = function(r) {
      return typeof r === t || "a" + (e < 1 ? "n " : " ") + t;
    };
  });
  const UA = {};
  ph.transitional = function(e, n, r) {
    function i(s, o) {
      return "[Axios v" + L5 + "] Transitional option '" + s + "'" + o + (r ? ". " + r : "");
    }
    return (s, o, a) => {
      if (e === false) throw new ze(i(o, " has been removed" + (n ? " in " + n : "")), ze.ERR_DEPRECATED);
      return n && !UA[o] && (UA[o] = true, console.warn(i(o, " has been deprecated since v" + n + " and will be removed in the near future"))), e ? e(s, o, a) : true;
    };
  };
  ph.spelling = function(e) {
    return (n, r) => (console.warn(`${r} is likely a misspelling of ${e}`), true);
  };
  function QD(t, e, n) {
    if (typeof t != "object") throw new ze("options must be an object", ze.ERR_BAD_OPTION_VALUE);
    const r = Object.keys(t);
    let i = r.length;
    for (; i-- > 0; ) {
      const s = r[i], o = e[s];
      if (o) {
        const a = t[s], c = a === void 0 || o(a, s, t);
        if (c !== true) throw new ze("option " + s + " must be " + c, ze.ERR_BAD_OPTION_VALUE);
        continue;
      }
      if (n !== true) throw new ze("Unknown option " + s, ze.ERR_BAD_OPTION);
    }
  }
  const w0 = {
    assertOptions: QD,
    validators: ph
  }, _i = w0.validators;
  let Sa = class {
    constructor(e) {
      this.defaults = e || {}, this.interceptors = {
        request: new RA(),
        response: new RA()
      };
    }
    async request(e, n) {
      try {
        return await this._request(e, n);
      } catch (r) {
        if (r instanceof Error) {
          let i = {};
          Error.captureStackTrace ? Error.captureStackTrace(i) : i = new Error();
          const s = i.stack ? i.stack.replace(/^.+\n/, "") : "";
          try {
            r.stack ? s && !String(r.stack).endsWith(s.replace(/^.+\n.+\n/, "")) && (r.stack += `
` + s) : r.stack = s;
          } catch {
          }
        }
        throw r;
      }
    }
    _request(e, n) {
      typeof e == "string" ? (n = n || {}, n.url = e) : n = e || {}, n = Oa(this.defaults, n);
      const { transitional: r, paramsSerializer: i, headers: s } = n;
      r !== void 0 && w0.assertOptions(r, {
        silentJSONParsing: _i.transitional(_i.boolean),
        forcedJSONParsing: _i.transitional(_i.boolean),
        clarifyTimeoutError: _i.transitional(_i.boolean)
      }, false), i != null && (he.isFunction(i) ? n.paramsSerializer = {
        serialize: i
      } : w0.assertOptions(i, {
        encode: _i.function,
        serialize: _i.function
      }, true)), n.allowAbsoluteUrls !== void 0 || (this.defaults.allowAbsoluteUrls !== void 0 ? n.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls : n.allowAbsoluteUrls = true), w0.assertOptions(n, {
        baseUrl: _i.spelling("baseURL"),
        withXsrfToken: _i.spelling("withXSRFToken")
      }, true), n.method = (n.method || this.defaults.method || "get").toLowerCase();
      let o = s && he.merge(s.common, s[n.method]);
      s && he.forEach([
        "delete",
        "get",
        "head",
        "post",
        "put",
        "patch",
        "common"
      ], (y) => {
        delete s[y];
      }), n.headers = br.concat(o, s);
      const a = [];
      let c = true;
      this.interceptors.request.forEach(function(x) {
        typeof x.runWhen == "function" && x.runWhen(n) === false || (c = c && x.synchronous, a.unshift(x.fulfilled, x.rejected));
      });
      const l = [];
      this.interceptors.response.forEach(function(x) {
        l.push(x.fulfilled, x.rejected);
      });
      let u, f = 0, d;
      if (!c) {
        const y = [
          DA.bind(this),
          void 0
        ];
        for (y.unshift.apply(y, a), y.push.apply(y, l), d = y.length, u = Promise.resolve(n); f < d; ) u = u.then(y[f++], y[f++]);
        return u;
      }
      d = a.length;
      let m = n;
      for (f = 0; f < d; ) {
        const y = a[f++], x = a[f++];
        try {
          m = y(m);
        } catch (w) {
          x.call(this, w);
          break;
        }
      }
      try {
        u = DA.call(this, m);
      } catch (y) {
        return Promise.reject(y);
      }
      for (f = 0, d = l.length; f < d; ) u = u.then(l[f++], l[f++]);
      return u;
    }
    getUri(e) {
      e = Oa(this.defaults, e);
      const n = O5(e.baseURL, e.url, e.allowAbsoluteUrls);
      return I5(n, e.params, e.paramsSerializer);
    }
  };
  he.forEach([
    "delete",
    "get",
    "head",
    "options"
  ], function(e) {
    Sa.prototype[e] = function(n, r) {
      return this.request(Oa(r || {}, {
        method: e,
        url: n,
        data: (r || {}).data
      }));
    };
  });
  he.forEach([
    "post",
    "put",
    "patch"
  ], function(e) {
    function n(r) {
      return function(s, o, a) {
        return this.request(Oa(a || {}, {
          method: e,
          headers: r ? {
            "Content-Type": "multipart/form-data"
          } : {},
          url: s,
          data: o
        }));
      };
    }
    Sa.prototype[e] = n(), Sa.prototype[e + "Form"] = n(true);
  });
  let jD = class D5 {
    constructor(e) {
      if (typeof e != "function") throw new TypeError("executor must be a function.");
      let n;
      this.promise = new Promise(function(s) {
        n = s;
      });
      const r = this;
      this.promise.then((i) => {
        if (!r._listeners) return;
        let s = r._listeners.length;
        for (; s-- > 0; ) r._listeners[s](i);
        r._listeners = null;
      }), this.promise.then = (i) => {
        let s;
        const o = new Promise((a) => {
          r.subscribe(a), s = a;
        }).then(i);
        return o.cancel = function() {
          r.unsubscribe(s);
        }, o;
      }, e(function(s, o, a) {
        r.reason || (r.reason = new Tl(s, o, a), n(r.reason));
      });
    }
    throwIfRequested() {
      if (this.reason) throw this.reason;
    }
    subscribe(e) {
      if (this.reason) {
        e(this.reason);
        return;
      }
      this._listeners ? this._listeners.push(e) : this._listeners = [
        e
      ];
    }
    unsubscribe(e) {
      if (!this._listeners) return;
      const n = this._listeners.indexOf(e);
      n !== -1 && this._listeners.splice(n, 1);
    }
    toAbortSignal() {
      const e = new AbortController(), n = (r) => {
        e.abort(r);
      };
      return this.subscribe(n), e.signal.unsubscribe = () => this.unsubscribe(n), e.signal;
    }
    static source() {
      let e;
      return {
        token: new D5(function(i) {
          e = i;
        }),
        cancel: e
      };
    }
  };
  function JD(t) {
    return function(n) {
      return t.apply(null, n);
    };
  }
  function KD(t) {
    return he.isObject(t) && t.isAxiosError === true;
  }
  const Qm = {
    Continue: 100,
    SwitchingProtocols: 101,
    Processing: 102,
    EarlyHints: 103,
    Ok: 200,
    Created: 201,
    Accepted: 202,
    NonAuthoritativeInformation: 203,
    NoContent: 204,
    ResetContent: 205,
    PartialContent: 206,
    MultiStatus: 207,
    AlreadyReported: 208,
    ImUsed: 226,
    MultipleChoices: 300,
    MovedPermanently: 301,
    Found: 302,
    SeeOther: 303,
    NotModified: 304,
    UseProxy: 305,
    Unused: 306,
    TemporaryRedirect: 307,
    PermanentRedirect: 308,
    BadRequest: 400,
    Unauthorized: 401,
    PaymentRequired: 402,
    Forbidden: 403,
    NotFound: 404,
    MethodNotAllowed: 405,
    NotAcceptable: 406,
    ProxyAuthenticationRequired: 407,
    RequestTimeout: 408,
    Conflict: 409,
    Gone: 410,
    LengthRequired: 411,
    PreconditionFailed: 412,
    PayloadTooLarge: 413,
    UriTooLong: 414,
    UnsupportedMediaType: 415,
    RangeNotSatisfiable: 416,
    ExpectationFailed: 417,
    ImATeapot: 418,
    MisdirectedRequest: 421,
    UnprocessableEntity: 422,
    Locked: 423,
    FailedDependency: 424,
    TooEarly: 425,
    UpgradeRequired: 426,
    PreconditionRequired: 428,
    TooManyRequests: 429,
    RequestHeaderFieldsTooLarge: 431,
    UnavailableForLegalReasons: 451,
    InternalServerError: 500,
    NotImplemented: 501,
    BadGateway: 502,
    ServiceUnavailable: 503,
    GatewayTimeout: 504,
    HttpVersionNotSupported: 505,
    VariantAlsoNegotiates: 506,
    InsufficientStorage: 507,
    LoopDetected: 508,
    NotExtended: 510,
    NetworkAuthenticationRequired: 511
  };
  Object.entries(Qm).forEach(([t, e]) => {
    Qm[e] = t;
  });
  function U5(t) {
    const e = new Sa(t), n = g5(Sa.prototype.request, e);
    return he.extend(n, Sa.prototype, e, {
      allOwnKeys: true
    }), he.extend(n, e, null, {
      allOwnKeys: true
    }), n.create = function(i) {
      return U5(Oa(t, i));
    }, n;
  }
  const rn = U5(xf);
  rn.Axios = Sa;
  rn.CanceledError = Tl;
  rn.CancelToken = jD;
  rn.isCancel = R5;
  rn.VERSION = L5;
  rn.toFormData = dh;
  rn.AxiosError = ze;
  rn.Cancel = rn.CanceledError;
  rn.all = function(e) {
    return Promise.all(e);
  };
  rn.spread = JD;
  rn.isAxiosError = KD;
  rn.mergeConfig = Oa;
  rn.AxiosHeaders = br;
  rn.formToJSON = (t) => _5(he.isHTMLForm(t) ? new FormData(t) : t);
  rn.getAdapter = F5.getAdapter;
  rn.HttpStatusCode = Qm;
  rn.default = rn;
  const { Axios: Pq, AxiosError: _q, CanceledError: Rq, isCancel: Nq, CancelToken: Oq, VERSION: Bq, all: Mq, Cancel: kq, isAxiosError: Fq, spread: Lq, toFormData: Dq, AxiosHeaders: Uq, HttpStatusCode: Hq, formToJSON: Gq, getAdapter: Vq, mergeConfig: zq } = rn;
  var Cl = TypeError;
  const WD = {}, qD = Object.freeze(Object.defineProperty({
    __proto__: null,
    default: WD
  }, Symbol.toStringTag, {
    value: "Module"
  })), H5 = sn(qD);
  var Ey = typeof Map == "function" && Map.prototype, qp = Object.getOwnPropertyDescriptor && Ey ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null, ad = Ey && qp && typeof qp.get == "function" ? qp.get : null, HA = Ey && Map.prototype.forEach, Sy = typeof Set == "function" && Set.prototype, Yp = Object.getOwnPropertyDescriptor && Sy ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null, cd = Sy && Yp && typeof Yp.get == "function" ? Yp.get : null, GA = Sy && Set.prototype.forEach, YD = typeof WeakMap == "function" && WeakMap.prototype, gu = YD ? WeakMap.prototype.has : null, XD = typeof WeakSet == "function" && WeakSet.prototype, mu = XD ? WeakSet.prototype.has : null, ZD = typeof WeakRef == "function" && WeakRef.prototype, VA = ZD ? WeakRef.prototype.deref : null, $D = Boolean.prototype.valueOf, eU = Object.prototype.toString, tU = Function.prototype.toString, nU = String.prototype.match, Ty = String.prototype.slice, Ao = String.prototype.replace, rU = String.prototype.toUpperCase, zA = String.prototype.toLowerCase, G5 = RegExp.prototype.test, QA = Array.prototype.concat, Di = Array.prototype.join, iU = Array.prototype.slice, jA = Math.floor, jm = typeof BigInt == "function" ? BigInt.prototype.valueOf : null, Xp = Object.getOwnPropertySymbols, Jm = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? Symbol.prototype.toString : null, ll = typeof Symbol == "function" && typeof Symbol.iterator == "object", yu = typeof Symbol == "function" && Symbol.toStringTag && (typeof Symbol.toStringTag === ll || true) ? Symbol.toStringTag : null, V5 = Object.prototype.propertyIsEnumerable, JA = (typeof Reflect == "function" ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(t) {
    return t.__proto__;
  } : null);
  function KA(t, e) {
    if (t === 1 / 0 || t === -1 / 0 || t !== t || t && t > -1e3 && t < 1e3 || G5.call(/e/, e)) return e;
    var n = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
    if (typeof t == "number") {
      var r = t < 0 ? -jA(-t) : jA(t);
      if (r !== t) {
        var i = String(r), s = Ty.call(e, i.length + 1);
        return Ao.call(i, n, "$&_") + "." + Ao.call(Ao.call(s, /([0-9]{3})/g, "$&_"), /_$/, "");
      }
    }
    return Ao.call(e, n, "$&_");
  }
  var Km = H5, WA = Km.custom, qA = j5(WA) ? WA : null, z5 = {
    __proto__: null,
    double: '"',
    single: "'"
  }, sU = {
    __proto__: null,
    double: /(["\\])/g,
    single: /(['\\])/g
  }, gh = function t(e, n, r, i) {
    var s = n || {};
    if (xs(s, "quoteStyle") && !xs(z5, s.quoteStyle)) throw new TypeError('option "quoteStyle" must be "single" or "double"');
    if (xs(s, "maxStringLength") && (typeof s.maxStringLength == "number" ? s.maxStringLength < 0 && s.maxStringLength !== 1 / 0 : s.maxStringLength !== null)) throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
    var o = xs(s, "customInspect") ? s.customInspect : true;
    if (typeof o != "boolean" && o !== "symbol") throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
    if (xs(s, "indent") && s.indent !== null && s.indent !== "	" && !(parseInt(s.indent, 10) === s.indent && s.indent > 0)) throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
    if (xs(s, "numericSeparator") && typeof s.numericSeparator != "boolean") throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
    var a = s.numericSeparator;
    if (typeof e > "u") return "undefined";
    if (e === null) return "null";
    if (typeof e == "boolean") return e ? "true" : "false";
    if (typeof e == "string") return K5(e, s);
    if (typeof e == "number") {
      if (e === 0) return 1 / 0 / e > 0 ? "0" : "-0";
      var c = String(e);
      return a ? KA(e, c) : c;
    }
    if (typeof e == "bigint") {
      var l = String(e) + "n";
      return a ? KA(e, l) : l;
    }
    var u = typeof s.depth > "u" ? 5 : s.depth;
    if (typeof r > "u" && (r = 0), r >= u && u > 0 && typeof e == "object") return Wm(e) ? "[Array]" : "[Object]";
    var f = EU(s, r);
    if (typeof i > "u") i = [];
    else if (J5(i, e) >= 0) return "[Circular]";
    function d(I, h, p) {
      if (h && (i = iU.call(i), i.push(h)), p) {
        var A = {
          depth: s.depth
        };
        return xs(s, "quoteStyle") && (A.quoteStyle = s.quoteStyle), t(I, A, r + 1, i);
      }
      return t(I, s, r + 1, i);
    }
    if (typeof e == "function" && !YA(e)) {
      var m = pU(e), y = Xf(e, d);
      return "[Function" + (m ? ": " + m : " (anonymous)") + "]" + (y.length > 0 ? " { " + Di.call(y, ", ") + " }" : "");
    }
    if (j5(e)) {
      var x = ll ? Ao.call(String(e), /^(Symbol\(.*\))_[^)]*$/, "$1") : Jm.call(e);
      return typeof e == "object" && !ll ? Ql(x) : x;
    }
    if (AU(e)) {
      for (var w = "<" + zA.call(String(e.nodeName)), R = e.attributes || [], O = 0; O < R.length; O++) w += " " + R[O].name + "=" + Q5(oU(R[O].value), "double", s);
      return w += ">", e.childNodes && e.childNodes.length && (w += "..."), w += "</" + zA.call(String(e.nodeName)) + ">", w;
    }
    if (Wm(e)) {
      if (e.length === 0) return "[]";
      var B = Xf(e, d);
      return f && !vU(B) ? "[" + qm(B, f) + "]" : "[ " + Di.call(B, ", ") + " ]";
    }
    if (cU(e)) {
      var M = Xf(e, d);
      return !("cause" in Error.prototype) && "cause" in e && !V5.call(e, "cause") ? "{ [" + String(e) + "] " + Di.call(QA.call("[cause]: " + d(e.cause), M), ", ") + " }" : M.length === 0 ? "[" + String(e) + "]" : "{ [" + String(e) + "] " + Di.call(M, ", ") + " }";
    }
    if (typeof e == "object" && o) {
      if (qA && typeof e[qA] == "function" && Km) return Km(e, {
        depth: u - r
      });
      if (o !== "symbol" && typeof e.inspect == "function") return e.inspect();
    }
    if (gU(e)) {
      var D = [];
      return HA && HA.call(e, function(I, h) {
        D.push(d(h, e, true) + " => " + d(I, e));
      }), XA("Map", ad.call(e), D, f);
    }
    if (bU(e)) {
      var H = [];
      return GA && GA.call(e, function(I) {
        H.push(d(I, e));
      }), XA("Set", cd.call(e), H, f);
    }
    if (mU(e)) return Zp("WeakMap");
    if (xU(e)) return Zp("WeakSet");
    if (yU(e)) return Zp("WeakRef");
    if (uU(e)) return Ql(d(Number(e)));
    if (dU(e)) return Ql(d(jm.call(e)));
    if (fU(e)) return Ql($D.call(e));
    if (lU(e)) return Ql(d(String(e)));
    if (typeof window < "u" && e === window) return "{ [object Window] }";
    if (typeof globalThis < "u" && e === globalThis || typeof Cr < "u" && e === Cr) return "{ [object globalThis] }";
    if (!aU(e) && !YA(e)) {
      var q = Xf(e, d), S = JA ? JA(e) === Object.prototype : e instanceof Object || e.constructor === Object, P = e instanceof Object ? "" : "null prototype", L = !S && yu && Object(e) === e && yu in e ? Ty.call(Do(e), 8, -1) : P ? "Object" : "", K = S || typeof e.constructor != "function" ? "" : e.constructor.name ? e.constructor.name + " " : "", z = K + (L || P ? "[" + Di.call(QA.call([], L || [], P || []), ": ") + "] " : "");
      return q.length === 0 ? z + "{}" : f ? z + "{" + qm(q, f) + "}" : z + "{ " + Di.call(q, ", ") + " }";
    }
    return String(e);
  };
  function Q5(t, e, n) {
    var r = n.quoteStyle || e, i = z5[r];
    return i + t + i;
  }
  function oU(t) {
    return Ao.call(String(t), /"/g, "&quot;");
  }
  function Va(t) {
    return !yu || !(typeof t == "object" && (yu in t || typeof t[yu] < "u"));
  }
  function Wm(t) {
    return Do(t) === "[object Array]" && Va(t);
  }
  function aU(t) {
    return Do(t) === "[object Date]" && Va(t);
  }
  function YA(t) {
    return Do(t) === "[object RegExp]" && Va(t);
  }
  function cU(t) {
    return Do(t) === "[object Error]" && Va(t);
  }
  function lU(t) {
    return Do(t) === "[object String]" && Va(t);
  }
  function uU(t) {
    return Do(t) === "[object Number]" && Va(t);
  }
  function fU(t) {
    return Do(t) === "[object Boolean]" && Va(t);
  }
  function j5(t) {
    if (ll) return t && typeof t == "object" && t instanceof Symbol;
    if (typeof t == "symbol") return true;
    if (!t || typeof t != "object" || !Jm) return false;
    try {
      return Jm.call(t), true;
    } catch {
    }
    return false;
  }
  function dU(t) {
    if (!t || typeof t != "object" || !jm) return false;
    try {
      return jm.call(t), true;
    } catch {
    }
    return false;
  }
  var hU = Object.prototype.hasOwnProperty || function(t) {
    return t in this;
  };
  function xs(t, e) {
    return hU.call(t, e);
  }
  function Do(t) {
    return eU.call(t);
  }
  function pU(t) {
    if (t.name) return t.name;
    var e = nU.call(tU.call(t), /^function\s*([\w$]+)/);
    return e ? e[1] : null;
  }
  function J5(t, e) {
    if (t.indexOf) return t.indexOf(e);
    for (var n = 0, r = t.length; n < r; n++) if (t[n] === e) return n;
    return -1;
  }
  function gU(t) {
    if (!ad || !t || typeof t != "object") return false;
    try {
      ad.call(t);
      try {
        cd.call(t);
      } catch {
        return true;
      }
      return t instanceof Map;
    } catch {
    }
    return false;
  }
  function mU(t) {
    if (!gu || !t || typeof t != "object") return false;
    try {
      gu.call(t, gu);
      try {
        mu.call(t, mu);
      } catch {
        return true;
      }
      return t instanceof WeakMap;
    } catch {
    }
    return false;
  }
  function yU(t) {
    if (!VA || !t || typeof t != "object") return false;
    try {
      return VA.call(t), true;
    } catch {
    }
    return false;
  }
  function bU(t) {
    if (!cd || !t || typeof t != "object") return false;
    try {
      cd.call(t);
      try {
        ad.call(t);
      } catch {
        return true;
      }
      return t instanceof Set;
    } catch {
    }
    return false;
  }
  function xU(t) {
    if (!mu || !t || typeof t != "object") return false;
    try {
      mu.call(t, mu);
      try {
        gu.call(t, gu);
      } catch {
        return true;
      }
      return t instanceof WeakSet;
    } catch {
    }
    return false;
  }
  function AU(t) {
    return !t || typeof t != "object" ? false : typeof HTMLElement < "u" && t instanceof HTMLElement ? true : typeof t.nodeName == "string" && typeof t.getAttribute == "function";
  }
  function K5(t, e) {
    if (t.length > e.maxStringLength) {
      var n = t.length - e.maxStringLength, r = "... " + n + " more character" + (n > 1 ? "s" : "");
      return K5(Ty.call(t, 0, e.maxStringLength), e) + r;
    }
    var i = sU[e.quoteStyle || "single"];
    i.lastIndex = 0;
    var s = Ao.call(Ao.call(t, i, "\\$1"), /[\x00-\x1f]/g, wU);
    return Q5(s, "single", e);
  }
  function wU(t) {
    var e = t.charCodeAt(0), n = {
      8: "b",
      9: "t",
      10: "n",
      12: "f",
      13: "r"
    }[e];
    return n ? "\\" + n : "\\x" + (e < 16 ? "0" : "") + rU.call(e.toString(16));
  }
  function Ql(t) {
    return "Object(" + t + ")";
  }
  function Zp(t) {
    return t + " { ? }";
  }
  function XA(t, e, n, r) {
    var i = r ? qm(n, r) : Di.call(n, ", ");
    return t + " (" + e + ") {" + i + "}";
  }
  function vU(t) {
    for (var e = 0; e < t.length; e++) if (J5(t[e], `
`) >= 0) return false;
    return true;
  }
  function EU(t, e) {
    var n;
    if (t.indent === "	") n = "	";
    else if (typeof t.indent == "number" && t.indent > 0) n = Di.call(Array(t.indent + 1), " ");
    else return null;
    return {
      base: n,
      prev: Di.call(Array(e + 1), n)
    };
  }
  function qm(t, e) {
    if (t.length === 0) return "";
    var n = `
` + e.prev + e.base;
    return n + Di.call(t, "," + n) + `
` + e.prev;
  }
  function Xf(t, e) {
    var n = Wm(t), r = [];
    if (n) {
      r.length = t.length;
      for (var i = 0; i < t.length; i++) r[i] = xs(t, i) ? e(t[i], t) : "";
    }
    var s = typeof Xp == "function" ? Xp(t) : [], o;
    if (ll) {
      o = {};
      for (var a = 0; a < s.length; a++) o["$" + s[a]] = s[a];
    }
    for (var c in t) xs(t, c) && (n && String(Number(c)) === c && c < t.length || ll && o["$" + c] instanceof Symbol || (G5.call(/[^\w$]/, c) ? r.push(e(c, t) + ": " + e(t[c], t)) : r.push(c + ": " + e(t[c], t))));
    if (typeof Xp == "function") for (var l = 0; l < s.length; l++) V5.call(t, s[l]) && r.push("[" + e(s[l]) + "]: " + e(t[s[l]], t));
    return r;
  }
  var SU = gh, TU = Cl, mh = function(t, e, n) {
    for (var r = t, i; (i = r.next) != null; r = i) if (i.key === e) return r.next = i.next, n || (i.next = t.next, t.next = i), i;
  }, CU = function(t, e) {
    if (t) {
      var n = mh(t, e);
      return n && n.value;
    }
  }, IU = function(t, e, n) {
    var r = mh(t, e);
    r ? r.value = n : t.next = {
      key: e,
      next: t.next,
      value: n
    };
  }, PU = function(t, e) {
    return t ? !!mh(t, e) : false;
  }, _U = function(t, e) {
    if (t) return mh(t, e, true);
  }, RU = function() {
    var e, n = {
      assert: function(r) {
        if (!n.has(r)) throw new TU("Side channel does not contain " + SU(r));
      },
      delete: function(r) {
        var i = e && e.next, s = _U(e, r);
        return s && i && i === s && (e = void 0), !!s;
      },
      get: function(r) {
        return CU(e, r);
      },
      has: function(r) {
        return PU(e, r);
      },
      set: function(r, i) {
        e || (e = {
          next: void 0
        }), IU(e, r, i);
      }
    };
    return n;
  }, W5 = Object, NU = Error, OU = EvalError, BU = RangeError, MU = ReferenceError, kU = SyntaxError, FU = URIError, LU = Math.abs, DU = Math.floor, UU = Math.max, HU = Math.min, GU = Math.pow, VU = Math.round, zU = Number.isNaN || function(e) {
    return e !== e;
  }, QU = zU, jU = function(e) {
    return QU(e) || e === 0 ? e : e < 0 ? -1 : 1;
  }, JU = Object.getOwnPropertyDescriptor, v0 = JU;
  if (v0) try {
    v0([], "length");
  } catch {
    v0 = null;
  }
  var q5 = v0, E0 = Object.defineProperty || false;
  if (E0) try {
    E0({}, "a", {
      value: 1
    });
  } catch {
    E0 = false;
  }
  var KU = E0, $p, ZA;
  function WU() {
    return ZA || (ZA = 1, $p = function() {
      if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function") return false;
      if (typeof Symbol.iterator == "symbol") return true;
      var e = {}, n = Symbol("test"), r = Object(n);
      if (typeof n == "string" || Object.prototype.toString.call(n) !== "[object Symbol]" || Object.prototype.toString.call(r) !== "[object Symbol]") return false;
      var i = 42;
      e[n] = i;
      for (var s in e) return false;
      if (typeof Object.keys == "function" && Object.keys(e).length !== 0 || typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(e).length !== 0) return false;
      var o = Object.getOwnPropertySymbols(e);
      if (o.length !== 1 || o[0] !== n || !Object.prototype.propertyIsEnumerable.call(e, n)) return false;
      if (typeof Object.getOwnPropertyDescriptor == "function") {
        var a = Object.getOwnPropertyDescriptor(e, n);
        if (a.value !== i || a.enumerable !== true) return false;
      }
      return true;
    }), $p;
  }
  var eg, $A;
  function qU() {
    if ($A) return eg;
    $A = 1;
    var t = typeof Symbol < "u" && Symbol, e = WU();
    return eg = function() {
      return typeof t != "function" || typeof Symbol != "function" || typeof t("foo") != "symbol" || typeof Symbol("bar") != "symbol" ? false : e();
    }, eg;
  }
  var tg, ew;
  function Y5() {
    return ew || (ew = 1, tg = typeof Reflect < "u" && Reflect.getPrototypeOf || null), tg;
  }
  var ng, tw;
  function X5() {
    if (tw) return ng;
    tw = 1;
    var t = W5;
    return ng = t.getPrototypeOf || null, ng;
  }
  var rg, nw;
  function YU() {
    if (nw) return rg;
    nw = 1;
    var t = "Function.prototype.bind called on incompatible ", e = Object.prototype.toString, n = Math.max, r = "[object Function]", i = function(c, l) {
      for (var u = [], f = 0; f < c.length; f += 1) u[f] = c[f];
      for (var d = 0; d < l.length; d += 1) u[d + c.length] = l[d];
      return u;
    }, s = function(c, l) {
      for (var u = [], f = l, d = 0; f < c.length; f += 1, d += 1) u[d] = c[f];
      return u;
    }, o = function(a, c) {
      for (var l = "", u = 0; u < a.length; u += 1) l += a[u], u + 1 < a.length && (l += c);
      return l;
    };
    return rg = function(c) {
      var l = this;
      if (typeof l != "function" || e.apply(l) !== r) throw new TypeError(t + l);
      for (var u = s(arguments, 1), f, d = function() {
        if (this instanceof f) {
          var R = l.apply(this, i(u, arguments));
          return Object(R) === R ? R : this;
        }
        return l.apply(c, i(u, arguments));
      }, m = n(0, l.length - u.length), y = [], x = 0; x < m; x++) y[x] = "$" + x;
      if (f = Function("binder", "return function (" + o(y, ",") + "){ return binder.apply(this,arguments); }")(d), l.prototype) {
        var w = function() {
        };
        w.prototype = l.prototype, f.prototype = new w(), w.prototype = null;
      }
      return f;
    }, rg;
  }
  var ig, rw;
  function yh() {
    if (rw) return ig;
    rw = 1;
    var t = YU();
    return ig = Function.prototype.bind || t, ig;
  }
  var sg, iw;
  function Cy() {
    return iw || (iw = 1, sg = Function.prototype.call), sg;
  }
  var og, sw;
  function Z5() {
    return sw || (sw = 1, og = Function.prototype.apply), og;
  }
  var XU = typeof Reflect < "u" && Reflect && Reflect.apply, ZU = yh(), $U = Z5(), eH = Cy(), tH = XU, nH = tH || ZU.call(eH, $U), rH = yh(), iH = Cl, sH = Cy(), oH = nH, $5 = function(e) {
    if (e.length < 1 || typeof e[0] != "function") throw new iH("a function is required");
    return oH(rH, sH, e);
  }, ag, ow;
  function aH() {
    if (ow) return ag;
    ow = 1;
    var t = $5, e = q5, n;
    try {
      n = [].__proto__ === Array.prototype;
    } catch (o) {
      if (!o || typeof o != "object" || !("code" in o) || o.code !== "ERR_PROTO_ACCESS") throw o;
    }
    var r = !!n && e && e(Object.prototype, "__proto__"), i = Object, s = i.getPrototypeOf;
    return ag = r && typeof r.get == "function" ? t([
      r.get
    ]) : typeof s == "function" ? function(a) {
      return s(a == null ? a : i(a));
    } : false, ag;
  }
  var cg, aw;
  function cH() {
    if (aw) return cg;
    aw = 1;
    var t = Y5(), e = X5(), n = aH();
    return cg = t ? function(i) {
      return t(i);
    } : e ? function(i) {
      if (!i || typeof i != "object" && typeof i != "function") throw new TypeError("getProto: not an object");
      return e(i);
    } : n ? function(i) {
      return n(i);
    } : null, cg;
  }
  var lg, cw;
  function lH() {
    if (cw) return lg;
    cw = 1;
    var t = Function.prototype.call, e = Object.prototype.hasOwnProperty, n = yh();
    return lg = n.call(t, e), lg;
  }
  var Xe, uH = W5, fH = NU, dH = OU, hH = BU, pH = MU, ul = kU, Gc = Cl, gH = FU, mH = LU, yH = DU, bH = UU, xH = HU, AH = GU, wH = VU, vH = jU, e8 = Function, ug = function(t) {
    try {
      return e8('"use strict"; return (' + t + ").constructor;")();
    } catch {
    }
  }, ju = q5, EH = KU, fg = function() {
    throw new Gc();
  }, SH = ju ? function() {
    try {
      return arguments.callee, fg;
    } catch {
      try {
        return ju(arguments, "callee").get;
      } catch {
        return fg;
      }
    }
  }() : fg, nc = qU()(), Cn = cH(), TH = X5(), CH = Y5(), t8 = Z5(), Af = Cy(), mc = {}, IH = typeof Uint8Array > "u" || !Cn ? Xe : Cn(Uint8Array), Ta = {
    __proto__: null,
    "%AggregateError%": typeof AggregateError > "u" ? Xe : AggregateError,
    "%Array%": Array,
    "%ArrayBuffer%": typeof ArrayBuffer > "u" ? Xe : ArrayBuffer,
    "%ArrayIteratorPrototype%": nc && Cn ? Cn([][Symbol.iterator]()) : Xe,
    "%AsyncFromSyncIteratorPrototype%": Xe,
    "%AsyncFunction%": mc,
    "%AsyncGenerator%": mc,
    "%AsyncGeneratorFunction%": mc,
    "%AsyncIteratorPrototype%": mc,
    "%Atomics%": typeof Atomics > "u" ? Xe : Atomics,
    "%BigInt%": typeof BigInt > "u" ? Xe : BigInt,
    "%BigInt64Array%": typeof BigInt64Array > "u" ? Xe : BigInt64Array,
    "%BigUint64Array%": typeof BigUint64Array > "u" ? Xe : BigUint64Array,
    "%Boolean%": Boolean,
    "%DataView%": typeof DataView > "u" ? Xe : DataView,
    "%Date%": Date,
    "%decodeURI%": decodeURI,
    "%decodeURIComponent%": decodeURIComponent,
    "%encodeURI%": encodeURI,
    "%encodeURIComponent%": encodeURIComponent,
    "%Error%": fH,
    "%eval%": eval,
    "%EvalError%": dH,
    "%Float16Array%": typeof Float16Array > "u" ? Xe : Float16Array,
    "%Float32Array%": typeof Float32Array > "u" ? Xe : Float32Array,
    "%Float64Array%": typeof Float64Array > "u" ? Xe : Float64Array,
    "%FinalizationRegistry%": typeof FinalizationRegistry > "u" ? Xe : FinalizationRegistry,
    "%Function%": e8,
    "%GeneratorFunction%": mc,
    "%Int8Array%": typeof Int8Array > "u" ? Xe : Int8Array,
    "%Int16Array%": typeof Int16Array > "u" ? Xe : Int16Array,
    "%Int32Array%": typeof Int32Array > "u" ? Xe : Int32Array,
    "%isFinite%": isFinite,
    "%isNaN%": isNaN,
    "%IteratorPrototype%": nc && Cn ? Cn(Cn([][Symbol.iterator]())) : Xe,
    "%JSON%": typeof JSON == "object" ? JSON : Xe,
    "%Map%": typeof Map > "u" ? Xe : Map,
    "%MapIteratorPrototype%": typeof Map > "u" || !nc || !Cn ? Xe : Cn((/* @__PURE__ */ new Map())[Symbol.iterator]()),
    "%Math%": Math,
    "%Number%": Number,
    "%Object%": uH,
    "%Object.getOwnPropertyDescriptor%": ju,
    "%parseFloat%": parseFloat,
    "%parseInt%": parseInt,
    "%Promise%": typeof Promise > "u" ? Xe : Promise,
    "%Proxy%": typeof Proxy > "u" ? Xe : Proxy,
    "%RangeError%": hH,
    "%ReferenceError%": pH,
    "%Reflect%": typeof Reflect > "u" ? Xe : Reflect,
    "%RegExp%": RegExp,
    "%Set%": typeof Set > "u" ? Xe : Set,
    "%SetIteratorPrototype%": typeof Set > "u" || !nc || !Cn ? Xe : Cn((/* @__PURE__ */ new Set())[Symbol.iterator]()),
    "%SharedArrayBuffer%": typeof SharedArrayBuffer > "u" ? Xe : SharedArrayBuffer,
    "%String%": String,
    "%StringIteratorPrototype%": nc && Cn ? Cn(""[Symbol.iterator]()) : Xe,
    "%Symbol%": nc ? Symbol : Xe,
    "%SyntaxError%": ul,
    "%ThrowTypeError%": SH,
    "%TypedArray%": IH,
    "%TypeError%": Gc,
    "%Uint8Array%": typeof Uint8Array > "u" ? Xe : Uint8Array,
    "%Uint8ClampedArray%": typeof Uint8ClampedArray > "u" ? Xe : Uint8ClampedArray,
    "%Uint16Array%": typeof Uint16Array > "u" ? Xe : Uint16Array,
    "%Uint32Array%": typeof Uint32Array > "u" ? Xe : Uint32Array,
    "%URIError%": gH,
    "%WeakMap%": typeof WeakMap > "u" ? Xe : WeakMap,
    "%WeakRef%": typeof WeakRef > "u" ? Xe : WeakRef,
    "%WeakSet%": typeof WeakSet > "u" ? Xe : WeakSet,
    "%Function.prototype.call%": Af,
    "%Function.prototype.apply%": t8,
    "%Object.defineProperty%": EH,
    "%Object.getPrototypeOf%": TH,
    "%Math.abs%": mH,
    "%Math.floor%": yH,
    "%Math.max%": bH,
    "%Math.min%": xH,
    "%Math.pow%": AH,
    "%Math.round%": wH,
    "%Math.sign%": vH,
    "%Reflect.getPrototypeOf%": CH
  };
  if (Cn) try {
    null.error;
  } catch (t) {
    var PH = Cn(Cn(t));
    Ta["%Error.prototype%"] = PH;
  }
  var _H = function t(e) {
    var n;
    if (e === "%AsyncFunction%") n = ug("async function () {}");
    else if (e === "%GeneratorFunction%") n = ug("function* () {}");
    else if (e === "%AsyncGeneratorFunction%") n = ug("async function* () {}");
    else if (e === "%AsyncGenerator%") {
      var r = t("%AsyncGeneratorFunction%");
      r && (n = r.prototype);
    } else if (e === "%AsyncIteratorPrototype%") {
      var i = t("%AsyncGenerator%");
      i && Cn && (n = Cn(i.prototype));
    }
    return Ta[e] = n, n;
  }, lw = {
    __proto__: null,
    "%ArrayBufferPrototype%": [
      "ArrayBuffer",
      "prototype"
    ],
    "%ArrayPrototype%": [
      "Array",
      "prototype"
    ],
    "%ArrayProto_entries%": [
      "Array",
      "prototype",
      "entries"
    ],
    "%ArrayProto_forEach%": [
      "Array",
      "prototype",
      "forEach"
    ],
    "%ArrayProto_keys%": [
      "Array",
      "prototype",
      "keys"
    ],
    "%ArrayProto_values%": [
      "Array",
      "prototype",
      "values"
    ],
    "%AsyncFunctionPrototype%": [
      "AsyncFunction",
      "prototype"
    ],
    "%AsyncGenerator%": [
      "AsyncGeneratorFunction",
      "prototype"
    ],
    "%AsyncGeneratorPrototype%": [
      "AsyncGeneratorFunction",
      "prototype",
      "prototype"
    ],
    "%BooleanPrototype%": [
      "Boolean",
      "prototype"
    ],
    "%DataViewPrototype%": [
      "DataView",
      "prototype"
    ],
    "%DatePrototype%": [
      "Date",
      "prototype"
    ],
    "%ErrorPrototype%": [
      "Error",
      "prototype"
    ],
    "%EvalErrorPrototype%": [
      "EvalError",
      "prototype"
    ],
    "%Float32ArrayPrototype%": [
      "Float32Array",
      "prototype"
    ],
    "%Float64ArrayPrototype%": [
      "Float64Array",
      "prototype"
    ],
    "%FunctionPrototype%": [
      "Function",
      "prototype"
    ],
    "%Generator%": [
      "GeneratorFunction",
      "prototype"
    ],
    "%GeneratorPrototype%": [
      "GeneratorFunction",
      "prototype",
      "prototype"
    ],
    "%Int8ArrayPrototype%": [
      "Int8Array",
      "prototype"
    ],
    "%Int16ArrayPrototype%": [
      "Int16Array",
      "prototype"
    ],
    "%Int32ArrayPrototype%": [
      "Int32Array",
      "prototype"
    ],
    "%JSONParse%": [
      "JSON",
      "parse"
    ],
    "%JSONStringify%": [
      "JSON",
      "stringify"
    ],
    "%MapPrototype%": [
      "Map",
      "prototype"
    ],
    "%NumberPrototype%": [
      "Number",
      "prototype"
    ],
    "%ObjectPrototype%": [
      "Object",
      "prototype"
    ],
    "%ObjProto_toString%": [
      "Object",
      "prototype",
      "toString"
    ],
    "%ObjProto_valueOf%": [
      "Object",
      "prototype",
      "valueOf"
    ],
    "%PromisePrototype%": [
      "Promise",
      "prototype"
    ],
    "%PromiseProto_then%": [
      "Promise",
      "prototype",
      "then"
    ],
    "%Promise_all%": [
      "Promise",
      "all"
    ],
    "%Promise_reject%": [
      "Promise",
      "reject"
    ],
    "%Promise_resolve%": [
      "Promise",
      "resolve"
    ],
    "%RangeErrorPrototype%": [
      "RangeError",
      "prototype"
    ],
    "%ReferenceErrorPrototype%": [
      "ReferenceError",
      "prototype"
    ],
    "%RegExpPrototype%": [
      "RegExp",
      "prototype"
    ],
    "%SetPrototype%": [
      "Set",
      "prototype"
    ],
    "%SharedArrayBufferPrototype%": [
      "SharedArrayBuffer",
      "prototype"
    ],
    "%StringPrototype%": [
      "String",
      "prototype"
    ],
    "%SymbolPrototype%": [
      "Symbol",
      "prototype"
    ],
    "%SyntaxErrorPrototype%": [
      "SyntaxError",
      "prototype"
    ],
    "%TypedArrayPrototype%": [
      "TypedArray",
      "prototype"
    ],
    "%TypeErrorPrototype%": [
      "TypeError",
      "prototype"
    ],
    "%Uint8ArrayPrototype%": [
      "Uint8Array",
      "prototype"
    ],
    "%Uint8ClampedArrayPrototype%": [
      "Uint8ClampedArray",
      "prototype"
    ],
    "%Uint16ArrayPrototype%": [
      "Uint16Array",
      "prototype"
    ],
    "%Uint32ArrayPrototype%": [
      "Uint32Array",
      "prototype"
    ],
    "%URIErrorPrototype%": [
      "URIError",
      "prototype"
    ],
    "%WeakMapPrototype%": [
      "WeakMap",
      "prototype"
    ],
    "%WeakSetPrototype%": [
      "WeakSet",
      "prototype"
    ]
  }, wf = yh(), ld = lH(), RH = wf.call(Af, Array.prototype.concat), NH = wf.call(t8, Array.prototype.splice), uw = wf.call(Af, String.prototype.replace), ud = wf.call(Af, String.prototype.slice), OH = wf.call(Af, RegExp.prototype.exec), BH = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g, MH = /\\(\\)?/g, kH = function(e) {
    var n = ud(e, 0, 1), r = ud(e, -1);
    if (n === "%" && r !== "%") throw new ul("invalid intrinsic syntax, expected closing `%`");
    if (r === "%" && n !== "%") throw new ul("invalid intrinsic syntax, expected opening `%`");
    var i = [];
    return uw(e, BH, function(s, o, a, c) {
      i[i.length] = a ? uw(c, MH, "$1") : o || s;
    }), i;
  }, FH = function(e, n) {
    var r = e, i;
    if (ld(lw, r) && (i = lw[r], r = "%" + i[0] + "%"), ld(Ta, r)) {
      var s = Ta[r];
      if (s === mc && (s = _H(r)), typeof s > "u" && !n) throw new Gc("intrinsic " + e + " exists, but is not available. Please file an issue!");
      return {
        alias: i,
        name: r,
        value: s
      };
    }
    throw new ul("intrinsic " + e + " does not exist!");
  }, Iy = function(e, n) {
    if (typeof e != "string" || e.length === 0) throw new Gc("intrinsic name must be a non-empty string");
    if (arguments.length > 1 && typeof n != "boolean") throw new Gc('"allowMissing" argument must be a boolean');
    if (OH(/^%?[^%]*%?$/, e) === null) throw new ul("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
    var r = kH(e), i = r.length > 0 ? r[0] : "", s = FH("%" + i + "%", n), o = s.name, a = s.value, c = false, l = s.alias;
    l && (i = l[0], NH(r, RH([
      0,
      1
    ], l)));
    for (var u = 1, f = true; u < r.length; u += 1) {
      var d = r[u], m = ud(d, 0, 1), y = ud(d, -1);
      if ((m === '"' || m === "'" || m === "`" || y === '"' || y === "'" || y === "`") && m !== y) throw new ul("property names with quotes must have matching quotes");
      if ((d === "constructor" || !f) && (c = true), i += "." + d, o = "%" + i + "%", ld(Ta, o)) a = Ta[o];
      else if (a != null) {
        if (!(d in a)) {
          if (!n) throw new Gc("base intrinsic for " + e + " exists, but the property is not available.");
          return;
        }
        if (ju && u + 1 >= r.length) {
          var x = ju(a, d);
          f = !!x, f && "get" in x && !("originalValue" in x.get) ? a = x.get : a = a[d];
        } else f = ld(a, d), a = a[d];
        f && !c && (Ta[o] = a);
      }
    }
    return a;
  }, n8 = Iy, r8 = $5, LH = r8([
    n8("%String.prototype.indexOf%")
  ]), i8 = function(e, n) {
    var r = n8(e, !!n);
    return typeof r == "function" && LH(e, ".prototype.") > -1 ? r8([
      r
    ]) : r;
  }, DH = Iy, vf = i8, UH = gh, HH = Cl, fw = DH("%Map%", true), GH = vf("Map.prototype.get", true), VH = vf("Map.prototype.set", true), zH = vf("Map.prototype.has", true), QH = vf("Map.prototype.delete", true), jH = vf("Map.prototype.size", true), s8 = !!fw && function() {
    var e, n = {
      assert: function(r) {
        if (!n.has(r)) throw new HH("Side channel does not contain " + UH(r));
      },
      delete: function(r) {
        if (e) {
          var i = QH(e, r);
          return jH(e) === 0 && (e = void 0), i;
        }
        return false;
      },
      get: function(r) {
        if (e) return GH(e, r);
      },
      has: function(r) {
        return e ? zH(e, r) : false;
      },
      set: function(r, i) {
        e || (e = new fw()), VH(e, r, i);
      }
    };
    return n;
  }, JH = Iy, bh = i8, KH = gh, Zf = s8, WH = Cl, rc = JH("%WeakMap%", true), qH = bh("WeakMap.prototype.get", true), YH = bh("WeakMap.prototype.set", true), XH = bh("WeakMap.prototype.has", true), ZH = bh("WeakMap.prototype.delete", true), $H = rc ? function() {
    var e, n, r = {
      assert: function(i) {
        if (!r.has(i)) throw new WH("Side channel does not contain " + KH(i));
      },
      delete: function(i) {
        if (rc && i && (typeof i == "object" || typeof i == "function")) {
          if (e) return ZH(e, i);
        } else if (Zf && n) return n.delete(i);
        return false;
      },
      get: function(i) {
        return rc && i && (typeof i == "object" || typeof i == "function") && e ? qH(e, i) : n && n.get(i);
      },
      has: function(i) {
        return rc && i && (typeof i == "object" || typeof i == "function") && e ? XH(e, i) : !!n && n.has(i);
      },
      set: function(i, s) {
        rc && i && (typeof i == "object" || typeof i == "function") ? (e || (e = new rc()), YH(e, i, s)) : Zf && (n || (n = Zf()), n.set(i, s));
      }
    };
    return r;
  } : Zf, eG = Cl, tG = gh, nG = RU, rG = s8, iG = $H, sG = iG || rG || nG, oG = function() {
    var e, n = {
      assert: function(r) {
        if (!n.has(r)) throw new eG("Side channel does not contain " + tG(r));
      },
      delete: function(r) {
        return !!e && e.delete(r);
      },
      get: function(r) {
        return e && e.get(r);
      },
      has: function(r) {
        return !!e && e.has(r);
      },
      set: function(r, i) {
        e || (e = sG()), e.set(r, i);
      }
    };
    return n;
  }, aG = String.prototype.replace, cG = /%20/g, dg = {
    RFC1738: "RFC1738",
    RFC3986: "RFC3986"
  }, Py = {
    default: dg.RFC3986,
    formatters: {
      RFC1738: function(t) {
        return aG.call(t, cG, "+");
      },
      RFC3986: function(t) {
        return String(t);
      }
    },
    RFC1738: dg.RFC1738,
    RFC3986: dg.RFC3986
  }, lG = Py, hg = Object.prototype.hasOwnProperty, ua = Array.isArray, Ri = function() {
    for (var t = [], e = 0; e < 256; ++e) t.push("%" + ((e < 16 ? "0" : "") + e.toString(16)).toUpperCase());
    return t;
  }(), uG = function(e) {
    for (; e.length > 1; ) {
      var n = e.pop(), r = n.obj[n.prop];
      if (ua(r)) {
        for (var i = [], s = 0; s < r.length; ++s) typeof r[s] < "u" && i.push(r[s]);
        n.obj[n.prop] = i;
      }
    }
  }, o8 = function(e, n) {
    for (var r = n && n.plainObjects ? {
      __proto__: null
    } : {}, i = 0; i < e.length; ++i) typeof e[i] < "u" && (r[i] = e[i]);
    return r;
  }, fG = function t(e, n, r) {
    if (!n) return e;
    if (typeof n != "object" && typeof n != "function") {
      if (ua(e)) e.push(n);
      else if (e && typeof e == "object") (r && (r.plainObjects || r.allowPrototypes) || !hg.call(Object.prototype, n)) && (e[n] = true);
      else return [
        e,
        n
      ];
      return e;
    }
    if (!e || typeof e != "object") return [
      e
    ].concat(n);
    var i = e;
    return ua(e) && !ua(n) && (i = o8(e, r)), ua(e) && ua(n) ? (n.forEach(function(s, o) {
      if (hg.call(e, o)) {
        var a = e[o];
        a && typeof a == "object" && s && typeof s == "object" ? e[o] = t(a, s, r) : e.push(s);
      } else e[o] = s;
    }), e) : Object.keys(n).reduce(function(s, o) {
      var a = n[o];
      return hg.call(s, o) ? s[o] = t(s[o], a, r) : s[o] = a, s;
    }, i);
  }, dG = function(e, n) {
    return Object.keys(n).reduce(function(r, i) {
      return r[i] = n[i], r;
    }, e);
  }, hG = function(t, e, n) {
    var r = t.replace(/\+/g, " ");
    if (n === "iso-8859-1") return r.replace(/%[0-9a-f]{2}/gi, unescape);
    try {
      return decodeURIComponent(r);
    } catch {
      return r;
    }
  }, pg = 1024, pG = function(e, n, r, i, s) {
    if (e.length === 0) return e;
    var o = e;
    if (typeof e == "symbol" ? o = Symbol.prototype.toString.call(e) : typeof e != "string" && (o = String(e)), r === "iso-8859-1") return escape(o).replace(/%u[0-9a-f]{4}/gi, function(m) {
      return "%26%23" + parseInt(m.slice(2), 16) + "%3B";
    });
    for (var a = "", c = 0; c < o.length; c += pg) {
      for (var l = o.length >= pg ? o.slice(c, c + pg) : o, u = [], f = 0; f < l.length; ++f) {
        var d = l.charCodeAt(f);
        if (d === 45 || d === 46 || d === 95 || d === 126 || d >= 48 && d <= 57 || d >= 65 && d <= 90 || d >= 97 && d <= 122 || s === lG.RFC1738 && (d === 40 || d === 41)) {
          u[u.length] = l.charAt(f);
          continue;
        }
        if (d < 128) {
          u[u.length] = Ri[d];
          continue;
        }
        if (d < 2048) {
          u[u.length] = Ri[192 | d >> 6] + Ri[128 | d & 63];
          continue;
        }
        if (d < 55296 || d >= 57344) {
          u[u.length] = Ri[224 | d >> 12] + Ri[128 | d >> 6 & 63] + Ri[128 | d & 63];
          continue;
        }
        f += 1, d = 65536 + ((d & 1023) << 10 | l.charCodeAt(f) & 1023), u[u.length] = Ri[240 | d >> 18] + Ri[128 | d >> 12 & 63] + Ri[128 | d >> 6 & 63] + Ri[128 | d & 63];
      }
      a += u.join("");
    }
    return a;
  }, gG = function(e) {
    for (var n = [
      {
        obj: {
          o: e
        },
        prop: "o"
      }
    ], r = [], i = 0; i < n.length; ++i) for (var s = n[i], o = s.obj[s.prop], a = Object.keys(o), c = 0; c < a.length; ++c) {
      var l = a[c], u = o[l];
      typeof u == "object" && u !== null && r.indexOf(u) === -1 && (n.push({
        obj: o,
        prop: l
      }), r.push(u));
    }
    return uG(n), e;
  }, mG = function(e) {
    return Object.prototype.toString.call(e) === "[object RegExp]";
  }, yG = function(e) {
    return !e || typeof e != "object" ? false : !!(e.constructor && e.constructor.isBuffer && e.constructor.isBuffer(e));
  }, bG = function(e, n) {
    return [].concat(e, n);
  }, xG = function(e, n) {
    if (ua(e)) {
      for (var r = [], i = 0; i < e.length; i += 1) r.push(n(e[i]));
      return r;
    }
    return n(e);
  }, a8 = {
    arrayToObject: o8,
    assign: dG,
    combine: bG,
    compact: gG,
    decode: hG,
    encode: pG,
    isBuffer: yG,
    isRegExp: mG,
    maybeMap: xG,
    merge: fG
  }, c8 = oG, S0 = a8, bu = Py, AG = Object.prototype.hasOwnProperty, l8 = {
    brackets: function(e) {
      return e + "[]";
    },
    comma: "comma",
    indices: function(e, n) {
      return e + "[" + n + "]";
    },
    repeat: function(e) {
      return e;
    }
  }, ki = Array.isArray, wG = Array.prototype.push, u8 = function(t, e) {
    wG.apply(t, ki(e) ? e : [
      e
    ]);
  }, vG = Date.prototype.toISOString, dw = bu.default, An = {
    addQueryPrefix: false,
    allowDots: false,
    allowEmptyArrays: false,
    arrayFormat: "indices",
    charset: "utf-8",
    charsetSentinel: false,
    commaRoundTrip: false,
    delimiter: "&",
    encode: true,
    encodeDotInKeys: false,
    encoder: S0.encode,
    encodeValuesOnly: false,
    filter: void 0,
    format: dw,
    formatter: bu.formatters[dw],
    indices: false,
    serializeDate: function(e) {
      return vG.call(e);
    },
    skipNulls: false,
    strictNullHandling: false
  }, EG = function(e) {
    return typeof e == "string" || typeof e == "number" || typeof e == "boolean" || typeof e == "symbol" || typeof e == "bigint";
  }, gg = {}, SG = function t(e, n, r, i, s, o, a, c, l, u, f, d, m, y, x, w, R, O) {
    for (var B = e, M = O, D = 0, H = false; (M = M.get(gg)) !== void 0 && !H; ) {
      var q = M.get(e);
      if (D += 1, typeof q < "u") {
        if (q === D) throw new RangeError("Cyclic object value");
        H = true;
      }
      typeof M.get(gg) > "u" && (D = 0);
    }
    if (typeof u == "function" ? B = u(n, B) : B instanceof Date ? B = m(B) : r === "comma" && ki(B) && (B = S0.maybeMap(B, function(Y) {
      return Y instanceof Date ? m(Y) : Y;
    })), B === null) {
      if (o) return l && !w ? l(n, An.encoder, R, "key", y) : n;
      B = "";
    }
    if (EG(B) || S0.isBuffer(B)) {
      if (l) {
        var S = w ? n : l(n, An.encoder, R, "key", y);
        return [
          x(S) + "=" + x(l(B, An.encoder, R, "value", y))
        ];
      }
      return [
        x(n) + "=" + x(String(B))
      ];
    }
    var P = [];
    if (typeof B > "u") return P;
    var L;
    if (r === "comma" && ki(B)) w && l && (B = S0.maybeMap(B, l)), L = [
      {
        value: B.length > 0 ? B.join(",") || null : void 0
      }
    ];
    else if (ki(u)) L = u;
    else {
      var K = Object.keys(B);
      L = f ? K.sort(f) : K;
    }
    var z = c ? String(n).replace(/\./g, "%2E") : String(n), I = i && ki(B) && B.length === 1 ? z + "[]" : z;
    if (s && ki(B) && B.length === 0) return I + "[]";
    for (var h = 0; h < L.length; ++h) {
      var p = L[h], A = typeof p == "object" && p && typeof p.value < "u" ? p.value : B[p];
      if (!(a && A === null)) {
        var C = d && c ? String(p).replace(/\./g, "%2E") : String(p), N = ki(B) ? typeof r == "function" ? r(I, C) : I : I + (d ? "." + C : "[" + C + "]");
        O.set(e, D);
        var U = c8();
        U.set(gg, O), u8(P, t(A, N, r, i, s, o, a, c, r === "comma" && w && ki(B) ? null : l, u, f, d, m, y, x, w, R, U));
      }
    }
    return P;
  }, TG = function(e) {
    if (!e) return An;
    if (typeof e.allowEmptyArrays < "u" && typeof e.allowEmptyArrays != "boolean") throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
    if (typeof e.encodeDotInKeys < "u" && typeof e.encodeDotInKeys != "boolean") throw new TypeError("`encodeDotInKeys` option can only be `true` or `false`, when provided");
    if (e.encoder !== null && typeof e.encoder < "u" && typeof e.encoder != "function") throw new TypeError("Encoder has to be a function.");
    var n = e.charset || An.charset;
    if (typeof e.charset < "u" && e.charset !== "utf-8" && e.charset !== "iso-8859-1") throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
    var r = bu.default;
    if (typeof e.format < "u") {
      if (!AG.call(bu.formatters, e.format)) throw new TypeError("Unknown format option provided.");
      r = e.format;
    }
    var i = bu.formatters[r], s = An.filter;
    (typeof e.filter == "function" || ki(e.filter)) && (s = e.filter);
    var o;
    if (e.arrayFormat in l8 ? o = e.arrayFormat : "indices" in e ? o = e.indices ? "indices" : "repeat" : o = An.arrayFormat, "commaRoundTrip" in e && typeof e.commaRoundTrip != "boolean") throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
    var a = typeof e.allowDots > "u" ? e.encodeDotInKeys === true ? true : An.allowDots : !!e.allowDots;
    return {
      addQueryPrefix: typeof e.addQueryPrefix == "boolean" ? e.addQueryPrefix : An.addQueryPrefix,
      allowDots: a,
      allowEmptyArrays: typeof e.allowEmptyArrays == "boolean" ? !!e.allowEmptyArrays : An.allowEmptyArrays,
      arrayFormat: o,
      charset: n,
      charsetSentinel: typeof e.charsetSentinel == "boolean" ? e.charsetSentinel : An.charsetSentinel,
      commaRoundTrip: !!e.commaRoundTrip,
      delimiter: typeof e.delimiter > "u" ? An.delimiter : e.delimiter,
      encode: typeof e.encode == "boolean" ? e.encode : An.encode,
      encodeDotInKeys: typeof e.encodeDotInKeys == "boolean" ? e.encodeDotInKeys : An.encodeDotInKeys,
      encoder: typeof e.encoder == "function" ? e.encoder : An.encoder,
      encodeValuesOnly: typeof e.encodeValuesOnly == "boolean" ? e.encodeValuesOnly : An.encodeValuesOnly,
      filter: s,
      format: r,
      formatter: i,
      serializeDate: typeof e.serializeDate == "function" ? e.serializeDate : An.serializeDate,
      skipNulls: typeof e.skipNulls == "boolean" ? e.skipNulls : An.skipNulls,
      sort: typeof e.sort == "function" ? e.sort : null,
      strictNullHandling: typeof e.strictNullHandling == "boolean" ? e.strictNullHandling : An.strictNullHandling
    };
  }, CG = function(t, e) {
    var n = t, r = TG(e), i, s;
    typeof r.filter == "function" ? (s = r.filter, n = s("", n)) : ki(r.filter) && (s = r.filter, i = s);
    var o = [];
    if (typeof n != "object" || n === null) return "";
    var a = l8[r.arrayFormat], c = a === "comma" && r.commaRoundTrip;
    i || (i = Object.keys(n)), r.sort && i.sort(r.sort);
    for (var l = c8(), u = 0; u < i.length; ++u) {
      var f = i[u], d = n[f];
      r.skipNulls && d === null || u8(o, SG(d, f, a, c, r.allowEmptyArrays, r.strictNullHandling, r.skipNulls, r.encodeDotInKeys, r.encode ? r.encoder : null, r.filter, r.sort, r.allowDots, r.serializeDate, r.format, r.formatter, r.encodeValuesOnly, r.charset, l));
    }
    var m = o.join(r.delimiter), y = r.addQueryPrefix === true ? "?" : "";
    return r.charsetSentinel && (r.charset === "iso-8859-1" ? y += "utf8=%26%2310003%3B&" : y += "utf8=%E2%9C%93&"), m.length > 0 ? y + m : "";
  }, Ba = a8, Ym = Object.prototype.hasOwnProperty, hw = Array.isArray, Zt = {
    allowDots: false,
    allowEmptyArrays: false,
    allowPrototypes: false,
    allowSparse: false,
    arrayLimit: 20,
    charset: "utf-8",
    charsetSentinel: false,
    comma: false,
    decodeDotInKeys: false,
    decoder: Ba.decode,
    delimiter: "&",
    depth: 5,
    duplicates: "combine",
    ignoreQueryPrefix: false,
    interpretNumericEntities: false,
    parameterLimit: 1e3,
    parseArrays: true,
    plainObjects: false,
    strictDepth: false,
    strictNullHandling: false,
    throwOnLimitExceeded: false
  }, IG = function(t) {
    return t.replace(/&#(\d+);/g, function(e, n) {
      return String.fromCharCode(parseInt(n, 10));
    });
  }, f8 = function(t, e, n) {
    if (t && typeof t == "string" && e.comma && t.indexOf(",") > -1) return t.split(",");
    if (e.throwOnLimitExceeded && n >= e.arrayLimit) throw new RangeError("Array limit exceeded. Only " + e.arrayLimit + " element" + (e.arrayLimit === 1 ? "" : "s") + " allowed in an array.");
    return t;
  }, PG = "utf8=%26%2310003%3B", _G = "utf8=%E2%9C%93", RG = function(e, n) {
    var r = {
      __proto__: null
    }, i = n.ignoreQueryPrefix ? e.replace(/^\?/, "") : e;
    i = i.replace(/%5B/gi, "[").replace(/%5D/gi, "]");
    var s = n.parameterLimit === 1 / 0 ? void 0 : n.parameterLimit, o = i.split(n.delimiter, n.throwOnLimitExceeded ? s + 1 : s);
    if (n.throwOnLimitExceeded && o.length > s) throw new RangeError("Parameter limit exceeded. Only " + s + " parameter" + (s === 1 ? "" : "s") + " allowed.");
    var a = -1, c, l = n.charset;
    if (n.charsetSentinel) for (c = 0; c < o.length; ++c) o[c].indexOf("utf8=") === 0 && (o[c] === _G ? l = "utf-8" : o[c] === PG && (l = "iso-8859-1"), a = c, c = o.length);
    for (c = 0; c < o.length; ++c) if (c !== a) {
      var u = o[c], f = u.indexOf("]="), d = f === -1 ? u.indexOf("=") : f + 1, m, y;
      d === -1 ? (m = n.decoder(u, Zt.decoder, l, "key"), y = n.strictNullHandling ? null : "") : (m = n.decoder(u.slice(0, d), Zt.decoder, l, "key"), y = Ba.maybeMap(f8(u.slice(d + 1), n, hw(r[m]) ? r[m].length : 0), function(w) {
        return n.decoder(w, Zt.decoder, l, "value");
      })), y && n.interpretNumericEntities && l === "iso-8859-1" && (y = IG(String(y))), u.indexOf("[]=") > -1 && (y = hw(y) ? [
        y
      ] : y);
      var x = Ym.call(r, m);
      x && n.duplicates === "combine" ? r[m] = Ba.combine(r[m], y) : (!x || n.duplicates === "last") && (r[m] = y);
    }
    return r;
  }, NG = function(t, e, n, r) {
    var i = 0;
    if (t.length > 0 && t[t.length - 1] === "[]") {
      var s = t.slice(0, -1).join("");
      i = Array.isArray(e) && e[s] ? e[s].length : 0;
    }
    for (var o = r ? e : f8(e, n, i), a = t.length - 1; a >= 0; --a) {
      var c, l = t[a];
      if (l === "[]" && n.parseArrays) c = n.allowEmptyArrays && (o === "" || n.strictNullHandling && o === null) ? [] : Ba.combine([], o);
      else {
        c = n.plainObjects ? {
          __proto__: null
        } : {};
        var u = l.charAt(0) === "[" && l.charAt(l.length - 1) === "]" ? l.slice(1, -1) : l, f = n.decodeDotInKeys ? u.replace(/%2E/g, ".") : u, d = parseInt(f, 10);
        !n.parseArrays && f === "" ? c = {
          0: o
        } : !isNaN(d) && l !== f && String(d) === f && d >= 0 && n.parseArrays && d <= n.arrayLimit ? (c = [], c[d] = o) : f !== "__proto__" && (c[f] = o);
      }
      o = c;
    }
    return o;
  }, OG = function(e, n, r, i) {
    if (e) {
      var s = r.allowDots ? e.replace(/\.([^.[]+)/g, "[$1]") : e, o = /(\[[^[\]]*])/, a = /(\[[^[\]]*])/g, c = r.depth > 0 && o.exec(s), l = c ? s.slice(0, c.index) : s, u = [];
      if (l) {
        if (!r.plainObjects && Ym.call(Object.prototype, l) && !r.allowPrototypes) return;
        u.push(l);
      }
      for (var f = 0; r.depth > 0 && (c = a.exec(s)) !== null && f < r.depth; ) {
        if (f += 1, !r.plainObjects && Ym.call(Object.prototype, c[1].slice(1, -1)) && !r.allowPrototypes) return;
        u.push(c[1]);
      }
      if (c) {
        if (r.strictDepth === true) throw new RangeError("Input depth exceeded depth option of " + r.depth + " and strictDepth is true");
        u.push("[" + s.slice(c.index) + "]");
      }
      return NG(u, n, r, i);
    }
  }, BG = function(e) {
    if (!e) return Zt;
    if (typeof e.allowEmptyArrays < "u" && typeof e.allowEmptyArrays != "boolean") throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
    if (typeof e.decodeDotInKeys < "u" && typeof e.decodeDotInKeys != "boolean") throw new TypeError("`decodeDotInKeys` option can only be `true` or `false`, when provided");
    if (e.decoder !== null && typeof e.decoder < "u" && typeof e.decoder != "function") throw new TypeError("Decoder has to be a function.");
    if (typeof e.charset < "u" && e.charset !== "utf-8" && e.charset !== "iso-8859-1") throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
    if (typeof e.throwOnLimitExceeded < "u" && typeof e.throwOnLimitExceeded != "boolean") throw new TypeError("`throwOnLimitExceeded` option must be a boolean");
    var n = typeof e.charset > "u" ? Zt.charset : e.charset, r = typeof e.duplicates > "u" ? Zt.duplicates : e.duplicates;
    if (r !== "combine" && r !== "first" && r !== "last") throw new TypeError("The duplicates option must be either combine, first, or last");
    var i = typeof e.allowDots > "u" ? e.decodeDotInKeys === true ? true : Zt.allowDots : !!e.allowDots;
    return {
      allowDots: i,
      allowEmptyArrays: typeof e.allowEmptyArrays == "boolean" ? !!e.allowEmptyArrays : Zt.allowEmptyArrays,
      allowPrototypes: typeof e.allowPrototypes == "boolean" ? e.allowPrototypes : Zt.allowPrototypes,
      allowSparse: typeof e.allowSparse == "boolean" ? e.allowSparse : Zt.allowSparse,
      arrayLimit: typeof e.arrayLimit == "number" ? e.arrayLimit : Zt.arrayLimit,
      charset: n,
      charsetSentinel: typeof e.charsetSentinel == "boolean" ? e.charsetSentinel : Zt.charsetSentinel,
      comma: typeof e.comma == "boolean" ? e.comma : Zt.comma,
      decodeDotInKeys: typeof e.decodeDotInKeys == "boolean" ? e.decodeDotInKeys : Zt.decodeDotInKeys,
      decoder: typeof e.decoder == "function" ? e.decoder : Zt.decoder,
      delimiter: typeof e.delimiter == "string" || Ba.isRegExp(e.delimiter) ? e.delimiter : Zt.delimiter,
      depth: typeof e.depth == "number" || e.depth === false ? +e.depth : Zt.depth,
      duplicates: r,
      ignoreQueryPrefix: e.ignoreQueryPrefix === true,
      interpretNumericEntities: typeof e.interpretNumericEntities == "boolean" ? e.interpretNumericEntities : Zt.interpretNumericEntities,
      parameterLimit: typeof e.parameterLimit == "number" ? e.parameterLimit : Zt.parameterLimit,
      parseArrays: e.parseArrays !== false,
      plainObjects: typeof e.plainObjects == "boolean" ? e.plainObjects : Zt.plainObjects,
      strictDepth: typeof e.strictDepth == "boolean" ? !!e.strictDepth : Zt.strictDepth,
      strictNullHandling: typeof e.strictNullHandling == "boolean" ? e.strictNullHandling : Zt.strictNullHandling,
      throwOnLimitExceeded: typeof e.throwOnLimitExceeded == "boolean" ? e.throwOnLimitExceeded : false
    };
  }, MG = function(t, e) {
    var n = BG(e);
    if (t === "" || t === null || typeof t > "u") return n.plainObjects ? {
      __proto__: null
    } : {};
    for (var r = typeof t == "string" ? RG(t, n) : t, i = n.plainObjects ? {
      __proto__: null
    } : {}, s = Object.keys(r), o = 0; o < s.length; ++o) {
      var a = s[o], c = OG(a, r[a], n, typeof t == "string");
      i = Ba.merge(i, c, n);
    }
    return n.allowSparse === true ? i : Ba.compact(i);
  }, kG = CG, FG = MG, LG = Py, DG = {
    formats: LG,
    parse: FG,
    stringify: kG
  };
  const UG = Js(DG);
  rn.defaults.timeout = 5e4;
  let $f, GG;
  $f = /* @__PURE__ */ new Map();
  HG = (t, e, n, r = true, i = "application/json", s = ts.baseUrl, o = true, a = `${e}${n ? JSON.stringify(n) : ""}`) => {
    $f.has(a) && $f.get(a).abort();
    const c = new AbortController();
    $f.set(a, c);
    const l = {
      "Content-type": i
    }, { accountStore: u, regionStore: f } = ks();
    if (l.region = f.country, l.language = uf.global.locale.value, u.isSign && (l.address = u.sign.address.toLowerCase(), l.message = u.sign.message, l.signature = u.sign.signature), r && !u.isSign) return new Promise((m) => {
      m({
        code: -1,
        success: false,
        data: null,
        message: "Network exception"
      });
    });
    const { disConnectWallet: d } = _y();
    return new Promise((m) => {
      rn({
        method: t,
        headers: l,
        baseURL: s,
        url: e,
        timeout: 15e3,
        params: t === "POST" ? {
          page: n == null ? void 0 : n.page,
          size: n == null ? void 0 : n.size
        } : t === "GET" || t === "DELETE" ? n : null,
        data: t === "POST" || t === "PUT" ? n : null,
        paramsSerializer: (y) => UG.stringify(y, {
          indices: false
        })
      }).then((y) => {
        y.data.code === 1 ? (y.data.success = true, m(y.data)) : +y.data.code == -1 ? (d(), m({
          code: -1,
          success: false,
          data: null,
          message: "Network exception"
        })) : (Yg(), o && lx(y.data.msg), m({
          code: 0,
          success: false,
          data: null,
          message: "Network exception",
          failMsg: y.data.msg
        }));
      }).catch((y) => {
        Yg();
        let x = "";
        y.response && y.response.data && y.response.data.message ? x = y.response.data.message : x = "Network exception", o && lx(x), m({
          code: 500,
          success: false,
          data: null,
          message: "Network exception",
          failMsg: x
        });
      }).finally(() => {
        $f.delete(a);
      });
    });
  };
  GG = (t) => {
    const { accountStore: e } = ks(), n = t || e.sign.address;
    return HG("GET", "/store/getStoreInfo?address=" + n, "", false);
  };
  _y = () => {
    const { accountStore: t, reloadStore: e } = ks(), { loadingToggle: n } = yL(), r = () => t.account, i = async () => {
      const f = await b0();
      f.success && f.result && e.reload();
    }, { clearBalance: s } = h6(), o = () => {
      t.changeAccount(""), t.changeSign({
        signature: "",
        address: "",
        message: ""
      }), t.changeStore({}), t.changeUserInfo({}), s(), e.reload();
    };
    return {
      getCurrentAccount: r,
      connectWallet: i,
      listenWallet: async () => {
        try {
          window.ethereum.on("accountsChanged", async () => {
            o(), location.reload();
          }), window.ethereum.on("disconnect", () => {
            o(), location.reload();
          });
        } catch (f) {
          console.error(f);
        }
      },
      disConnectWallet: o,
      signData: async () => {
        if (!(await b0()).success) return;
        const d = Math.random().toString(36).slice(-8), m = await TA(d);
        if (!m.success) return t.changeAccount(""), Kc(m.result);
        const y = m.result, w = (await CA(d)).result, R = {
          address: t.account,
          message: w,
          signature: y
        };
        t.changeSign(R), t.changeUsers(R), e.reload();
      },
      login: async () => {
        if (n(true, 0), !t.isSign) {
          try {
            if (!(await b0()).success) {
              n(false);
              return;
            }
          } catch (R) {
            console.log(R);
          } finally {
            n(false);
          }
          const f = `Welcomes_Flashmall_${(/* @__PURE__ */ new Date()).getTime().toString().slice(0, 10)}`, d = await TA(f);
          if (!d.success) return n(false), t.changeAccount(""), Kc(d.result);
          const m = d.result, x = (await CA(f)).result, w = {
            address: t.account,
            message: x,
            signature: m
          };
          t.changeSign(w), t.changeUsers(w);
        }
        n(false), e.reload();
      },
      getCurrentStoreId: async () => {
        var _a6;
        const { accountStore: f } = ks();
        if ((_a6 = f.store) == null ? void 0 : _a6.id) return f.store;
        {
          const d = await GG(f.account);
          return d.success ? (await f.changeStore(d.data), d.data) : {};
        }
      }
    };
  };
  var Ry = {
    exports: {}
  };
  Ry.exports;
  (function(t) {
    (function(e, n) {
      function r(I, h) {
        if (!I) throw new Error(h || "Assertion failed");
      }
      function i(I, h) {
        I.super_ = h;
        var p = function() {
        };
        p.prototype = h.prototype, I.prototype = new p(), I.prototype.constructor = I;
      }
      function s(I, h, p) {
        if (s.isBN(I)) return I;
        this.negative = 0, this.words = null, this.length = 0, this.red = null, I !== null && ((h === "le" || h === "be") && (p = h, h = 10), this._init(I || 0, h || 10, p || "be"));
      }
      typeof e == "object" ? e.exports = s : n.BN = s, s.BN = s, s.wordSize = 26;
      var o;
      try {
        typeof window < "u" && typeof window.Buffer < "u" ? o = window.Buffer : o = H5.Buffer;
      } catch {
      }
      s.isBN = function(h) {
        return h instanceof s ? true : h !== null && typeof h == "object" && h.constructor.wordSize === s.wordSize && Array.isArray(h.words);
      }, s.max = function(h, p) {
        return h.cmp(p) > 0 ? h : p;
      }, s.min = function(h, p) {
        return h.cmp(p) < 0 ? h : p;
      }, s.prototype._init = function(h, p, A) {
        if (typeof h == "number") return this._initNumber(h, p, A);
        if (typeof h == "object") return this._initArray(h, p, A);
        p === "hex" && (p = 16), r(p === (p | 0) && p >= 2 && p <= 36), h = h.toString().replace(/\s+/g, "");
        var C = 0;
        h[0] === "-" && (C++, this.negative = 1), C < h.length && (p === 16 ? this._parseHex(h, C, A) : (this._parseBase(h, p, C), A === "le" && this._initArray(this.toArray(), p, A)));
      }, s.prototype._initNumber = function(h, p, A) {
        h < 0 && (this.negative = 1, h = -h), h < 67108864 ? (this.words = [
          h & 67108863
        ], this.length = 1) : h < 4503599627370496 ? (this.words = [
          h & 67108863,
          h / 67108864 & 67108863
        ], this.length = 2) : (r(h < 9007199254740992), this.words = [
          h & 67108863,
          h / 67108864 & 67108863,
          1
        ], this.length = 3), A === "le" && this._initArray(this.toArray(), p, A);
      }, s.prototype._initArray = function(h, p, A) {
        if (r(typeof h.length == "number"), h.length <= 0) return this.words = [
          0
        ], this.length = 1, this;
        this.length = Math.ceil(h.length / 3), this.words = new Array(this.length);
        for (var C = 0; C < this.length; C++) this.words[C] = 0;
        var N, U, Y = 0;
        if (A === "be") for (C = h.length - 1, N = 0; C >= 0; C -= 3) U = h[C] | h[C - 1] << 8 | h[C - 2] << 16, this.words[N] |= U << Y & 67108863, this.words[N + 1] = U >>> 26 - Y & 67108863, Y += 24, Y >= 26 && (Y -= 26, N++);
        else if (A === "le") for (C = 0, N = 0; C < h.length; C += 3) U = h[C] | h[C + 1] << 8 | h[C + 2] << 16, this.words[N] |= U << Y & 67108863, this.words[N + 1] = U >>> 26 - Y & 67108863, Y += 24, Y >= 26 && (Y -= 26, N++);
        return this._strip();
      };
      function a(I, h) {
        var p = I.charCodeAt(h);
        if (p >= 48 && p <= 57) return p - 48;
        if (p >= 65 && p <= 70) return p - 55;
        if (p >= 97 && p <= 102) return p - 87;
        r(false, "Invalid character in " + I);
      }
      function c(I, h, p) {
        var A = a(I, p);
        return p - 1 >= h && (A |= a(I, p - 1) << 4), A;
      }
      s.prototype._parseHex = function(h, p, A) {
        this.length = Math.ceil((h.length - p) / 6), this.words = new Array(this.length);
        for (var C = 0; C < this.length; C++) this.words[C] = 0;
        var N = 0, U = 0, Y;
        if (A === "be") for (C = h.length - 1; C >= p; C -= 2) Y = c(h, p, C) << N, this.words[U] |= Y & 67108863, N >= 18 ? (N -= 18, U += 1, this.words[U] |= Y >>> 26) : N += 8;
        else {
          var T = h.length - p;
          for (C = T % 2 === 0 ? p + 1 : p; C < h.length; C += 2) Y = c(h, p, C) << N, this.words[U] |= Y & 67108863, N >= 18 ? (N -= 18, U += 1, this.words[U] |= Y >>> 26) : N += 8;
        }
        this._strip();
      };
      function l(I, h, p, A) {
        for (var C = 0, N = 0, U = Math.min(I.length, p), Y = h; Y < U; Y++) {
          var T = I.charCodeAt(Y) - 48;
          C *= A, T >= 49 ? N = T - 49 + 10 : T >= 17 ? N = T - 17 + 10 : N = T, r(T >= 0 && N < A, "Invalid character"), C += N;
        }
        return C;
      }
      s.prototype._parseBase = function(h, p, A) {
        this.words = [
          0
        ], this.length = 1;
        for (var C = 0, N = 1; N <= 67108863; N *= p) C++;
        C--, N = N / p | 0;
        for (var U = h.length - A, Y = U % C, T = Math.min(U, U - Y) + A, g = 0, F = A; F < T; F += C) g = l(h, F, F + C, p), this.imuln(N), this.words[0] + g < 67108864 ? this.words[0] += g : this._iaddn(g);
        if (Y !== 0) {
          var ee = 1;
          for (g = l(h, F, h.length, p), F = 0; F < Y; F++) ee *= p;
          this.imuln(ee), this.words[0] + g < 67108864 ? this.words[0] += g : this._iaddn(g);
        }
        this._strip();
      }, s.prototype.copy = function(h) {
        h.words = new Array(this.length);
        for (var p = 0; p < this.length; p++) h.words[p] = this.words[p];
        h.length = this.length, h.negative = this.negative, h.red = this.red;
      };
      function u(I, h) {
        I.words = h.words, I.length = h.length, I.negative = h.negative, I.red = h.red;
      }
      if (s.prototype._move = function(h) {
        u(h, this);
      }, s.prototype.clone = function() {
        var h = new s(null);
        return this.copy(h), h;
      }, s.prototype._expand = function(h) {
        for (; this.length < h; ) this.words[this.length++] = 0;
        return this;
      }, s.prototype._strip = function() {
        for (; this.length > 1 && this.words[this.length - 1] === 0; ) this.length--;
        return this._normSign();
      }, s.prototype._normSign = function() {
        return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
      }, typeof Symbol < "u" && typeof Symbol.for == "function") try {
        s.prototype[Symbol.for("nodejs.util.inspect.custom")] = f;
      } catch {
        s.prototype.inspect = f;
      }
      else s.prototype.inspect = f;
      function f() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      }
      var d = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ], m = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ], y = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      s.prototype.toString = function(h, p) {
        h = h || 10, p = p | 0 || 1;
        var A;
        if (h === 16 || h === "hex") {
          A = "";
          for (var C = 0, N = 0, U = 0; U < this.length; U++) {
            var Y = this.words[U], T = ((Y << C | N) & 16777215).toString(16);
            N = Y >>> 24 - C & 16777215, C += 2, C >= 26 && (C -= 26, U--), N !== 0 || U !== this.length - 1 ? A = d[6 - T.length] + T + A : A = T + A;
          }
          for (N !== 0 && (A = N.toString(16) + A); A.length % p !== 0; ) A = "0" + A;
          return this.negative !== 0 && (A = "-" + A), A;
        }
        if (h === (h | 0) && h >= 2 && h <= 36) {
          var g = m[h], F = y[h];
          A = "";
          var ee = this.clone();
          for (ee.negative = 0; !ee.isZero(); ) {
            var E = ee.modrn(F).toString(h);
            ee = ee.idivn(F), ee.isZero() ? A = E + A : A = d[g - E.length] + E + A;
          }
          for (this.isZero() && (A = "0" + A); A.length % p !== 0; ) A = "0" + A;
          return this.negative !== 0 && (A = "-" + A), A;
        }
        r(false, "Base should be between 2 and 36");
      }, s.prototype.toNumber = function() {
        var h = this.words[0];
        return this.length === 2 ? h += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? h += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && r(false, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -h : h;
      }, s.prototype.toJSON = function() {
        return this.toString(16, 2);
      }, o && (s.prototype.toBuffer = function(h, p) {
        return this.toArrayLike(o, h, p);
      }), s.prototype.toArray = function(h, p) {
        return this.toArrayLike(Array, h, p);
      };
      var x = function(h, p) {
        return h.allocUnsafe ? h.allocUnsafe(p) : new h(p);
      };
      s.prototype.toArrayLike = function(h, p, A) {
        this._strip();
        var C = this.byteLength(), N = A || Math.max(1, C);
        r(C <= N, "byte array longer than desired length"), r(N > 0, "Requested array length <= 0");
        var U = x(h, N), Y = p === "le" ? "LE" : "BE";
        return this["_toArrayLike" + Y](U, C), U;
      }, s.prototype._toArrayLikeLE = function(h, p) {
        for (var A = 0, C = 0, N = 0, U = 0; N < this.length; N++) {
          var Y = this.words[N] << U | C;
          h[A++] = Y & 255, A < h.length && (h[A++] = Y >> 8 & 255), A < h.length && (h[A++] = Y >> 16 & 255), U === 6 ? (A < h.length && (h[A++] = Y >> 24 & 255), C = 0, U = 0) : (C = Y >>> 24, U += 2);
        }
        if (A < h.length) for (h[A++] = C; A < h.length; ) h[A++] = 0;
      }, s.prototype._toArrayLikeBE = function(h, p) {
        for (var A = h.length - 1, C = 0, N = 0, U = 0; N < this.length; N++) {
          var Y = this.words[N] << U | C;
          h[A--] = Y & 255, A >= 0 && (h[A--] = Y >> 8 & 255), A >= 0 && (h[A--] = Y >> 16 & 255), U === 6 ? (A >= 0 && (h[A--] = Y >> 24 & 255), C = 0, U = 0) : (C = Y >>> 24, U += 2);
        }
        if (A >= 0) for (h[A--] = C; A >= 0; ) h[A--] = 0;
      }, Math.clz32 ? s.prototype._countBits = function(h) {
        return 32 - Math.clz32(h);
      } : s.prototype._countBits = function(h) {
        var p = h, A = 0;
        return p >= 4096 && (A += 13, p >>>= 13), p >= 64 && (A += 7, p >>>= 7), p >= 8 && (A += 4, p >>>= 4), p >= 2 && (A += 2, p >>>= 2), A + p;
      }, s.prototype._zeroBits = function(h) {
        if (h === 0) return 26;
        var p = h, A = 0;
        return p & 8191 || (A += 13, p >>>= 13), p & 127 || (A += 7, p >>>= 7), p & 15 || (A += 4, p >>>= 4), p & 3 || (A += 2, p >>>= 2), p & 1 || A++, A;
      }, s.prototype.bitLength = function() {
        var h = this.words[this.length - 1], p = this._countBits(h);
        return (this.length - 1) * 26 + p;
      };
      function w(I) {
        for (var h = new Array(I.bitLength()), p = 0; p < h.length; p++) {
          var A = p / 26 | 0, C = p % 26;
          h[p] = I.words[A] >>> C & 1;
        }
        return h;
      }
      s.prototype.zeroBits = function() {
        if (this.isZero()) return 0;
        for (var h = 0, p = 0; p < this.length; p++) {
          var A = this._zeroBits(this.words[p]);
          if (h += A, A !== 26) break;
        }
        return h;
      }, s.prototype.byteLength = function() {
        return Math.ceil(this.bitLength() / 8);
      }, s.prototype.toTwos = function(h) {
        return this.negative !== 0 ? this.abs().inotn(h).iaddn(1) : this.clone();
      }, s.prototype.fromTwos = function(h) {
        return this.testn(h - 1) ? this.notn(h).iaddn(1).ineg() : this.clone();
      }, s.prototype.isNeg = function() {
        return this.negative !== 0;
      }, s.prototype.neg = function() {
        return this.clone().ineg();
      }, s.prototype.ineg = function() {
        return this.isZero() || (this.negative ^= 1), this;
      }, s.prototype.iuor = function(h) {
        for (; this.length < h.length; ) this.words[this.length++] = 0;
        for (var p = 0; p < h.length; p++) this.words[p] = this.words[p] | h.words[p];
        return this._strip();
      }, s.prototype.ior = function(h) {
        return r((this.negative | h.negative) === 0), this.iuor(h);
      }, s.prototype.or = function(h) {
        return this.length > h.length ? this.clone().ior(h) : h.clone().ior(this);
      }, s.prototype.uor = function(h) {
        return this.length > h.length ? this.clone().iuor(h) : h.clone().iuor(this);
      }, s.prototype.iuand = function(h) {
        var p;
        this.length > h.length ? p = h : p = this;
        for (var A = 0; A < p.length; A++) this.words[A] = this.words[A] & h.words[A];
        return this.length = p.length, this._strip();
      }, s.prototype.iand = function(h) {
        return r((this.negative | h.negative) === 0), this.iuand(h);
      }, s.prototype.and = function(h) {
        return this.length > h.length ? this.clone().iand(h) : h.clone().iand(this);
      }, s.prototype.uand = function(h) {
        return this.length > h.length ? this.clone().iuand(h) : h.clone().iuand(this);
      }, s.prototype.iuxor = function(h) {
        var p, A;
        this.length > h.length ? (p = this, A = h) : (p = h, A = this);
        for (var C = 0; C < A.length; C++) this.words[C] = p.words[C] ^ A.words[C];
        if (this !== p) for (; C < p.length; C++) this.words[C] = p.words[C];
        return this.length = p.length, this._strip();
      }, s.prototype.ixor = function(h) {
        return r((this.negative | h.negative) === 0), this.iuxor(h);
      }, s.prototype.xor = function(h) {
        return this.length > h.length ? this.clone().ixor(h) : h.clone().ixor(this);
      }, s.prototype.uxor = function(h) {
        return this.length > h.length ? this.clone().iuxor(h) : h.clone().iuxor(this);
      }, s.prototype.inotn = function(h) {
        r(typeof h == "number" && h >= 0);
        var p = Math.ceil(h / 26) | 0, A = h % 26;
        this._expand(p), A > 0 && p--;
        for (var C = 0; C < p; C++) this.words[C] = ~this.words[C] & 67108863;
        return A > 0 && (this.words[C] = ~this.words[C] & 67108863 >> 26 - A), this._strip();
      }, s.prototype.notn = function(h) {
        return this.clone().inotn(h);
      }, s.prototype.setn = function(h, p) {
        r(typeof h == "number" && h >= 0);
        var A = h / 26 | 0, C = h % 26;
        return this._expand(A + 1), p ? this.words[A] = this.words[A] | 1 << C : this.words[A] = this.words[A] & ~(1 << C), this._strip();
      }, s.prototype.iadd = function(h) {
        var p;
        if (this.negative !== 0 && h.negative === 0) return this.negative = 0, p = this.isub(h), this.negative ^= 1, this._normSign();
        if (this.negative === 0 && h.negative !== 0) return h.negative = 0, p = this.isub(h), h.negative = 1, p._normSign();
        var A, C;
        this.length > h.length ? (A = this, C = h) : (A = h, C = this);
        for (var N = 0, U = 0; U < C.length; U++) p = (A.words[U] | 0) + (C.words[U] | 0) + N, this.words[U] = p & 67108863, N = p >>> 26;
        for (; N !== 0 && U < A.length; U++) p = (A.words[U] | 0) + N, this.words[U] = p & 67108863, N = p >>> 26;
        if (this.length = A.length, N !== 0) this.words[this.length] = N, this.length++;
        else if (A !== this) for (; U < A.length; U++) this.words[U] = A.words[U];
        return this;
      }, s.prototype.add = function(h) {
        var p;
        return h.negative !== 0 && this.negative === 0 ? (h.negative = 0, p = this.sub(h), h.negative ^= 1, p) : h.negative === 0 && this.negative !== 0 ? (this.negative = 0, p = h.sub(this), this.negative = 1, p) : this.length > h.length ? this.clone().iadd(h) : h.clone().iadd(this);
      }, s.prototype.isub = function(h) {
        if (h.negative !== 0) {
          h.negative = 0;
          var p = this.iadd(h);
          return h.negative = 1, p._normSign();
        } else if (this.negative !== 0) return this.negative = 0, this.iadd(h), this.negative = 1, this._normSign();
        var A = this.cmp(h);
        if (A === 0) return this.negative = 0, this.length = 1, this.words[0] = 0, this;
        var C, N;
        A > 0 ? (C = this, N = h) : (C = h, N = this);
        for (var U = 0, Y = 0; Y < N.length; Y++) p = (C.words[Y] | 0) - (N.words[Y] | 0) + U, U = p >> 26, this.words[Y] = p & 67108863;
        for (; U !== 0 && Y < C.length; Y++) p = (C.words[Y] | 0) + U, U = p >> 26, this.words[Y] = p & 67108863;
        if (U === 0 && Y < C.length && C !== this) for (; Y < C.length; Y++) this.words[Y] = C.words[Y];
        return this.length = Math.max(this.length, Y), C !== this && (this.negative = 1), this._strip();
      }, s.prototype.sub = function(h) {
        return this.clone().isub(h);
      };
      function R(I, h, p) {
        p.negative = h.negative ^ I.negative;
        var A = I.length + h.length | 0;
        p.length = A, A = A - 1 | 0;
        var C = I.words[0] | 0, N = h.words[0] | 0, U = C * N, Y = U & 67108863, T = U / 67108864 | 0;
        p.words[0] = Y;
        for (var g = 1; g < A; g++) {
          for (var F = T >>> 26, ee = T & 67108863, E = Math.min(g, h.length - 1), Z = Math.max(0, g - I.length + 1); Z <= E; Z++) {
            var k = g - Z | 0;
            C = I.words[k] | 0, N = h.words[Z] | 0, U = C * N + ee, F += U / 67108864 | 0, ee = U & 67108863;
          }
          p.words[g] = ee | 0, T = F | 0;
        }
        return T !== 0 ? p.words[g] = T | 0 : p.length--, p._strip();
      }
      var O = function(h, p, A) {
        var C = h.words, N = p.words, U = A.words, Y = 0, T, g, F, ee = C[0] | 0, E = ee & 8191, Z = ee >>> 13, k = C[1] | 0, X = k & 8191, $ = k >>> 13, ce = C[2] | 0, fe = ce & 8191, G = ce >>> 13, W = C[3] | 0, V = W & 8191, te = W >>> 13, pe = C[4] | 0, ue = pe & 8191, ye = pe >>> 13, we = C[5] | 0, Q = we & 8191, j = we >>> 13, ae = C[6] | 0, le = ae & 8191, be = ae >>> 13, xe = C[7] | 0, ie = xe & 8191, _ = xe >>> 13, b = C[8] | 0, v = b & 8191, J = b >>> 13, ne = C[9] | 0, se = ne & 8191, de = ne >>> 13, Fe = N[0] | 0, Re = Fe & 8191, Ne = Fe >>> 13, ot = N[1] | 0, Oe = ot & 8191, St = ot >>> 13, Vo = N[2] | 0, Tt = Vo & 8191, Ct = Vo >>> 13, zo = N[3] | 0, It = zo & 8191, Pt = zo >>> 13, Qo = N[4] | 0, _t23 = Qo & 8191, Rt = Qo >>> 13, jo = N[5] | 0, Nt = jo & 8191, Ot = jo >>> 13, Jo = N[6] | 0, Bt = Jo & 8191, Mt = Jo >>> 13, Ko = N[7] | 0, kt = Ko & 8191, Ft = Ko >>> 13, Wo = N[8] | 0, Lt = Wo & 8191, Dt = Wo >>> 13, qo = N[9] | 0, Ut = qo & 8191, Ht = qo >>> 13;
        A.negative = h.negative ^ p.negative, A.length = 19, T = Math.imul(E, Re), g = Math.imul(E, Ne), g = g + Math.imul(Z, Re) | 0, F = Math.imul(Z, Ne);
        var Ws = (Y + T | 0) + ((g & 8191) << 13) | 0;
        Y = (F + (g >>> 13) | 0) + (Ws >>> 26) | 0, Ws &= 67108863, T = Math.imul(X, Re), g = Math.imul(X, Ne), g = g + Math.imul($, Re) | 0, F = Math.imul($, Ne), T = T + Math.imul(E, Oe) | 0, g = g + Math.imul(E, St) | 0, g = g + Math.imul(Z, Oe) | 0, F = F + Math.imul(Z, St) | 0;
        var qs = (Y + T | 0) + ((g & 8191) << 13) | 0;
        Y = (F + (g >>> 13) | 0) + (qs >>> 26) | 0, qs &= 67108863, T = Math.imul(fe, Re), g = Math.imul(fe, Ne), g = g + Math.imul(G, Re) | 0, F = Math.imul(G, Ne), T = T + Math.imul(X, Oe) | 0, g = g + Math.imul(X, St) | 0, g = g + Math.imul($, Oe) | 0, F = F + Math.imul($, St) | 0, T = T + Math.imul(E, Tt) | 0, g = g + Math.imul(E, Ct) | 0, g = g + Math.imul(Z, Tt) | 0, F = F + Math.imul(Z, Ct) | 0;
        var Ys = (Y + T | 0) + ((g & 8191) << 13) | 0;
        Y = (F + (g >>> 13) | 0) + (Ys >>> 26) | 0, Ys &= 67108863, T = Math.imul(V, Re), g = Math.imul(V, Ne), g = g + Math.imul(te, Re) | 0, F = Math.imul(te, Ne), T = T + Math.imul(fe, Oe) | 0, g = g + Math.imul(fe, St) | 0, g = g + Math.imul(G, Oe) | 0, F = F + Math.imul(G, St) | 0, T = T + Math.imul(X, Tt) | 0, g = g + Math.imul(X, Ct) | 0, g = g + Math.imul($, Tt) | 0, F = F + Math.imul($, Ct) | 0, T = T + Math.imul(E, It) | 0, g = g + Math.imul(E, Pt) | 0, g = g + Math.imul(Z, It) | 0, F = F + Math.imul(Z, Pt) | 0;
        var Xs = (Y + T | 0) + ((g & 8191) << 13) | 0;
        Y = (F + (g >>> 13) | 0) + (Xs >>> 26) | 0, Xs &= 67108863, T = Math.imul(ue, Re), g = Math.imul(ue, Ne), g = g + Math.imul(ye, Re) | 0, F = Math.imul(ye, Ne), T = T + Math.imul(V, Oe) | 0, g = g + Math.imul(V, St) | 0, g = g + Math.imul(te, Oe) | 0, F = F + Math.imul(te, St) | 0, T = T + Math.imul(fe, Tt) | 0, g = g + Math.imul(fe, Ct) | 0, g = g + Math.imul(G, Tt) | 0, F = F + Math.imul(G, Ct) | 0, T = T + Math.imul(X, It) | 0, g = g + Math.imul(X, Pt) | 0, g = g + Math.imul($, It) | 0, F = F + Math.imul($, Pt) | 0, T = T + Math.imul(E, _t23) | 0, g = g + Math.imul(E, Rt) | 0, g = g + Math.imul(Z, _t23) | 0, F = F + Math.imul(Z, Rt) | 0;
        var Zs = (Y + T | 0) + ((g & 8191) << 13) | 0;
        Y = (F + (g >>> 13) | 0) + (Zs >>> 26) | 0, Zs &= 67108863, T = Math.imul(Q, Re), g = Math.imul(Q, Ne), g = g + Math.imul(j, Re) | 0, F = Math.imul(j, Ne), T = T + Math.imul(ue, Oe) | 0, g = g + Math.imul(ue, St) | 0, g = g + Math.imul(ye, Oe) | 0, F = F + Math.imul(ye, St) | 0, T = T + Math.imul(V, Tt) | 0, g = g + Math.imul(V, Ct) | 0, g = g + Math.imul(te, Tt) | 0, F = F + Math.imul(te, Ct) | 0, T = T + Math.imul(fe, It) | 0, g = g + Math.imul(fe, Pt) | 0, g = g + Math.imul(G, It) | 0, F = F + Math.imul(G, Pt) | 0, T = T + Math.imul(X, _t23) | 0, g = g + Math.imul(X, Rt) | 0, g = g + Math.imul($, _t23) | 0, F = F + Math.imul($, Rt) | 0, T = T + Math.imul(E, Nt) | 0, g = g + Math.imul(E, Ot) | 0, g = g + Math.imul(Z, Nt) | 0, F = F + Math.imul(Z, Ot) | 0;
        var Fh = (Y + T | 0) + ((g & 8191) << 13) | 0;
        Y = (F + (g >>> 13) | 0) + (Fh >>> 26) | 0, Fh &= 67108863, T = Math.imul(le, Re), g = Math.imul(le, Ne), g = g + Math.imul(be, Re) | 0, F = Math.imul(be, Ne), T = T + Math.imul(Q, Oe) | 0, g = g + Math.imul(Q, St) | 0, g = g + Math.imul(j, Oe) | 0, F = F + Math.imul(j, St) | 0, T = T + Math.imul(ue, Tt) | 0, g = g + Math.imul(ue, Ct) | 0, g = g + Math.imul(ye, Tt) | 0, F = F + Math.imul(ye, Ct) | 0, T = T + Math.imul(V, It) | 0, g = g + Math.imul(V, Pt) | 0, g = g + Math.imul(te, It) | 0, F = F + Math.imul(te, Pt) | 0, T = T + Math.imul(fe, _t23) | 0, g = g + Math.imul(fe, Rt) | 0, g = g + Math.imul(G, _t23) | 0, F = F + Math.imul(G, Rt) | 0, T = T + Math.imul(X, Nt) | 0, g = g + Math.imul(X, Ot) | 0, g = g + Math.imul($, Nt) | 0, F = F + Math.imul($, Ot) | 0, T = T + Math.imul(E, Bt) | 0, g = g + Math.imul(E, Mt) | 0, g = g + Math.imul(Z, Bt) | 0, F = F + Math.imul(Z, Mt) | 0;
        var Lh = (Y + T | 0) + ((g & 8191) << 13) | 0;
        Y = (F + (g >>> 13) | 0) + (Lh >>> 26) | 0, Lh &= 67108863, T = Math.imul(ie, Re), g = Math.imul(ie, Ne), g = g + Math.imul(_, Re) | 0, F = Math.imul(_, Ne), T = T + Math.imul(le, Oe) | 0, g = g + Math.imul(le, St) | 0, g = g + Math.imul(be, Oe) | 0, F = F + Math.imul(be, St) | 0, T = T + Math.imul(Q, Tt) | 0, g = g + Math.imul(Q, Ct) | 0, g = g + Math.imul(j, Tt) | 0, F = F + Math.imul(j, Ct) | 0, T = T + Math.imul(ue, It) | 0, g = g + Math.imul(ue, Pt) | 0, g = g + Math.imul(ye, It) | 0, F = F + Math.imul(ye, Pt) | 0, T = T + Math.imul(V, _t23) | 0, g = g + Math.imul(V, Rt) | 0, g = g + Math.imul(te, _t23) | 0, F = F + Math.imul(te, Rt) | 0, T = T + Math.imul(fe, Nt) | 0, g = g + Math.imul(fe, Ot) | 0, g = g + Math.imul(G, Nt) | 0, F = F + Math.imul(G, Ot) | 0, T = T + Math.imul(X, Bt) | 0, g = g + Math.imul(X, Mt) | 0, g = g + Math.imul($, Bt) | 0, F = F + Math.imul($, Mt) | 0, T = T + Math.imul(E, kt) | 0, g = g + Math.imul(E, Ft) | 0, g = g + Math.imul(Z, kt) | 0, F = F + Math.imul(Z, Ft) | 0;
        var Dh = (Y + T | 0) + ((g & 8191) << 13) | 0;
        Y = (F + (g >>> 13) | 0) + (Dh >>> 26) | 0, Dh &= 67108863, T = Math.imul(v, Re), g = Math.imul(v, Ne), g = g + Math.imul(J, Re) | 0, F = Math.imul(J, Ne), T = T + Math.imul(ie, Oe) | 0, g = g + Math.imul(ie, St) | 0, g = g + Math.imul(_, Oe) | 0, F = F + Math.imul(_, St) | 0, T = T + Math.imul(le, Tt) | 0, g = g + Math.imul(le, Ct) | 0, g = g + Math.imul(be, Tt) | 0, F = F + Math.imul(be, Ct) | 0, T = T + Math.imul(Q, It) | 0, g = g + Math.imul(Q, Pt) | 0, g = g + Math.imul(j, It) | 0, F = F + Math.imul(j, Pt) | 0, T = T + Math.imul(ue, _t23) | 0, g = g + Math.imul(ue, Rt) | 0, g = g + Math.imul(ye, _t23) | 0, F = F + Math.imul(ye, Rt) | 0, T = T + Math.imul(V, Nt) | 0, g = g + Math.imul(V, Ot) | 0, g = g + Math.imul(te, Nt) | 0, F = F + Math.imul(te, Ot) | 0, T = T + Math.imul(fe, Bt) | 0, g = g + Math.imul(fe, Mt) | 0, g = g + Math.imul(G, Bt) | 0, F = F + Math.imul(G, Mt) | 0, T = T + Math.imul(X, kt) | 0, g = g + Math.imul(X, Ft) | 0, g = g + Math.imul($, kt) | 0, F = F + Math.imul($, Ft) | 0, T = T + Math.imul(E, Lt) | 0, g = g + Math.imul(E, Dt) | 0, g = g + Math.imul(Z, Lt) | 0, F = F + Math.imul(Z, Dt) | 0;
        var Uh = (Y + T | 0) + ((g & 8191) << 13) | 0;
        Y = (F + (g >>> 13) | 0) + (Uh >>> 26) | 0, Uh &= 67108863, T = Math.imul(se, Re), g = Math.imul(se, Ne), g = g + Math.imul(de, Re) | 0, F = Math.imul(de, Ne), T = T + Math.imul(v, Oe) | 0, g = g + Math.imul(v, St) | 0, g = g + Math.imul(J, Oe) | 0, F = F + Math.imul(J, St) | 0, T = T + Math.imul(ie, Tt) | 0, g = g + Math.imul(ie, Ct) | 0, g = g + Math.imul(_, Tt) | 0, F = F + Math.imul(_, Ct) | 0, T = T + Math.imul(le, It) | 0, g = g + Math.imul(le, Pt) | 0, g = g + Math.imul(be, It) | 0, F = F + Math.imul(be, Pt) | 0, T = T + Math.imul(Q, _t23) | 0, g = g + Math.imul(Q, Rt) | 0, g = g + Math.imul(j, _t23) | 0, F = F + Math.imul(j, Rt) | 0, T = T + Math.imul(ue, Nt) | 0, g = g + Math.imul(ue, Ot) | 0, g = g + Math.imul(ye, Nt) | 0, F = F + Math.imul(ye, Ot) | 0, T = T + Math.imul(V, Bt) | 0, g = g + Math.imul(V, Mt) | 0, g = g + Math.imul(te, Bt) | 0, F = F + Math.imul(te, Mt) | 0, T = T + Math.imul(fe, kt) | 0, g = g + Math.imul(fe, Ft) | 0, g = g + Math.imul(G, kt) | 0, F = F + Math.imul(G, Ft) | 0, T = T + Math.imul(X, Lt) | 0, g = g + Math.imul(X, Dt) | 0, g = g + Math.imul($, Lt) | 0, F = F + Math.imul($, Dt) | 0, T = T + Math.imul(E, Ut) | 0, g = g + Math.imul(E, Ht) | 0, g = g + Math.imul(Z, Ut) | 0, F = F + Math.imul(Z, Ht) | 0;
        var Hh = (Y + T | 0) + ((g & 8191) << 13) | 0;
        Y = (F + (g >>> 13) | 0) + (Hh >>> 26) | 0, Hh &= 67108863, T = Math.imul(se, Oe), g = Math.imul(se, St), g = g + Math.imul(de, Oe) | 0, F = Math.imul(de, St), T = T + Math.imul(v, Tt) | 0, g = g + Math.imul(v, Ct) | 0, g = g + Math.imul(J, Tt) | 0, F = F + Math.imul(J, Ct) | 0, T = T + Math.imul(ie, It) | 0, g = g + Math.imul(ie, Pt) | 0, g = g + Math.imul(_, It) | 0, F = F + Math.imul(_, Pt) | 0, T = T + Math.imul(le, _t23) | 0, g = g + Math.imul(le, Rt) | 0, g = g + Math.imul(be, _t23) | 0, F = F + Math.imul(be, Rt) | 0, T = T + Math.imul(Q, Nt) | 0, g = g + Math.imul(Q, Ot) | 0, g = g + Math.imul(j, Nt) | 0, F = F + Math.imul(j, Ot) | 0, T = T + Math.imul(ue, Bt) | 0, g = g + Math.imul(ue, Mt) | 0, g = g + Math.imul(ye, Bt) | 0, F = F + Math.imul(ye, Mt) | 0, T = T + Math.imul(V, kt) | 0, g = g + Math.imul(V, Ft) | 0, g = g + Math.imul(te, kt) | 0, F = F + Math.imul(te, Ft) | 0, T = T + Math.imul(fe, Lt) | 0, g = g + Math.imul(fe, Dt) | 0, g = g + Math.imul(G, Lt) | 0, F = F + Math.imul(G, Dt) | 0, T = T + Math.imul(X, Ut) | 0, g = g + Math.imul(X, Ht) | 0, g = g + Math.imul($, Ut) | 0, F = F + Math.imul($, Ht) | 0;
        var Gh = (Y + T | 0) + ((g & 8191) << 13) | 0;
        Y = (F + (g >>> 13) | 0) + (Gh >>> 26) | 0, Gh &= 67108863, T = Math.imul(se, Tt), g = Math.imul(se, Ct), g = g + Math.imul(de, Tt) | 0, F = Math.imul(de, Ct), T = T + Math.imul(v, It) | 0, g = g + Math.imul(v, Pt) | 0, g = g + Math.imul(J, It) | 0, F = F + Math.imul(J, Pt) | 0, T = T + Math.imul(ie, _t23) | 0, g = g + Math.imul(ie, Rt) | 0, g = g + Math.imul(_, _t23) | 0, F = F + Math.imul(_, Rt) | 0, T = T + Math.imul(le, Nt) | 0, g = g + Math.imul(le, Ot) | 0, g = g + Math.imul(be, Nt) | 0, F = F + Math.imul(be, Ot) | 0, T = T + Math.imul(Q, Bt) | 0, g = g + Math.imul(Q, Mt) | 0, g = g + Math.imul(j, Bt) | 0, F = F + Math.imul(j, Mt) | 0, T = T + Math.imul(ue, kt) | 0, g = g + Math.imul(ue, Ft) | 0, g = g + Math.imul(ye, kt) | 0, F = F + Math.imul(ye, Ft) | 0, T = T + Math.imul(V, Lt) | 0, g = g + Math.imul(V, Dt) | 0, g = g + Math.imul(te, Lt) | 0, F = F + Math.imul(te, Dt) | 0, T = T + Math.imul(fe, Ut) | 0, g = g + Math.imul(fe, Ht) | 0, g = g + Math.imul(G, Ut) | 0, F = F + Math.imul(G, Ht) | 0;
        var Vh = (Y + T | 0) + ((g & 8191) << 13) | 0;
        Y = (F + (g >>> 13) | 0) + (Vh >>> 26) | 0, Vh &= 67108863, T = Math.imul(se, It), g = Math.imul(se, Pt), g = g + Math.imul(de, It) | 0, F = Math.imul(de, Pt), T = T + Math.imul(v, _t23) | 0, g = g + Math.imul(v, Rt) | 0, g = g + Math.imul(J, _t23) | 0, F = F + Math.imul(J, Rt) | 0, T = T + Math.imul(ie, Nt) | 0, g = g + Math.imul(ie, Ot) | 0, g = g + Math.imul(_, Nt) | 0, F = F + Math.imul(_, Ot) | 0, T = T + Math.imul(le, Bt) | 0, g = g + Math.imul(le, Mt) | 0, g = g + Math.imul(be, Bt) | 0, F = F + Math.imul(be, Mt) | 0, T = T + Math.imul(Q, kt) | 0, g = g + Math.imul(Q, Ft) | 0, g = g + Math.imul(j, kt) | 0, F = F + Math.imul(j, Ft) | 0, T = T + Math.imul(ue, Lt) | 0, g = g + Math.imul(ue, Dt) | 0, g = g + Math.imul(ye, Lt) | 0, F = F + Math.imul(ye, Dt) | 0, T = T + Math.imul(V, Ut) | 0, g = g + Math.imul(V, Ht) | 0, g = g + Math.imul(te, Ut) | 0, F = F + Math.imul(te, Ht) | 0;
        var zh = (Y + T | 0) + ((g & 8191) << 13) | 0;
        Y = (F + (g >>> 13) | 0) + (zh >>> 26) | 0, zh &= 67108863, T = Math.imul(se, _t23), g = Math.imul(se, Rt), g = g + Math.imul(de, _t23) | 0, F = Math.imul(de, Rt), T = T + Math.imul(v, Nt) | 0, g = g + Math.imul(v, Ot) | 0, g = g + Math.imul(J, Nt) | 0, F = F + Math.imul(J, Ot) | 0, T = T + Math.imul(ie, Bt) | 0, g = g + Math.imul(ie, Mt) | 0, g = g + Math.imul(_, Bt) | 0, F = F + Math.imul(_, Mt) | 0, T = T + Math.imul(le, kt) | 0, g = g + Math.imul(le, Ft) | 0, g = g + Math.imul(be, kt) | 0, F = F + Math.imul(be, Ft) | 0, T = T + Math.imul(Q, Lt) | 0, g = g + Math.imul(Q, Dt) | 0, g = g + Math.imul(j, Lt) | 0, F = F + Math.imul(j, Dt) | 0, T = T + Math.imul(ue, Ut) | 0, g = g + Math.imul(ue, Ht) | 0, g = g + Math.imul(ye, Ut) | 0, F = F + Math.imul(ye, Ht) | 0;
        var Qh = (Y + T | 0) + ((g & 8191) << 13) | 0;
        Y = (F + (g >>> 13) | 0) + (Qh >>> 26) | 0, Qh &= 67108863, T = Math.imul(se, Nt), g = Math.imul(se, Ot), g = g + Math.imul(de, Nt) | 0, F = Math.imul(de, Ot), T = T + Math.imul(v, Bt) | 0, g = g + Math.imul(v, Mt) | 0, g = g + Math.imul(J, Bt) | 0, F = F + Math.imul(J, Mt) | 0, T = T + Math.imul(ie, kt) | 0, g = g + Math.imul(ie, Ft) | 0, g = g + Math.imul(_, kt) | 0, F = F + Math.imul(_, Ft) | 0, T = T + Math.imul(le, Lt) | 0, g = g + Math.imul(le, Dt) | 0, g = g + Math.imul(be, Lt) | 0, F = F + Math.imul(be, Dt) | 0, T = T + Math.imul(Q, Ut) | 0, g = g + Math.imul(Q, Ht) | 0, g = g + Math.imul(j, Ut) | 0, F = F + Math.imul(j, Ht) | 0;
        var jh = (Y + T | 0) + ((g & 8191) << 13) | 0;
        Y = (F + (g >>> 13) | 0) + (jh >>> 26) | 0, jh &= 67108863, T = Math.imul(se, Bt), g = Math.imul(se, Mt), g = g + Math.imul(de, Bt) | 0, F = Math.imul(de, Mt), T = T + Math.imul(v, kt) | 0, g = g + Math.imul(v, Ft) | 0, g = g + Math.imul(J, kt) | 0, F = F + Math.imul(J, Ft) | 0, T = T + Math.imul(ie, Lt) | 0, g = g + Math.imul(ie, Dt) | 0, g = g + Math.imul(_, Lt) | 0, F = F + Math.imul(_, Dt) | 0, T = T + Math.imul(le, Ut) | 0, g = g + Math.imul(le, Ht) | 0, g = g + Math.imul(be, Ut) | 0, F = F + Math.imul(be, Ht) | 0;
        var Jh = (Y + T | 0) + ((g & 8191) << 13) | 0;
        Y = (F + (g >>> 13) | 0) + (Jh >>> 26) | 0, Jh &= 67108863, T = Math.imul(se, kt), g = Math.imul(se, Ft), g = g + Math.imul(de, kt) | 0, F = Math.imul(de, Ft), T = T + Math.imul(v, Lt) | 0, g = g + Math.imul(v, Dt) | 0, g = g + Math.imul(J, Lt) | 0, F = F + Math.imul(J, Dt) | 0, T = T + Math.imul(ie, Ut) | 0, g = g + Math.imul(ie, Ht) | 0, g = g + Math.imul(_, Ut) | 0, F = F + Math.imul(_, Ht) | 0;
        var Kh = (Y + T | 0) + ((g & 8191) << 13) | 0;
        Y = (F + (g >>> 13) | 0) + (Kh >>> 26) | 0, Kh &= 67108863, T = Math.imul(se, Lt), g = Math.imul(se, Dt), g = g + Math.imul(de, Lt) | 0, F = Math.imul(de, Dt), T = T + Math.imul(v, Ut) | 0, g = g + Math.imul(v, Ht) | 0, g = g + Math.imul(J, Ut) | 0, F = F + Math.imul(J, Ht) | 0;
        var Wh = (Y + T | 0) + ((g & 8191) << 13) | 0;
        Y = (F + (g >>> 13) | 0) + (Wh >>> 26) | 0, Wh &= 67108863, T = Math.imul(se, Ut), g = Math.imul(se, Ht), g = g + Math.imul(de, Ut) | 0, F = Math.imul(de, Ht);
        var qh = (Y + T | 0) + ((g & 8191) << 13) | 0;
        return Y = (F + (g >>> 13) | 0) + (qh >>> 26) | 0, qh &= 67108863, U[0] = Ws, U[1] = qs, U[2] = Ys, U[3] = Xs, U[4] = Zs, U[5] = Fh, U[6] = Lh, U[7] = Dh, U[8] = Uh, U[9] = Hh, U[10] = Gh, U[11] = Vh, U[12] = zh, U[13] = Qh, U[14] = jh, U[15] = Jh, U[16] = Kh, U[17] = Wh, U[18] = qh, Y !== 0 && (U[19] = Y, A.length++), A;
      };
      Math.imul || (O = R);
      function B(I, h, p) {
        p.negative = h.negative ^ I.negative, p.length = I.length + h.length;
        for (var A = 0, C = 0, N = 0; N < p.length - 1; N++) {
          var U = C;
          C = 0;
          for (var Y = A & 67108863, T = Math.min(N, h.length - 1), g = Math.max(0, N - I.length + 1); g <= T; g++) {
            var F = N - g, ee = I.words[F] | 0, E = h.words[g] | 0, Z = ee * E, k = Z & 67108863;
            U = U + (Z / 67108864 | 0) | 0, k = k + Y | 0, Y = k & 67108863, U = U + (k >>> 26) | 0, C += U >>> 26, U &= 67108863;
          }
          p.words[N] = Y, A = U, U = C;
        }
        return A !== 0 ? p.words[N] = A : p.length--, p._strip();
      }
      function M(I, h, p) {
        return B(I, h, p);
      }
      s.prototype.mulTo = function(h, p) {
        var A, C = this.length + h.length;
        return this.length === 10 && h.length === 10 ? A = O(this, h, p) : C < 63 ? A = R(this, h, p) : C < 1024 ? A = B(this, h, p) : A = M(this, h, p), A;
      }, s.prototype.mul = function(h) {
        var p = new s(null);
        return p.words = new Array(this.length + h.length), this.mulTo(h, p);
      }, s.prototype.mulf = function(h) {
        var p = new s(null);
        return p.words = new Array(this.length + h.length), M(this, h, p);
      }, s.prototype.imul = function(h) {
        return this.clone().mulTo(h, this);
      }, s.prototype.imuln = function(h) {
        var p = h < 0;
        p && (h = -h), r(typeof h == "number"), r(h < 67108864);
        for (var A = 0, C = 0; C < this.length; C++) {
          var N = (this.words[C] | 0) * h, U = (N & 67108863) + (A & 67108863);
          A >>= 26, A += N / 67108864 | 0, A += U >>> 26, this.words[C] = U & 67108863;
        }
        return A !== 0 && (this.words[C] = A, this.length++), this.length = h === 0 ? 1 : this.length, p ? this.ineg() : this;
      }, s.prototype.muln = function(h) {
        return this.clone().imuln(h);
      }, s.prototype.sqr = function() {
        return this.mul(this);
      }, s.prototype.isqr = function() {
        return this.imul(this.clone());
      }, s.prototype.pow = function(h) {
        var p = w(h);
        if (p.length === 0) return new s(1);
        for (var A = this, C = 0; C < p.length && p[C] === 0; C++, A = A.sqr()) ;
        if (++C < p.length) for (var N = A.sqr(); C < p.length; C++, N = N.sqr()) p[C] !== 0 && (A = A.mul(N));
        return A;
      }, s.prototype.iushln = function(h) {
        r(typeof h == "number" && h >= 0);
        var p = h % 26, A = (h - p) / 26, C = 67108863 >>> 26 - p << 26 - p, N;
        if (p !== 0) {
          var U = 0;
          for (N = 0; N < this.length; N++) {
            var Y = this.words[N] & C, T = (this.words[N] | 0) - Y << p;
            this.words[N] = T | U, U = Y >>> 26 - p;
          }
          U && (this.words[N] = U, this.length++);
        }
        if (A !== 0) {
          for (N = this.length - 1; N >= 0; N--) this.words[N + A] = this.words[N];
          for (N = 0; N < A; N++) this.words[N] = 0;
          this.length += A;
        }
        return this._strip();
      }, s.prototype.ishln = function(h) {
        return r(this.negative === 0), this.iushln(h);
      }, s.prototype.iushrn = function(h, p, A) {
        r(typeof h == "number" && h >= 0);
        var C;
        p ? C = (p - p % 26) / 26 : C = 0;
        var N = h % 26, U = Math.min((h - N) / 26, this.length), Y = 67108863 ^ 67108863 >>> N << N, T = A;
        if (C -= U, C = Math.max(0, C), T) {
          for (var g = 0; g < U; g++) T.words[g] = this.words[g];
          T.length = U;
        }
        if (U !== 0) if (this.length > U) for (this.length -= U, g = 0; g < this.length; g++) this.words[g] = this.words[g + U];
        else this.words[0] = 0, this.length = 1;
        var F = 0;
        for (g = this.length - 1; g >= 0 && (F !== 0 || g >= C); g--) {
          var ee = this.words[g] | 0;
          this.words[g] = F << 26 - N | ee >>> N, F = ee & Y;
        }
        return T && F !== 0 && (T.words[T.length++] = F), this.length === 0 && (this.words[0] = 0, this.length = 1), this._strip();
      }, s.prototype.ishrn = function(h, p, A) {
        return r(this.negative === 0), this.iushrn(h, p, A);
      }, s.prototype.shln = function(h) {
        return this.clone().ishln(h);
      }, s.prototype.ushln = function(h) {
        return this.clone().iushln(h);
      }, s.prototype.shrn = function(h) {
        return this.clone().ishrn(h);
      }, s.prototype.ushrn = function(h) {
        return this.clone().iushrn(h);
      }, s.prototype.testn = function(h) {
        r(typeof h == "number" && h >= 0);
        var p = h % 26, A = (h - p) / 26, C = 1 << p;
        if (this.length <= A) return false;
        var N = this.words[A];
        return !!(N & C);
      }, s.prototype.imaskn = function(h) {
        r(typeof h == "number" && h >= 0);
        var p = h % 26, A = (h - p) / 26;
        if (r(this.negative === 0, "imaskn works only with positive numbers"), this.length <= A) return this;
        if (p !== 0 && A++, this.length = Math.min(A, this.length), p !== 0) {
          var C = 67108863 ^ 67108863 >>> p << p;
          this.words[this.length - 1] &= C;
        }
        return this._strip();
      }, s.prototype.maskn = function(h) {
        return this.clone().imaskn(h);
      }, s.prototype.iaddn = function(h) {
        return r(typeof h == "number"), r(h < 67108864), h < 0 ? this.isubn(-h) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) <= h ? (this.words[0] = h - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(h), this.negative = 1, this) : this._iaddn(h);
      }, s.prototype._iaddn = function(h) {
        this.words[0] += h;
        for (var p = 0; p < this.length && this.words[p] >= 67108864; p++) this.words[p] -= 67108864, p === this.length - 1 ? this.words[p + 1] = 1 : this.words[p + 1]++;
        return this.length = Math.max(this.length, p + 1), this;
      }, s.prototype.isubn = function(h) {
        if (r(typeof h == "number"), r(h < 67108864), h < 0) return this.iaddn(-h);
        if (this.negative !== 0) return this.negative = 0, this.iaddn(h), this.negative = 1, this;
        if (this.words[0] -= h, this.length === 1 && this.words[0] < 0) this.words[0] = -this.words[0], this.negative = 1;
        else for (var p = 0; p < this.length && this.words[p] < 0; p++) this.words[p] += 67108864, this.words[p + 1] -= 1;
        return this._strip();
      }, s.prototype.addn = function(h) {
        return this.clone().iaddn(h);
      }, s.prototype.subn = function(h) {
        return this.clone().isubn(h);
      }, s.prototype.iabs = function() {
        return this.negative = 0, this;
      }, s.prototype.abs = function() {
        return this.clone().iabs();
      }, s.prototype._ishlnsubmul = function(h, p, A) {
        var C = h.length + A, N;
        this._expand(C);
        var U, Y = 0;
        for (N = 0; N < h.length; N++) {
          U = (this.words[N + A] | 0) + Y;
          var T = (h.words[N] | 0) * p;
          U -= T & 67108863, Y = (U >> 26) - (T / 67108864 | 0), this.words[N + A] = U & 67108863;
        }
        for (; N < this.length - A; N++) U = (this.words[N + A] | 0) + Y, Y = U >> 26, this.words[N + A] = U & 67108863;
        if (Y === 0) return this._strip();
        for (r(Y === -1), Y = 0, N = 0; N < this.length; N++) U = -(this.words[N] | 0) + Y, Y = U >> 26, this.words[N] = U & 67108863;
        return this.negative = 1, this._strip();
      }, s.prototype._wordDiv = function(h, p) {
        var A = this.length - h.length, C = this.clone(), N = h, U = N.words[N.length - 1] | 0, Y = this._countBits(U);
        A = 26 - Y, A !== 0 && (N = N.ushln(A), C.iushln(A), U = N.words[N.length - 1] | 0);
        var T = C.length - N.length, g;
        if (p !== "mod") {
          g = new s(null), g.length = T + 1, g.words = new Array(g.length);
          for (var F = 0; F < g.length; F++) g.words[F] = 0;
        }
        var ee = C.clone()._ishlnsubmul(N, 1, T);
        ee.negative === 0 && (C = ee, g && (g.words[T] = 1));
        for (var E = T - 1; E >= 0; E--) {
          var Z = (C.words[N.length + E] | 0) * 67108864 + (C.words[N.length + E - 1] | 0);
          for (Z = Math.min(Z / U | 0, 67108863), C._ishlnsubmul(N, Z, E); C.negative !== 0; ) Z--, C.negative = 0, C._ishlnsubmul(N, 1, E), C.isZero() || (C.negative ^= 1);
          g && (g.words[E] = Z);
        }
        return g && g._strip(), C._strip(), p !== "div" && A !== 0 && C.iushrn(A), {
          div: g || null,
          mod: C
        };
      }, s.prototype.divmod = function(h, p, A) {
        if (r(!h.isZero()), this.isZero()) return {
          div: new s(0),
          mod: new s(0)
        };
        var C, N, U;
        return this.negative !== 0 && h.negative === 0 ? (U = this.neg().divmod(h, p), p !== "mod" && (C = U.div.neg()), p !== "div" && (N = U.mod.neg(), A && N.negative !== 0 && N.iadd(h)), {
          div: C,
          mod: N
        }) : this.negative === 0 && h.negative !== 0 ? (U = this.divmod(h.neg(), p), p !== "mod" && (C = U.div.neg()), {
          div: C,
          mod: U.mod
        }) : this.negative & h.negative ? (U = this.neg().divmod(h.neg(), p), p !== "div" && (N = U.mod.neg(), A && N.negative !== 0 && N.isub(h)), {
          div: U.div,
          mod: N
        }) : h.length > this.length || this.cmp(h) < 0 ? {
          div: new s(0),
          mod: this
        } : h.length === 1 ? p === "div" ? {
          div: this.divn(h.words[0]),
          mod: null
        } : p === "mod" ? {
          div: null,
          mod: new s(this.modrn(h.words[0]))
        } : {
          div: this.divn(h.words[0]),
          mod: new s(this.modrn(h.words[0]))
        } : this._wordDiv(h, p);
      }, s.prototype.div = function(h) {
        return this.divmod(h, "div", false).div;
      }, s.prototype.mod = function(h) {
        return this.divmod(h, "mod", false).mod;
      }, s.prototype.umod = function(h) {
        return this.divmod(h, "mod", true).mod;
      }, s.prototype.divRound = function(h) {
        var p = this.divmod(h);
        if (p.mod.isZero()) return p.div;
        var A = p.div.negative !== 0 ? p.mod.isub(h) : p.mod, C = h.ushrn(1), N = h.andln(1), U = A.cmp(C);
        return U < 0 || N === 1 && U === 0 ? p.div : p.div.negative !== 0 ? p.div.isubn(1) : p.div.iaddn(1);
      }, s.prototype.modrn = function(h) {
        var p = h < 0;
        p && (h = -h), r(h <= 67108863);
        for (var A = (1 << 26) % h, C = 0, N = this.length - 1; N >= 0; N--) C = (A * C + (this.words[N] | 0)) % h;
        return p ? -C : C;
      }, s.prototype.modn = function(h) {
        return this.modrn(h);
      }, s.prototype.idivn = function(h) {
        var p = h < 0;
        p && (h = -h), r(h <= 67108863);
        for (var A = 0, C = this.length - 1; C >= 0; C--) {
          var N = (this.words[C] | 0) + A * 67108864;
          this.words[C] = N / h | 0, A = N % h;
        }
        return this._strip(), p ? this.ineg() : this;
      }, s.prototype.divn = function(h) {
        return this.clone().idivn(h);
      }, s.prototype.egcd = function(h) {
        r(h.negative === 0), r(!h.isZero());
        var p = this, A = h.clone();
        p.negative !== 0 ? p = p.umod(h) : p = p.clone();
        for (var C = new s(1), N = new s(0), U = new s(0), Y = new s(1), T = 0; p.isEven() && A.isEven(); ) p.iushrn(1), A.iushrn(1), ++T;
        for (var g = A.clone(), F = p.clone(); !p.isZero(); ) {
          for (var ee = 0, E = 1; !(p.words[0] & E) && ee < 26; ++ee, E <<= 1) ;
          if (ee > 0) for (p.iushrn(ee); ee-- > 0; ) (C.isOdd() || N.isOdd()) && (C.iadd(g), N.isub(F)), C.iushrn(1), N.iushrn(1);
          for (var Z = 0, k = 1; !(A.words[0] & k) && Z < 26; ++Z, k <<= 1) ;
          if (Z > 0) for (A.iushrn(Z); Z-- > 0; ) (U.isOdd() || Y.isOdd()) && (U.iadd(g), Y.isub(F)), U.iushrn(1), Y.iushrn(1);
          p.cmp(A) >= 0 ? (p.isub(A), C.isub(U), N.isub(Y)) : (A.isub(p), U.isub(C), Y.isub(N));
        }
        return {
          a: U,
          b: Y,
          gcd: A.iushln(T)
        };
      }, s.prototype._invmp = function(h) {
        r(h.negative === 0), r(!h.isZero());
        var p = this, A = h.clone();
        p.negative !== 0 ? p = p.umod(h) : p = p.clone();
        for (var C = new s(1), N = new s(0), U = A.clone(); p.cmpn(1) > 0 && A.cmpn(1) > 0; ) {
          for (var Y = 0, T = 1; !(p.words[0] & T) && Y < 26; ++Y, T <<= 1) ;
          if (Y > 0) for (p.iushrn(Y); Y-- > 0; ) C.isOdd() && C.iadd(U), C.iushrn(1);
          for (var g = 0, F = 1; !(A.words[0] & F) && g < 26; ++g, F <<= 1) ;
          if (g > 0) for (A.iushrn(g); g-- > 0; ) N.isOdd() && N.iadd(U), N.iushrn(1);
          p.cmp(A) >= 0 ? (p.isub(A), C.isub(N)) : (A.isub(p), N.isub(C));
        }
        var ee;
        return p.cmpn(1) === 0 ? ee = C : ee = N, ee.cmpn(0) < 0 && ee.iadd(h), ee;
      }, s.prototype.gcd = function(h) {
        if (this.isZero()) return h.abs();
        if (h.isZero()) return this.abs();
        var p = this.clone(), A = h.clone();
        p.negative = 0, A.negative = 0;
        for (var C = 0; p.isEven() && A.isEven(); C++) p.iushrn(1), A.iushrn(1);
        do {
          for (; p.isEven(); ) p.iushrn(1);
          for (; A.isEven(); ) A.iushrn(1);
          var N = p.cmp(A);
          if (N < 0) {
            var U = p;
            p = A, A = U;
          } else if (N === 0 || A.cmpn(1) === 0) break;
          p.isub(A);
        } while (true);
        return A.iushln(C);
      }, s.prototype.invm = function(h) {
        return this.egcd(h).a.umod(h);
      }, s.prototype.isEven = function() {
        return (this.words[0] & 1) === 0;
      }, s.prototype.isOdd = function() {
        return (this.words[0] & 1) === 1;
      }, s.prototype.andln = function(h) {
        return this.words[0] & h;
      }, s.prototype.bincn = function(h) {
        r(typeof h == "number");
        var p = h % 26, A = (h - p) / 26, C = 1 << p;
        if (this.length <= A) return this._expand(A + 1), this.words[A] |= C, this;
        for (var N = C, U = A; N !== 0 && U < this.length; U++) {
          var Y = this.words[U] | 0;
          Y += N, N = Y >>> 26, Y &= 67108863, this.words[U] = Y;
        }
        return N !== 0 && (this.words[U] = N, this.length++), this;
      }, s.prototype.isZero = function() {
        return this.length === 1 && this.words[0] === 0;
      }, s.prototype.cmpn = function(h) {
        var p = h < 0;
        if (this.negative !== 0 && !p) return -1;
        if (this.negative === 0 && p) return 1;
        this._strip();
        var A;
        if (this.length > 1) A = 1;
        else {
          p && (h = -h), r(h <= 67108863, "Number is too big");
          var C = this.words[0] | 0;
          A = C === h ? 0 : C < h ? -1 : 1;
        }
        return this.negative !== 0 ? -A | 0 : A;
      }, s.prototype.cmp = function(h) {
        if (this.negative !== 0 && h.negative === 0) return -1;
        if (this.negative === 0 && h.negative !== 0) return 1;
        var p = this.ucmp(h);
        return this.negative !== 0 ? -p | 0 : p;
      }, s.prototype.ucmp = function(h) {
        if (this.length > h.length) return 1;
        if (this.length < h.length) return -1;
        for (var p = 0, A = this.length - 1; A >= 0; A--) {
          var C = this.words[A] | 0, N = h.words[A] | 0;
          if (C !== N) {
            C < N ? p = -1 : C > N && (p = 1);
            break;
          }
        }
        return p;
      }, s.prototype.gtn = function(h) {
        return this.cmpn(h) === 1;
      }, s.prototype.gt = function(h) {
        return this.cmp(h) === 1;
      }, s.prototype.gten = function(h) {
        return this.cmpn(h) >= 0;
      }, s.prototype.gte = function(h) {
        return this.cmp(h) >= 0;
      }, s.prototype.ltn = function(h) {
        return this.cmpn(h) === -1;
      }, s.prototype.lt = function(h) {
        return this.cmp(h) === -1;
      }, s.prototype.lten = function(h) {
        return this.cmpn(h) <= 0;
      }, s.prototype.lte = function(h) {
        return this.cmp(h) <= 0;
      }, s.prototype.eqn = function(h) {
        return this.cmpn(h) === 0;
      }, s.prototype.eq = function(h) {
        return this.cmp(h) === 0;
      }, s.red = function(h) {
        return new K(h);
      }, s.prototype.toRed = function(h) {
        return r(!this.red, "Already a number in reduction context"), r(this.negative === 0, "red works only with positives"), h.convertTo(this)._forceRed(h);
      }, s.prototype.fromRed = function() {
        return r(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
      }, s.prototype._forceRed = function(h) {
        return this.red = h, this;
      }, s.prototype.forceRed = function(h) {
        return r(!this.red, "Already a number in reduction context"), this._forceRed(h);
      }, s.prototype.redAdd = function(h) {
        return r(this.red, "redAdd works only with red numbers"), this.red.add(this, h);
      }, s.prototype.redIAdd = function(h) {
        return r(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, h);
      }, s.prototype.redSub = function(h) {
        return r(this.red, "redSub works only with red numbers"), this.red.sub(this, h);
      }, s.prototype.redISub = function(h) {
        return r(this.red, "redISub works only with red numbers"), this.red.isub(this, h);
      }, s.prototype.redShl = function(h) {
        return r(this.red, "redShl works only with red numbers"), this.red.shl(this, h);
      }, s.prototype.redMul = function(h) {
        return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, h), this.red.mul(this, h);
      }, s.prototype.redIMul = function(h) {
        return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, h), this.red.imul(this, h);
      }, s.prototype.redSqr = function() {
        return r(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
      }, s.prototype.redISqr = function() {
        return r(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
      }, s.prototype.redSqrt = function() {
        return r(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
      }, s.prototype.redInvm = function() {
        return r(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
      }, s.prototype.redNeg = function() {
        return r(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
      }, s.prototype.redPow = function(h) {
        return r(this.red && !h.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, h);
      };
      var D = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function H(I, h) {
        this.name = I, this.p = new s(h, 16), this.n = this.p.bitLength(), this.k = new s(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
      }
      H.prototype._tmp = function() {
        var h = new s(null);
        return h.words = new Array(Math.ceil(this.n / 13)), h;
      }, H.prototype.ireduce = function(h) {
        var p = h, A;
        do
          this.split(p, this.tmp), p = this.imulK(p), p = p.iadd(this.tmp), A = p.bitLength();
        while (A > this.n);
        var C = A < this.n ? -1 : p.ucmp(this.p);
        return C === 0 ? (p.words[0] = 0, p.length = 1) : C > 0 ? p.isub(this.p) : p.strip !== void 0 ? p.strip() : p._strip(), p;
      }, H.prototype.split = function(h, p) {
        h.iushrn(this.n, 0, p);
      }, H.prototype.imulK = function(h) {
        return h.imul(this.k);
      };
      function q() {
        H.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
      }
      i(q, H), q.prototype.split = function(h, p) {
        for (var A = 4194303, C = Math.min(h.length, 9), N = 0; N < C; N++) p.words[N] = h.words[N];
        if (p.length = C, h.length <= 9) {
          h.words[0] = 0, h.length = 1;
          return;
        }
        var U = h.words[9];
        for (p.words[p.length++] = U & A, N = 10; N < h.length; N++) {
          var Y = h.words[N] | 0;
          h.words[N - 10] = (Y & A) << 4 | U >>> 22, U = Y;
        }
        U >>>= 22, h.words[N - 10] = U, U === 0 && h.length > 10 ? h.length -= 10 : h.length -= 9;
      }, q.prototype.imulK = function(h) {
        h.words[h.length] = 0, h.words[h.length + 1] = 0, h.length += 2;
        for (var p = 0, A = 0; A < h.length; A++) {
          var C = h.words[A] | 0;
          p += C * 977, h.words[A] = p & 67108863, p = C * 64 + (p / 67108864 | 0);
        }
        return h.words[h.length - 1] === 0 && (h.length--, h.words[h.length - 1] === 0 && h.length--), h;
      };
      function S() {
        H.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
      }
      i(S, H);
      function P() {
        H.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
      }
      i(P, H);
      function L() {
        H.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
      }
      i(L, H), L.prototype.imulK = function(h) {
        for (var p = 0, A = 0; A < h.length; A++) {
          var C = (h.words[A] | 0) * 19 + p, N = C & 67108863;
          C >>>= 26, h.words[A] = N, p = C;
        }
        return p !== 0 && (h.words[h.length++] = p), h;
      }, s._prime = function(h) {
        if (D[h]) return D[h];
        var p;
        if (h === "k256") p = new q();
        else if (h === "p224") p = new S();
        else if (h === "p192") p = new P();
        else if (h === "p25519") p = new L();
        else throw new Error("Unknown prime " + h);
        return D[h] = p, p;
      };
      function K(I) {
        if (typeof I == "string") {
          var h = s._prime(I);
          this.m = h.p, this.prime = h;
        } else r(I.gtn(1), "modulus must be greater than 1"), this.m = I, this.prime = null;
      }
      K.prototype._verify1 = function(h) {
        r(h.negative === 0, "red works only with positives"), r(h.red, "red works only with red numbers");
      }, K.prototype._verify2 = function(h, p) {
        r((h.negative | p.negative) === 0, "red works only with positives"), r(h.red && h.red === p.red, "red works only with red numbers");
      }, K.prototype.imod = function(h) {
        return this.prime ? this.prime.ireduce(h)._forceRed(this) : (u(h, h.umod(this.m)._forceRed(this)), h);
      }, K.prototype.neg = function(h) {
        return h.isZero() ? h.clone() : this.m.sub(h)._forceRed(this);
      }, K.prototype.add = function(h, p) {
        this._verify2(h, p);
        var A = h.add(p);
        return A.cmp(this.m) >= 0 && A.isub(this.m), A._forceRed(this);
      }, K.prototype.iadd = function(h, p) {
        this._verify2(h, p);
        var A = h.iadd(p);
        return A.cmp(this.m) >= 0 && A.isub(this.m), A;
      }, K.prototype.sub = function(h, p) {
        this._verify2(h, p);
        var A = h.sub(p);
        return A.cmpn(0) < 0 && A.iadd(this.m), A._forceRed(this);
      }, K.prototype.isub = function(h, p) {
        this._verify2(h, p);
        var A = h.isub(p);
        return A.cmpn(0) < 0 && A.iadd(this.m), A;
      }, K.prototype.shl = function(h, p) {
        return this._verify1(h), this.imod(h.ushln(p));
      }, K.prototype.imul = function(h, p) {
        return this._verify2(h, p), this.imod(h.imul(p));
      }, K.prototype.mul = function(h, p) {
        return this._verify2(h, p), this.imod(h.mul(p));
      }, K.prototype.isqr = function(h) {
        return this.imul(h, h.clone());
      }, K.prototype.sqr = function(h) {
        return this.mul(h, h);
      }, K.prototype.sqrt = function(h) {
        if (h.isZero()) return h.clone();
        var p = this.m.andln(3);
        if (r(p % 2 === 1), p === 3) {
          var A = this.m.add(new s(1)).iushrn(2);
          return this.pow(h, A);
        }
        for (var C = this.m.subn(1), N = 0; !C.isZero() && C.andln(1) === 0; ) N++, C.iushrn(1);
        r(!C.isZero());
        var U = new s(1).toRed(this), Y = U.redNeg(), T = this.m.subn(1).iushrn(1), g = this.m.bitLength();
        for (g = new s(2 * g * g).toRed(this); this.pow(g, T).cmp(Y) !== 0; ) g.redIAdd(Y);
        for (var F = this.pow(g, C), ee = this.pow(h, C.addn(1).iushrn(1)), E = this.pow(h, C), Z = N; E.cmp(U) !== 0; ) {
          for (var k = E, X = 0; k.cmp(U) !== 0; X++) k = k.redSqr();
          r(X < Z);
          var $ = this.pow(F, new s(1).iushln(Z - X - 1));
          ee = ee.redMul($), F = $.redSqr(), E = E.redMul(F), Z = X;
        }
        return ee;
      }, K.prototype.invm = function(h) {
        var p = h._invmp(this.m);
        return p.negative !== 0 ? (p.negative = 0, this.imod(p).redNeg()) : this.imod(p);
      }, K.prototype.pow = function(h, p) {
        if (p.isZero()) return new s(1).toRed(this);
        if (p.cmpn(1) === 0) return h.clone();
        var A = 4, C = new Array(1 << A);
        C[0] = new s(1).toRed(this), C[1] = h;
        for (var N = 2; N < C.length; N++) C[N] = this.mul(C[N - 1], h);
        var U = C[0], Y = 0, T = 0, g = p.bitLength() % 26;
        for (g === 0 && (g = 26), N = p.length - 1; N >= 0; N--) {
          for (var F = p.words[N], ee = g - 1; ee >= 0; ee--) {
            var E = F >> ee & 1;
            if (U !== C[0] && (U = this.sqr(U)), E === 0 && Y === 0) {
              T = 0;
              continue;
            }
            Y <<= 1, Y |= E, T++, !(T !== A && (N !== 0 || ee !== 0)) && (U = this.mul(U, C[Y]), T = 0, Y = 0);
          }
          g = 26;
        }
        return U;
      }, K.prototype.convertTo = function(h) {
        var p = h.umod(this.m);
        return p === h ? p.clone() : p;
      }, K.prototype.convertFrom = function(h) {
        var p = h.clone();
        return p.red = null, p;
      }, s.mont = function(h) {
        return new z(h);
      };
      function z(I) {
        K.call(this, I), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new s(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
      }
      i(z, K), z.prototype.convertTo = function(h) {
        return this.imod(h.ushln(this.shift));
      }, z.prototype.convertFrom = function(h) {
        var p = this.imod(h.mul(this.rinv));
        return p.red = null, p;
      }, z.prototype.imul = function(h, p) {
        if (h.isZero() || p.isZero()) return h.words[0] = 0, h.length = 1, h;
        var A = h.imul(p), C = A.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), N = A.isub(C).iushrn(this.shift), U = N;
        return N.cmp(this.m) >= 0 ? U = N.isub(this.m) : N.cmpn(0) < 0 && (U = N.iadd(this.m)), U._forceRed(this);
      }, z.prototype.mul = function(h, p) {
        if (h.isZero() || p.isZero()) return new s(0)._forceRed(this);
        var A = h.mul(p), C = A.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), N = A.isub(C).iushrn(this.shift), U = N;
        return N.cmp(this.m) >= 0 ? U = N.isub(this.m) : N.cmpn(0) < 0 && (U = N.iadd(this.m)), U._forceRed(this);
      }, z.prototype.invm = function(h) {
        var p = this.imod(h._invmp(this.m).mul(this.r2));
        return p._forceRed(this);
      };
    })(t, Cr);
  })(Ry);
  var VG = Ry.exports;
  const De = Js(VG), zG = "logger/5.8.0";
  let pw = false, gw = false;
  const T0 = {
    debug: 1,
    default: 2,
    info: 2,
    warning: 3,
    error: 4,
    off: 5
  };
  let mw = T0.default, mg = null;
  function QG() {
    try {
      const t = [];
      if ([
        "NFD",
        "NFC",
        "NFKD",
        "NFKC"
      ].forEach((e) => {
        try {
          if ("test".normalize(e) !== "test") throw new Error("bad normalize");
        } catch {
          t.push(e);
        }
      }), t.length) throw new Error("missing " + t.join(", "));
      if ("\xE9".normalize("NFD") !== "e\u0301") throw new Error("broken implementation");
    } catch (t) {
      return t.message;
    }
    return null;
  }
  const yw = QG();
  var fd;
  (function(t) {
    t.DEBUG = "DEBUG", t.INFO = "INFO", t.WARNING = "WARNING", t.ERROR = "ERROR", t.OFF = "OFF";
  })(fd || (fd = {}));
  var Vr;
  (function(t) {
    t.UNKNOWN_ERROR = "UNKNOWN_ERROR", t.NOT_IMPLEMENTED = "NOT_IMPLEMENTED", t.UNSUPPORTED_OPERATION = "UNSUPPORTED_OPERATION", t.NETWORK_ERROR = "NETWORK_ERROR", t.SERVER_ERROR = "SERVER_ERROR", t.TIMEOUT = "TIMEOUT", t.BUFFER_OVERRUN = "BUFFER_OVERRUN", t.NUMERIC_FAULT = "NUMERIC_FAULT", t.MISSING_NEW = "MISSING_NEW", t.INVALID_ARGUMENT = "INVALID_ARGUMENT", t.MISSING_ARGUMENT = "MISSING_ARGUMENT", t.UNEXPECTED_ARGUMENT = "UNEXPECTED_ARGUMENT", t.CALL_EXCEPTION = "CALL_EXCEPTION", t.INSUFFICIENT_FUNDS = "INSUFFICIENT_FUNDS", t.NONCE_EXPIRED = "NONCE_EXPIRED", t.REPLACEMENT_UNDERPRICED = "REPLACEMENT_UNDERPRICED", t.UNPREDICTABLE_GAS_LIMIT = "UNPREDICTABLE_GAS_LIMIT", t.TRANSACTION_REPLACED = "TRANSACTION_REPLACED", t.ACTION_REJECTED = "ACTION_REJECTED";
  })(Vr || (Vr = {}));
  const bw = "0123456789abcdef";
  class oe {
    constructor(e) {
      Object.defineProperty(this, "version", {
        enumerable: true,
        value: e,
        writable: false
      });
    }
    _log(e, n) {
      const r = e.toLowerCase();
      T0[r] == null && this.throwArgumentError("invalid log level name", "logLevel", e), !(mw > T0[r]) && console.log.apply(console, n);
    }
    debug(...e) {
      this._log(oe.levels.DEBUG, e);
    }
    info(...e) {
      this._log(oe.levels.INFO, e);
    }
    warn(...e) {
      this._log(oe.levels.WARNING, e);
    }
    makeError(e, n, r) {
      if (gw) return this.makeError("censored error", n, {});
      n || (n = oe.errors.UNKNOWN_ERROR), r || (r = {});
      const i = [];
      Object.keys(r).forEach((c) => {
        const l = r[c];
        try {
          if (l instanceof Uint8Array) {
            let u = "";
            for (let f = 0; f < l.length; f++) u += bw[l[f] >> 4], u += bw[l[f] & 15];
            i.push(c + "=Uint8Array(0x" + u + ")");
          } else i.push(c + "=" + JSON.stringify(l));
        } catch {
          i.push(c + "=" + JSON.stringify(r[c].toString()));
        }
      }), i.push(`code=${n}`), i.push(`version=${this.version}`);
      const s = e;
      let o = "";
      switch (n) {
        case Vr.NUMERIC_FAULT: {
          o = "NUMERIC_FAULT";
          const c = e;
          switch (c) {
            case "overflow":
            case "underflow":
            case "division-by-zero":
              o += "-" + c;
              break;
            case "negative-power":
            case "negative-width":
              o += "-unsupported";
              break;
            case "unbound-bitwise-result":
              o += "-unbound-result";
              break;
          }
          break;
        }
        case Vr.CALL_EXCEPTION:
        case Vr.INSUFFICIENT_FUNDS:
        case Vr.MISSING_NEW:
        case Vr.NONCE_EXPIRED:
        case Vr.REPLACEMENT_UNDERPRICED:
        case Vr.TRANSACTION_REPLACED:
        case Vr.UNPREDICTABLE_GAS_LIMIT:
          o = n;
          break;
      }
      o && (e += " [ See: https://links.ethers.org/v5-errors-" + o + " ]"), i.length && (e += " (" + i.join(", ") + ")");
      const a = new Error(e);
      return a.reason = s, a.code = n, Object.keys(r).forEach(function(c) {
        a[c] = r[c];
      }), a;
    }
    throwError(e, n, r) {
      throw this.makeError(e, n, r);
    }
    throwArgumentError(e, n, r) {
      return this.throwError(e, oe.errors.INVALID_ARGUMENT, {
        argument: n,
        value: r
      });
    }
    assert(e, n, r, i) {
      e || this.throwError(n, r, i);
    }
    assertArgument(e, n, r, i) {
      e || this.throwArgumentError(n, r, i);
    }
    checkNormalize(e) {
      yw && this.throwError("platform missing String.prototype.normalize", oe.errors.UNSUPPORTED_OPERATION, {
        operation: "String.prototype.normalize",
        form: yw
      });
    }
    checkSafeUint53(e, n) {
      typeof e == "number" && (n == null && (n = "value not safe"), (e < 0 || e >= 9007199254740991) && this.throwError(n, oe.errors.NUMERIC_FAULT, {
        operation: "checkSafeInteger",
        fault: "out-of-safe-range",
        value: e
      }), e % 1 && this.throwError(n, oe.errors.NUMERIC_FAULT, {
        operation: "checkSafeInteger",
        fault: "non-integer",
        value: e
      }));
    }
    checkArgumentCount(e, n, r) {
      r ? r = ": " + r : r = "", e < n && this.throwError("missing argument" + r, oe.errors.MISSING_ARGUMENT, {
        count: e,
        expectedCount: n
      }), e > n && this.throwError("too many arguments" + r, oe.errors.UNEXPECTED_ARGUMENT, {
        count: e,
        expectedCount: n
      });
    }
    checkNew(e, n) {
      (e === Object || e == null) && this.throwError("missing new", oe.errors.MISSING_NEW, {
        name: n.name
      });
    }
    checkAbstract(e, n) {
      e === n ? this.throwError("cannot instantiate abstract class " + JSON.stringify(n.name) + " directly; use a sub-class", oe.errors.UNSUPPORTED_OPERATION, {
        name: e.name,
        operation: "new"
      }) : (e === Object || e == null) && this.throwError("missing new", oe.errors.MISSING_NEW, {
        name: n.name
      });
    }
    static globalLogger() {
      return mg || (mg = new oe(zG)), mg;
    }
    static setCensorship(e, n) {
      if (!e && n && this.globalLogger().throwError("cannot permanently disable censorship", oe.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      }), pw) {
        if (!e) return;
        this.globalLogger().throwError("error censorship permanent", oe.errors.UNSUPPORTED_OPERATION, {
          operation: "setCensorship"
        });
      }
      gw = !!e, pw = !!n;
    }
    static setLogLevel(e) {
      const n = T0[e.toLowerCase()];
      if (n == null) {
        oe.globalLogger().warn("invalid log level - " + e);
        return;
      }
      mw = n;
    }
    static from(e) {
      return new oe(e);
    }
  }
  oe.errors = Vr;
  oe.levels = fd;
  const jG = Object.freeze(Object.defineProperty({
    __proto__: null,
    get ErrorCode() {
      return Vr;
    },
    get LogLevel() {
      return fd;
    },
    Logger: oe
  }, Symbol.toStringTag, {
    value: "Module"
  })), JG = "bytes/5.8.0", $t = new oe(JG);
  function d8(t) {
    return !!t.toHexString;
  }
  function Vc(t) {
    return t.slice || (t.slice = function() {
      const e = Array.prototype.slice.call(arguments);
      return Vc(new Uint8Array(Array.prototype.slice.apply(t, e)));
    }), t;
  }
  function Ef(t) {
    return st(t) && !(t.length % 2) || za(t);
  }
  function xw(t) {
    return typeof t == "number" && t == t && t % 1 === 0;
  }
  function za(t) {
    if (t == null) return false;
    if (t.constructor === Uint8Array) return true;
    if (typeof t == "string" || !xw(t.length) || t.length < 0) return false;
    for (let e = 0; e < t.length; e++) {
      const n = t[e];
      if (!xw(n) || n < 0 || n >= 256) return false;
    }
    return true;
  }
  function Ae(t, e) {
    if (e || (e = {}), typeof t == "number") {
      $t.checkSafeUint53(t, "invalid arrayify value");
      const n = [];
      for (; t; ) n.unshift(t & 255), t = parseInt(String(t / 256));
      return n.length === 0 && n.push(0), Vc(new Uint8Array(n));
    }
    if (e.allowMissingPrefix && typeof t == "string" && t.substring(0, 2) !== "0x" && (t = "0x" + t), d8(t) && (t = t.toHexString()), st(t)) {
      let n = t.substring(2);
      n.length % 2 && (e.hexPad === "left" ? n = "0" + n : e.hexPad === "right" ? n += "0" : $t.throwArgumentError("hex data is odd-length", "value", t));
      const r = [];
      for (let i = 0; i < n.length; i += 2) r.push(parseInt(n.substring(i, i + 2), 16));
      return Vc(new Uint8Array(r));
    }
    return za(t) ? Vc(new Uint8Array(t)) : $t.throwArgumentError("invalid arrayify value", "value", t);
  }
  function Et(t) {
    const e = t.map((i) => Ae(i)), n = e.reduce((i, s) => i + s.length, 0), r = new Uint8Array(n);
    return e.reduce((i, s) => (r.set(s, i), i + s.length), 0), Vc(r);
  }
  function qi(t) {
    let e = Ae(t);
    if (e.length === 0) return e;
    let n = 0;
    for (; n < e.length && e[n] === 0; ) n++;
    return n && (e = e.slice(n)), e;
  }
  function xu(t, e) {
    t = Ae(t), t.length > e && $t.throwArgumentError("value out of range", "value", arguments[0]);
    const n = new Uint8Array(e);
    return n.set(t, e - t.length), Vc(n);
  }
  function st(t, e) {
    return !(typeof t != "string" || !t.match(/^0x[0-9A-Fa-f]*$/) || e && t.length !== 2 + 2 * e);
  }
  const yg = "0123456789abcdef";
  function Ee(t, e) {
    if (e || (e = {}), typeof t == "number") {
      $t.checkSafeUint53(t, "invalid hexlify value");
      let n = "";
      for (; t; ) n = yg[t & 15] + n, t = Math.floor(t / 16);
      return n.length ? (n.length % 2 && (n = "0" + n), "0x" + n) : "0x00";
    }
    if (typeof t == "bigint") return t = t.toString(16), t.length % 2 ? "0x0" + t : "0x" + t;
    if (e.allowMissingPrefix && typeof t == "string" && t.substring(0, 2) !== "0x" && (t = "0x" + t), d8(t)) return t.toHexString();
    if (st(t)) return t.length % 2 && (e.hexPad === "left" ? t = "0x0" + t.substring(2) : e.hexPad === "right" ? t += "0" : $t.throwArgumentError("hex data is odd-length", "value", t)), t.toLowerCase();
    if (za(t)) {
      let n = "0x";
      for (let r = 0; r < t.length; r++) {
        let i = t[r];
        n += yg[(i & 240) >> 4] + yg[i & 15];
      }
      return n;
    }
    return $t.throwArgumentError("invalid hexlify value", "value", t);
  }
  function ns(t) {
    if (typeof t != "string") t = Ee(t);
    else if (!st(t) || t.length % 2) return null;
    return (t.length - 2) / 2;
  }
  function ln(t, e, n) {
    return typeof t != "string" ? t = Ee(t) : (!st(t) || t.length % 2) && $t.throwArgumentError("invalid hexData", "value", t), e = 2 + 2 * e, n != null ? "0x" + t.substring(e, 2 + 2 * n) : "0x" + t.substring(e);
  }
  function nr(t) {
    let e = "0x";
    return t.forEach((n) => {
      e += Ee(n).substring(2);
    }), e;
  }
  function xh(t) {
    const e = h8(Ee(t, {
      hexPad: "left"
    }));
    return e === "0x" ? "0x0" : e;
  }
  function h8(t) {
    typeof t != "string" && (t = Ee(t)), st(t) || $t.throwArgumentError("invalid hex string", "value", t), t = t.substring(2);
    let e = 0;
    for (; e < t.length && t[e] === "0"; ) e++;
    return "0x" + t.substring(e);
  }
  function xt(t, e) {
    for (typeof t != "string" ? t = Ee(t) : st(t) || $t.throwArgumentError("invalid hex string", "value", t), t.length > 2 * e + 2 && $t.throwArgumentError("value out of range", "value", arguments[1]); t.length < 2 * e + 2; ) t = "0x0" + t.substring(2);
    return t;
  }
  function Qa(t) {
    const e = {
      r: "0x",
      s: "0x",
      _vs: "0x",
      recoveryParam: 0,
      v: 0,
      yParityAndS: "0x",
      compact: "0x"
    };
    if (Ef(t)) {
      let n = Ae(t);
      n.length === 64 ? (e.v = 27 + (n[32] >> 7), n[32] &= 127, e.r = Ee(n.slice(0, 32)), e.s = Ee(n.slice(32, 64))) : n.length === 65 ? (e.r = Ee(n.slice(0, 32)), e.s = Ee(n.slice(32, 64)), e.v = n[64]) : $t.throwArgumentError("invalid signature string", "signature", t), e.v < 27 && (e.v === 0 || e.v === 1 ? e.v += 27 : $t.throwArgumentError("signature invalid v byte", "signature", t)), e.recoveryParam = 1 - e.v % 2, e.recoveryParam && (n[32] |= 128), e._vs = Ee(n.slice(32, 64));
    } else {
      if (e.r = t.r, e.s = t.s, e.v = t.v, e.recoveryParam = t.recoveryParam, e._vs = t._vs, e._vs != null) {
        const i = xu(Ae(e._vs), 32);
        e._vs = Ee(i);
        const s = i[0] >= 128 ? 1 : 0;
        e.recoveryParam == null ? e.recoveryParam = s : e.recoveryParam !== s && $t.throwArgumentError("signature recoveryParam mismatch _vs", "signature", t), i[0] &= 127;
        const o = Ee(i);
        e.s == null ? e.s = o : e.s !== o && $t.throwArgumentError("signature v mismatch _vs", "signature", t);
      }
      if (e.recoveryParam == null) e.v == null ? $t.throwArgumentError("signature missing v and recoveryParam", "signature", t) : e.v === 0 || e.v === 1 ? e.recoveryParam = e.v : e.recoveryParam = 1 - e.v % 2;
      else if (e.v == null) e.v = 27 + e.recoveryParam;
      else {
        const i = e.v === 0 || e.v === 1 ? e.v : 1 - e.v % 2;
        e.recoveryParam !== i && $t.throwArgumentError("signature recoveryParam mismatch v", "signature", t);
      }
      e.r == null || !st(e.r) ? $t.throwArgumentError("signature missing or invalid r", "signature", t) : e.r = xt(e.r, 32), e.s == null || !st(e.s) ? $t.throwArgumentError("signature missing or invalid s", "signature", t) : e.s = xt(e.s, 32);
      const n = Ae(e.s);
      n[0] >= 128 && $t.throwArgumentError("signature s out of range", "signature", t), e.recoveryParam && (n[0] |= 128);
      const r = Ee(n);
      e._vs && (st(e._vs) || $t.throwArgumentError("signature invalid _vs", "signature", t), e._vs = xt(e._vs, 32)), e._vs == null ? e._vs = r : e._vs !== r && $t.throwArgumentError("signature _vs mismatch v and s", "signature", t);
    }
    return e.yParityAndS = e._vs, e.compact = e.r + e.yParityAndS.substring(2), e;
  }
  function Xm(t) {
    return t = Qa(t), Ee(Et([
      t.r,
      t.s,
      t.recoveryParam ? "0x1c" : "0x1b"
    ]));
  }
  const KG = Object.freeze(Object.defineProperty({
    __proto__: null,
    arrayify: Ae,
    concat: Et,
    hexConcat: nr,
    hexDataLength: ns,
    hexDataSlice: ln,
    hexStripZeros: h8,
    hexValue: xh,
    hexZeroPad: xt,
    hexlify: Ee,
    isBytes: za,
    isBytesLike: Ef,
    isHexString: st,
    joinSignature: Xm,
    splitSignature: Qa,
    stripZeros: qi,
    zeroPad: xu
  }, Symbol.toStringTag, {
    value: "Module"
  })), p8 = "bignumber/5.8.0";
  var Ju = De.BN;
  const As = new oe(p8), bg = {}, Aw = 9007199254740991;
  function WG(t) {
    return t != null && (ve.isBigNumber(t) || typeof t == "number" && t % 1 === 0 || typeof t == "string" && !!t.match(/^-?[0-9]+$/) || st(t) || typeof t == "bigint" || za(t));
  }
  let ww = false;
  class ve {
    constructor(e, n) {
      e !== bg && As.throwError("cannot call constructor directly; use BigNumber.from", oe.errors.UNSUPPORTED_OPERATION, {
        operation: "new (BigNumber)"
      }), this._hex = n, this._isBigNumber = true, Object.freeze(this);
    }
    fromTwos(e) {
      return ur($e(this).fromTwos(e));
    }
    toTwos(e) {
      return ur($e(this).toTwos(e));
    }
    abs() {
      return this._hex[0] === "-" ? ve.from(this._hex.substring(1)) : this;
    }
    add(e) {
      return ur($e(this).add($e(e)));
    }
    sub(e) {
      return ur($e(this).sub($e(e)));
    }
    div(e) {
      return ve.from(e).isZero() && kr("division-by-zero", "div"), ur($e(this).div($e(e)));
    }
    mul(e) {
      return ur($e(this).mul($e(e)));
    }
    mod(e) {
      const n = $e(e);
      return n.isNeg() && kr("division-by-zero", "mod"), ur($e(this).umod(n));
    }
    pow(e) {
      const n = $e(e);
      return n.isNeg() && kr("negative-power", "pow"), ur($e(this).pow(n));
    }
    and(e) {
      const n = $e(e);
      return (this.isNegative() || n.isNeg()) && kr("unbound-bitwise-result", "and"), ur($e(this).and(n));
    }
    or(e) {
      const n = $e(e);
      return (this.isNegative() || n.isNeg()) && kr("unbound-bitwise-result", "or"), ur($e(this).or(n));
    }
    xor(e) {
      const n = $e(e);
      return (this.isNegative() || n.isNeg()) && kr("unbound-bitwise-result", "xor"), ur($e(this).xor(n));
    }
    mask(e) {
      return (this.isNegative() || e < 0) && kr("negative-width", "mask"), ur($e(this).maskn(e));
    }
    shl(e) {
      return (this.isNegative() || e < 0) && kr("negative-width", "shl"), ur($e(this).shln(e));
    }
    shr(e) {
      return (this.isNegative() || e < 0) && kr("negative-width", "shr"), ur($e(this).shrn(e));
    }
    eq(e) {
      return $e(this).eq($e(e));
    }
    lt(e) {
      return $e(this).lt($e(e));
    }
    lte(e) {
      return $e(this).lte($e(e));
    }
    gt(e) {
      return $e(this).gt($e(e));
    }
    gte(e) {
      return $e(this).gte($e(e));
    }
    isNegative() {
      return this._hex[0] === "-";
    }
    isZero() {
      return $e(this).isZero();
    }
    toNumber() {
      try {
        return $e(this).toNumber();
      } catch {
        kr("overflow", "toNumber", this.toString());
      }
      return null;
    }
    toBigInt() {
      try {
        return BigInt(this.toString());
      } catch {
      }
      return As.throwError("this platform does not support BigInt", oe.errors.UNSUPPORTED_OPERATION, {
        value: this.toString()
      });
    }
    toString() {
      return arguments.length > 0 && (arguments[0] === 10 ? ww || (ww = true, As.warn("BigNumber.toString does not accept any parameters; base-10 is assumed")) : arguments[0] === 16 ? As.throwError("BigNumber.toString does not accept any parameters; use bigNumber.toHexString()", oe.errors.UNEXPECTED_ARGUMENT, {}) : As.throwError("BigNumber.toString does not accept parameters", oe.errors.UNEXPECTED_ARGUMENT, {})), $e(this).toString(10);
    }
    toHexString() {
      return this._hex;
    }
    toJSON(e) {
      return {
        type: "BigNumber",
        hex: this.toHexString()
      };
    }
    static from(e) {
      if (e instanceof ve) return e;
      if (typeof e == "string") return e.match(/^-?0x[0-9a-f]+$/i) ? new ve(bg, Ku(e)) : e.match(/^-?[0-9]+$/) ? new ve(bg, Ku(new Ju(e))) : As.throwArgumentError("invalid BigNumber string", "value", e);
      if (typeof e == "number") return e % 1 && kr("underflow", "BigNumber.from", e), (e >= Aw || e <= -Aw) && kr("overflow", "BigNumber.from", e), ve.from(String(e));
      const n = e;
      if (typeof n == "bigint") return ve.from(n.toString());
      if (za(n)) return ve.from(Ee(n));
      if (n) if (n.toHexString) {
        const r = n.toHexString();
        if (typeof r == "string") return ve.from(r);
      } else {
        let r = n._hex;
        if (r == null && n.type === "BigNumber" && (r = n.hex), typeof r == "string" && (st(r) || r[0] === "-" && st(r.substring(1)))) return ve.from(r);
      }
      return As.throwArgumentError("invalid BigNumber value", "value", e);
    }
    static isBigNumber(e) {
      return !!(e && e._isBigNumber);
    }
  }
  function Ku(t) {
    if (typeof t != "string") return Ku(t.toString(16));
    if (t[0] === "-") return t = t.substring(1), t[0] === "-" && As.throwArgumentError("invalid hex", "value", t), t = Ku(t), t === "0x00" ? t : "-" + t;
    if (t.substring(0, 2) !== "0x" && (t = "0x" + t), t === "0x") return "0x00";
    for (t.length % 2 && (t = "0x0" + t.substring(2)); t.length > 4 && t.substring(0, 4) === "0x00"; ) t = "0x" + t.substring(4);
    return t;
  }
  function ur(t) {
    return ve.from(Ku(t));
  }
  function $e(t) {
    const e = ve.from(t).toHexString();
    return e[0] === "-" ? new Ju("-" + e.substring(3), 16) : new Ju(e.substring(2), 16);
  }
  function kr(t, e, n) {
    const r = {
      fault: t,
      operation: e
    };
    return n != null && (r.value = n), As.throwError(t, oe.errors.NUMERIC_FAULT, r);
  }
  function qG(t) {
    return new Ju(t, 36).toString(16);
  }
  function YG(t) {
    return new Ju(t, 16).toString(36);
  }
  const rr = new oe(p8), Au = {}, g8 = ve.from(0), m8 = ve.from(-1);
  function y8(t, e, n, r) {
    const i = {
      fault: e,
      operation: n
    };
    return r !== void 0 && (i.value = r), rr.throwError(t, oe.errors.NUMERIC_FAULT, i);
  }
  let wu = "0";
  for (; wu.length < 256; ) wu += wu;
  function Ny(t) {
    if (typeof t != "number") try {
      t = ve.from(t).toNumber();
    } catch {
    }
    return typeof t == "number" && t >= 0 && t <= 256 && !(t % 1) ? "1" + wu.substring(0, t) : rr.throwArgumentError("invalid decimal size", "decimals", t);
  }
  function C0(t, e) {
    e == null && (e = 0);
    const n = Ny(e);
    t = ve.from(t);
    const r = t.lt(g8);
    r && (t = t.mul(m8));
    let i = t.mod(n).toString();
    for (; i.length < n.length - 1; ) i = "0" + i;
    i = i.match(/^([0-9]*[1-9]|0)(0*)/)[1];
    const s = t.div(n).toString();
    return n.length === 1 ? t = s : t = s + "." + i, r && (t = "-" + t), t;
  }
  function Oi(t, e) {
    e == null && (e = 0);
    const n = Ny(e);
    (typeof t != "string" || !t.match(/^-?[0-9.]+$/)) && rr.throwArgumentError("invalid decimal value", "value", t);
    const r = t.substring(0, 1) === "-";
    r && (t = t.substring(1)), t === "." && rr.throwArgumentError("missing value", "value", t);
    const i = t.split(".");
    i.length > 2 && rr.throwArgumentError("too many decimal points", "value", t);
    let s = i[0], o = i[1];
    for (s || (s = "0"), o || (o = "0"); o[o.length - 1] === "0"; ) o = o.substring(0, o.length - 1);
    for (o.length > n.length - 1 && y8("fractional component exceeds decimals", "underflow", "parseFixed"), o === "" && (o = "0"); o.length < n.length - 1; ) o += "0";
    const a = ve.from(s), c = ve.from(o);
    let l = a.mul(n).add(c);
    return r && (l = l.mul(m8)), l;
  }
  class zc {
    constructor(e, n, r, i) {
      e !== Au && rr.throwError("cannot use FixedFormat constructor; use FixedFormat.from", oe.errors.UNSUPPORTED_OPERATION, {
        operation: "new FixedFormat"
      }), this.signed = n, this.width = r, this.decimals = i, this.name = (n ? "" : "u") + "fixed" + String(r) + "x" + String(i), this._multiplier = Ny(i), Object.freeze(this);
    }
    static from(e) {
      if (e instanceof zc) return e;
      typeof e == "number" && (e = `fixed128x${e}`);
      let n = true, r = 128, i = 18;
      if (typeof e == "string") {
        if (e !== "fixed") if (e === "ufixed") n = false;
        else {
          const s = e.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);
          s || rr.throwArgumentError("invalid fixed format", "format", e), n = s[1] !== "u", r = parseInt(s[2]), i = parseInt(s[3]);
        }
      } else if (e) {
        const s = (o, a, c) => e[o] == null ? c : (typeof e[o] !== a && rr.throwArgumentError("invalid fixed format (" + o + " not " + a + ")", "format." + o, e[o]), e[o]);
        n = s("signed", "boolean", n), r = s("width", "number", r), i = s("decimals", "number", i);
      }
      return r % 8 && rr.throwArgumentError("invalid fixed format width (not byte aligned)", "format.width", r), i > 80 && rr.throwArgumentError("invalid fixed format (decimals too large)", "format.decimals", i), new zc(Au, n, r, i);
    }
  }
  class Bn {
    constructor(e, n, r, i) {
      e !== Au && rr.throwError("cannot use FixedNumber constructor; use FixedNumber.from", oe.errors.UNSUPPORTED_OPERATION, {
        operation: "new FixedFormat"
      }), this.format = i, this._hex = n, this._value = r, this._isFixedNumber = true, Object.freeze(this);
    }
    _checkFormat(e) {
      this.format.name !== e.format.name && rr.throwArgumentError("incompatible format; use fixedNumber.toFormat", "other", e);
    }
    addUnsafe(e) {
      this._checkFormat(e);
      const n = Oi(this._value, this.format.decimals), r = Oi(e._value, e.format.decimals);
      return Bn.fromValue(n.add(r), this.format.decimals, this.format);
    }
    subUnsafe(e) {
      this._checkFormat(e);
      const n = Oi(this._value, this.format.decimals), r = Oi(e._value, e.format.decimals);
      return Bn.fromValue(n.sub(r), this.format.decimals, this.format);
    }
    mulUnsafe(e) {
      this._checkFormat(e);
      const n = Oi(this._value, this.format.decimals), r = Oi(e._value, e.format.decimals);
      return Bn.fromValue(n.mul(r).div(this.format._multiplier), this.format.decimals, this.format);
    }
    divUnsafe(e) {
      this._checkFormat(e);
      const n = Oi(this._value, this.format.decimals), r = Oi(e._value, e.format.decimals);
      return Bn.fromValue(n.mul(this.format._multiplier).div(r), this.format.decimals, this.format);
    }
    floor() {
      const e = this.toString().split(".");
      e.length === 1 && e.push("0");
      let n = Bn.from(e[0], this.format);
      const r = !e[1].match(/^(0*)$/);
      return this.isNegative() && r && (n = n.subUnsafe(vw.toFormat(n.format))), n;
    }
    ceiling() {
      const e = this.toString().split(".");
      e.length === 1 && e.push("0");
      let n = Bn.from(e[0], this.format);
      const r = !e[1].match(/^(0*)$/);
      return !this.isNegative() && r && (n = n.addUnsafe(vw.toFormat(n.format))), n;
    }
    round(e) {
      e == null && (e = 0);
      const n = this.toString().split(".");
      if (n.length === 1 && n.push("0"), (e < 0 || e > 80 || e % 1) && rr.throwArgumentError("invalid decimal count", "decimals", e), n[1].length <= e) return this;
      const r = Bn.from("1" + wu.substring(0, e), this.format), i = XG.toFormat(this.format);
      return this.mulUnsafe(r).addUnsafe(i).floor().divUnsafe(r);
    }
    isZero() {
      return this._value === "0.0" || this._value === "0";
    }
    isNegative() {
      return this._value[0] === "-";
    }
    toString() {
      return this._value;
    }
    toHexString(e) {
      if (e == null) return this._hex;
      e % 8 && rr.throwArgumentError("invalid byte width", "width", e);
      const n = ve.from(this._hex).fromTwos(this.format.width).toTwos(e).toHexString();
      return xt(n, e / 8);
    }
    toUnsafeFloat() {
      return parseFloat(this.toString());
    }
    toFormat(e) {
      return Bn.fromString(this._value, e);
    }
    static fromValue(e, n, r) {
      return r == null && n != null && !WG(n) && (r = n, n = null), n == null && (n = 0), r == null && (r = "fixed"), Bn.fromString(C0(e, n), zc.from(r));
    }
    static fromString(e, n) {
      n == null && (n = "fixed");
      const r = zc.from(n), i = Oi(e, r.decimals);
      !r.signed && i.lt(g8) && y8("unsigned value cannot be negative", "overflow", "value", e);
      let s = null;
      r.signed ? s = i.toTwos(r.width).toHexString() : (s = i.toHexString(), s = xt(s, r.width / 8));
      const o = C0(i, r.decimals);
      return new Bn(Au, s, o, r);
    }
    static fromBytes(e, n) {
      n == null && (n = "fixed");
      const r = zc.from(n);
      if (Ae(e).length > r.width / 8) throw new Error("overflow");
      let i = ve.from(e);
      r.signed && (i = i.fromTwos(r.width));
      const s = i.toTwos((r.signed ? 0 : 1) + r.width).toHexString(), o = C0(i, r.decimals);
      return new Bn(Au, s, o, r);
    }
    static from(e, n) {
      if (typeof e == "string") return Bn.fromString(e, n);
      if (za(e)) return Bn.fromBytes(e, n);
      try {
        return Bn.fromValue(e, 0, n);
      } catch (r) {
        if (r.code !== oe.errors.INVALID_ARGUMENT) throw r;
      }
      return rr.throwArgumentError("invalid FixedNumber value", "value", e);
    }
    static isFixedNumber(e) {
      return !!(e && e._isFixedNumber);
    }
  }
  const vw = Bn.from(1), XG = Bn.from("0.5"), ZG = "properties/5.8.0";
  var $G = function(t, e, n, r) {
    function i(s) {
      return s instanceof n ? s : new n(function(o) {
        o(s);
      });
    }
    return new (n || (n = Promise))(function(s, o) {
      function a(u) {
        try {
          l(r.next(u));
        } catch (f) {
          o(f);
        }
      }
      function c(u) {
        try {
          l(r.throw(u));
        } catch (f) {
          o(f);
        }
      }
      function l(u) {
        u.done ? s(u.value) : i(u.value).then(a, c);
      }
      l((r = r.apply(t, e || [])).next());
    });
  };
  const dd = new oe(ZG);
  function ge(t, e, n) {
    Object.defineProperty(t, e, {
      enumerable: true,
      value: n,
      writable: false
    });
  }
  function bi(t, e) {
    for (let n = 0; n < 32; n++) {
      if (t[e]) return t[e];
      if (!t.prototype || typeof t.prototype != "object") break;
      t = Object.getPrototypeOf(t.prototype).constructor;
    }
    return null;
  }
  function tn(t) {
    return $G(this, void 0, void 0, function* () {
      const e = Object.keys(t).map((r) => {
        const i = t[r];
        return Promise.resolve(i).then((s) => ({
          key: r,
          value: s
        }));
      });
      return (yield Promise.all(e)).reduce((r, i) => (r[i.key] = i.value, r), {});
    });
  }
  function Oy(t, e) {
    (!t || typeof t != "object") && dd.throwArgumentError("invalid object", "object", t), Object.keys(t).forEach((n) => {
      e[n] || dd.throwArgumentError("invalid object key - " + n, "transaction:" + n, t);
    });
  }
  function bn(t) {
    const e = {};
    for (const n in t) e[n] = t[n];
    return e;
  }
  const eV = {
    bigint: true,
    boolean: true,
    function: true,
    number: true,
    string: true
  };
  function b8(t) {
    if (t == null || eV[typeof t]) return true;
    if (Array.isArray(t) || typeof t == "object") {
      if (!Object.isFrozen(t)) return false;
      const e = Object.keys(t);
      for (let n = 0; n < e.length; n++) {
        let r = null;
        try {
          r = t[e[n]];
        } catch {
          continue;
        }
        if (!b8(r)) return false;
      }
      return true;
    }
    return dd.throwArgumentError(`Cannot deepCopy ${typeof t}`, "object", t);
  }
  function tV(t) {
    if (b8(t)) return t;
    if (Array.isArray(t)) return Object.freeze(t.map((e) => rs(e)));
    if (typeof t == "object") {
      const e = {};
      for (const n in t) {
        const r = t[n];
        r !== void 0 && ge(e, n, rs(r));
      }
      return e;
    }
    return dd.throwArgumentError(`Cannot deepCopy ${typeof t}`, "object", t);
  }
  function rs(t) {
    return tV(t);
  }
  class Uo {
    constructor(e) {
      for (const n in e) this[n] = rs(e[n]);
    }
  }
  const nV = Object.freeze(Object.defineProperty({
    __proto__: null,
    Description: Uo,
    checkProperties: Oy,
    deepCopy: rs,
    defineReadOnly: ge,
    getStatic: bi,
    resolveProperties: tn,
    shallowCopy: bn
  }, Symbol.toStringTag, {
    value: "Module"
  })), Sf = "abi/5.8.0", rt = new oe(Sf), Ma = {};
  let Ew = {
    calldata: true,
    memory: true,
    storage: true
  }, rV = {
    calldata: true,
    memory: true
  };
  function e0(t, e) {
    if (t === "bytes" || t === "string") {
      if (Ew[e]) return true;
    } else if (t === "address") {
      if (e === "payable") return true;
    } else if ((t.indexOf("[") >= 0 || t === "tuple") && rV[e]) return true;
    return (Ew[e] || e === "payable") && rt.throwArgumentError("invalid modifier", "name", e), false;
  }
  function iV(t, e) {
    let n = t;
    function r(a) {
      rt.throwArgumentError(`unexpected character at position ${a}`, "param", t);
    }
    t = t.replace(/\s/g, " ");
    function i(a) {
      let c = {
        type: "",
        name: "",
        parent: a,
        state: {
          allowType: true
        }
      };
      return e && (c.indexed = false), c;
    }
    let s = {
      type: "",
      name: "",
      state: {
        allowType: true
      }
    }, o = s;
    for (let a = 0; a < t.length; a++) {
      let c = t[a];
      switch (c) {
        case "(":
          o.state.allowType && o.type === "" ? o.type = "tuple" : o.state.allowParams || r(a), o.state.allowType = false, o.type = yc(o.type), o.components = [
            i(o)
          ], o = o.components[0];
          break;
        case ")":
          delete o.state, o.name === "indexed" && (e || r(a), o.indexed = true, o.name = ""), e0(o.type, o.name) && (o.name = ""), o.type = yc(o.type);
          let l = o;
          o = o.parent, o || r(a), delete l.parent, o.state.allowParams = false, o.state.allowName = true, o.state.allowArray = true;
          break;
        case ",":
          delete o.state, o.name === "indexed" && (e || r(a), o.indexed = true, o.name = ""), e0(o.type, o.name) && (o.name = ""), o.type = yc(o.type);
          let u = i(o.parent);
          o.parent.components.push(u), delete o.parent, o = u;
          break;
        case " ":
          o.state.allowType && o.type !== "" && (o.type = yc(o.type), delete o.state.allowType, o.state.allowName = true, o.state.allowParams = true), o.state.allowName && o.name !== "" && (o.name === "indexed" ? (e || r(a), o.indexed && r(a), o.indexed = true, o.name = "") : e0(o.type, o.name) ? o.name = "" : o.state.allowName = false);
          break;
        case "[":
          o.state.allowArray || r(a), o.type += c, o.state.allowArray = false, o.state.allowName = false, o.state.readArray = true;
          break;
        case "]":
          o.state.readArray || r(a), o.type += c, o.state.readArray = false, o.state.allowArray = true, o.state.allowName = true;
          break;
        default:
          o.state.allowType ? (o.type += c, o.state.allowParams = true, o.state.allowArray = true) : o.state.allowName ? (o.name += c, delete o.state.allowArray) : o.state.readArray ? o.type += c : r(a);
      }
    }
    return o.parent && rt.throwArgumentError("unexpected eof", "param", t), delete s.state, o.name === "indexed" ? (e || r(n.length - 7), o.indexed && r(n.length - 7), o.indexed = true, o.name = "") : e0(o.type, o.name) && (o.name = ""), s.type = yc(s.type), s;
  }
  function I0(t, e) {
    for (let n in e) ge(t, n, e[n]);
  }
  const ct = Object.freeze({
    sighash: "sighash",
    minimal: "minimal",
    full: "full",
    json: "json"
  }), sV = new RegExp(/^(.*)\[([0-9]*)\]$/);
  class vn {
    constructor(e, n) {
      e !== Ma && rt.throwError("use fromString", oe.errors.UNSUPPORTED_OPERATION, {
        operation: "new ParamType()"
      }), I0(this, n);
      let r = this.type.match(sV);
      r ? I0(this, {
        arrayLength: parseInt(r[2] || "-1"),
        arrayChildren: vn.fromObject({
          type: r[1],
          components: this.components
        }),
        baseType: "array"
      }) : I0(this, {
        arrayLength: null,
        arrayChildren: null,
        baseType: this.components != null ? "tuple" : this.type
      }), this._isParamType = true, Object.freeze(this);
    }
    format(e) {
      if (e || (e = ct.sighash), ct[e] || rt.throwArgumentError("invalid format type", "format", e), e === ct.json) {
        let r = {
          type: this.baseType === "tuple" ? "tuple" : this.type,
          name: this.name || void 0
        };
        return typeof this.indexed == "boolean" && (r.indexed = this.indexed), this.components && (r.components = this.components.map((i) => JSON.parse(i.format(e)))), JSON.stringify(r);
      }
      let n = "";
      return this.baseType === "array" ? (n += this.arrayChildren.format(e), n += "[" + (this.arrayLength < 0 ? "" : String(this.arrayLength)) + "]") : this.baseType === "tuple" ? (e !== ct.sighash && (n += this.type), n += "(" + this.components.map((r) => r.format(e)).join(e === ct.full ? ", " : ",") + ")") : n += this.type, e !== ct.sighash && (this.indexed === true && (n += " indexed"), e === ct.full && this.name && (n += " " + this.name)), n;
    }
    static from(e, n) {
      return typeof e == "string" ? vn.fromString(e, n) : vn.fromObject(e);
    }
    static fromObject(e) {
      return vn.isParamType(e) ? e : new vn(Ma, {
        name: e.name || null,
        type: yc(e.type),
        indexed: e.indexed == null ? null : !!e.indexed,
        components: e.components ? e.components.map(vn.fromObject) : null
      });
    }
    static fromString(e, n) {
      function r(i) {
        return vn.fromObject({
          name: i.name,
          type: i.type,
          indexed: i.indexed,
          components: i.components
        });
      }
      return r(iV(e, !!n));
    }
    static isParamType(e) {
      return !!(e != null && e._isParamType);
    }
  }
  function Wu(t, e) {
    return aV(t).map((n) => vn.fromString(n, e));
  }
  class ji {
    constructor(e, n) {
      e !== Ma && rt.throwError("use a static from method", oe.errors.UNSUPPORTED_OPERATION, {
        operation: "new Fragment()"
      }), I0(this, n), this._isFragment = true, Object.freeze(this);
    }
    static from(e) {
      return ji.isFragment(e) ? e : typeof e == "string" ? ji.fromString(e) : ji.fromObject(e);
    }
    static fromObject(e) {
      if (ji.isFragment(e)) return e;
      switch (e.type) {
        case "function":
          return gi.fromObject(e);
        case "event":
          return Vi.fromObject(e);
        case "constructor":
          return pi.fromObject(e);
        case "error":
          return Ps.fromObject(e);
        case "fallback":
        case "receive":
          return null;
      }
      return rt.throwArgumentError("invalid fragment object", "value", e);
    }
    static fromString(e) {
      return e = e.replace(/\s/g, " "), e = e.replace(/\(/g, " (").replace(/\)/g, ") ").replace(/\s+/g, " "), e = e.trim(), e.split(" ")[0] === "event" ? Vi.fromString(e.substring(5).trim()) : e.split(" ")[0] === "function" ? gi.fromString(e.substring(8).trim()) : e.split("(")[0].trim() === "constructor" ? pi.fromString(e.trim()) : e.split(" ")[0] === "error" ? Ps.fromString(e.substring(5).trim()) : rt.throwArgumentError("unsupported fragment", "value", e);
    }
    static isFragment(e) {
      return !!(e && e._isFragment);
    }
  }
  class Vi extends ji {
    format(e) {
      if (e || (e = ct.sighash), ct[e] || rt.throwArgumentError("invalid format type", "format", e), e === ct.json) return JSON.stringify({
        type: "event",
        anonymous: this.anonymous,
        name: this.name,
        inputs: this.inputs.map((r) => JSON.parse(r.format(e)))
      });
      let n = "";
      return e !== ct.sighash && (n += "event "), n += this.name + "(" + this.inputs.map((r) => r.format(e)).join(e === ct.full ? ", " : ",") + ") ", e !== ct.sighash && this.anonymous && (n += "anonymous "), n.trim();
    }
    static from(e) {
      return typeof e == "string" ? Vi.fromString(e) : Vi.fromObject(e);
    }
    static fromObject(e) {
      if (Vi.isEventFragment(e)) return e;
      e.type !== "event" && rt.throwArgumentError("invalid event object", "value", e);
      const n = {
        name: qu(e.name),
        anonymous: e.anonymous,
        inputs: e.inputs ? e.inputs.map(vn.fromObject) : [],
        type: "event"
      };
      return new Vi(Ma, n);
    }
    static fromString(e) {
      let n = e.match(Yu);
      n || rt.throwArgumentError("invalid event string", "value", e);
      let r = false;
      return n[3].split(" ").forEach((i) => {
        switch (i.trim()) {
          case "anonymous":
            r = true;
            break;
          case "":
            break;
          default:
            rt.warn("unknown modifier: " + i);
        }
      }), Vi.fromObject({
        name: n[1].trim(),
        anonymous: r,
        inputs: Wu(n[2], true),
        type: "event"
      });
    }
    static isEventFragment(e) {
      return e && e._isFragment && e.type === "event";
    }
  }
  function x8(t, e) {
    e.gas = null;
    let n = t.split("@");
    return n.length !== 1 ? (n.length > 2 && rt.throwArgumentError("invalid human-readable ABI signature", "value", t), n[1].match(/^[0-9]+$/) || rt.throwArgumentError("invalid human-readable ABI signature gas", "value", t), e.gas = ve.from(n[1]), n[0]) : t;
  }
  function A8(t, e) {
    e.constant = false, e.payable = false, e.stateMutability = "nonpayable", t.split(" ").forEach((n) => {
      switch (n.trim()) {
        case "constant":
          e.constant = true;
          break;
        case "payable":
          e.payable = true, e.stateMutability = "payable";
          break;
        case "nonpayable":
          e.payable = false, e.stateMutability = "nonpayable";
          break;
        case "pure":
          e.constant = true, e.stateMutability = "pure";
          break;
        case "view":
          e.constant = true, e.stateMutability = "view";
          break;
        case "external":
        case "public":
        case "":
          break;
        default:
          console.log("unknown modifier: " + n);
      }
    });
  }
  function w8(t) {
    let e = {
      constant: false,
      payable: true,
      stateMutability: "payable"
    };
    return t.stateMutability != null ? (e.stateMutability = t.stateMutability, e.constant = e.stateMutability === "view" || e.stateMutability === "pure", t.constant != null && !!t.constant !== e.constant && rt.throwArgumentError("cannot have constant function with mutability " + e.stateMutability, "value", t), e.payable = e.stateMutability === "payable", t.payable != null && !!t.payable !== e.payable && rt.throwArgumentError("cannot have payable function with mutability " + e.stateMutability, "value", t)) : t.payable != null ? (e.payable = !!t.payable, t.constant == null && !e.payable && t.type !== "constructor" && rt.throwArgumentError("unable to determine stateMutability", "value", t), e.constant = !!t.constant, e.constant ? e.stateMutability = "view" : e.stateMutability = e.payable ? "payable" : "nonpayable", e.payable && e.constant && rt.throwArgumentError("cannot have constant payable function", "value", t)) : t.constant != null ? (e.constant = !!t.constant, e.payable = !e.constant, e.stateMutability = e.constant ? "view" : "payable") : t.type !== "constructor" && rt.throwArgumentError("unable to determine stateMutability", "value", t), e;
  }
  class pi extends ji {
    format(e) {
      if (e || (e = ct.sighash), ct[e] || rt.throwArgumentError("invalid format type", "format", e), e === ct.json) return JSON.stringify({
        type: "constructor",
        stateMutability: this.stateMutability !== "nonpayable" ? this.stateMutability : void 0,
        payable: this.payable,
        gas: this.gas ? this.gas.toNumber() : void 0,
        inputs: this.inputs.map((r) => JSON.parse(r.format(e)))
      });
      e === ct.sighash && rt.throwError("cannot format a constructor for sighash", oe.errors.UNSUPPORTED_OPERATION, {
        operation: "format(sighash)"
      });
      let n = "constructor(" + this.inputs.map((r) => r.format(e)).join(e === ct.full ? ", " : ",") + ") ";
      return this.stateMutability && this.stateMutability !== "nonpayable" && (n += this.stateMutability + " "), n.trim();
    }
    static from(e) {
      return typeof e == "string" ? pi.fromString(e) : pi.fromObject(e);
    }
    static fromObject(e) {
      if (pi.isConstructorFragment(e)) return e;
      e.type !== "constructor" && rt.throwArgumentError("invalid constructor object", "value", e);
      let n = w8(e);
      n.constant && rt.throwArgumentError("constructor cannot be constant", "value", e);
      const r = {
        name: null,
        type: e.type,
        inputs: e.inputs ? e.inputs.map(vn.fromObject) : [],
        payable: n.payable,
        stateMutability: n.stateMutability,
        gas: e.gas ? ve.from(e.gas) : null
      };
      return new pi(Ma, r);
    }
    static fromString(e) {
      let n = {
        type: "constructor"
      };
      e = x8(e, n);
      let r = e.match(Yu);
      return (!r || r[1].trim() !== "constructor") && rt.throwArgumentError("invalid constructor string", "value", e), n.inputs = Wu(r[2].trim(), false), A8(r[3].trim(), n), pi.fromObject(n);
    }
    static isConstructorFragment(e) {
      return e && e._isFragment && e.type === "constructor";
    }
  }
  class gi extends pi {
    format(e) {
      if (e || (e = ct.sighash), ct[e] || rt.throwArgumentError("invalid format type", "format", e), e === ct.json) return JSON.stringify({
        type: "function",
        name: this.name,
        constant: this.constant,
        stateMutability: this.stateMutability !== "nonpayable" ? this.stateMutability : void 0,
        payable: this.payable,
        gas: this.gas ? this.gas.toNumber() : void 0,
        inputs: this.inputs.map((r) => JSON.parse(r.format(e))),
        outputs: this.outputs.map((r) => JSON.parse(r.format(e)))
      });
      let n = "";
      return e !== ct.sighash && (n += "function "), n += this.name + "(" + this.inputs.map((r) => r.format(e)).join(e === ct.full ? ", " : ",") + ") ", e !== ct.sighash && (this.stateMutability ? this.stateMutability !== "nonpayable" && (n += this.stateMutability + " ") : this.constant && (n += "view "), this.outputs && this.outputs.length && (n += "returns (" + this.outputs.map((r) => r.format(e)).join(", ") + ") "), this.gas != null && (n += "@" + this.gas.toString() + " ")), n.trim();
    }
    static from(e) {
      return typeof e == "string" ? gi.fromString(e) : gi.fromObject(e);
    }
    static fromObject(e) {
      if (gi.isFunctionFragment(e)) return e;
      e.type !== "function" && rt.throwArgumentError("invalid function object", "value", e);
      let n = w8(e);
      const r = {
        type: e.type,
        name: qu(e.name),
        constant: n.constant,
        inputs: e.inputs ? e.inputs.map(vn.fromObject) : [],
        outputs: e.outputs ? e.outputs.map(vn.fromObject) : [],
        payable: n.payable,
        stateMutability: n.stateMutability,
        gas: e.gas ? ve.from(e.gas) : null
      };
      return new gi(Ma, r);
    }
    static fromString(e) {
      let n = {
        type: "function"
      };
      e = x8(e, n);
      let r = e.split(" returns ");
      r.length > 2 && rt.throwArgumentError("invalid function string", "value", e);
      let i = r[0].match(Yu);
      if (i || rt.throwArgumentError("invalid function signature", "value", e), n.name = i[1].trim(), n.name && qu(n.name), n.inputs = Wu(i[2], false), A8(i[3].trim(), n), r.length > 1) {
        let s = r[1].match(Yu);
        (s[1].trim() != "" || s[3].trim() != "") && rt.throwArgumentError("unexpected tokens", "value", e), n.outputs = Wu(s[2], false);
      } else n.outputs = [];
      return gi.fromObject(n);
    }
    static isFunctionFragment(e) {
      return e && e._isFragment && e.type === "function";
    }
  }
  function Sw(t) {
    const e = t.format();
    return (e === "Error(string)" || e === "Panic(uint256)") && rt.throwArgumentError(`cannot specify user defined ${e} error`, "fragment", t), t;
  }
  class Ps extends ji {
    format(e) {
      if (e || (e = ct.sighash), ct[e] || rt.throwArgumentError("invalid format type", "format", e), e === ct.json) return JSON.stringify({
        type: "error",
        name: this.name,
        inputs: this.inputs.map((r) => JSON.parse(r.format(e)))
      });
      let n = "";
      return e !== ct.sighash && (n += "error "), n += this.name + "(" + this.inputs.map((r) => r.format(e)).join(e === ct.full ? ", " : ",") + ") ", n.trim();
    }
    static from(e) {
      return typeof e == "string" ? Ps.fromString(e) : Ps.fromObject(e);
    }
    static fromObject(e) {
      if (Ps.isErrorFragment(e)) return e;
      e.type !== "error" && rt.throwArgumentError("invalid error object", "value", e);
      const n = {
        type: e.type,
        name: qu(e.name),
        inputs: e.inputs ? e.inputs.map(vn.fromObject) : []
      };
      return Sw(new Ps(Ma, n));
    }
    static fromString(e) {
      let n = {
        type: "error"
      }, r = e.match(Yu);
      return r || rt.throwArgumentError("invalid error signature", "value", e), n.name = r[1].trim(), n.name && qu(n.name), n.inputs = Wu(r[2], false), Sw(Ps.fromObject(n));
    }
    static isErrorFragment(e) {
      return e && e._isFragment && e.type === "error";
    }
  }
  function yc(t) {
    return t.match(/^uint($|[^1-9])/) ? t = "uint256" + t.substring(4) : t.match(/^int($|[^1-9])/) && (t = "int256" + t.substring(3)), t;
  }
  const oV = new RegExp("^[a-zA-Z$_][a-zA-Z0-9$_]*$");
  function qu(t) {
    return (!t || !t.match(oV)) && rt.throwArgumentError(`invalid identifier "${t}"`, "value", t), t;
  }
  const Yu = new RegExp("^([^)(]*)\\((.*)\\)([^)(]*)$");
  function aV(t) {
    t = t.trim();
    let e = [], n = "", r = 0;
    for (let i = 0; i < t.length; i++) {
      let s = t[i];
      s === "," && r === 0 ? (e.push(n), n = "") : (n += s, s === "(" ? r++ : s === ")" && (r--, r === -1 && rt.throwArgumentError("unbalanced parenthesis", "value", t)));
    }
    return n && e.push(n), e;
  }
  const By = new oe(Sf);
  function v8(t) {
    const e = [], n = function(r, i) {
      if (Array.isArray(i)) for (let s in i) {
        const o = r.slice();
        o.push(s);
        try {
          n(o, i[s]);
        } catch (a) {
          e.push({
            path: o,
            error: a
          });
        }
      }
    };
    return n([], t), e;
  }
  class Ks {
    constructor(e, n, r, i) {
      this.name = e, this.type = n, this.localName = r, this.dynamic = i;
    }
    _throwError(e, n) {
      By.throwArgumentError(e, this.localName, n);
    }
  }
  class Zm {
    constructor(e) {
      ge(this, "wordSize", e || 32), this._data = [], this._dataLength = 0, this._padding = new Uint8Array(e);
    }
    get data() {
      return nr(this._data);
    }
    get length() {
      return this._dataLength;
    }
    _writeData(e) {
      return this._data.push(e), this._dataLength += e.length, e.length;
    }
    appendWriter(e) {
      return this._writeData(Et(e._data));
    }
    writeBytes(e) {
      let n = Ae(e);
      const r = n.length % this.wordSize;
      return r && (n = Et([
        n,
        this._padding.slice(r)
      ])), this._writeData(n);
    }
    _getValue(e) {
      let n = Ae(ve.from(e));
      return n.length > this.wordSize && By.throwError("value out-of-bounds", oe.errors.BUFFER_OVERRUN, {
        length: this.wordSize,
        offset: n.length
      }), n.length % this.wordSize && (n = Et([
        this._padding.slice(n.length % this.wordSize),
        n
      ])), n;
    }
    writeValue(e) {
      return this._writeData(this._getValue(e));
    }
    writeUpdatableValue() {
      const e = this._data.length;
      return this._data.push(this._padding), this._dataLength += this.wordSize, (n) => {
        this._data[e] = this._getValue(n);
      };
    }
  }
  class hd {
    constructor(e, n, r, i) {
      ge(this, "_data", Ae(e)), ge(this, "wordSize", n || 32), ge(this, "_coerceFunc", r), ge(this, "allowLoose", i), this._offset = 0;
    }
    get data() {
      return Ee(this._data);
    }
    get consumed() {
      return this._offset;
    }
    static coerce(e, n) {
      let r = e.match("^u?int([0-9]+)$");
      return r && parseInt(r[1]) <= 48 && (n = n.toNumber()), n;
    }
    coerce(e, n) {
      return this._coerceFunc ? this._coerceFunc(e, n) : hd.coerce(e, n);
    }
    _peekBytes(e, n, r) {
      let i = Math.ceil(n / this.wordSize) * this.wordSize;
      return this._offset + i > this._data.length && (this.allowLoose && r && this._offset + n <= this._data.length ? i = n : By.throwError("data out-of-bounds", oe.errors.BUFFER_OVERRUN, {
        length: this._data.length,
        offset: this._offset + i
      })), this._data.slice(this._offset, this._offset + i);
    }
    subReader(e) {
      return new hd(this._data.slice(this._offset + e), this.wordSize, this._coerceFunc, this.allowLoose);
    }
    readBytes(e, n) {
      let r = this._peekBytes(0, e, !!n);
      return this._offset += r.length, r.slice(0, e);
    }
    readValue() {
      return ve.from(this.readBytes(this.wordSize));
    }
  }
  var E8 = {
    exports: {}
  };
  (function(t) {
    (function() {
      var e = "input is invalid type", n = "finalize already called", r = typeof window == "object", i = r ? window : {};
      i.JS_SHA3_NO_WINDOW && (r = false);
      var s = !r && typeof self == "object", o = !i.JS_SHA3_NO_NODE_JS && typeof process == "object" && process.versions && process.versions.node;
      o ? i = Cr : s && (i = self);
      var a = !i.JS_SHA3_NO_COMMON_JS && true && t.exports, c = !i.JS_SHA3_NO_ARRAY_BUFFER && typeof ArrayBuffer < "u", l = "0123456789abcdef".split(""), u = [
        31,
        7936,
        2031616,
        520093696
      ], f = [
        4,
        1024,
        262144,
        67108864
      ], d = [
        1,
        256,
        65536,
        16777216
      ], m = [
        6,
        1536,
        393216,
        100663296
      ], y = [
        0,
        8,
        16,
        24
      ], x = [
        1,
        0,
        32898,
        0,
        32906,
        2147483648,
        2147516416,
        2147483648,
        32907,
        0,
        2147483649,
        0,
        2147516545,
        2147483648,
        32777,
        2147483648,
        138,
        0,
        136,
        0,
        2147516425,
        0,
        2147483658,
        0,
        2147516555,
        0,
        139,
        2147483648,
        32905,
        2147483648,
        32771,
        2147483648,
        32770,
        2147483648,
        128,
        2147483648,
        32778,
        0,
        2147483658,
        2147483648,
        2147516545,
        2147483648,
        32896,
        2147483648,
        2147483649,
        0,
        2147516424,
        2147483648
      ], w = [
        224,
        256,
        384,
        512
      ], R = [
        128,
        256
      ], O = [
        "hex",
        "buffer",
        "arrayBuffer",
        "array",
        "digest"
      ], B = {
        128: 168,
        256: 136
      };
      (i.JS_SHA3_NO_NODE_JS || !Array.isArray) && (Array.isArray = function(E) {
        return Object.prototype.toString.call(E) === "[object Array]";
      }), c && (i.JS_SHA3_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView) && (ArrayBuffer.isView = function(E) {
        return typeof E == "object" && E.buffer && E.buffer.constructor === ArrayBuffer;
      });
      for (var M = function(E, Z, k) {
        return function(X) {
          return new g(E, Z, E).update(X)[k]();
        };
      }, D = function(E, Z, k) {
        return function(X, $) {
          return new g(E, Z, $).update(X)[k]();
        };
      }, H = function(E, Z, k) {
        return function(X, $, ce, fe) {
          return h["cshake" + E].update(X, $, ce, fe)[k]();
        };
      }, q = function(E, Z, k) {
        return function(X, $, ce, fe) {
          return h["kmac" + E].update(X, $, ce, fe)[k]();
        };
      }, S = function(E, Z, k, X) {
        for (var $ = 0; $ < O.length; ++$) {
          var ce = O[$];
          E[ce] = Z(k, X, ce);
        }
        return E;
      }, P = function(E, Z) {
        var k = M(E, Z, "hex");
        return k.create = function() {
          return new g(E, Z, E);
        }, k.update = function(X) {
          return k.create().update(X);
        }, S(k, M, E, Z);
      }, L = function(E, Z) {
        var k = D(E, Z, "hex");
        return k.create = function(X) {
          return new g(E, Z, X);
        }, k.update = function(X, $) {
          return k.create($).update(X);
        }, S(k, D, E, Z);
      }, K = function(E, Z) {
        var k = B[E], X = H(E, Z, "hex");
        return X.create = function($, ce, fe) {
          return !ce && !fe ? h["shake" + E].create($) : new g(E, Z, $).bytepad([
            ce,
            fe
          ], k);
        }, X.update = function($, ce, fe, G) {
          return X.create(ce, fe, G).update($);
        }, S(X, H, E, Z);
      }, z = function(E, Z) {
        var k = B[E], X = q(E, Z, "hex");
        return X.create = function($, ce, fe) {
          return new F(E, Z, ce).bytepad([
            "KMAC",
            fe
          ], k).bytepad([
            $
          ], k);
        }, X.update = function($, ce, fe, G) {
          return X.create($, fe, G).update(ce);
        }, S(X, q, E, Z);
      }, I = [
        {
          name: "keccak",
          padding: d,
          bits: w,
          createMethod: P
        },
        {
          name: "sha3",
          padding: m,
          bits: w,
          createMethod: P
        },
        {
          name: "shake",
          padding: u,
          bits: R,
          createMethod: L
        },
        {
          name: "cshake",
          padding: f,
          bits: R,
          createMethod: K
        },
        {
          name: "kmac",
          padding: f,
          bits: R,
          createMethod: z
        }
      ], h = {}, p = [], A = 0; A < I.length; ++A) for (var C = I[A], N = C.bits, U = 0; U < N.length; ++U) {
        var Y = C.name + "_" + N[U];
        if (p.push(Y), h[Y] = C.createMethod(N[U], C.padding), C.name !== "sha3") {
          var T = C.name + N[U];
          p.push(T), h[T] = h[Y];
        }
      }
      function g(E, Z, k) {
        this.blocks = [], this.s = [], this.padding = Z, this.outputBits = k, this.reset = true, this.finalized = false, this.block = 0, this.start = 0, this.blockCount = 1600 - (E << 1) >> 5, this.byteCount = this.blockCount << 2, this.outputBlocks = k >> 5, this.extraBytes = (k & 31) >> 3;
        for (var X = 0; X < 50; ++X) this.s[X] = 0;
      }
      g.prototype.update = function(E) {
        if (this.finalized) throw new Error(n);
        var Z, k = typeof E;
        if (k !== "string") {
          if (k === "object") {
            if (E === null) throw new Error(e);
            if (c && E.constructor === ArrayBuffer) E = new Uint8Array(E);
            else if (!Array.isArray(E) && (!c || !ArrayBuffer.isView(E))) throw new Error(e);
          } else throw new Error(e);
          Z = true;
        }
        for (var X = this.blocks, $ = this.byteCount, ce = E.length, fe = this.blockCount, G = 0, W = this.s, V, te; G < ce; ) {
          if (this.reset) for (this.reset = false, X[0] = this.block, V = 1; V < fe + 1; ++V) X[V] = 0;
          if (Z) for (V = this.start; G < ce && V < $; ++G) X[V >> 2] |= E[G] << y[V++ & 3];
          else for (V = this.start; G < ce && V < $; ++G) te = E.charCodeAt(G), te < 128 ? X[V >> 2] |= te << y[V++ & 3] : te < 2048 ? (X[V >> 2] |= (192 | te >> 6) << y[V++ & 3], X[V >> 2] |= (128 | te & 63) << y[V++ & 3]) : te < 55296 || te >= 57344 ? (X[V >> 2] |= (224 | te >> 12) << y[V++ & 3], X[V >> 2] |= (128 | te >> 6 & 63) << y[V++ & 3], X[V >> 2] |= (128 | te & 63) << y[V++ & 3]) : (te = 65536 + ((te & 1023) << 10 | E.charCodeAt(++G) & 1023), X[V >> 2] |= (240 | te >> 18) << y[V++ & 3], X[V >> 2] |= (128 | te >> 12 & 63) << y[V++ & 3], X[V >> 2] |= (128 | te >> 6 & 63) << y[V++ & 3], X[V >> 2] |= (128 | te & 63) << y[V++ & 3]);
          if (this.lastByteIndex = V, V >= $) {
            for (this.start = V - $, this.block = X[fe], V = 0; V < fe; ++V) W[V] ^= X[V];
            ee(W), this.reset = true;
          } else this.start = V;
        }
        return this;
      }, g.prototype.encode = function(E, Z) {
        var k = E & 255, X = 1, $ = [
          k
        ];
        for (E = E >> 8, k = E & 255; k > 0; ) $.unshift(k), E = E >> 8, k = E & 255, ++X;
        return Z ? $.push(X) : $.unshift(X), this.update($), $.length;
      }, g.prototype.encodeString = function(E) {
        var Z, k = typeof E;
        if (k !== "string") {
          if (k === "object") {
            if (E === null) throw new Error(e);
            if (c && E.constructor === ArrayBuffer) E = new Uint8Array(E);
            else if (!Array.isArray(E) && (!c || !ArrayBuffer.isView(E))) throw new Error(e);
          } else throw new Error(e);
          Z = true;
        }
        var X = 0, $ = E.length;
        if (Z) X = $;
        else for (var ce = 0; ce < E.length; ++ce) {
          var fe = E.charCodeAt(ce);
          fe < 128 ? X += 1 : fe < 2048 ? X += 2 : fe < 55296 || fe >= 57344 ? X += 3 : (fe = 65536 + ((fe & 1023) << 10 | E.charCodeAt(++ce) & 1023), X += 4);
        }
        return X += this.encode(X * 8), this.update(E), X;
      }, g.prototype.bytepad = function(E, Z) {
        for (var k = this.encode(Z), X = 0; X < E.length; ++X) k += this.encodeString(E[X]);
        var $ = Z - k % Z, ce = [];
        return ce.length = $, this.update(ce), this;
      }, g.prototype.finalize = function() {
        if (!this.finalized) {
          this.finalized = true;
          var E = this.blocks, Z = this.lastByteIndex, k = this.blockCount, X = this.s;
          if (E[Z >> 2] |= this.padding[Z & 3], this.lastByteIndex === this.byteCount) for (E[0] = E[k], Z = 1; Z < k + 1; ++Z) E[Z] = 0;
          for (E[k - 1] |= 2147483648, Z = 0; Z < k; ++Z) X[Z] ^= E[Z];
          ee(X);
        }
      }, g.prototype.toString = g.prototype.hex = function() {
        this.finalize();
        for (var E = this.blockCount, Z = this.s, k = this.outputBlocks, X = this.extraBytes, $ = 0, ce = 0, fe = "", G; ce < k; ) {
          for ($ = 0; $ < E && ce < k; ++$, ++ce) G = Z[$], fe += l[G >> 4 & 15] + l[G & 15] + l[G >> 12 & 15] + l[G >> 8 & 15] + l[G >> 20 & 15] + l[G >> 16 & 15] + l[G >> 28 & 15] + l[G >> 24 & 15];
          ce % E === 0 && (ee(Z), $ = 0);
        }
        return X && (G = Z[$], fe += l[G >> 4 & 15] + l[G & 15], X > 1 && (fe += l[G >> 12 & 15] + l[G >> 8 & 15]), X > 2 && (fe += l[G >> 20 & 15] + l[G >> 16 & 15])), fe;
      }, g.prototype.arrayBuffer = function() {
        this.finalize();
        var E = this.blockCount, Z = this.s, k = this.outputBlocks, X = this.extraBytes, $ = 0, ce = 0, fe = this.outputBits >> 3, G;
        X ? G = new ArrayBuffer(k + 1 << 2) : G = new ArrayBuffer(fe);
        for (var W = new Uint32Array(G); ce < k; ) {
          for ($ = 0; $ < E && ce < k; ++$, ++ce) W[ce] = Z[$];
          ce % E === 0 && ee(Z);
        }
        return X && (W[$] = Z[$], G = G.slice(0, fe)), G;
      }, g.prototype.buffer = g.prototype.arrayBuffer, g.prototype.digest = g.prototype.array = function() {
        this.finalize();
        for (var E = this.blockCount, Z = this.s, k = this.outputBlocks, X = this.extraBytes, $ = 0, ce = 0, fe = [], G, W; ce < k; ) {
          for ($ = 0; $ < E && ce < k; ++$, ++ce) G = ce << 2, W = Z[$], fe[G] = W & 255, fe[G + 1] = W >> 8 & 255, fe[G + 2] = W >> 16 & 255, fe[G + 3] = W >> 24 & 255;
          ce % E === 0 && ee(Z);
        }
        return X && (G = ce << 2, W = Z[$], fe[G] = W & 255, X > 1 && (fe[G + 1] = W >> 8 & 255), X > 2 && (fe[G + 2] = W >> 16 & 255)), fe;
      };
      function F(E, Z, k) {
        g.call(this, E, Z, k);
      }
      F.prototype = new g(), F.prototype.finalize = function() {
        return this.encode(this.outputBits, true), g.prototype.finalize.call(this);
      };
      var ee = function(E) {
        var Z, k, X, $, ce, fe, G, W, V, te, pe, ue, ye, we, Q, j, ae, le, be, xe, ie, _, b, v, J, ne, se, de, Fe, Re, Ne, ot, Oe, St, Vo, Tt, Ct, zo, It, Pt, Qo, _t23, Rt, jo, Nt, Ot, Jo, Bt, Mt, Ko, kt, Ft, Wo, Lt, Dt, qo, Ut, Ht, Ws, qs, Ys, Xs, Zs;
        for (X = 0; X < 48; X += 2) $ = E[0] ^ E[10] ^ E[20] ^ E[30] ^ E[40], ce = E[1] ^ E[11] ^ E[21] ^ E[31] ^ E[41], fe = E[2] ^ E[12] ^ E[22] ^ E[32] ^ E[42], G = E[3] ^ E[13] ^ E[23] ^ E[33] ^ E[43], W = E[4] ^ E[14] ^ E[24] ^ E[34] ^ E[44], V = E[5] ^ E[15] ^ E[25] ^ E[35] ^ E[45], te = E[6] ^ E[16] ^ E[26] ^ E[36] ^ E[46], pe = E[7] ^ E[17] ^ E[27] ^ E[37] ^ E[47], ue = E[8] ^ E[18] ^ E[28] ^ E[38] ^ E[48], ye = E[9] ^ E[19] ^ E[29] ^ E[39] ^ E[49], Z = ue ^ (fe << 1 | G >>> 31), k = ye ^ (G << 1 | fe >>> 31), E[0] ^= Z, E[1] ^= k, E[10] ^= Z, E[11] ^= k, E[20] ^= Z, E[21] ^= k, E[30] ^= Z, E[31] ^= k, E[40] ^= Z, E[41] ^= k, Z = $ ^ (W << 1 | V >>> 31), k = ce ^ (V << 1 | W >>> 31), E[2] ^= Z, E[3] ^= k, E[12] ^= Z, E[13] ^= k, E[22] ^= Z, E[23] ^= k, E[32] ^= Z, E[33] ^= k, E[42] ^= Z, E[43] ^= k, Z = fe ^ (te << 1 | pe >>> 31), k = G ^ (pe << 1 | te >>> 31), E[4] ^= Z, E[5] ^= k, E[14] ^= Z, E[15] ^= k, E[24] ^= Z, E[25] ^= k, E[34] ^= Z, E[35] ^= k, E[44] ^= Z, E[45] ^= k, Z = W ^ (ue << 1 | ye >>> 31), k = V ^ (ye << 1 | ue >>> 31), E[6] ^= Z, E[7] ^= k, E[16] ^= Z, E[17] ^= k, E[26] ^= Z, E[27] ^= k, E[36] ^= Z, E[37] ^= k, E[46] ^= Z, E[47] ^= k, Z = te ^ ($ << 1 | ce >>> 31), k = pe ^ (ce << 1 | $ >>> 31), E[8] ^= Z, E[9] ^= k, E[18] ^= Z, E[19] ^= k, E[28] ^= Z, E[29] ^= k, E[38] ^= Z, E[39] ^= k, E[48] ^= Z, E[49] ^= k, we = E[0], Q = E[1], Ot = E[11] << 4 | E[10] >>> 28, Jo = E[10] << 4 | E[11] >>> 28, de = E[20] << 3 | E[21] >>> 29, Fe = E[21] << 3 | E[20] >>> 29, qs = E[31] << 9 | E[30] >>> 23, Ys = E[30] << 9 | E[31] >>> 23, _t23 = E[40] << 18 | E[41] >>> 14, Rt = E[41] << 18 | E[40] >>> 14, St = E[2] << 1 | E[3] >>> 31, Vo = E[3] << 1 | E[2] >>> 31, j = E[13] << 12 | E[12] >>> 20, ae = E[12] << 12 | E[13] >>> 20, Bt = E[22] << 10 | E[23] >>> 22, Mt = E[23] << 10 | E[22] >>> 22, Re = E[33] << 13 | E[32] >>> 19, Ne = E[32] << 13 | E[33] >>> 19, Xs = E[42] << 2 | E[43] >>> 30, Zs = E[43] << 2 | E[42] >>> 30, Lt = E[5] << 30 | E[4] >>> 2, Dt = E[4] << 30 | E[5] >>> 2, Tt = E[14] << 6 | E[15] >>> 26, Ct = E[15] << 6 | E[14] >>> 26, le = E[25] << 11 | E[24] >>> 21, be = E[24] << 11 | E[25] >>> 21, Ko = E[34] << 15 | E[35] >>> 17, kt = E[35] << 15 | E[34] >>> 17, ot = E[45] << 29 | E[44] >>> 3, Oe = E[44] << 29 | E[45] >>> 3, v = E[6] << 28 | E[7] >>> 4, J = E[7] << 28 | E[6] >>> 4, qo = E[17] << 23 | E[16] >>> 9, Ut = E[16] << 23 | E[17] >>> 9, zo = E[26] << 25 | E[27] >>> 7, It = E[27] << 25 | E[26] >>> 7, xe = E[36] << 21 | E[37] >>> 11, ie = E[37] << 21 | E[36] >>> 11, Ft = E[47] << 24 | E[46] >>> 8, Wo = E[46] << 24 | E[47] >>> 8, jo = E[8] << 27 | E[9] >>> 5, Nt = E[9] << 27 | E[8] >>> 5, ne = E[18] << 20 | E[19] >>> 12, se = E[19] << 20 | E[18] >>> 12, Ht = E[29] << 7 | E[28] >>> 25, Ws = E[28] << 7 | E[29] >>> 25, Pt = E[38] << 8 | E[39] >>> 24, Qo = E[39] << 8 | E[38] >>> 24, _ = E[48] << 14 | E[49] >>> 18, b = E[49] << 14 | E[48] >>> 18, E[0] = we ^ ~j & le, E[1] = Q ^ ~ae & be, E[10] = v ^ ~ne & de, E[11] = J ^ ~se & Fe, E[20] = St ^ ~Tt & zo, E[21] = Vo ^ ~Ct & It, E[30] = jo ^ ~Ot & Bt, E[31] = Nt ^ ~Jo & Mt, E[40] = Lt ^ ~qo & Ht, E[41] = Dt ^ ~Ut & Ws, E[2] = j ^ ~le & xe, E[3] = ae ^ ~be & ie, E[12] = ne ^ ~de & Re, E[13] = se ^ ~Fe & Ne, E[22] = Tt ^ ~zo & Pt, E[23] = Ct ^ ~It & Qo, E[32] = Ot ^ ~Bt & Ko, E[33] = Jo ^ ~Mt & kt, E[42] = qo ^ ~Ht & qs, E[43] = Ut ^ ~Ws & Ys, E[4] = le ^ ~xe & _, E[5] = be ^ ~ie & b, E[14] = de ^ ~Re & ot, E[15] = Fe ^ ~Ne & Oe, E[24] = zo ^ ~Pt & _t23, E[25] = It ^ ~Qo & Rt, E[34] = Bt ^ ~Ko & Ft, E[35] = Mt ^ ~kt & Wo, E[44] = Ht ^ ~qs & Xs, E[45] = Ws ^ ~Ys & Zs, E[6] = xe ^ ~_ & we, E[7] = ie ^ ~b & Q, E[16] = Re ^ ~ot & v, E[17] = Ne ^ ~Oe & J, E[26] = Pt ^ ~_t23 & St, E[27] = Qo ^ ~Rt & Vo, E[36] = Ko ^ ~Ft & jo, E[37] = kt ^ ~Wo & Nt, E[46] = qs ^ ~Xs & Lt, E[47] = Ys ^ ~Zs & Dt, E[8] = _ ^ ~we & j, E[9] = b ^ ~Q & ae, E[18] = ot ^ ~v & ne, E[19] = Oe ^ ~J & se, E[28] = _t23 ^ ~St & Tt, E[29] = Rt ^ ~Vo & Ct, E[38] = Ft ^ ~jo & Ot, E[39] = Wo ^ ~Nt & Jo, E[48] = Xs ^ ~Lt & qo, E[49] = Zs ^ ~Dt & Ut, E[0] ^= x[X], E[1] ^= x[X + 1];
      };
      if (a) t.exports = h;
      else for (A = 0; A < p.length; ++A) i[p[A]] = h[p[A]];
    })();
  })(E8);
  var cV = E8.exports;
  const lV = Js(cV);
  function mt(t) {
    return "0x" + lV.keccak_256(Ae(t));
  }
  const uV = Object.freeze(Object.defineProperty({
    __proto__: null,
    keccak256: mt
  }, Symbol.toStringTag, {
    value: "Module"
  })), fV = "rlp/5.8.0", Fi = new oe(fV);
  function Tw(t) {
    const e = [];
    for (; t; ) e.unshift(t & 255), t >>= 8;
    return e;
  }
  function Cw(t, e, n) {
    let r = 0;
    for (let i = 0; i < n; i++) r = r * 256 + t[e + i];
    return r;
  }
  function S8(t) {
    if (Array.isArray(t)) {
      let r = [];
      if (t.forEach(function(s) {
        r = r.concat(S8(s));
      }), r.length <= 55) return r.unshift(192 + r.length), r;
      const i = Tw(r.length);
      return i.unshift(247 + i.length), i.concat(r);
    }
    Ef(t) || Fi.throwArgumentError("RLP object must be BytesLike", "object", t);
    const e = Array.prototype.slice.call(Ae(t));
    if (e.length === 1 && e[0] <= 127) return e;
    if (e.length <= 55) return e.unshift(128 + e.length), e;
    const n = Tw(e.length);
    return n.unshift(183 + n.length), n.concat(e);
  }
  function ka(t) {
    return Ee(S8(t));
  }
  function Iw(t, e, n, r) {
    const i = [];
    for (; n < e + 1 + r; ) {
      const s = T8(t, n);
      i.push(s.result), n += s.consumed, n > e + 1 + r && Fi.throwError("child data too short", oe.errors.BUFFER_OVERRUN, {});
    }
    return {
      consumed: 1 + r,
      result: i
    };
  }
  function T8(t, e) {
    if (t.length === 0 && Fi.throwError("data too short", oe.errors.BUFFER_OVERRUN, {}), t[e] >= 248) {
      const n = t[e] - 247;
      e + 1 + n > t.length && Fi.throwError("data short segment too short", oe.errors.BUFFER_OVERRUN, {});
      const r = Cw(t, e + 1, n);
      return e + 1 + n + r > t.length && Fi.throwError("data long segment too short", oe.errors.BUFFER_OVERRUN, {}), Iw(t, e, e + 1 + n, n + r);
    } else if (t[e] >= 192) {
      const n = t[e] - 192;
      return e + 1 + n > t.length && Fi.throwError("data array too short", oe.errors.BUFFER_OVERRUN, {}), Iw(t, e, e + 1, n);
    } else if (t[e] >= 184) {
      const n = t[e] - 183;
      e + 1 + n > t.length && Fi.throwError("data array too short", oe.errors.BUFFER_OVERRUN, {});
      const r = Cw(t, e + 1, n);
      e + 1 + n + r > t.length && Fi.throwError("data array too short", oe.errors.BUFFER_OVERRUN, {});
      const i = Ee(t.slice(e + 1 + n, e + 1 + n + r));
      return {
        consumed: 1 + n + r,
        result: i
      };
    } else if (t[e] >= 128) {
      const n = t[e] - 128;
      e + 1 + n > t.length && Fi.throwError("data too short", oe.errors.BUFFER_OVERRUN, {});
      const r = Ee(t.slice(e + 1, e + 1 + n));
      return {
        consumed: 1 + n,
        result: r
      };
    }
    return {
      consumed: 1,
      result: Ee(t[e])
    };
  }
  function Ah(t) {
    const e = Ae(t), n = T8(e, 0);
    return n.consumed !== e.length && Fi.throwArgumentError("invalid rlp data", "data", t), n.result;
  }
  const dV = Object.freeze(Object.defineProperty({
    __proto__: null,
    decode: Ah,
    encode: ka
  }, Symbol.toStringTag, {
    value: "Module"
  })), hV = "address/5.8.0", wo = new oe(hV);
  function Pw(t) {
    st(t, 20) || wo.throwArgumentError("invalid address", "address", t), t = t.toLowerCase();
    const e = t.substring(2).split(""), n = new Uint8Array(40);
    for (let i = 0; i < 40; i++) n[i] = e[i].charCodeAt(0);
    const r = Ae(mt(n));
    for (let i = 0; i < 40; i += 2) r[i >> 1] >> 4 >= 8 && (e[i] = e[i].toUpperCase()), (r[i >> 1] & 15) >= 8 && (e[i + 1] = e[i + 1].toUpperCase());
    return "0x" + e.join("");
  }
  const pV = 9007199254740991;
  function gV(t) {
    return Math.log10 ? Math.log10(t) : Math.log(t) / Math.LN10;
  }
  const My = {};
  for (let t = 0; t < 10; t++) My[String(t)] = String(t);
  for (let t = 0; t < 26; t++) My[String.fromCharCode(65 + t)] = String(10 + t);
  const _w = Math.floor(gV(pV));
  function C8(t) {
    t = t.toUpperCase(), t = t.substring(4) + t.substring(0, 2) + "00";
    let e = t.split("").map((r) => My[r]).join("");
    for (; e.length >= _w; ) {
      let r = e.substring(0, _w);
      e = parseInt(r, 10) % 97 + e.substring(r.length);
    }
    let n = String(98 - parseInt(e, 10) % 97);
    for (; n.length < 2; ) n = "0" + n;
    return n;
  }
  function pt(t) {
    let e = null;
    if (typeof t != "string" && wo.throwArgumentError("invalid address", "address", t), t.match(/^(0x)?[0-9a-fA-F]{40}$/)) t.substring(0, 2) !== "0x" && (t = "0x" + t), e = Pw(t), t.match(/([A-F].*[a-f])|([a-f].*[A-F])/) && e !== t && wo.throwArgumentError("bad address checksum", "address", t);
    else if (t.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
      for (t.substring(2, 4) !== C8(t) && wo.throwArgumentError("bad icap checksum", "address", t), e = qG(t.substring(4)); e.length < 40; ) e = "0" + e;
      e = Pw("0x" + e);
    } else wo.throwArgumentError("invalid address", "address", t);
    return e;
  }
  function mV(t) {
    try {
      return pt(t), true;
    } catch {
    }
    return false;
  }
  function yV(t) {
    let e = YG(pt(t).substring(2)).toUpperCase();
    for (; e.length < 30; ) e = "0" + e;
    return "XE" + C8("XE00" + e) + e;
  }
  function ky(t) {
    let e = null;
    try {
      e = pt(t.from);
    } catch {
      wo.throwArgumentError("missing from address", "transaction", t);
    }
    const n = qi(Ae(ve.from(t.nonce).toHexString()));
    return pt(ln(mt(ka([
      e,
      n
    ])), 12));
  }
  function bV(t, e, n) {
    return ns(e) !== 32 && wo.throwArgumentError("salt must be 32 bytes", "salt", e), ns(n) !== 32 && wo.throwArgumentError("initCodeHash must be 32 bytes", "initCodeHash", n), pt(ln(mt(Et([
      "0xff",
      pt(t),
      e,
      n
    ])), 12));
  }
  const xV = Object.freeze(Object.defineProperty({
    __proto__: null,
    getAddress: pt,
    getContractAddress: ky,
    getCreate2Address: bV,
    getIcapAddress: yV,
    isAddress: mV
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  class AV extends Ks {
    constructor(e) {
      super("address", "address", e, false);
    }
    defaultValue() {
      return "0x0000000000000000000000000000000000000000";
    }
    encode(e, n) {
      try {
        n = pt(n);
      } catch (r) {
        this._throwError(r.message, n);
      }
      return e.writeValue(n);
    }
    decode(e) {
      return pt(xt(e.readValue().toHexString(), 20));
    }
  }
  class wV extends Ks {
    constructor(e) {
      super(e.name, e.type, void 0, e.dynamic), this.coder = e;
    }
    defaultValue() {
      return this.coder.defaultValue();
    }
    encode(e, n) {
      return this.coder.encode(e, n);
    }
    decode(e) {
      return this.coder.decode(e);
    }
  }
  const Cc = new oe(Sf);
  function I8(t, e, n) {
    let r = null;
    if (Array.isArray(n)) r = n;
    else if (n && typeof n == "object") {
      let c = {};
      r = e.map((l) => {
        const u = l.localName;
        return u || Cc.throwError("cannot encode object for signature with missing names", oe.errors.INVALID_ARGUMENT, {
          argument: "values",
          coder: l,
          value: n
        }), c[u] && Cc.throwError("cannot encode object for signature with duplicate names", oe.errors.INVALID_ARGUMENT, {
          argument: "values",
          coder: l,
          value: n
        }), c[u] = true, n[u];
      });
    } else Cc.throwArgumentError("invalid tuple value", "tuple", n);
    e.length !== r.length && Cc.throwArgumentError("types/value length mismatch", "tuple", n);
    let i = new Zm(t.wordSize), s = new Zm(t.wordSize), o = [];
    e.forEach((c, l) => {
      let u = r[l];
      if (c.dynamic) {
        let f = s.length;
        c.encode(s, u);
        let d = i.writeUpdatableValue();
        o.push((m) => {
          d(m + f);
        });
      } else c.encode(i, u);
    }), o.forEach((c) => {
      c(i.length);
    });
    let a = t.appendWriter(i);
    return a += t.appendWriter(s), a;
  }
  function P8(t, e) {
    let n = [], r = t.subReader(0);
    e.forEach((s) => {
      let o = null;
      if (s.dynamic) {
        let a = t.readValue(), c = r.subReader(a.toNumber());
        try {
          o = s.decode(c);
        } catch (l) {
          if (l.code === oe.errors.BUFFER_OVERRUN) throw l;
          o = l, o.baseType = s.name, o.name = s.localName, o.type = s.type;
        }
      } else try {
        o = s.decode(t);
      } catch (a) {
        if (a.code === oe.errors.BUFFER_OVERRUN) throw a;
        o = a, o.baseType = s.name, o.name = s.localName, o.type = s.type;
      }
      o != null && n.push(o);
    });
    const i = e.reduce((s, o) => {
      const a = o.localName;
      return a && (s[a] || (s[a] = 0), s[a]++), s;
    }, {});
    e.forEach((s, o) => {
      let a = s.localName;
      if (!a || i[a] !== 1 || (a === "length" && (a = "_length"), n[a] != null)) return;
      const c = n[o];
      c instanceof Error ? Object.defineProperty(n, a, {
        enumerable: true,
        get: () => {
          throw c;
        }
      }) : n[a] = c;
    });
    for (let s = 0; s < n.length; s++) {
      const o = n[s];
      o instanceof Error && Object.defineProperty(n, s, {
        enumerable: true,
        get: () => {
          throw o;
        }
      });
    }
    return Object.freeze(n);
  }
  class vV extends Ks {
    constructor(e, n, r) {
      const i = e.type + "[" + (n >= 0 ? n : "") + "]", s = n === -1 || e.dynamic;
      super("array", i, r, s), this.coder = e, this.length = n;
    }
    defaultValue() {
      const e = this.coder.defaultValue(), n = [];
      for (let r = 0; r < this.length; r++) n.push(e);
      return n;
    }
    encode(e, n) {
      Array.isArray(n) || this._throwError("expected array value", n);
      let r = this.length;
      r === -1 && (r = n.length, e.writeValue(n.length)), Cc.checkArgumentCount(n.length, r, "coder array" + (this.localName ? " " + this.localName : ""));
      let i = [];
      for (let s = 0; s < n.length; s++) i.push(this.coder);
      return I8(e, i, n);
    }
    decode(e) {
      let n = this.length;
      n === -1 && (n = e.readValue().toNumber(), n * 32 > e._data.length && Cc.throwError("insufficient data length", oe.errors.BUFFER_OVERRUN, {
        length: e._data.length,
        count: n
      }));
      let r = [];
      for (let i = 0; i < n; i++) r.push(new wV(this.coder));
      return e.coerce(this.name, P8(e, r));
    }
  }
  class EV extends Ks {
    constructor(e) {
      super("bool", "bool", e, false);
    }
    defaultValue() {
      return false;
    }
    encode(e, n) {
      return e.writeValue(n ? 1 : 0);
    }
    decode(e) {
      return e.coerce(this.type, !e.readValue().isZero());
    }
  }
  class _8 extends Ks {
    constructor(e, n) {
      super(e, e, n, true);
    }
    defaultValue() {
      return "0x";
    }
    encode(e, n) {
      n = Ae(n);
      let r = e.writeValue(n.length);
      return r += e.writeBytes(n), r;
    }
    decode(e) {
      return e.readBytes(e.readValue().toNumber(), true);
    }
  }
  class SV extends _8 {
    constructor(e) {
      super("bytes", e);
    }
    decode(e) {
      return e.coerce(this.name, Ee(super.decode(e)));
    }
  }
  class TV extends Ks {
    constructor(e, n) {
      let r = "bytes" + String(e);
      super(r, r, n, false), this.size = e;
    }
    defaultValue() {
      return "0x0000000000000000000000000000000000000000000000000000000000000000".substring(0, 2 + this.size * 2);
    }
    encode(e, n) {
      let r = Ae(n);
      return r.length !== this.size && this._throwError("incorrect data length", n), e.writeBytes(r);
    }
    decode(e) {
      return e.coerce(this.name, Ee(e.readBytes(this.size)));
    }
  }
  class CV extends Ks {
    constructor(e) {
      super("null", "", e, false);
    }
    defaultValue() {
      return null;
    }
    encode(e, n) {
      return n != null && this._throwError("not null", n), e.writeBytes([]);
    }
    decode(e) {
      return e.readBytes(0), e.coerce(this.name, null);
    }
  }
  const IV = "0x0000000000000000000000000000000000000000", PV = ve.from(-1), R8 = ve.from(0), _V = ve.from(1), RV = ve.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"), N8 = "0x0000000000000000000000000000000000000000000000000000000000000000";
  class NV extends Ks {
    constructor(e, n, r) {
      const i = (n ? "int" : "uint") + e * 8;
      super(i, i, r, false), this.size = e, this.signed = n;
    }
    defaultValue() {
      return 0;
    }
    encode(e, n) {
      let r = ve.from(n), i = RV.mask(e.wordSize * 8);
      if (this.signed) {
        let s = i.mask(this.size * 8 - 1);
        (r.gt(s) || r.lt(s.add(_V).mul(PV))) && this._throwError("value out-of-bounds", n);
      } else (r.lt(R8) || r.gt(i.mask(this.size * 8))) && this._throwError("value out-of-bounds", n);
      return r = r.toTwos(this.size * 8).mask(this.size * 8), this.signed && (r = r.fromTwos(this.size * 8).toTwos(8 * e.wordSize)), e.writeValue(r);
    }
    decode(e) {
      let n = e.readValue().mask(this.size * 8);
      return this.signed && (n = n.fromTwos(this.size * 8)), e.coerce(this.name, n);
    }
  }
  const OV = "strings/5.8.0", O8 = new oe(OV);
  var is;
  (function(t) {
    t.current = "", t.NFC = "NFC", t.NFD = "NFD", t.NFKC = "NFKC", t.NFKD = "NFKD";
  })(is || (is = {}));
  var mr;
  (function(t) {
    t.UNEXPECTED_CONTINUE = "unexpected continuation byte", t.BAD_PREFIX = "bad codepoint prefix", t.OVERRUN = "string overrun", t.MISSING_CONTINUE = "missing continuation byte", t.OUT_OF_RANGE = "out of UTF-8 range", t.UTF16_SURROGATE = "UTF-16 surrogate", t.OVERLONG = "overlong representation";
  })(mr || (mr = {}));
  function BV(t, e, n, r, i) {
    return O8.throwArgumentError(`invalid codepoint at offset ${e}; ${t}`, "bytes", n);
  }
  function B8(t, e, n, r, i) {
    if (t === mr.BAD_PREFIX || t === mr.UNEXPECTED_CONTINUE) {
      let s = 0;
      for (let o = e + 1; o < n.length && n[o] >> 6 === 2; o++) s++;
      return s;
    }
    return t === mr.OVERRUN ? n.length - e - 1 : 0;
  }
  function MV(t, e, n, r, i) {
    return t === mr.OVERLONG ? (r.push(i), 0) : (r.push(65533), B8(t, e, n));
  }
  const M8 = Object.freeze({
    error: BV,
    ignore: B8,
    replace: MV
  });
  function Fy(t, e) {
    e == null && (e = M8.error), t = Ae(t);
    const n = [];
    let r = 0;
    for (; r < t.length; ) {
      const i = t[r++];
      if (!(i >> 7)) {
        n.push(i);
        continue;
      }
      let s = null, o = null;
      if ((i & 224) === 192) s = 1, o = 127;
      else if ((i & 240) === 224) s = 2, o = 2047;
      else if ((i & 248) === 240) s = 3, o = 65535;
      else {
        (i & 192) === 128 ? r += e(mr.UNEXPECTED_CONTINUE, r - 1, t, n) : r += e(mr.BAD_PREFIX, r - 1, t, n);
        continue;
      }
      if (r - 1 + s >= t.length) {
        r += e(mr.OVERRUN, r - 1, t, n);
        continue;
      }
      let a = i & (1 << 8 - s - 1) - 1;
      for (let c = 0; c < s; c++) {
        let l = t[r];
        if ((l & 192) != 128) {
          r += e(mr.MISSING_CONTINUE, r, t, n), a = null;
          break;
        }
        a = a << 6 | l & 63, r++;
      }
      if (a !== null) {
        if (a > 1114111) {
          r += e(mr.OUT_OF_RANGE, r - 1 - s, t, n, a);
          continue;
        }
        if (a >= 55296 && a <= 57343) {
          r += e(mr.UTF16_SURROGATE, r - 1 - s, t, n, a);
          continue;
        }
        if (a <= o) {
          r += e(mr.OVERLONG, r - 1 - s, t, n, a);
          continue;
        }
        n.push(a);
      }
    }
    return n;
  }
  function gn(t, e = is.current) {
    e != is.current && (O8.checkNormalize(), t = t.normalize(e));
    let n = [];
    for (let r = 0; r < t.length; r++) {
      const i = t.charCodeAt(r);
      if (i < 128) n.push(i);
      else if (i < 2048) n.push(i >> 6 | 192), n.push(i & 63 | 128);
      else if ((i & 64512) == 55296) {
        r++;
        const s = t.charCodeAt(r);
        if (r >= t.length || (s & 64512) !== 56320) throw new Error("invalid utf-8 string");
        const o = 65536 + ((i & 1023) << 10) + (s & 1023);
        n.push(o >> 18 | 240), n.push(o >> 12 & 63 | 128), n.push(o >> 6 & 63 | 128), n.push(o & 63 | 128);
      } else n.push(i >> 12 | 224), n.push(i >> 6 & 63 | 128), n.push(i & 63 | 128);
    }
    return Ae(n);
  }
  function xg(t) {
    const e = "0000" + t.toString(16);
    return "\\u" + e.substring(e.length - 4);
  }
  function kV(t, e) {
    return '"' + Fy(t, e).map((n) => {
      if (n < 256) {
        switch (n) {
          case 8:
            return "\\b";
          case 9:
            return "\\t";
          case 10:
            return "\\n";
          case 13:
            return "\\r";
          case 34:
            return '\\"';
          case 92:
            return "\\\\";
        }
        if (n >= 32 && n < 127) return String.fromCharCode(n);
      }
      return n <= 65535 ? xg(n) : (n -= 65536, xg((n >> 10 & 1023) + 55296) + xg((n & 1023) + 56320));
    }).join("") + '"';
  }
  function $m(t) {
    return t.map((e) => e <= 65535 ? String.fromCharCode(e) : (e -= 65536, String.fromCharCode((e >> 10 & 1023) + 55296, (e & 1023) + 56320))).join("");
  }
  function Ho(t, e) {
    return $m(Fy(t, e));
  }
  function pd(t, e = is.current) {
    return Fy(gn(t, e));
  }
  function FV(t) {
    const e = gn(t);
    if (e.length > 31) throw new Error("bytes32 string must be less than 32 bytes");
    return Ee(Et([
      e,
      N8
    ]).slice(0, 32));
  }
  function LV(t) {
    const e = Ae(t);
    if (e.length !== 32) throw new Error("invalid bytes32 - not 32 bytes long");
    if (e[31] !== 0) throw new Error("invalid bytes32 string - no null terminator");
    let n = 31;
    for (; e[n - 1] === 0; ) n--;
    return Ho(e.slice(0, n));
  }
  function DV(t) {
    if (t.length % 4 !== 0) throw new Error("bad data");
    let e = [];
    for (let n = 0; n < t.length; n += 4) e.push(parseInt(t.substring(n, n + 4), 16));
    return e;
  }
  function Ly(t, e) {
    e || (e = function(i) {
      return [
        parseInt(i, 16)
      ];
    });
    let n = 0, r = {};
    return t.split(",").forEach((i) => {
      let s = i.split(":");
      n += parseInt(s[0], 16), r[n] = e(s[1]);
    }), r;
  }
  function k8(t) {
    let e = 0;
    return t.split(",").map((n) => {
      let r = n.split("-");
      r.length === 1 ? r[1] = "0" : r[1] === "" && (r[1] = "1");
      let i = e + parseInt(r[0], 16);
      return e = parseInt(r[1], 16), {
        l: i,
        h: e
      };
    });
  }
  function Dy(t, e) {
    let n = 0;
    for (let r = 0; r < e.length; r++) {
      let i = e[r];
      if (n += i.l, t >= n && t <= n + i.h && (t - n) % (i.d || 1) === 0) {
        if (i.e && i.e.indexOf(t - n) !== -1) continue;
        return i;
      }
    }
    return null;
  }
  const UV = k8("221,13-1b,5f-,40-10,51-f,11-3,3-3,2-2,2-4,8,2,15,2d,28-8,88,48,27-,3-5,11-20,27-,8,28,3-5,12,18,b-a,1c-4,6-16,2-d,2-2,2,1b-4,17-9,8f-,10,f,1f-2,1c-34,33-14e,4,36-,13-,6-2,1a-f,4,9-,3-,17,8,2-2,5-,2,8-,3-,4-8,2-3,3,6-,16-6,2-,7-3,3-,17,8,3,3,3-,2,6-3,3-,4-a,5,2-6,10-b,4,8,2,4,17,8,3,6-,b,4,4-,2-e,2-4,b-10,4,9-,3-,17,8,3-,5-,9-2,3-,4-7,3-3,3,4-3,c-10,3,7-2,4,5-2,3,2,3-2,3-2,4-2,9,4-3,6-2,4,5-8,2-e,d-d,4,9,4,18,b,6-3,8,4,5-6,3-8,3-3,b-11,3,9,4,18,b,6-3,8,4,5-6,3-6,2,3-3,b-11,3,9,4,18,11-3,7-,4,5-8,2-7,3-3,b-11,3,13-2,19,a,2-,8-2,2-3,7,2,9-11,4-b,3b-3,1e-24,3,2-,3,2-,2-5,5,8,4,2,2-,3,e,4-,6,2,7-,b-,3-21,49,23-5,1c-3,9,25,10-,2-2f,23,6,3,8-2,5-5,1b-45,27-9,2a-,2-3,5b-4,45-4,53-5,8,40,2,5-,8,2,5-,28,2,5-,20,2,5-,8,2,5-,8,8,18,20,2,5-,8,28,14-5,1d-22,56-b,277-8,1e-2,52-e,e,8-a,18-8,15-b,e,4,3-b,5e-2,b-15,10,b-5,59-7,2b-555,9d-3,5b-5,17-,7-,27-,7-,9,2,2,2,20-,36,10,f-,7,14-,4,a,54-3,2-6,6-5,9-,1c-10,13-1d,1c-14,3c-,10-6,32-b,240-30,28-18,c-14,a0,115-,3,66-,b-76,5,5-,1d,24,2,5-2,2,8-,35-2,19,f-10,1d-3,311-37f,1b,5a-b,d7-19,d-3,41,57-,68-4,29-3,5f,29-37,2e-2,25-c,2c-2,4e-3,30,78-3,64-,20,19b7-49,51a7-59,48e-2,38-738,2ba5-5b,222f-,3c-94,8-b,6-4,1b,6,2,3,3,6d-20,16e-f,41-,37-7,2e-2,11-f,5-b,18-,b,14,5-3,6,88-,2,bf-2,7-,7-,7-,4-2,8,8-9,8-2ff,20,5-b,1c-b4,27-,27-cbb1,f7-9,28-2,b5-221,56,48,3-,2-,3-,5,d,2,5,3,42,5-,9,8,1d,5,6,2-2,8,153-3,123-3,33-27fd,a6da-5128,21f-5df,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3,2-1d,61-ff7d"), HV = "ad,34f,1806,180b,180c,180d,200b,200c,200d,2060,feff".split(",").map((t) => parseInt(t, 16)), GV = [
    {
      h: 25,
      s: 32,
      l: 65
    },
    {
      h: 30,
      s: 32,
      e: [
        23
      ],
      l: 127
    },
    {
      h: 54,
      s: 1,
      e: [
        48
      ],
      l: 64,
      d: 2
    },
    {
      h: 14,
      s: 1,
      l: 57,
      d: 2
    },
    {
      h: 44,
      s: 1,
      l: 17,
      d: 2
    },
    {
      h: 10,
      s: 1,
      e: [
        2,
        6,
        8
      ],
      l: 61,
      d: 2
    },
    {
      h: 16,
      s: 1,
      l: 68,
      d: 2
    },
    {
      h: 84,
      s: 1,
      e: [
        18,
        24,
        66
      ],
      l: 19,
      d: 2
    },
    {
      h: 26,
      s: 32,
      e: [
        17
      ],
      l: 435
    },
    {
      h: 22,
      s: 1,
      l: 71,
      d: 2
    },
    {
      h: 15,
      s: 80,
      l: 40
    },
    {
      h: 31,
      s: 32,
      l: 16
    },
    {
      h: 32,
      s: 1,
      l: 80,
      d: 2
    },
    {
      h: 52,
      s: 1,
      l: 42,
      d: 2
    },
    {
      h: 12,
      s: 1,
      l: 55,
      d: 2
    },
    {
      h: 40,
      s: 1,
      e: [
        38
      ],
      l: 15,
      d: 2
    },
    {
      h: 14,
      s: 1,
      l: 48,
      d: 2
    },
    {
      h: 37,
      s: 48,
      l: 49
    },
    {
      h: 148,
      s: 1,
      l: 6351,
      d: 2
    },
    {
      h: 88,
      s: 1,
      l: 160,
      d: 2
    },
    {
      h: 15,
      s: 16,
      l: 704
    },
    {
      h: 25,
      s: 26,
      l: 854
    },
    {
      h: 25,
      s: 32,
      l: 55915
    },
    {
      h: 37,
      s: 40,
      l: 1247
    },
    {
      h: 25,
      s: -119711,
      l: 53248
    },
    {
      h: 25,
      s: -119763,
      l: 52
    },
    {
      h: 25,
      s: -119815,
      l: 52
    },
    {
      h: 25,
      s: -119867,
      e: [
        1,
        4,
        5,
        7,
        8,
        11,
        12,
        17
      ],
      l: 52
    },
    {
      h: 25,
      s: -119919,
      l: 52
    },
    {
      h: 24,
      s: -119971,
      e: [
        2,
        7,
        8,
        17
      ],
      l: 52
    },
    {
      h: 24,
      s: -120023,
      e: [
        2,
        7,
        13,
        15,
        16,
        17
      ],
      l: 52
    },
    {
      h: 25,
      s: -120075,
      l: 52
    },
    {
      h: 25,
      s: -120127,
      l: 52
    },
    {
      h: 25,
      s: -120179,
      l: 52
    },
    {
      h: 25,
      s: -120231,
      l: 52
    },
    {
      h: 25,
      s: -120283,
      l: 52
    },
    {
      h: 25,
      s: -120335,
      l: 52
    },
    {
      h: 24,
      s: -119543,
      e: [
        17
      ],
      l: 56
    },
    {
      h: 24,
      s: -119601,
      e: [
        17
      ],
      l: 58
    },
    {
      h: 24,
      s: -119659,
      e: [
        17
      ],
      l: 58
    },
    {
      h: 24,
      s: -119717,
      e: [
        17
      ],
      l: 58
    },
    {
      h: 24,
      s: -119775,
      e: [
        17
      ],
      l: 58
    }
  ], VV = Ly("b5:3bc,c3:ff,7:73,2:253,5:254,3:256,1:257,5:259,1:25b,3:260,1:263,2:269,1:268,5:26f,1:272,2:275,7:280,3:283,5:288,3:28a,1:28b,5:292,3f:195,1:1bf,29:19e,125:3b9,8b:3b2,1:3b8,1:3c5,3:3c6,1:3c0,1a:3ba,1:3c1,1:3c3,2:3b8,1:3b5,1bc9:3b9,1c:1f76,1:1f77,f:1f7a,1:1f7b,d:1f78,1:1f79,1:1f7c,1:1f7d,107:63,5:25b,4:68,1:68,1:68,3:69,1:69,1:6c,3:6e,4:70,1:71,1:72,1:72,1:72,7:7a,2:3c9,2:7a,2:6b,1:e5,1:62,1:63,3:65,1:66,2:6d,b:3b3,1:3c0,6:64,1b574:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3"), zV = Ly("179:1,2:1,2:1,5:1,2:1,a:4f,a:1,8:1,2:1,2:1,3:1,5:1,3:1,4:1,2:1,3:1,4:1,8:2,1:1,2:2,1:1,2:2,27:2,195:26,2:25,1:25,1:25,2:40,2:3f,1:3f,33:1,11:-6,1:-9,1ac7:-3a,6d:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,b:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,c:-8,2:-8,2:-8,2:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,49:-8,1:-8,1:-4a,1:-4a,d:-56,1:-56,1:-56,1:-56,d:-8,1:-8,f:-8,1:-8,3:-7"), QV = Ly("df:00730073,51:00690307,19:02BC006E,a7:006A030C,18a:002003B9,16:03B903080301,20:03C503080301,1d7:05650582,190f:00680331,1:00740308,1:0077030A,1:0079030A,1:006102BE,b6:03C50313,2:03C503130300,2:03C503130301,2:03C503130342,2a:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,3:1F7003B9,1:03B103B9,1:03AC03B9,2:03B10342,1:03B1034203B9,5:03B103B9,6:1F7403B9,1:03B703B9,1:03AE03B9,2:03B70342,1:03B7034203B9,5:03B703B9,6:03B903080300,1:03B903080301,3:03B90342,1:03B903080342,b:03C503080300,1:03C503080301,1:03C10313,2:03C50342,1:03C503080342,b:1F7C03B9,1:03C903B9,1:03CE03B9,2:03C90342,1:03C9034203B9,5:03C903B9,ac:00720073,5b:00B00063,6:00B00066,d:006E006F,a:0073006D,1:00740065006C,1:0074006D,124f:006800700061,2:00610075,2:006F0076,b:00700061,1:006E0061,1:03BC0061,1:006D0061,1:006B0061,1:006B0062,1:006D0062,1:00670062,3:00700066,1:006E0066,1:03BC0066,4:0068007A,1:006B0068007A,1:006D0068007A,1:00670068007A,1:00740068007A,15:00700061,1:006B00700061,1:006D00700061,1:006700700061,8:00700076,1:006E0076,1:03BC0076,1:006D0076,1:006B0076,1:006D0076,1:00700077,1:006E0077,1:03BC0077,1:006D0077,1:006B0077,1:006D0077,1:006B03C9,1:006D03C9,2:00620071,3:00632215006B0067,1:0063006F002E,1:00640062,1:00670079,2:00680070,2:006B006B,1:006B006D,9:00700068,2:00700070006D,1:00700072,2:00730076,1:00770062,c723:00660066,1:00660069,1:0066006C,1:006600660069,1:00660066006C,1:00730074,1:00730074,d:05740576,1:05740565,1:0574056B,1:057E0576,1:0574056D", DV), jV = k8("80-20,2a0-,39c,32,f71,18e,7f2-f,19-7,30-4,7-5,f81-b,5,a800-20ff,4d1-1f,110,fa-6,d174-7,2e84-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,2,1f-5f,ff7f-20001");
  function JV(t) {
    return t.reduce((e, n) => (n.forEach((r) => {
      e.push(r);
    }), e), []);
  }
  function KV(t) {
    return !!Dy(t, UV);
  }
  function WV(t) {
    let e = Dy(t, GV);
    if (e) return [
      t + e.s
    ];
    let n = VV[t];
    if (n) return n;
    let r = zV[t];
    if (r) return [
      t + r[0]
    ];
    let i = QV[t];
    return i || null;
  }
  function qV(t) {
    return !!Dy(t, jV);
  }
  function YV(t) {
    if (t.match(/^[a-z0-9-]*$/i) && t.length <= 59) return t.toLowerCase();
    let e = pd(t);
    e = JV(e.map((r) => {
      if (HV.indexOf(r) >= 0) return [];
      if (r >= 65024 && r <= 65039) return [];
      let i = WV(r);
      return i || [
        r
      ];
    })), e = pd($m(e), is.NFKC), e.forEach((r) => {
      if (qV(r)) throw new Error("STRINGPREP_CONTAINS_PROHIBITED");
    }), e.forEach((r) => {
      if (KV(r)) throw new Error("STRINGPREP_CONTAINS_UNASSIGNED");
    });
    let n = $m(e);
    if (n.substring(0, 1) === "-" || n.substring(2, 4) === "--" || n.substring(n.length - 1) === "-") throw new Error("invalid hyphen");
    return n;
  }
  const XV = Object.freeze(Object.defineProperty({
    __proto__: null,
    get UnicodeNormalizationForm() {
      return is;
    },
    Utf8ErrorFuncs: M8,
    get Utf8ErrorReason() {
      return mr;
    },
    _toEscapedUtf8String: kV,
    formatBytes32String: FV,
    nameprep: YV,
    parseBytes32String: LV,
    toUtf8Bytes: gn,
    toUtf8CodePoints: pd,
    toUtf8String: Ho
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  class ZV extends _8 {
    constructor(e) {
      super("string", e);
    }
    defaultValue() {
      return "";
    }
    encode(e, n) {
      return super.encode(e, gn(n));
    }
    decode(e) {
      return Ho(super.decode(e));
    }
  }
  class t0 extends Ks {
    constructor(e, n) {
      let r = false;
      const i = [];
      e.forEach((o) => {
        o.dynamic && (r = true), i.push(o.type);
      });
      const s = "tuple(" + i.join(",") + ")";
      super("tuple", s, n, r), this.coders = e;
    }
    defaultValue() {
      const e = [];
      this.coders.forEach((r) => {
        e.push(r.defaultValue());
      });
      const n = this.coders.reduce((r, i) => {
        const s = i.localName;
        return s && (r[s] || (r[s] = 0), r[s]++), r;
      }, {});
      return this.coders.forEach((r, i) => {
        let s = r.localName;
        !s || n[s] !== 1 || (s === "length" && (s = "_length"), e[s] == null && (e[s] = e[i]));
      }), Object.freeze(e);
    }
    encode(e, n) {
      return I8(e, this.coders, n);
    }
    decode(e) {
      return e.coerce(this.name, P8(e, this.coders));
    }
  }
  const n0 = new oe(Sf), $V = new RegExp(/^bytes([0-9]*)$/), ez = new RegExp(/^(u?int)([0-9]*)$/);
  class F8 {
    constructor(e) {
      ge(this, "coerceFunc", e || null);
    }
    _getCoder(e) {
      switch (e.baseType) {
        case "address":
          return new AV(e.name);
        case "bool":
          return new EV(e.name);
        case "string":
          return new ZV(e.name);
        case "bytes":
          return new SV(e.name);
        case "array":
          return new vV(this._getCoder(e.arrayChildren), e.arrayLength, e.name);
        case "tuple":
          return new t0((e.components || []).map((r) => this._getCoder(r)), e.name);
        case "":
          return new CV(e.name);
      }
      let n = e.type.match(ez);
      if (n) {
        let r = parseInt(n[2] || "256");
        return (r === 0 || r > 256 || r % 8 !== 0) && n0.throwArgumentError("invalid " + n[1] + " bit length", "param", e), new NV(r / 8, n[1] === "int", e.name);
      }
      if (n = e.type.match($V), n) {
        let r = parseInt(n[1]);
        return (r === 0 || r > 32) && n0.throwArgumentError("invalid bytes length", "param", e), new TV(r, e.name);
      }
      return n0.throwArgumentError("invalid type", "type", e.type);
    }
    _getWordSize() {
      return 32;
    }
    _getReader(e, n) {
      return new hd(e, this._getWordSize(), this.coerceFunc, n);
    }
    _getWriter() {
      return new Zm(this._getWordSize());
    }
    getDefaultValue(e) {
      const n = e.map((i) => this._getCoder(vn.from(i)));
      return new t0(n, "_").defaultValue();
    }
    encode(e, n) {
      e.length !== n.length && n0.throwError("types/values length mismatch", oe.errors.INVALID_ARGUMENT, {
        count: {
          types: e.length,
          values: n.length
        },
        value: {
          types: e,
          values: n
        }
      });
      const r = e.map((o) => this._getCoder(vn.from(o))), i = new t0(r, "_"), s = this._getWriter();
      return i.encode(s, n), s.data;
    }
    decode(e, n, r) {
      const i = e.map((o) => this._getCoder(vn.from(o)));
      return new t0(i, "_").decode(this._getReader(Ae(n), r));
    }
  }
  const L8 = new F8();
  function vo(t) {
    return mt(gn(t));
  }
  const D8 = "hash/5.8.0";
  function Uy(t) {
    t = atob(t);
    const e = [];
    for (let n = 0; n < t.length; n++) e.push(t.charCodeAt(n));
    return Ae(e);
  }
  function Hy(t) {
    t = Ae(t);
    let e = "";
    for (let n = 0; n < t.length; n++) e += String.fromCharCode(t[n]);
    return btoa(e);
  }
  const tz = Object.freeze(Object.defineProperty({
    __proto__: null,
    decode: Uy,
    encode: Hy
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  function U8(t, e) {
    e == null && (e = 1);
    const n = [], r = n.forEach, i = function(s, o) {
      r.call(s, function(a) {
        o > 0 && Array.isArray(a) ? i(a, o - 1) : n.push(a);
      });
    };
    return i(t, e), n;
  }
  function nz(t) {
    const e = {};
    for (let n = 0; n < t.length; n++) {
      const r = t[n];
      e[r[0]] = r[1];
    }
    return e;
  }
  function rz(t) {
    let e = 0;
    function n() {
      return t[e++] << 8 | t[e++];
    }
    let r = n(), i = 1, s = [
      0,
      1
    ];
    for (let D = 1; D < r; D++) s.push(i += n());
    let o = n(), a = e;
    e += o;
    let c = 0, l = 0;
    function u() {
      return c == 0 && (l = l << 8 | t[e++], c = 8), l >> --c & 1;
    }
    const f = 31, d = Math.pow(2, f), m = d >>> 1, y = m >> 1, x = d - 1;
    let w = 0;
    for (let D = 0; D < f; D++) w = w << 1 | u();
    let R = [], O = 0, B = d;
    for (; ; ) {
      let D = Math.floor(((w - O + 1) * i - 1) / B), H = 0, q = r;
      for (; q - H > 1; ) {
        let L = H + q >>> 1;
        D < s[L] ? q = L : H = L;
      }
      if (H == 0) break;
      R.push(H);
      let S = O + Math.floor(B * s[H] / i), P = O + Math.floor(B * s[H + 1] / i) - 1;
      for (; !((S ^ P) & m); ) w = w << 1 & x | u(), S = S << 1 & x, P = P << 1 & x | 1;
      for (; S & ~P & y; ) w = w & m | w << 1 & x >>> 1 | u(), S = S << 1 ^ m, P = (P ^ m) << 1 | m | 1;
      O = S, B = 1 + P - S;
    }
    let M = r - 4;
    return R.map((D) => {
      switch (D - M) {
        case 3:
          return M + 65792 + (t[a++] << 16 | t[a++] << 8 | t[a++]);
        case 2:
          return M + 256 + (t[a++] << 8 | t[a++]);
        case 1:
          return M + t[a++];
        default:
          return D - 1;
      }
    });
  }
  function iz(t) {
    let e = 0;
    return () => t[e++];
  }
  function sz(t) {
    return iz(rz(t));
  }
  function oz(t) {
    return t & 1 ? ~t >> 1 : t >> 1;
  }
  function az(t, e) {
    let n = Array(t);
    for (let r = 0; r < t; r++) n[r] = 1 + e();
    return n;
  }
  function Rw(t, e) {
    let n = Array(t);
    for (let r = 0, i = -1; r < t; r++) n[r] = i += 1 + e();
    return n;
  }
  function cz(t, e) {
    let n = Array(t);
    for (let r = 0, i = 0; r < t; r++) n[r] = i += oz(e());
    return n;
  }
  function gd(t, e) {
    let n = Rw(t(), t), r = t(), i = Rw(r, t), s = az(r, t);
    for (let o = 0; o < r; o++) for (let a = 0; a < s[o]; a++) n.push(i[o] + a);
    return e ? n.map((o) => e[o]) : n;
  }
  function lz(t) {
    let e = [];
    for (; ; ) {
      let n = t();
      if (n == 0) break;
      e.push(fz(n, t));
    }
    for (; ; ) {
      let n = t() - 1;
      if (n < 0) break;
      e.push(dz(n, t));
    }
    return nz(U8(e));
  }
  function uz(t) {
    let e = [];
    for (; ; ) {
      let n = t();
      if (n == 0) break;
      e.push(n);
    }
    return e;
  }
  function H8(t, e, n) {
    let r = Array(t).fill(void 0).map(() => []);
    for (let i = 0; i < e; i++) cz(t, n).forEach((s, o) => r[o].push(s));
    return r;
  }
  function fz(t, e) {
    let n = 1 + e(), r = e(), i = uz(e), s = H8(i.length, 1 + t, e);
    return U8(s.map((o, a) => {
      const c = o[0], l = o.slice(1);
      return Array(i[a]).fill(void 0).map((u, f) => {
        let d = f * r;
        return [
          c + f * n,
          l.map((m) => m + d)
        ];
      });
    }));
  }
  function dz(t, e) {
    let n = 1 + e();
    return H8(n, 1 + t, e).map((i) => [
      i[0],
      i.slice(1)
    ]);
  }
  function hz(t) {
    let e = gd(t).sort((r, i) => r - i);
    return n();
    function n() {
      let r = [];
      for (; ; ) {
        let l = gd(t, e);
        if (l.length == 0) break;
        r.push({
          set: new Set(l),
          node: n()
        });
      }
      r.sort((l, u) => u.set.size - l.set.size);
      let i = t(), s = i % 3;
      i = i / 3 | 0;
      let o = !!(i & 1);
      i >>= 1;
      let a = i == 1, c = i == 2;
      return {
        branches: r,
        valid: s,
        fe0f: o,
        save: a,
        check: c
      };
    }
  }
  function pz() {
    return sz(Uy("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"));
  }
  const wh = pz(), gz = new Set(gd(wh)), mz = new Set(gd(wh)), yz = lz(wh), bz = hz(wh), Nw = 45, Ow = 95;
  function G8(t) {
    return pd(t);
  }
  function xz(t) {
    return t.filter((e) => e != 65039);
  }
  function V8(t) {
    for (let e of t.split(".")) {
      let n = G8(e);
      try {
        for (let r = n.lastIndexOf(Ow) - 1; r >= 0; r--) if (n[r] !== Ow) throw new Error("underscore only allowed at start");
        if (n.length >= 4 && n.every((r) => r < 128) && n[2] === Nw && n[3] === Nw) throw new Error("invalid label extension");
      } catch (r) {
        throw new Error(`Invalid label "${e}": ${r.message}`);
      }
    }
    return t;
  }
  function Az(t) {
    return V8(wz(t, xz));
  }
  function wz(t, e) {
    let n = G8(t).reverse(), r = [];
    for (; n.length; ) {
      let i = Ez(n);
      if (i) {
        r.push(...e(i));
        continue;
      }
      let s = n.pop();
      if (gz.has(s)) {
        r.push(s);
        continue;
      }
      if (mz.has(s)) continue;
      let o = yz[s];
      if (o) {
        r.push(...o);
        continue;
      }
      throw new Error(`Disallowed codepoint: 0x${s.toString(16).toUpperCase()}`);
    }
    return V8(vz(String.fromCodePoint(...r)));
  }
  function vz(t) {
    return t.normalize("NFC");
  }
  function Ez(t, e) {
    var n;
    let r = bz, i, s, o = [], a = t.length;
    for (; a; ) {
      let c = t[--a];
      if (r = (n = r.branches.find((l) => l.set.has(c))) === null || n === void 0 ? void 0 : n.node, !r) break;
      if (r.save) s = c;
      else if (r.check && c === s) break;
      o.push(c), r.fe0f && (o.push(65039), a > 0 && t[a - 1] == 65039 && a--), r.valid && (i = o.slice(), r.valid == 2 && i.splice(1, 1), t.length = a);
    }
    return i;
  }
  const Sz = new oe(D8), z8 = new Uint8Array(32);
  z8.fill(0);
  function Bw(t) {
    if (t.length === 0) throw new Error("invalid ENS name; empty component");
    return t;
  }
  function vh(t) {
    const e = gn(Az(t)), n = [];
    if (t.length === 0) return n;
    let r = 0;
    for (let i = 0; i < e.length; i++) e[i] === 46 && (n.push(Bw(e.slice(r, i))), r = i + 1);
    if (r >= e.length) throw new Error("invalid ENS name; empty component");
    return n.push(Bw(e.slice(r))), n;
  }
  function Tz(t) {
    return vh(t).map((e) => Ho(e)).join(".");
  }
  function Cz(t) {
    try {
      return vh(t).length !== 0;
    } catch {
    }
    return false;
  }
  function vu(t) {
    typeof t != "string" && Sz.throwArgumentError("invalid ENS name; not a string", "name", t);
    let e = z8;
    const n = vh(t);
    for (; n.length; ) e = mt(Et([
      e,
      mt(n.pop())
    ]));
    return Ee(e);
  }
  function Q8(t) {
    return Ee(Et(vh(t).map((e) => {
      if (e.length > 63) throw new Error("invalid DNS encoded entry; length exceeds 63 bytes");
      const n = new Uint8Array(e.length + 1);
      return n.set(e, 1), n[0] = n.length - 1, n;
    }))) + "00";
  }
  const j8 = `Ethereum Signed Message:
`;
  function Gy(t) {
    return typeof t == "string" && (t = gn(t)), mt(Et([
      gn(j8),
      gn(String(t.length)),
      t
    ]));
  }
  var Iz = function(t, e, n, r) {
    function i(s) {
      return s instanceof n ? s : new n(function(o) {
        o(s);
      });
    }
    return new (n || (n = Promise))(function(s, o) {
      function a(u) {
        try {
          l(r.next(u));
        } catch (f) {
          o(f);
        }
      }
      function c(u) {
        try {
          l(r.throw(u));
        } catch (f) {
          o(f);
        }
      }
      function l(u) {
        u.done ? s(u.value) : i(u.value).then(a, c);
      }
      l((r = r.apply(t, e || [])).next());
    });
  };
  const Wt = new oe(D8), J8 = new Uint8Array(32);
  J8.fill(0);
  const Pz = ve.from(-1), K8 = ve.from(0), W8 = ve.from(1), _z = ve.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
  function Rz(t) {
    const e = Ae(t), n = e.length % 32;
    return n ? nr([
      e,
      J8.slice(n)
    ]) : Ee(e);
  }
  const Nz = xt(W8.toHexString(), 32), Oz = xt(K8.toHexString(), 32), Mw = {
    name: "string",
    version: "string",
    chainId: "uint256",
    verifyingContract: "address",
    salt: "bytes32"
  }, Ag = [
    "name",
    "version",
    "chainId",
    "verifyingContract",
    "salt"
  ];
  function kw(t) {
    return function(e) {
      return typeof e != "string" && Wt.throwArgumentError(`invalid domain value for ${JSON.stringify(t)}`, `domain.${t}`, e), e;
    };
  }
  const Bz = {
    name: kw("name"),
    version: kw("version"),
    chainId: function(t) {
      try {
        return ve.from(t).toString();
      } catch {
      }
      return Wt.throwArgumentError('invalid domain value for "chainId"', "domain.chainId", t);
    },
    verifyingContract: function(t) {
      try {
        return pt(t).toLowerCase();
      } catch {
      }
      return Wt.throwArgumentError('invalid domain value "verifyingContract"', "domain.verifyingContract", t);
    },
    salt: function(t) {
      try {
        const e = Ae(t);
        if (e.length !== 32) throw new Error("bad length");
        return Ee(e);
      } catch {
      }
      return Wt.throwArgumentError('invalid domain value "salt"', "domain.salt", t);
    }
  };
  function wg(t) {
    {
      const e = t.match(/^(u?)int(\d*)$/);
      if (e) {
        const n = e[1] === "", r = parseInt(e[2] || "256");
        (r % 8 !== 0 || r > 256 || e[2] && e[2] !== String(r)) && Wt.throwArgumentError("invalid numeric width", "type", t);
        const i = _z.mask(n ? r - 1 : r), s = n ? i.add(W8).mul(Pz) : K8;
        return function(o) {
          const a = ve.from(o);
          return (a.lt(s) || a.gt(i)) && Wt.throwArgumentError(`value out-of-bounds for ${t}`, "value", o), xt(a.toTwos(256).toHexString(), 32);
        };
      }
    }
    {
      const e = t.match(/^bytes(\d+)$/);
      if (e) {
        const n = parseInt(e[1]);
        return (n === 0 || n > 32 || e[1] !== String(n)) && Wt.throwArgumentError("invalid bytes width", "type", t), function(r) {
          return Ae(r).length !== n && Wt.throwArgumentError(`invalid length for ${t}`, "value", r), Rz(r);
        };
      }
    }
    switch (t) {
      case "address":
        return function(e) {
          return xt(pt(e), 32);
        };
      case "bool":
        return function(e) {
          return e ? Nz : Oz;
        };
      case "bytes":
        return function(e) {
          return mt(e);
        };
      case "string":
        return function(e) {
          return vo(e);
        };
    }
    return null;
  }
  function Fw(t, e) {
    return `${t}(${e.map(({ name: n, type: r }) => r + " " + n).join(",")})`;
  }
  class Mn {
    constructor(e) {
      ge(this, "types", Object.freeze(rs(e))), ge(this, "_encoderCache", {}), ge(this, "_types", {});
      const n = {}, r = {}, i = {};
      Object.keys(e).forEach((a) => {
        n[a] = {}, r[a] = [], i[a] = {};
      });
      for (const a in e) {
        const c = {};
        e[a].forEach((l) => {
          c[l.name] && Wt.throwArgumentError(`duplicate variable name ${JSON.stringify(l.name)} in ${JSON.stringify(a)}`, "types", e), c[l.name] = true;
          const u = l.type.match(/^([^\x5b]*)(\x5b|$)/)[1];
          u === a && Wt.throwArgumentError(`circular type reference to ${JSON.stringify(u)}`, "types", e), !wg(u) && (r[u] || Wt.throwArgumentError(`unknown type ${JSON.stringify(u)}`, "types", e), r[u].push(a), n[a][u] = true);
        });
      }
      const s = Object.keys(r).filter((a) => r[a].length === 0);
      s.length === 0 ? Wt.throwArgumentError("missing primary type", "types", e) : s.length > 1 && Wt.throwArgumentError(`ambiguous primary types or unused types: ${s.map((a) => JSON.stringify(a)).join(", ")}`, "types", e), ge(this, "primaryType", s[0]);
      function o(a, c) {
        c[a] && Wt.throwArgumentError(`circular type reference to ${JSON.stringify(a)}`, "types", e), c[a] = true, Object.keys(n[a]).forEach((l) => {
          r[l] && (o(l, c), Object.keys(c).forEach((u) => {
            i[u][l] = true;
          }));
        }), delete c[a];
      }
      o(this.primaryType, {});
      for (const a in i) {
        const c = Object.keys(i[a]);
        c.sort(), this._types[a] = Fw(a, e[a]) + c.map((l) => Fw(l, e[l])).join("");
      }
    }
    getEncoder(e) {
      let n = this._encoderCache[e];
      return n || (n = this._encoderCache[e] = this._getEncoder(e)), n;
    }
    _getEncoder(e) {
      {
        const i = wg(e);
        if (i) return i;
      }
      const n = e.match(/^(.*)(\x5b(\d*)\x5d)$/);
      if (n) {
        const i = n[1], s = this.getEncoder(i), o = parseInt(n[3]);
        return (a) => {
          o >= 0 && a.length !== o && Wt.throwArgumentError("array length mismatch; expected length ${ arrayLength }", "value", a);
          let c = a.map(s);
          return this._types[i] && (c = c.map(mt)), mt(nr(c));
        };
      }
      const r = this.types[e];
      if (r) {
        const i = vo(this._types[e]);
        return (s) => {
          const o = r.map(({ name: a, type: c }) => {
            const l = this.getEncoder(c)(s[a]);
            return this._types[c] ? mt(l) : l;
          });
          return o.unshift(i), nr(o);
        };
      }
      return Wt.throwArgumentError(`unknown type: ${e}`, "type", e);
    }
    encodeType(e) {
      const n = this._types[e];
      return n || Wt.throwArgumentError(`unknown type: ${JSON.stringify(e)}`, "name", e), n;
    }
    encodeData(e, n) {
      return this.getEncoder(e)(n);
    }
    hashStruct(e, n) {
      return mt(this.encodeData(e, n));
    }
    encode(e) {
      return this.encodeData(this.primaryType, e);
    }
    hash(e) {
      return this.hashStruct(this.primaryType, e);
    }
    _visit(e, n, r) {
      if (wg(e)) return r(e, n);
      const i = e.match(/^(.*)(\x5b(\d*)\x5d)$/);
      if (i) {
        const o = i[1], a = parseInt(i[3]);
        return a >= 0 && n.length !== a && Wt.throwArgumentError("array length mismatch; expected length ${ arrayLength }", "value", n), n.map((c) => this._visit(o, c, r));
      }
      const s = this.types[e];
      return s ? s.reduce((o, { name: a, type: c }) => (o[a] = this._visit(c, n[a], r), o), {}) : Wt.throwArgumentError(`unknown type: ${e}`, "type", e);
    }
    visit(e, n) {
      return this._visit(this.primaryType, e, n);
    }
    static from(e) {
      return new Mn(e);
    }
    static getPrimaryType(e) {
      return Mn.from(e).primaryType;
    }
    static hashStruct(e, n, r) {
      return Mn.from(n).hashStruct(e, r);
    }
    static hashDomain(e) {
      const n = [];
      for (const r in e) {
        const i = Mw[r];
        i || Wt.throwArgumentError(`invalid typed-data domain key: ${JSON.stringify(r)}`, "domain", e), n.push({
          name: r,
          type: i
        });
      }
      return n.sort((r, i) => Ag.indexOf(r.name) - Ag.indexOf(i.name)), Mn.hashStruct("EIP712Domain", {
        EIP712Domain: n
      }, e);
    }
    static encode(e, n, r) {
      return nr([
        "0x1901",
        Mn.hashDomain(e),
        Mn.from(n).hash(r)
      ]);
    }
    static hash(e, n, r) {
      return mt(Mn.encode(e, n, r));
    }
    static resolveNames(e, n, r, i) {
      return Iz(this, void 0, void 0, function* () {
        e = bn(e);
        const s = {};
        e.verifyingContract && !st(e.verifyingContract, 20) && (s[e.verifyingContract] = "0x");
        const o = Mn.from(n);
        o.visit(r, (a, c) => (a === "address" && !st(c, 20) && (s[c] = "0x"), c));
        for (const a in s) s[a] = yield i(a);
        return e.verifyingContract && s[e.verifyingContract] && (e.verifyingContract = s[e.verifyingContract]), r = o.visit(r, (a, c) => a === "address" && s[c] ? s[c] : c), {
          domain: e,
          value: r
        };
      });
    }
    static getPayload(e, n, r) {
      Mn.hashDomain(e);
      const i = {}, s = [];
      Ag.forEach((c) => {
        const l = e[c];
        l != null && (i[c] = Bz[c](l), s.push({
          name: c,
          type: Mw[c]
        }));
      });
      const o = Mn.from(n), a = bn(n);
      return a.EIP712Domain ? Wt.throwArgumentError("types must not contain EIP712Domain type", "types.EIP712Domain", n) : a.EIP712Domain = s, o.encode(r), {
        types: a,
        domain: i,
        primaryType: o.primaryType,
        message: o.visit(r, (c, l) => {
          if (c.match(/^bytes(\d*)/)) return Ee(Ae(l));
          if (c.match(/^u?int/)) return ve.from(l).toString();
          switch (c) {
            case "address":
              return l.toLowerCase();
            case "bool":
              return !!l;
            case "string":
              return typeof l != "string" && Wt.throwArgumentError("invalid string", "value", l), l;
          }
          return Wt.throwArgumentError("unsupported type", "type", c);
        })
      };
    }
  }
  const Mz = Object.freeze(Object.defineProperty({
    __proto__: null,
    _TypedDataEncoder: Mn,
    dnsEncode: Q8,
    ensNormalize: Tz,
    hashMessage: Gy,
    id: vo,
    isValidName: Cz,
    messagePrefix: j8,
    namehash: vu
  }, Symbol.toStringTag, {
    value: "Module"
  })), Kt = new oe(Sf);
  class q8 extends Uo {
  }
  class Y8 extends Uo {
  }
  class kz extends Uo {
  }
  class md extends Uo {
    static isIndexed(e) {
      return !!(e && e._isIndexed);
    }
  }
  const Fz = {
    "0x08c379a0": {
      signature: "Error(string)",
      name: "Error",
      inputs: [
        "string"
      ],
      reason: true
    },
    "0x4e487b71": {
      signature: "Panic(uint256)",
      name: "Panic",
      inputs: [
        "uint256"
      ]
    }
  };
  function Lw(t, e) {
    const n = new Error(`deferred error during ABI decoding triggered accessing ${t}`);
    return n.error = e, n;
  }
  class e1 {
    constructor(e) {
      let n = [];
      typeof e == "string" ? n = JSON.parse(e) : n = e, ge(this, "fragments", n.map((r) => ji.from(r)).filter((r) => r != null)), ge(this, "_abiCoder", bi(new.target, "getAbiCoder")()), ge(this, "functions", {}), ge(this, "errors", {}), ge(this, "events", {}), ge(this, "structs", {}), this.fragments.forEach((r) => {
        let i = null;
        switch (r.type) {
          case "constructor":
            if (this.deploy) {
              Kt.warn("duplicate definition - constructor");
              return;
            }
            ge(this, "deploy", r);
            return;
          case "function":
            i = this.functions;
            break;
          case "event":
            i = this.events;
            break;
          case "error":
            i = this.errors;
            break;
          default:
            return;
        }
        let s = r.format();
        if (i[s]) {
          Kt.warn("duplicate definition - " + s);
          return;
        }
        i[s] = r;
      }), this.deploy || ge(this, "deploy", pi.from({
        payable: false,
        type: "constructor"
      })), ge(this, "_isInterface", true);
    }
    format(e) {
      e || (e = ct.full), e === ct.sighash && Kt.throwArgumentError("interface does not support formatting sighash", "format", e);
      const n = this.fragments.map((r) => r.format(e));
      return e === ct.json ? JSON.stringify(n.map((r) => JSON.parse(r))) : n;
    }
    static getAbiCoder() {
      return L8;
    }
    static getAddress(e) {
      return pt(e);
    }
    static getSighash(e) {
      return ln(vo(e.format()), 0, 4);
    }
    static getEventTopic(e) {
      return vo(e.format());
    }
    getFunction(e) {
      if (st(e)) {
        for (const r in this.functions) if (e === this.getSighash(r)) return this.functions[r];
        Kt.throwArgumentError("no matching function", "sighash", e);
      }
      if (e.indexOf("(") === -1) {
        const r = e.trim(), i = Object.keys(this.functions).filter((s) => s.split("(")[0] === r);
        return i.length === 0 ? Kt.throwArgumentError("no matching function", "name", r) : i.length > 1 && Kt.throwArgumentError("multiple matching functions", "name", r), this.functions[i[0]];
      }
      const n = this.functions[gi.fromString(e).format()];
      return n || Kt.throwArgumentError("no matching function", "signature", e), n;
    }
    getEvent(e) {
      if (st(e)) {
        const r = e.toLowerCase();
        for (const i in this.events) if (r === this.getEventTopic(i)) return this.events[i];
        Kt.throwArgumentError("no matching event", "topichash", r);
      }
      if (e.indexOf("(") === -1) {
        const r = e.trim(), i = Object.keys(this.events).filter((s) => s.split("(")[0] === r);
        return i.length === 0 ? Kt.throwArgumentError("no matching event", "name", r) : i.length > 1 && Kt.throwArgumentError("multiple matching events", "name", r), this.events[i[0]];
      }
      const n = this.events[Vi.fromString(e).format()];
      return n || Kt.throwArgumentError("no matching event", "signature", e), n;
    }
    getError(e) {
      if (st(e)) {
        const r = bi(this.constructor, "getSighash");
        for (const i in this.errors) {
          const s = this.errors[i];
          if (e === r(s)) return this.errors[i];
        }
        Kt.throwArgumentError("no matching error", "sighash", e);
      }
      if (e.indexOf("(") === -1) {
        const r = e.trim(), i = Object.keys(this.errors).filter((s) => s.split("(")[0] === r);
        return i.length === 0 ? Kt.throwArgumentError("no matching error", "name", r) : i.length > 1 && Kt.throwArgumentError("multiple matching errors", "name", r), this.errors[i[0]];
      }
      const n = this.errors[gi.fromString(e).format()];
      return n || Kt.throwArgumentError("no matching error", "signature", e), n;
    }
    getSighash(e) {
      if (typeof e == "string") try {
        e = this.getFunction(e);
      } catch (n) {
        try {
          e = this.getError(e);
        } catch {
          throw n;
        }
      }
      return bi(this.constructor, "getSighash")(e);
    }
    getEventTopic(e) {
      return typeof e == "string" && (e = this.getEvent(e)), bi(this.constructor, "getEventTopic")(e);
    }
    _decodeParams(e, n) {
      return this._abiCoder.decode(e, n);
    }
    _encodeParams(e, n) {
      return this._abiCoder.encode(e, n);
    }
    encodeDeploy(e) {
      return this._encodeParams(this.deploy.inputs, e || []);
    }
    decodeErrorResult(e, n) {
      typeof e == "string" && (e = this.getError(e));
      const r = Ae(n);
      return Ee(r.slice(0, 4)) !== this.getSighash(e) && Kt.throwArgumentError(`data signature does not match error ${e.name}.`, "data", Ee(r)), this._decodeParams(e.inputs, r.slice(4));
    }
    encodeErrorResult(e, n) {
      return typeof e == "string" && (e = this.getError(e)), Ee(Et([
        this.getSighash(e),
        this._encodeParams(e.inputs, n || [])
      ]));
    }
    decodeFunctionData(e, n) {
      typeof e == "string" && (e = this.getFunction(e));
      const r = Ae(n);
      return Ee(r.slice(0, 4)) !== this.getSighash(e) && Kt.throwArgumentError(`data signature does not match function ${e.name}.`, "data", Ee(r)), this._decodeParams(e.inputs, r.slice(4));
    }
    encodeFunctionData(e, n) {
      return typeof e == "string" && (e = this.getFunction(e)), Ee(Et([
        this.getSighash(e),
        this._encodeParams(e.inputs, n || [])
      ]));
    }
    decodeFunctionResult(e, n) {
      typeof e == "string" && (e = this.getFunction(e));
      let r = Ae(n), i = null, s = "", o = null, a = null, c = null;
      switch (r.length % this._abiCoder._getWordSize()) {
        case 0:
          try {
            return this._abiCoder.decode(e.outputs, r);
          } catch {
          }
          break;
        case 4: {
          const l = Ee(r.slice(0, 4)), u = Fz[l];
          if (u) o = this._abiCoder.decode(u.inputs, r.slice(4)), a = u.name, c = u.signature, u.reason && (i = o[0]), a === "Error" ? s = `; VM Exception while processing transaction: reverted with reason string ${JSON.stringify(o[0])}` : a === "Panic" && (s = `; VM Exception while processing transaction: reverted with panic code ${o[0]}`);
          else try {
            const f = this.getError(l);
            o = this._abiCoder.decode(f.inputs, r.slice(4)), a = f.name, c = f.format();
          } catch {
          }
          break;
        }
      }
      return Kt.throwError("call revert exception" + s, oe.errors.CALL_EXCEPTION, {
        method: e.format(),
        data: Ee(n),
        errorArgs: o,
        errorName: a,
        errorSignature: c,
        reason: i
      });
    }
    encodeFunctionResult(e, n) {
      return typeof e == "string" && (e = this.getFunction(e)), Ee(this._abiCoder.encode(e.outputs, n || []));
    }
    encodeFilterTopics(e, n) {
      typeof e == "string" && (e = this.getEvent(e)), n.length > e.inputs.length && Kt.throwError("too many arguments for " + e.format(), oe.errors.UNEXPECTED_ARGUMENT, {
        argument: "values",
        value: n
      });
      let r = [];
      e.anonymous || r.push(this.getEventTopic(e));
      const i = (s, o) => s.type === "string" ? vo(o) : s.type === "bytes" ? mt(Ee(o)) : (s.type === "bool" && typeof o == "boolean" && (o = o ? "0x01" : "0x00"), s.type.match(/^u?int/) && (o = ve.from(o).toHexString()), s.type === "address" && this._abiCoder.encode([
        "address"
      ], [
        o
      ]), xt(Ee(o), 32));
      for (n.forEach((s, o) => {
        let a = e.inputs[o];
        if (!a.indexed) {
          s != null && Kt.throwArgumentError("cannot filter non-indexed parameters; must be null", "contract." + a.name, s);
          return;
        }
        s == null ? r.push(null) : a.baseType === "array" || a.baseType === "tuple" ? Kt.throwArgumentError("filtering with tuples or arrays not supported", "contract." + a.name, s) : Array.isArray(s) ? r.push(s.map((c) => i(a, c))) : r.push(i(a, s));
      }); r.length && r[r.length - 1] === null; ) r.pop();
      return r;
    }
    encodeEventLog(e, n) {
      typeof e == "string" && (e = this.getEvent(e));
      const r = [], i = [], s = [];
      return e.anonymous || r.push(this.getEventTopic(e)), n.length !== e.inputs.length && Kt.throwArgumentError("event arguments/values mismatch", "values", n), e.inputs.forEach((o, a) => {
        const c = n[a];
        if (o.indexed) if (o.type === "string") r.push(vo(c));
        else if (o.type === "bytes") r.push(mt(c));
        else {
          if (o.baseType === "tuple" || o.baseType === "array") throw new Error("not implemented");
          r.push(this._abiCoder.encode([
            o.type
          ], [
            c
          ]));
        }
        else i.push(o), s.push(c);
      }), {
        data: this._abiCoder.encode(i, s),
        topics: r
      };
    }
    decodeEventLog(e, n, r) {
      if (typeof e == "string" && (e = this.getEvent(e)), r != null && !e.anonymous) {
        let d = this.getEventTopic(e);
        (!st(r[0], 32) || r[0].toLowerCase() !== d) && Kt.throwError("fragment/topic mismatch", oe.errors.INVALID_ARGUMENT, {
          argument: "topics[0]",
          expected: d,
          value: r[0]
        }), r = r.slice(1);
      }
      let i = [], s = [], o = [];
      e.inputs.forEach((d, m) => {
        d.indexed ? d.type === "string" || d.type === "bytes" || d.baseType === "tuple" || d.baseType === "array" ? (i.push(vn.fromObject({
          type: "bytes32",
          name: d.name
        })), o.push(true)) : (i.push(d), o.push(false)) : (s.push(d), o.push(false));
      });
      let a = r != null ? this._abiCoder.decode(i, Et(r)) : null, c = this._abiCoder.decode(s, n, true), l = [], u = 0, f = 0;
      e.inputs.forEach((d, m) => {
        if (d.indexed) if (a == null) l[m] = new md({
          _isIndexed: true,
          hash: null
        });
        else if (o[m]) l[m] = new md({
          _isIndexed: true,
          hash: a[f++]
        });
        else try {
          l[m] = a[f++];
        } catch (y) {
          l[m] = y;
        }
        else try {
          l[m] = c[u++];
        } catch (y) {
          l[m] = y;
        }
        if (d.name && l[d.name] == null) {
          const y = l[m];
          y instanceof Error ? Object.defineProperty(l, d.name, {
            enumerable: true,
            get: () => {
              throw Lw(`property ${JSON.stringify(d.name)}`, y);
            }
          }) : l[d.name] = y;
        }
      });
      for (let d = 0; d < l.length; d++) {
        const m = l[d];
        m instanceof Error && Object.defineProperty(l, d, {
          enumerable: true,
          get: () => {
            throw Lw(`index ${d}`, m);
          }
        });
      }
      return Object.freeze(l);
    }
    parseTransaction(e) {
      let n = this.getFunction(e.data.substring(0, 10).toLowerCase());
      return n ? new Y8({
        args: this._abiCoder.decode(n.inputs, "0x" + e.data.substring(10)),
        functionFragment: n,
        name: n.name,
        signature: n.format(),
        sighash: this.getSighash(n),
        value: ve.from(e.value || "0")
      }) : null;
    }
    parseLog(e) {
      let n = this.getEvent(e.topics[0]);
      return !n || n.anonymous ? null : new q8({
        eventFragment: n,
        name: n.name,
        signature: n.format(),
        topic: this.getEventTopic(n),
        args: this.decodeEventLog(n, e.data, e.topics)
      });
    }
    parseError(e) {
      const n = Ee(e);
      let r = this.getError(n.substring(0, 10).toLowerCase());
      return r ? new kz({
        args: this._abiCoder.decode(r.inputs, "0x" + n.substring(10)),
        errorFragment: r,
        name: r.name,
        signature: r.format(),
        sighash: this.getSighash(r)
      }) : null;
    }
    static isInterface(e) {
      return !!(e && e._isInterface);
    }
  }
  const Lz = Object.freeze(Object.defineProperty({
    __proto__: null,
    AbiCoder: F8,
    ConstructorFragment: pi,
    ErrorFragment: Ps,
    EventFragment: Vi,
    FormatTypes: ct,
    Fragment: ji,
    FunctionFragment: gi,
    Indexed: md,
    Interface: e1,
    LogDescription: q8,
    ParamType: vn,
    TransactionDescription: Y8,
    checkResultErrors: v8,
    defaultAbiCoder: L8
  }, Symbol.toStringTag, {
    value: "Module"
  })), Dz = "abstract-provider/5.8.0";
  var Uz = function(t, e, n, r) {
    function i(s) {
      return s instanceof n ? s : new n(function(o) {
        o(s);
      });
    }
    return new (n || (n = Promise))(function(s, o) {
      function a(u) {
        try {
          l(r.next(u));
        } catch (f) {
          o(f);
        }
      }
      function c(u) {
        try {
          l(r.throw(u));
        } catch (f) {
          o(f);
        }
      }
      function l(u) {
        u.done ? s(u.value) : i(u.value).then(a, c);
      }
      l((r = r.apply(t, e || [])).next());
    });
  };
  const Hz = new oe(Dz);
  class Gz extends Uo {
    static isForkEvent(e) {
      return !!(e && e._isForkEvent);
    }
  }
  class Tf {
    constructor() {
      Hz.checkAbstract(new.target, Tf), ge(this, "_isProvider", true);
    }
    getFeeData() {
      return Uz(this, void 0, void 0, function* () {
        const { block: e, gasPrice: n } = yield tn({
          block: this.getBlock("latest"),
          gasPrice: this.getGasPrice().catch((o) => null)
        });
        let r = null, i = null, s = null;
        return e && e.baseFeePerGas && (r = e.baseFeePerGas, s = ve.from("1500000000"), i = e.baseFeePerGas.mul(2).add(s)), {
          lastBaseFeePerGas: r,
          maxFeePerGas: i,
          maxPriorityFeePerGas: s,
          gasPrice: n
        };
      });
    }
    addListener(e, n) {
      return this.on(e, n);
    }
    removeListener(e, n) {
      return this.off(e, n);
    }
    static isProvider(e) {
      return !!(e && e._isProvider);
    }
  }
  const Vz = "abstract-signer/5.8.0";
  var ni = function(t, e, n, r) {
    function i(s) {
      return s instanceof n ? s : new n(function(o) {
        o(s);
      });
    }
    return new (n || (n = Promise))(function(s, o) {
      function a(u) {
        try {
          l(r.next(u));
        } catch (f) {
          o(f);
        }
      }
      function c(u) {
        try {
          l(r.throw(u));
        } catch (f) {
          o(f);
        }
      }
      function l(u) {
        u.done ? s(u.value) : i(u.value).then(a, c);
      }
      l((r = r.apply(t, e || [])).next());
    });
  };
  const Dr = new oe(Vz), zz = [
    "accessList",
    "ccipReadEnabled",
    "chainId",
    "customData",
    "data",
    "from",
    "gasLimit",
    "gasPrice",
    "maxFeePerGas",
    "maxPriorityFeePerGas",
    "nonce",
    "to",
    "type",
    "value"
  ], Qz = [
    oe.errors.INSUFFICIENT_FUNDS,
    oe.errors.NONCE_EXPIRED,
    oe.errors.REPLACEMENT_UNDERPRICED
  ];
  class Il {
    constructor() {
      Dr.checkAbstract(new.target, Il), ge(this, "_isSigner", true);
    }
    getBalance(e) {
      return ni(this, void 0, void 0, function* () {
        return this._checkProvider("getBalance"), yield this.provider.getBalance(this.getAddress(), e);
      });
    }
    getTransactionCount(e) {
      return ni(this, void 0, void 0, function* () {
        return this._checkProvider("getTransactionCount"), yield this.provider.getTransactionCount(this.getAddress(), e);
      });
    }
    estimateGas(e) {
      return ni(this, void 0, void 0, function* () {
        this._checkProvider("estimateGas");
        const n = yield tn(this.checkTransaction(e));
        return yield this.provider.estimateGas(n);
      });
    }
    call(e, n) {
      return ni(this, void 0, void 0, function* () {
        this._checkProvider("call");
        const r = yield tn(this.checkTransaction(e));
        return yield this.provider.call(r, n);
      });
    }
    sendTransaction(e) {
      return ni(this, void 0, void 0, function* () {
        this._checkProvider("sendTransaction");
        const n = yield this.populateTransaction(e), r = yield this.signTransaction(n);
        return yield this.provider.sendTransaction(r);
      });
    }
    getChainId() {
      return ni(this, void 0, void 0, function* () {
        return this._checkProvider("getChainId"), (yield this.provider.getNetwork()).chainId;
      });
    }
    getGasPrice() {
      return ni(this, void 0, void 0, function* () {
        return this._checkProvider("getGasPrice"), yield this.provider.getGasPrice();
      });
    }
    getFeeData() {
      return ni(this, void 0, void 0, function* () {
        return this._checkProvider("getFeeData"), yield this.provider.getFeeData();
      });
    }
    resolveName(e) {
      return ni(this, void 0, void 0, function* () {
        return this._checkProvider("resolveName"), yield this.provider.resolveName(e);
      });
    }
    checkTransaction(e) {
      for (const r in e) zz.indexOf(r) === -1 && Dr.throwArgumentError("invalid transaction key: " + r, "transaction", e);
      const n = bn(e);
      return n.from == null ? n.from = this.getAddress() : n.from = Promise.all([
        Promise.resolve(n.from),
        this.getAddress()
      ]).then((r) => (r[0].toLowerCase() !== r[1].toLowerCase() && Dr.throwArgumentError("from address mismatch", "transaction", e), r[0])), n;
    }
    populateTransaction(e) {
      return ni(this, void 0, void 0, function* () {
        const n = yield tn(this.checkTransaction(e));
        n.to != null && (n.to = Promise.resolve(n.to).then((i) => ni(this, void 0, void 0, function* () {
          if (i == null) return null;
          const s = yield this.resolveName(i);
          return s == null && Dr.throwArgumentError("provided ENS name resolves to null", "tx.to", i), s;
        })), n.to.catch((i) => {
        }));
        const r = n.maxFeePerGas != null || n.maxPriorityFeePerGas != null;
        if (n.gasPrice != null && (n.type === 2 || r) ? Dr.throwArgumentError("eip-1559 transaction do not support gasPrice", "transaction", e) : (n.type === 0 || n.type === 1) && r && Dr.throwArgumentError("pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas", "transaction", e), (n.type === 2 || n.type == null) && n.maxFeePerGas != null && n.maxPriorityFeePerGas != null) n.type = 2;
        else if (n.type === 0 || n.type === 1) n.gasPrice == null && (n.gasPrice = this.getGasPrice());
        else {
          const i = yield this.getFeeData();
          if (n.type == null) if (i.maxFeePerGas != null && i.maxPriorityFeePerGas != null) if (n.type = 2, n.gasPrice != null) {
            const s = n.gasPrice;
            delete n.gasPrice, n.maxFeePerGas = s, n.maxPriorityFeePerGas = s;
          } else n.maxFeePerGas == null && (n.maxFeePerGas = i.maxFeePerGas), n.maxPriorityFeePerGas == null && (n.maxPriorityFeePerGas = i.maxPriorityFeePerGas);
          else i.gasPrice != null ? (r && Dr.throwError("network does not support EIP-1559", oe.errors.UNSUPPORTED_OPERATION, {
            operation: "populateTransaction"
          }), n.gasPrice == null && (n.gasPrice = i.gasPrice), n.type = 0) : Dr.throwError("failed to get consistent fee data", oe.errors.UNSUPPORTED_OPERATION, {
            operation: "signer.getFeeData"
          });
          else n.type === 2 && (n.maxFeePerGas == null && (n.maxFeePerGas = i.maxFeePerGas), n.maxPriorityFeePerGas == null && (n.maxPriorityFeePerGas = i.maxPriorityFeePerGas));
        }
        return n.nonce == null && (n.nonce = this.getTransactionCount("pending")), n.gasLimit == null && (n.gasLimit = this.estimateGas(n).catch((i) => {
          if (Qz.indexOf(i.code) >= 0) throw i;
          return Dr.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", oe.errors.UNPREDICTABLE_GAS_LIMIT, {
            error: i,
            tx: n
          });
        })), n.chainId == null ? n.chainId = this.getChainId() : n.chainId = Promise.all([
          Promise.resolve(n.chainId),
          this.getChainId()
        ]).then((i) => (i[1] !== 0 && i[0] !== i[1] && Dr.throwArgumentError("chainId address mismatch", "transaction", e), i[0])), yield tn(n);
      });
    }
    _checkProvider(e) {
      this.provider || Dr.throwError("missing provider", oe.errors.UNSUPPORTED_OPERATION, {
        operation: e || "_checkProvider"
      });
    }
    static isSigner(e) {
      return !!(e && e._isSigner);
    }
  }
  class Vy extends Il {
    constructor(e, n) {
      super(), ge(this, "address", e), ge(this, "provider", n || null);
    }
    getAddress() {
      return Promise.resolve(this.address);
    }
    _fail(e, n) {
      return Promise.resolve().then(() => {
        Dr.throwError(e, oe.errors.UNSUPPORTED_OPERATION, {
          operation: n
        });
      });
    }
    signMessage(e) {
      return this._fail("VoidSigner cannot sign messages", "signMessage");
    }
    signTransaction(e) {
      return this._fail("VoidSigner cannot sign transactions", "signTransaction");
    }
    _signTypedData(e, n, r) {
      return this._fail("VoidSigner cannot sign typed data", "signTypedData");
    }
    connect(e) {
      return new Vy(this.address, e);
    }
  }
  var X8 = {}, et = {}, Cf = Z8;
  function Z8(t, e) {
    if (!t) throw new Error(e || "Assertion failed");
  }
  Z8.equal = function(e, n, r) {
    if (e != n) throw new Error(r || "Assertion failed: " + e + " != " + n);
  };
  var t1 = {
    exports: {}
  };
  typeof Object.create == "function" ? t1.exports = function(e, n) {
    n && (e.super_ = n, e.prototype = Object.create(n.prototype, {
      constructor: {
        value: e,
        enumerable: false,
        writable: true,
        configurable: true
      }
    }));
  } : t1.exports = function(e, n) {
    if (n) {
      e.super_ = n;
      var r = function() {
      };
      r.prototype = n.prototype, e.prototype = new r(), e.prototype.constructor = e;
    }
  };
  var jz = t1.exports, Jz = Cf, Kz = jz;
  et.inherits = Kz;
  function Wz(t, e) {
    return (t.charCodeAt(e) & 64512) !== 55296 || e < 0 || e + 1 >= t.length ? false : (t.charCodeAt(e + 1) & 64512) === 56320;
  }
  function qz(t, e) {
    if (Array.isArray(t)) return t.slice();
    if (!t) return [];
    var n = [];
    if (typeof t == "string") if (e) {
      if (e === "hex") for (t = t.replace(/[^a-z0-9]+/ig, ""), t.length % 2 !== 0 && (t = "0" + t), i = 0; i < t.length; i += 2) n.push(parseInt(t[i] + t[i + 1], 16));
    } else for (var r = 0, i = 0; i < t.length; i++) {
      var s = t.charCodeAt(i);
      s < 128 ? n[r++] = s : s < 2048 ? (n[r++] = s >> 6 | 192, n[r++] = s & 63 | 128) : Wz(t, i) ? (s = 65536 + ((s & 1023) << 10) + (t.charCodeAt(++i) & 1023), n[r++] = s >> 18 | 240, n[r++] = s >> 12 & 63 | 128, n[r++] = s >> 6 & 63 | 128, n[r++] = s & 63 | 128) : (n[r++] = s >> 12 | 224, n[r++] = s >> 6 & 63 | 128, n[r++] = s & 63 | 128);
    }
    else for (i = 0; i < t.length; i++) n[i] = t[i] | 0;
    return n;
  }
  et.toArray = qz;
  function Yz(t) {
    for (var e = "", n = 0; n < t.length; n++) e += e7(t[n].toString(16));
    return e;
  }
  et.toHex = Yz;
  function $8(t) {
    var e = t >>> 24 | t >>> 8 & 65280 | t << 8 & 16711680 | (t & 255) << 24;
    return e >>> 0;
  }
  et.htonl = $8;
  function Xz(t, e) {
    for (var n = "", r = 0; r < t.length; r++) {
      var i = t[r];
      e === "little" && (i = $8(i)), n += t7(i.toString(16));
    }
    return n;
  }
  et.toHex32 = Xz;
  function e7(t) {
    return t.length === 1 ? "0" + t : t;
  }
  et.zero2 = e7;
  function t7(t) {
    return t.length === 7 ? "0" + t : t.length === 6 ? "00" + t : t.length === 5 ? "000" + t : t.length === 4 ? "0000" + t : t.length === 3 ? "00000" + t : t.length === 2 ? "000000" + t : t.length === 1 ? "0000000" + t : t;
  }
  et.zero8 = t7;
  function Zz(t, e, n, r) {
    var i = n - e;
    Jz(i % 4 === 0);
    for (var s = new Array(i / 4), o = 0, a = e; o < s.length; o++, a += 4) {
      var c;
      r === "big" ? c = t[a] << 24 | t[a + 1] << 16 | t[a + 2] << 8 | t[a + 3] : c = t[a + 3] << 24 | t[a + 2] << 16 | t[a + 1] << 8 | t[a], s[o] = c >>> 0;
    }
    return s;
  }
  et.join32 = Zz;
  function $z(t, e) {
    for (var n = new Array(t.length * 4), r = 0, i = 0; r < t.length; r++, i += 4) {
      var s = t[r];
      e === "big" ? (n[i] = s >>> 24, n[i + 1] = s >>> 16 & 255, n[i + 2] = s >>> 8 & 255, n[i + 3] = s & 255) : (n[i + 3] = s >>> 24, n[i + 2] = s >>> 16 & 255, n[i + 1] = s >>> 8 & 255, n[i] = s & 255);
    }
    return n;
  }
  et.split32 = $z;
  function eQ(t, e) {
    return t >>> e | t << 32 - e;
  }
  et.rotr32 = eQ;
  function tQ(t, e) {
    return t << e | t >>> 32 - e;
  }
  et.rotl32 = tQ;
  function nQ(t, e) {
    return t + e >>> 0;
  }
  et.sum32 = nQ;
  function rQ(t, e, n) {
    return t + e + n >>> 0;
  }
  et.sum32_3 = rQ;
  function iQ(t, e, n, r) {
    return t + e + n + r >>> 0;
  }
  et.sum32_4 = iQ;
  function sQ(t, e, n, r, i) {
    return t + e + n + r + i >>> 0;
  }
  et.sum32_5 = sQ;
  function oQ(t, e, n, r) {
    var i = t[e], s = t[e + 1], o = r + s >>> 0, a = (o < r ? 1 : 0) + n + i;
    t[e] = a >>> 0, t[e + 1] = o;
  }
  et.sum64 = oQ;
  function aQ(t, e, n, r) {
    var i = e + r >>> 0, s = (i < e ? 1 : 0) + t + n;
    return s >>> 0;
  }
  et.sum64_hi = aQ;
  function cQ(t, e, n, r) {
    var i = e + r;
    return i >>> 0;
  }
  et.sum64_lo = cQ;
  function lQ(t, e, n, r, i, s, o, a) {
    var c = 0, l = e;
    l = l + r >>> 0, c += l < e ? 1 : 0, l = l + s >>> 0, c += l < s ? 1 : 0, l = l + a >>> 0, c += l < a ? 1 : 0;
    var u = t + n + i + o + c;
    return u >>> 0;
  }
  et.sum64_4_hi = lQ;
  function uQ(t, e, n, r, i, s, o, a) {
    var c = e + r + s + a;
    return c >>> 0;
  }
  et.sum64_4_lo = uQ;
  function fQ(t, e, n, r, i, s, o, a, c, l) {
    var u = 0, f = e;
    f = f + r >>> 0, u += f < e ? 1 : 0, f = f + s >>> 0, u += f < s ? 1 : 0, f = f + a >>> 0, u += f < a ? 1 : 0, f = f + l >>> 0, u += f < l ? 1 : 0;
    var d = t + n + i + o + c + u;
    return d >>> 0;
  }
  et.sum64_5_hi = fQ;
  function dQ(t, e, n, r, i, s, o, a, c, l) {
    var u = e + r + s + a + l;
    return u >>> 0;
  }
  et.sum64_5_lo = dQ;
  function hQ(t, e, n) {
    var r = e << 32 - n | t >>> n;
    return r >>> 0;
  }
  et.rotr64_hi = hQ;
  function pQ(t, e, n) {
    var r = t << 32 - n | e >>> n;
    return r >>> 0;
  }
  et.rotr64_lo = pQ;
  function gQ(t, e, n) {
    return t >>> n;
  }
  et.shr64_hi = gQ;
  function mQ(t, e, n) {
    var r = t << 32 - n | e >>> n;
    return r >>> 0;
  }
  et.shr64_lo = mQ;
  var Pl = {}, Dw = et, yQ = Cf;
  function Eh() {
    this.pending = null, this.pendingTotal = 0, this.blockSize = this.constructor.blockSize, this.outSize = this.constructor.outSize, this.hmacStrength = this.constructor.hmacStrength, this.padLength = this.constructor.padLength / 8, this.endian = "big", this._delta8 = this.blockSize / 8, this._delta32 = this.blockSize / 32;
  }
  Pl.BlockHash = Eh;
  Eh.prototype.update = function(e, n) {
    if (e = Dw.toArray(e, n), this.pending ? this.pending = this.pending.concat(e) : this.pending = e, this.pendingTotal += e.length, this.pending.length >= this._delta8) {
      e = this.pending;
      var r = e.length % this._delta8;
      this.pending = e.slice(e.length - r, e.length), this.pending.length === 0 && (this.pending = null), e = Dw.join32(e, 0, e.length - r, this.endian);
      for (var i = 0; i < e.length; i += this._delta32) this._update(e, i, i + this._delta32);
    }
    return this;
  };
  Eh.prototype.digest = function(e) {
    return this.update(this._pad()), yQ(this.pending === null), this._digest(e);
  };
  Eh.prototype._pad = function() {
    var e = this.pendingTotal, n = this._delta8, r = n - (e + this.padLength) % n, i = new Array(r + this.padLength);
    i[0] = 128;
    for (var s = 1; s < r; s++) i[s] = 0;
    if (e <<= 3, this.endian === "big") {
      for (var o = 8; o < this.padLength; o++) i[s++] = 0;
      i[s++] = 0, i[s++] = 0, i[s++] = 0, i[s++] = 0, i[s++] = e >>> 24 & 255, i[s++] = e >>> 16 & 255, i[s++] = e >>> 8 & 255, i[s++] = e & 255;
    } else for (i[s++] = e & 255, i[s++] = e >>> 8 & 255, i[s++] = e >>> 16 & 255, i[s++] = e >>> 24 & 255, i[s++] = 0, i[s++] = 0, i[s++] = 0, i[s++] = 0, o = 8; o < this.padLength; o++) i[s++] = 0;
    return i;
  };
  var _l = {}, ls = {}, bQ = et, Yi = bQ.rotr32;
  function xQ(t, e, n, r) {
    if (t === 0) return n7(e, n, r);
    if (t === 1 || t === 3) return i7(e, n, r);
    if (t === 2) return r7(e, n, r);
  }
  ls.ft_1 = xQ;
  function n7(t, e, n) {
    return t & e ^ ~t & n;
  }
  ls.ch32 = n7;
  function r7(t, e, n) {
    return t & e ^ t & n ^ e & n;
  }
  ls.maj32 = r7;
  function i7(t, e, n) {
    return t ^ e ^ n;
  }
  ls.p32 = i7;
  function AQ(t) {
    return Yi(t, 2) ^ Yi(t, 13) ^ Yi(t, 22);
  }
  ls.s0_256 = AQ;
  function wQ(t) {
    return Yi(t, 6) ^ Yi(t, 11) ^ Yi(t, 25);
  }
  ls.s1_256 = wQ;
  function vQ(t) {
    return Yi(t, 7) ^ Yi(t, 18) ^ t >>> 3;
  }
  ls.g0_256 = vQ;
  function EQ(t) {
    return Yi(t, 17) ^ Yi(t, 19) ^ t >>> 10;
  }
  ls.g1_256 = EQ;
  var fl = et, SQ = Pl, TQ = ls, vg = fl.rotl32, jl = fl.sum32, CQ = fl.sum32_5, IQ = TQ.ft_1, s7 = SQ.BlockHash, PQ = [
    1518500249,
    1859775393,
    2400959708,
    3395469782
  ];
  function ss() {
    if (!(this instanceof ss)) return new ss();
    s7.call(this), this.h = [
      1732584193,
      4023233417,
      2562383102,
      271733878,
      3285377520
    ], this.W = new Array(80);
  }
  fl.inherits(ss, s7);
  var _Q = ss;
  ss.blockSize = 512;
  ss.outSize = 160;
  ss.hmacStrength = 80;
  ss.padLength = 64;
  ss.prototype._update = function(e, n) {
    for (var r = this.W, i = 0; i < 16; i++) r[i] = e[n + i];
    for (; i < r.length; i++) r[i] = vg(r[i - 3] ^ r[i - 8] ^ r[i - 14] ^ r[i - 16], 1);
    var s = this.h[0], o = this.h[1], a = this.h[2], c = this.h[3], l = this.h[4];
    for (i = 0; i < r.length; i++) {
      var u = ~~(i / 20), f = CQ(vg(s, 5), IQ(u, o, a, c), l, r[i], PQ[u]);
      l = c, c = a, a = vg(o, 30), o = s, s = f;
    }
    this.h[0] = jl(this.h[0], s), this.h[1] = jl(this.h[1], o), this.h[2] = jl(this.h[2], a), this.h[3] = jl(this.h[3], c), this.h[4] = jl(this.h[4], l);
  };
  ss.prototype._digest = function(e) {
    return e === "hex" ? fl.toHex32(this.h, "big") : fl.split32(this.h, "big");
  };
  var dl = et, RQ = Pl, Rl = ls, NQ = Cf, ri = dl.sum32, OQ = dl.sum32_4, BQ = dl.sum32_5, MQ = Rl.ch32, kQ = Rl.maj32, FQ = Rl.s0_256, LQ = Rl.s1_256, DQ = Rl.g0_256, UQ = Rl.g1_256, o7 = RQ.BlockHash, HQ = [
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ];
  function os() {
    if (!(this instanceof os)) return new os();
    o7.call(this), this.h = [
      1779033703,
      3144134277,
      1013904242,
      2773480762,
      1359893119,
      2600822924,
      528734635,
      1541459225
    ], this.k = HQ, this.W = new Array(64);
  }
  dl.inherits(os, o7);
  var a7 = os;
  os.blockSize = 512;
  os.outSize = 256;
  os.hmacStrength = 192;
  os.padLength = 64;
  os.prototype._update = function(e, n) {
    for (var r = this.W, i = 0; i < 16; i++) r[i] = e[n + i];
    for (; i < r.length; i++) r[i] = OQ(UQ(r[i - 2]), r[i - 7], DQ(r[i - 15]), r[i - 16]);
    var s = this.h[0], o = this.h[1], a = this.h[2], c = this.h[3], l = this.h[4], u = this.h[5], f = this.h[6], d = this.h[7];
    for (NQ(this.k.length === r.length), i = 0; i < r.length; i++) {
      var m = BQ(d, LQ(l), MQ(l, u, f), this.k[i], r[i]), y = ri(FQ(s), kQ(s, o, a));
      d = f, f = u, u = l, l = ri(c, m), c = a, a = o, o = s, s = ri(m, y);
    }
    this.h[0] = ri(this.h[0], s), this.h[1] = ri(this.h[1], o), this.h[2] = ri(this.h[2], a), this.h[3] = ri(this.h[3], c), this.h[4] = ri(this.h[4], l), this.h[5] = ri(this.h[5], u), this.h[6] = ri(this.h[6], f), this.h[7] = ri(this.h[7], d);
  };
  os.prototype._digest = function(e) {
    return e === "hex" ? dl.toHex32(this.h, "big") : dl.split32(this.h, "big");
  };
  var n1 = et, c7 = a7;
  function Us() {
    if (!(this instanceof Us)) return new Us();
    c7.call(this), this.h = [
      3238371032,
      914150663,
      812702999,
      4144912697,
      4290775857,
      1750603025,
      1694076839,
      3204075428
    ];
  }
  n1.inherits(Us, c7);
  var GQ = Us;
  Us.blockSize = 512;
  Us.outSize = 224;
  Us.hmacStrength = 192;
  Us.padLength = 64;
  Us.prototype._digest = function(e) {
    return e === "hex" ? n1.toHex32(this.h.slice(0, 7), "big") : n1.split32(this.h.slice(0, 7), "big");
  };
  var wr = et, VQ = Pl, zQ = Cf, Xi = wr.rotr64_hi, Zi = wr.rotr64_lo, l7 = wr.shr64_hi, u7 = wr.shr64_lo, ao = wr.sum64, Eg = wr.sum64_hi, Sg = wr.sum64_lo, QQ = wr.sum64_4_hi, jQ = wr.sum64_4_lo, JQ = wr.sum64_5_hi, KQ = wr.sum64_5_lo, f7 = VQ.BlockHash, WQ = [
    1116352408,
    3609767458,
    1899447441,
    602891725,
    3049323471,
    3964484399,
    3921009573,
    2173295548,
    961987163,
    4081628472,
    1508970993,
    3053834265,
    2453635748,
    2937671579,
    2870763221,
    3664609560,
    3624381080,
    2734883394,
    310598401,
    1164996542,
    607225278,
    1323610764,
    1426881987,
    3590304994,
    1925078388,
    4068182383,
    2162078206,
    991336113,
    2614888103,
    633803317,
    3248222580,
    3479774868,
    3835390401,
    2666613458,
    4022224774,
    944711139,
    264347078,
    2341262773,
    604807628,
    2007800933,
    770255983,
    1495990901,
    1249150122,
    1856431235,
    1555081692,
    3175218132,
    1996064986,
    2198950837,
    2554220882,
    3999719339,
    2821834349,
    766784016,
    2952996808,
    2566594879,
    3210313671,
    3203337956,
    3336571891,
    1034457026,
    3584528711,
    2466948901,
    113926993,
    3758326383,
    338241895,
    168717936,
    666307205,
    1188179964,
    773529912,
    1546045734,
    1294757372,
    1522805485,
    1396182291,
    2643833823,
    1695183700,
    2343527390,
    1986661051,
    1014477480,
    2177026350,
    1206759142,
    2456956037,
    344077627,
    2730485921,
    1290863460,
    2820302411,
    3158454273,
    3259730800,
    3505952657,
    3345764771,
    106217008,
    3516065817,
    3606008344,
    3600352804,
    1432725776,
    4094571909,
    1467031594,
    275423344,
    851169720,
    430227734,
    3100823752,
    506948616,
    1363258195,
    659060556,
    3750685593,
    883997877,
    3785050280,
    958139571,
    3318307427,
    1322822218,
    3812723403,
    1537002063,
    2003034995,
    1747873779,
    3602036899,
    1955562222,
    1575990012,
    2024104815,
    1125592928,
    2227730452,
    2716904306,
    2361852424,
    442776044,
    2428436474,
    593698344,
    2756734187,
    3733110249,
    3204031479,
    2999351573,
    3329325298,
    3815920427,
    3391569614,
    3928383900,
    3515267271,
    566280711,
    3940187606,
    3454069534,
    4118630271,
    4000239992,
    116418474,
    1914138554,
    174292421,
    2731055270,
    289380356,
    3203993006,
    460393269,
    320620315,
    685471733,
    587496836,
    852142971,
    1086792851,
    1017036298,
    365543100,
    1126000580,
    2618297676,
    1288033470,
    3409855158,
    1501505948,
    4234509866,
    1607167915,
    987167468,
    1816402316,
    1246189591
  ];
  function Ei() {
    if (!(this instanceof Ei)) return new Ei();
    f7.call(this), this.h = [
      1779033703,
      4089235720,
      3144134277,
      2227873595,
      1013904242,
      4271175723,
      2773480762,
      1595750129,
      1359893119,
      2917565137,
      2600822924,
      725511199,
      528734635,
      4215389547,
      1541459225,
      327033209
    ], this.k = WQ, this.W = new Array(160);
  }
  wr.inherits(Ei, f7);
  var d7 = Ei;
  Ei.blockSize = 1024;
  Ei.outSize = 512;
  Ei.hmacStrength = 192;
  Ei.padLength = 128;
  Ei.prototype._prepareBlock = function(e, n) {
    for (var r = this.W, i = 0; i < 32; i++) r[i] = e[n + i];
    for (; i < r.length; i += 2) {
      var s = sj(r[i - 4], r[i - 3]), o = oj(r[i - 4], r[i - 3]), a = r[i - 14], c = r[i - 13], l = rj(r[i - 30], r[i - 29]), u = ij(r[i - 30], r[i - 29]), f = r[i - 32], d = r[i - 31];
      r[i] = QQ(s, o, a, c, l, u, f, d), r[i + 1] = jQ(s, o, a, c, l, u, f, d);
    }
  };
  Ei.prototype._update = function(e, n) {
    this._prepareBlock(e, n);
    var r = this.W, i = this.h[0], s = this.h[1], o = this.h[2], a = this.h[3], c = this.h[4], l = this.h[5], u = this.h[6], f = this.h[7], d = this.h[8], m = this.h[9], y = this.h[10], x = this.h[11], w = this.h[12], R = this.h[13], O = this.h[14], B = this.h[15];
    zQ(this.k.length === r.length);
    for (var M = 0; M < r.length; M += 2) {
      var D = O, H = B, q = tj(d, m), S = nj(d, m), P = qQ(d, m, y, x, w), L = YQ(d, m, y, x, w, R), K = this.k[M], z = this.k[M + 1], I = r[M], h = r[M + 1], p = JQ(D, H, q, S, P, L, K, z, I, h), A = KQ(D, H, q, S, P, L, K, z, I, h);
      D = $Q(i, s), H = ej(i, s), q = XQ(i, s, o, a, c), S = ZQ(i, s, o, a, c, l);
      var C = Eg(D, H, q, S), N = Sg(D, H, q, S);
      O = w, B = R, w = y, R = x, y = d, x = m, d = Eg(u, f, p, A), m = Sg(f, f, p, A), u = c, f = l, c = o, l = a, o = i, a = s, i = Eg(p, A, C, N), s = Sg(p, A, C, N);
    }
    ao(this.h, 0, i, s), ao(this.h, 2, o, a), ao(this.h, 4, c, l), ao(this.h, 6, u, f), ao(this.h, 8, d, m), ao(this.h, 10, y, x), ao(this.h, 12, w, R), ao(this.h, 14, O, B);
  };
  Ei.prototype._digest = function(e) {
    return e === "hex" ? wr.toHex32(this.h, "big") : wr.split32(this.h, "big");
  };
  function qQ(t, e, n, r, i) {
    var s = t & n ^ ~t & i;
    return s < 0 && (s += 4294967296), s;
  }
  function YQ(t, e, n, r, i, s) {
    var o = e & r ^ ~e & s;
    return o < 0 && (o += 4294967296), o;
  }
  function XQ(t, e, n, r, i) {
    var s = t & n ^ t & i ^ n & i;
    return s < 0 && (s += 4294967296), s;
  }
  function ZQ(t, e, n, r, i, s) {
    var o = e & r ^ e & s ^ r & s;
    return o < 0 && (o += 4294967296), o;
  }
  function $Q(t, e) {
    var n = Xi(t, e, 28), r = Xi(e, t, 2), i = Xi(e, t, 7), s = n ^ r ^ i;
    return s < 0 && (s += 4294967296), s;
  }
  function ej(t, e) {
    var n = Zi(t, e, 28), r = Zi(e, t, 2), i = Zi(e, t, 7), s = n ^ r ^ i;
    return s < 0 && (s += 4294967296), s;
  }
  function tj(t, e) {
    var n = Xi(t, e, 14), r = Xi(t, e, 18), i = Xi(e, t, 9), s = n ^ r ^ i;
    return s < 0 && (s += 4294967296), s;
  }
  function nj(t, e) {
    var n = Zi(t, e, 14), r = Zi(t, e, 18), i = Zi(e, t, 9), s = n ^ r ^ i;
    return s < 0 && (s += 4294967296), s;
  }
  function rj(t, e) {
    var n = Xi(t, e, 1), r = Xi(t, e, 8), i = l7(t, e, 7), s = n ^ r ^ i;
    return s < 0 && (s += 4294967296), s;
  }
  function ij(t, e) {
    var n = Zi(t, e, 1), r = Zi(t, e, 8), i = u7(t, e, 7), s = n ^ r ^ i;
    return s < 0 && (s += 4294967296), s;
  }
  function sj(t, e) {
    var n = Xi(t, e, 19), r = Xi(e, t, 29), i = l7(t, e, 6), s = n ^ r ^ i;
    return s < 0 && (s += 4294967296), s;
  }
  function oj(t, e) {
    var n = Zi(t, e, 19), r = Zi(e, t, 29), i = u7(t, e, 6), s = n ^ r ^ i;
    return s < 0 && (s += 4294967296), s;
  }
  var r1 = et, h7 = d7;
  function Hs() {
    if (!(this instanceof Hs)) return new Hs();
    h7.call(this), this.h = [
      3418070365,
      3238371032,
      1654270250,
      914150663,
      2438529370,
      812702999,
      355462360,
      4144912697,
      1731405415,
      4290775857,
      2394180231,
      1750603025,
      3675008525,
      1694076839,
      1203062813,
      3204075428
    ];
  }
  r1.inherits(Hs, h7);
  var aj = Hs;
  Hs.blockSize = 1024;
  Hs.outSize = 384;
  Hs.hmacStrength = 192;
  Hs.padLength = 128;
  Hs.prototype._digest = function(e) {
    return e === "hex" ? r1.toHex32(this.h.slice(0, 12), "big") : r1.split32(this.h.slice(0, 12), "big");
  };
  _l.sha1 = _Q;
  _l.sha224 = GQ;
  _l.sha256 = a7;
  _l.sha384 = aj;
  _l.sha512 = d7;
  var p7 = {}, Fa = et, cj = Pl, r0 = Fa.rotl32, Uw = Fa.sum32, Jl = Fa.sum32_3, Hw = Fa.sum32_4, g7 = cj.BlockHash;
  function as() {
    if (!(this instanceof as)) return new as();
    g7.call(this), this.h = [
      1732584193,
      4023233417,
      2562383102,
      271733878,
      3285377520
    ], this.endian = "little";
  }
  Fa.inherits(as, g7);
  p7.ripemd160 = as;
  as.blockSize = 512;
  as.outSize = 160;
  as.hmacStrength = 192;
  as.padLength = 64;
  as.prototype._update = function(e, n) {
    for (var r = this.h[0], i = this.h[1], s = this.h[2], o = this.h[3], a = this.h[4], c = r, l = i, u = s, f = o, d = a, m = 0; m < 80; m++) {
      var y = Uw(r0(Hw(r, Gw(m, i, s, o), e[fj[m] + n], lj(m)), hj[m]), a);
      r = a, a = o, o = r0(s, 10), s = i, i = y, y = Uw(r0(Hw(c, Gw(79 - m, l, u, f), e[dj[m] + n], uj(m)), pj[m]), d), c = d, d = f, f = r0(u, 10), u = l, l = y;
    }
    y = Jl(this.h[1], s, f), this.h[1] = Jl(this.h[2], o, d), this.h[2] = Jl(this.h[3], a, c), this.h[3] = Jl(this.h[4], r, l), this.h[4] = Jl(this.h[0], i, u), this.h[0] = y;
  };
  as.prototype._digest = function(e) {
    return e === "hex" ? Fa.toHex32(this.h, "little") : Fa.split32(this.h, "little");
  };
  function Gw(t, e, n, r) {
    return t <= 15 ? e ^ n ^ r : t <= 31 ? e & n | ~e & r : t <= 47 ? (e | ~n) ^ r : t <= 63 ? e & r | n & ~r : e ^ (n | ~r);
  }
  function lj(t) {
    return t <= 15 ? 0 : t <= 31 ? 1518500249 : t <= 47 ? 1859775393 : t <= 63 ? 2400959708 : 2840853838;
  }
  function uj(t) {
    return t <= 15 ? 1352829926 : t <= 31 ? 1548603684 : t <= 47 ? 1836072691 : t <= 63 ? 2053994217 : 0;
  }
  var fj = [
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    7,
    4,
    13,
    1,
    10,
    6,
    15,
    3,
    12,
    0,
    9,
    5,
    2,
    14,
    11,
    8,
    3,
    10,
    14,
    4,
    9,
    15,
    8,
    1,
    2,
    7,
    0,
    6,
    13,
    11,
    5,
    12,
    1,
    9,
    11,
    10,
    0,
    8,
    12,
    4,
    13,
    3,
    7,
    15,
    14,
    5,
    6,
    2,
    4,
    0,
    5,
    9,
    7,
    12,
    2,
    10,
    14,
    1,
    3,
    8,
    11,
    6,
    15,
    13
  ], dj = [
    5,
    14,
    7,
    0,
    9,
    2,
    11,
    4,
    13,
    6,
    15,
    8,
    1,
    10,
    3,
    12,
    6,
    11,
    3,
    7,
    0,
    13,
    5,
    10,
    14,
    15,
    8,
    12,
    4,
    9,
    1,
    2,
    15,
    5,
    1,
    3,
    7,
    14,
    6,
    9,
    11,
    8,
    12,
    2,
    10,
    0,
    4,
    13,
    8,
    6,
    4,
    1,
    3,
    11,
    15,
    0,
    5,
    12,
    2,
    13,
    9,
    7,
    10,
    14,
    12,
    15,
    10,
    4,
    1,
    5,
    8,
    7,
    6,
    2,
    13,
    14,
    0,
    3,
    9,
    11
  ], hj = [
    11,
    14,
    15,
    12,
    5,
    8,
    7,
    9,
    11,
    13,
    14,
    15,
    6,
    7,
    9,
    8,
    7,
    6,
    8,
    13,
    11,
    9,
    7,
    15,
    7,
    12,
    15,
    9,
    11,
    7,
    13,
    12,
    11,
    13,
    6,
    7,
    14,
    9,
    13,
    15,
    14,
    8,
    13,
    6,
    5,
    12,
    7,
    5,
    11,
    12,
    14,
    15,
    14,
    15,
    9,
    8,
    9,
    14,
    5,
    6,
    8,
    6,
    5,
    12,
    9,
    15,
    5,
    11,
    6,
    8,
    13,
    12,
    5,
    12,
    13,
    14,
    11,
    8,
    5,
    6
  ], pj = [
    8,
    9,
    9,
    11,
    13,
    15,
    15,
    5,
    7,
    7,
    8,
    11,
    14,
    14,
    12,
    6,
    9,
    13,
    15,
    7,
    12,
    8,
    9,
    11,
    7,
    7,
    12,
    7,
    6,
    15,
    13,
    11,
    9,
    7,
    15,
    11,
    8,
    6,
    6,
    14,
    12,
    13,
    5,
    14,
    13,
    13,
    7,
    5,
    15,
    5,
    8,
    11,
    14,
    14,
    6,
    14,
    6,
    9,
    12,
    9,
    12,
    5,
    15,
    8,
    8,
    5,
    12,
    9,
    12,
    5,
    14,
    6,
    8,
    13,
    6,
    5,
    15,
    13,
    11,
    11
  ], gj = et, mj = Cf;
  function hl(t, e, n) {
    if (!(this instanceof hl)) return new hl(t, e, n);
    this.Hash = t, this.blockSize = t.blockSize / 8, this.outSize = t.outSize / 8, this.inner = null, this.outer = null, this._init(gj.toArray(e, n));
  }
  var yj = hl;
  hl.prototype._init = function(e) {
    e.length > this.blockSize && (e = new this.Hash().update(e).digest()), mj(e.length <= this.blockSize);
    for (var n = e.length; n < this.blockSize; n++) e.push(0);
    for (n = 0; n < e.length; n++) e[n] ^= 54;
    for (this.inner = new this.Hash().update(e), n = 0; n < e.length; n++) e[n] ^= 106;
    this.outer = new this.Hash().update(e);
  };
  hl.prototype.update = function(e, n) {
    return this.inner.update(e, n), this;
  };
  hl.prototype.digest = function(e) {
    return this.outer.update(this.inner.digest()), this.outer.digest(e);
  };
  (function(t) {
    var e = t;
    e.utils = et, e.common = Pl, e.sha = _l, e.ripemd = p7, e.hmac = yj, e.sha1 = e.sha.sha1, e.sha256 = e.sha.sha256, e.sha224 = e.sha.sha224, e.sha384 = e.sha.sha384, e.sha512 = e.sha.sha512, e.ripemd160 = e.ripemd.ripemd160;
  })(X8);
  const hr = Js(X8);
  function Nl(t, e, n) {
    return n = {
      path: e,
      exports: {},
      require: function(r, i) {
        return bj(r, i ?? n.path);
      }
    }, t(n, n.exports), n.exports;
  }
  function bj() {
    throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs");
  }
  var zy = m7;
  function m7(t, e) {
    if (!t) throw new Error(e || "Assertion failed");
  }
  m7.equal = function(e, n, r) {
    if (e != n) throw new Error(r || "Assertion failed: " + e + " != " + n);
  };
  var xi = Nl(function(t, e) {
    var n = e;
    function r(o, a) {
      if (Array.isArray(o)) return o.slice();
      if (!o) return [];
      var c = [];
      if (typeof o != "string") {
        for (var l = 0; l < o.length; l++) c[l] = o[l] | 0;
        return c;
      }
      if (a === "hex") {
        o = o.replace(/[^a-z0-9]+/ig, ""), o.length % 2 !== 0 && (o = "0" + o);
        for (var l = 0; l < o.length; l += 2) c.push(parseInt(o[l] + o[l + 1], 16));
      } else for (var l = 0; l < o.length; l++) {
        var u = o.charCodeAt(l), f = u >> 8, d = u & 255;
        f ? c.push(f, d) : c.push(d);
      }
      return c;
    }
    n.toArray = r;
    function i(o) {
      return o.length === 1 ? "0" + o : o;
    }
    n.zero2 = i;
    function s(o) {
      for (var a = "", c = 0; c < o.length; c++) a += i(o[c].toString(16));
      return a;
    }
    n.toHex = s, n.encode = function(a, c) {
      return c === "hex" ? s(a) : a;
    };
  }), Rr = Nl(function(t, e) {
    var n = e;
    n.assert = zy, n.toArray = xi.toArray, n.zero2 = xi.zero2, n.toHex = xi.toHex, n.encode = xi.encode;
    function r(c, l, u) {
      var f = new Array(Math.max(c.bitLength(), u) + 1), d;
      for (d = 0; d < f.length; d += 1) f[d] = 0;
      var m = 1 << l + 1, y = c.clone();
      for (d = 0; d < f.length; d++) {
        var x, w = y.andln(m - 1);
        y.isOdd() ? (w > (m >> 1) - 1 ? x = (m >> 1) - w : x = w, y.isubn(x)) : x = 0, f[d] = x, y.iushrn(1);
      }
      return f;
    }
    n.getNAF = r;
    function i(c, l) {
      var u = [
        [],
        []
      ];
      c = c.clone(), l = l.clone();
      for (var f = 0, d = 0, m; c.cmpn(-f) > 0 || l.cmpn(-d) > 0; ) {
        var y = c.andln(3) + f & 3, x = l.andln(3) + d & 3;
        y === 3 && (y = -1), x === 3 && (x = -1);
        var w;
        y & 1 ? (m = c.andln(7) + f & 7, (m === 3 || m === 5) && x === 2 ? w = -y : w = y) : w = 0, u[0].push(w);
        var R;
        x & 1 ? (m = l.andln(7) + d & 7, (m === 3 || m === 5) && y === 2 ? R = -x : R = x) : R = 0, u[1].push(R), 2 * f === w + 1 && (f = 1 - f), 2 * d === R + 1 && (d = 1 - d), c.iushrn(1), l.iushrn(1);
      }
      return u;
    }
    n.getJSF = i;
    function s(c, l, u) {
      var f = "_" + l;
      c.prototype[l] = function() {
        return this[f] !== void 0 ? this[f] : this[f] = u.call(this);
      };
    }
    n.cachedProperty = s;
    function o(c) {
      return typeof c == "string" ? n.toArray(c, "hex") : c;
    }
    n.parseBytes = o;
    function a(c) {
      return new De(c, "hex", "le");
    }
    n.intFromLE = a;
  }), yd = Rr.getNAF, xj = Rr.getJSF, bd = Rr.assert;
  function Go(t, e) {
    this.type = t, this.p = new De(e.p, 16), this.red = e.prime ? De.red(e.prime) : De.mont(this.p), this.zero = new De(0).toRed(this.red), this.one = new De(1).toRed(this.red), this.two = new De(2).toRed(this.red), this.n = e.n && new De(e.n, 16), this.g = e.g && this.pointFromJSON(e.g, e.gRed), this._wnafT1 = new Array(4), this._wnafT2 = new Array(4), this._wnafT3 = new Array(4), this._wnafT4 = new Array(4), this._bitLength = this.n ? this.n.bitLength() : 0;
    var n = this.n && this.p.div(this.n);
    !n || n.cmpn(100) > 0 ? this.redN = null : (this._maxwellTrick = true, this.redN = this.n.toRed(this.red));
  }
  var ja = Go;
  Go.prototype.point = function() {
    throw new Error("Not implemented");
  };
  Go.prototype.validate = function() {
    throw new Error("Not implemented");
  };
  Go.prototype._fixedNafMul = function(e, n) {
    bd(e.precomputed);
    var r = e._getDoubles(), i = yd(n, 1, this._bitLength), s = (1 << r.step + 1) - (r.step % 2 === 0 ? 2 : 1);
    s /= 3;
    var o = [], a, c;
    for (a = 0; a < i.length; a += r.step) {
      c = 0;
      for (var l = a + r.step - 1; l >= a; l--) c = (c << 1) + i[l];
      o.push(c);
    }
    for (var u = this.jpoint(null, null, null), f = this.jpoint(null, null, null), d = s; d > 0; d--) {
      for (a = 0; a < o.length; a++) c = o[a], c === d ? f = f.mixedAdd(r.points[a]) : c === -d && (f = f.mixedAdd(r.points[a].neg()));
      u = u.add(f);
    }
    return u.toP();
  };
  Go.prototype._wnafMul = function(e, n) {
    var r = 4, i = e._getNAFPoints(r);
    r = i.wnd;
    for (var s = i.points, o = yd(n, r, this._bitLength), a = this.jpoint(null, null, null), c = o.length - 1; c >= 0; c--) {
      for (var l = 0; c >= 0 && o[c] === 0; c--) l++;
      if (c >= 0 && l++, a = a.dblp(l), c < 0) break;
      var u = o[c];
      bd(u !== 0), e.type === "affine" ? u > 0 ? a = a.mixedAdd(s[u - 1 >> 1]) : a = a.mixedAdd(s[-u - 1 >> 1].neg()) : u > 0 ? a = a.add(s[u - 1 >> 1]) : a = a.add(s[-u - 1 >> 1].neg());
    }
    return e.type === "affine" ? a.toP() : a;
  };
  Go.prototype._wnafMulAdd = function(e, n, r, i, s) {
    var o = this._wnafT1, a = this._wnafT2, c = this._wnafT3, l = 0, u, f, d;
    for (u = 0; u < i; u++) {
      d = n[u];
      var m = d._getNAFPoints(e);
      o[u] = m.wnd, a[u] = m.points;
    }
    for (u = i - 1; u >= 1; u -= 2) {
      var y = u - 1, x = u;
      if (o[y] !== 1 || o[x] !== 1) {
        c[y] = yd(r[y], o[y], this._bitLength), c[x] = yd(r[x], o[x], this._bitLength), l = Math.max(c[y].length, l), l = Math.max(c[x].length, l);
        continue;
      }
      var w = [
        n[y],
        null,
        null,
        n[x]
      ];
      n[y].y.cmp(n[x].y) === 0 ? (w[1] = n[y].add(n[x]), w[2] = n[y].toJ().mixedAdd(n[x].neg())) : n[y].y.cmp(n[x].y.redNeg()) === 0 ? (w[1] = n[y].toJ().mixedAdd(n[x]), w[2] = n[y].add(n[x].neg())) : (w[1] = n[y].toJ().mixedAdd(n[x]), w[2] = n[y].toJ().mixedAdd(n[x].neg()));
      var R = [
        -3,
        -1,
        -5,
        -7,
        0,
        7,
        5,
        1,
        3
      ], O = xj(r[y], r[x]);
      for (l = Math.max(O[0].length, l), c[y] = new Array(l), c[x] = new Array(l), f = 0; f < l; f++) {
        var B = O[0][f] | 0, M = O[1][f] | 0;
        c[y][f] = R[(B + 1) * 3 + (M + 1)], c[x][f] = 0, a[y] = w;
      }
    }
    var D = this.jpoint(null, null, null), H = this._wnafT4;
    for (u = l; u >= 0; u--) {
      for (var q = 0; u >= 0; ) {
        var S = true;
        for (f = 0; f < i; f++) H[f] = c[f][u] | 0, H[f] !== 0 && (S = false);
        if (!S) break;
        q++, u--;
      }
      if (u >= 0 && q++, D = D.dblp(q), u < 0) break;
      for (f = 0; f < i; f++) {
        var P = H[f];
        P !== 0 && (P > 0 ? d = a[f][P - 1 >> 1] : P < 0 && (d = a[f][-P - 1 >> 1].neg()), d.type === "affine" ? D = D.mixedAdd(d) : D = D.add(d));
      }
    }
    for (u = 0; u < i; u++) a[u] = null;
    return s ? D : D.toP();
  };
  function Zr(t, e) {
    this.curve = t, this.type = e, this.precomputed = null;
  }
  Go.BasePoint = Zr;
  Zr.prototype.eq = function() {
    throw new Error("Not implemented");
  };
  Zr.prototype.validate = function() {
    return this.curve.validate(this);
  };
  Go.prototype.decodePoint = function(e, n) {
    e = Rr.toArray(e, n);
    var r = this.p.byteLength();
    if ((e[0] === 4 || e[0] === 6 || e[0] === 7) && e.length - 1 === 2 * r) {
      e[0] === 6 ? bd(e[e.length - 1] % 2 === 0) : e[0] === 7 && bd(e[e.length - 1] % 2 === 1);
      var i = this.point(e.slice(1, 1 + r), e.slice(1 + r, 1 + 2 * r));
      return i;
    } else if ((e[0] === 2 || e[0] === 3) && e.length - 1 === r) return this.pointFromX(e.slice(1, 1 + r), e[0] === 3);
    throw new Error("Unknown point format");
  };
  Zr.prototype.encodeCompressed = function(e) {
    return this.encode(e, true);
  };
  Zr.prototype._encode = function(e) {
    var n = this.curve.p.byteLength(), r = this.getX().toArray("be", n);
    return e ? [
      this.getY().isEven() ? 2 : 3
    ].concat(r) : [
      4
    ].concat(r, this.getY().toArray("be", n));
  };
  Zr.prototype.encode = function(e, n) {
    return Rr.encode(this._encode(n), e);
  };
  Zr.prototype.precompute = function(e) {
    if (this.precomputed) return this;
    var n = {
      doubles: null,
      naf: null,
      beta: null
    };
    return n.naf = this._getNAFPoints(8), n.doubles = this._getDoubles(4, e), n.beta = this._getBeta(), this.precomputed = n, this;
  };
  Zr.prototype._hasDoubles = function(e) {
    if (!this.precomputed) return false;
    var n = this.precomputed.doubles;
    return n ? n.points.length >= Math.ceil((e.bitLength() + 1) / n.step) : false;
  };
  Zr.prototype._getDoubles = function(e, n) {
    if (this.precomputed && this.precomputed.doubles) return this.precomputed.doubles;
    for (var r = [
      this
    ], i = this, s = 0; s < n; s += e) {
      for (var o = 0; o < e; o++) i = i.dbl();
      r.push(i);
    }
    return {
      step: e,
      points: r
    };
  };
  Zr.prototype._getNAFPoints = function(e) {
    if (this.precomputed && this.precomputed.naf) return this.precomputed.naf;
    for (var n = [
      this
    ], r = (1 << e) - 1, i = r === 1 ? null : this.dbl(), s = 1; s < r; s++) n[s] = n[s - 1].add(i);
    return {
      wnd: e,
      points: n
    };
  };
  Zr.prototype._getBeta = function() {
    return null;
  };
  Zr.prototype.dblp = function(e) {
    for (var n = this, r = 0; r < e; r++) n = n.dbl();
    return n;
  };
  var Qy = Nl(function(t) {
    typeof Object.create == "function" ? t.exports = function(n, r) {
      r && (n.super_ = r, n.prototype = Object.create(r.prototype, {
        constructor: {
          value: n,
          enumerable: false,
          writable: true,
          configurable: true
        }
      }));
    } : t.exports = function(n, r) {
      if (r) {
        n.super_ = r;
        var i = function() {
        };
        i.prototype = r.prototype, n.prototype = new i(), n.prototype.constructor = n;
      }
    };
  }), Aj = Rr.assert;
  function $r(t) {
    ja.call(this, "short", t), this.a = new De(t.a, 16).toRed(this.red), this.b = new De(t.b, 16).toRed(this.red), this.tinv = this.two.redInvm(), this.zeroA = this.a.fromRed().cmpn(0) === 0, this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0, this.endo = this._getEndomorphism(t), this._endoWnafT1 = new Array(4), this._endoWnafT2 = new Array(4);
  }
  Qy($r, ja);
  var wj = $r;
  $r.prototype._getEndomorphism = function(e) {
    if (!(!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)) {
      var n, r;
      if (e.beta) n = new De(e.beta, 16).toRed(this.red);
      else {
        var i = this._getEndoRoots(this.p);
        n = i[0].cmp(i[1]) < 0 ? i[0] : i[1], n = n.toRed(this.red);
      }
      if (e.lambda) r = new De(e.lambda, 16);
      else {
        var s = this._getEndoRoots(this.n);
        this.g.mul(s[0]).x.cmp(this.g.x.redMul(n)) === 0 ? r = s[0] : (r = s[1], Aj(this.g.mul(r).x.cmp(this.g.x.redMul(n)) === 0));
      }
      var o;
      return e.basis ? o = e.basis.map(function(a) {
        return {
          a: new De(a.a, 16),
          b: new De(a.b, 16)
        };
      }) : o = this._getEndoBasis(r), {
        beta: n,
        lambda: r,
        basis: o
      };
    }
  };
  $r.prototype._getEndoRoots = function(e) {
    var n = e === this.p ? this.red : De.mont(e), r = new De(2).toRed(n).redInvm(), i = r.redNeg(), s = new De(3).toRed(n).redNeg().redSqrt().redMul(r), o = i.redAdd(s).fromRed(), a = i.redSub(s).fromRed();
    return [
      o,
      a
    ];
  };
  $r.prototype._getEndoBasis = function(e) {
    for (var n = this.n.ushrn(Math.floor(this.n.bitLength() / 2)), r = e, i = this.n.clone(), s = new De(1), o = new De(0), a = new De(0), c = new De(1), l, u, f, d, m, y, x, w = 0, R, O; r.cmpn(0) !== 0; ) {
      var B = i.div(r);
      R = i.sub(B.mul(r)), O = a.sub(B.mul(s));
      var M = c.sub(B.mul(o));
      if (!f && R.cmp(n) < 0) l = x.neg(), u = s, f = R.neg(), d = O;
      else if (f && ++w === 2) break;
      x = R, i = r, r = R, a = s, s = O, c = o, o = M;
    }
    m = R.neg(), y = O;
    var D = f.sqr().add(d.sqr()), H = m.sqr().add(y.sqr());
    return H.cmp(D) >= 0 && (m = l, y = u), f.negative && (f = f.neg(), d = d.neg()), m.negative && (m = m.neg(), y = y.neg()), [
      {
        a: f,
        b: d
      },
      {
        a: m,
        b: y
      }
    ];
  };
  $r.prototype._endoSplit = function(e) {
    var n = this.endo.basis, r = n[0], i = n[1], s = i.b.mul(e).divRound(this.n), o = r.b.neg().mul(e).divRound(this.n), a = s.mul(r.a), c = o.mul(i.a), l = s.mul(r.b), u = o.mul(i.b), f = e.sub(a).sub(c), d = l.add(u).neg();
    return {
      k1: f,
      k2: d
    };
  };
  $r.prototype.pointFromX = function(e, n) {
    e = new De(e, 16), e.red || (e = e.toRed(this.red));
    var r = e.redSqr().redMul(e).redIAdd(e.redMul(this.a)).redIAdd(this.b), i = r.redSqrt();
    if (i.redSqr().redSub(r).cmp(this.zero) !== 0) throw new Error("invalid point");
    var s = i.fromRed().isOdd();
    return (n && !s || !n && s) && (i = i.redNeg()), this.point(e, i);
  };
  $r.prototype.validate = function(e) {
    if (e.inf) return true;
    var n = e.x, r = e.y, i = this.a.redMul(n), s = n.redSqr().redMul(n).redIAdd(i).redIAdd(this.b);
    return r.redSqr().redISub(s).cmpn(0) === 0;
  };
  $r.prototype._endoWnafMulAdd = function(e, n, r) {
    for (var i = this._endoWnafT1, s = this._endoWnafT2, o = 0; o < e.length; o++) {
      var a = this._endoSplit(n[o]), c = e[o], l = c._getBeta();
      a.k1.negative && (a.k1.ineg(), c = c.neg(true)), a.k2.negative && (a.k2.ineg(), l = l.neg(true)), i[o * 2] = c, i[o * 2 + 1] = l, s[o * 2] = a.k1, s[o * 2 + 1] = a.k2;
    }
    for (var u = this._wnafMulAdd(1, i, s, o * 2, r), f = 0; f < o * 2; f++) i[f] = null, s[f] = null;
    return u;
  };
  function On(t, e, n, r) {
    ja.BasePoint.call(this, t, "affine"), e === null && n === null ? (this.x = null, this.y = null, this.inf = true) : (this.x = new De(e, 16), this.y = new De(n, 16), r && (this.x.forceRed(this.curve.red), this.y.forceRed(this.curve.red)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.inf = false);
  }
  Qy(On, ja.BasePoint);
  $r.prototype.point = function(e, n, r) {
    return new On(this, e, n, r);
  };
  $r.prototype.pointFromJSON = function(e, n) {
    return On.fromJSON(this, e, n);
  };
  On.prototype._getBeta = function() {
    if (this.curve.endo) {
      var e = this.precomputed;
      if (e && e.beta) return e.beta;
      var n = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
      if (e) {
        var r = this.curve, i = function(s) {
          return r.point(s.x.redMul(r.endo.beta), s.y);
        };
        e.beta = n, n.precomputed = {
          beta: null,
          naf: e.naf && {
            wnd: e.naf.wnd,
            points: e.naf.points.map(i)
          },
          doubles: e.doubles && {
            step: e.doubles.step,
            points: e.doubles.points.map(i)
          }
        };
      }
      return n;
    }
  };
  On.prototype.toJSON = function() {
    return this.precomputed ? [
      this.x,
      this.y,
      this.precomputed && {
        doubles: this.precomputed.doubles && {
          step: this.precomputed.doubles.step,
          points: this.precomputed.doubles.points.slice(1)
        },
        naf: this.precomputed.naf && {
          wnd: this.precomputed.naf.wnd,
          points: this.precomputed.naf.points.slice(1)
        }
      }
    ] : [
      this.x,
      this.y
    ];
  };
  On.fromJSON = function(e, n, r) {
    typeof n == "string" && (n = JSON.parse(n));
    var i = e.point(n[0], n[1], r);
    if (!n[2]) return i;
    function s(a) {
      return e.point(a[0], a[1], r);
    }
    var o = n[2];
    return i.precomputed = {
      beta: null,
      doubles: o.doubles && {
        step: o.doubles.step,
        points: [
          i
        ].concat(o.doubles.points.map(s))
      },
      naf: o.naf && {
        wnd: o.naf.wnd,
        points: [
          i
        ].concat(o.naf.points.map(s))
      }
    }, i;
  };
  On.prototype.inspect = function() {
    return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
  };
  On.prototype.isInfinity = function() {
    return this.inf;
  };
  On.prototype.add = function(e) {
    if (this.inf) return e;
    if (e.inf) return this;
    if (this.eq(e)) return this.dbl();
    if (this.neg().eq(e)) return this.curve.point(null, null);
    if (this.x.cmp(e.x) === 0) return this.curve.point(null, null);
    var n = this.y.redSub(e.y);
    n.cmpn(0) !== 0 && (n = n.redMul(this.x.redSub(e.x).redInvm()));
    var r = n.redSqr().redISub(this.x).redISub(e.x), i = n.redMul(this.x.redSub(r)).redISub(this.y);
    return this.curve.point(r, i);
  };
  On.prototype.dbl = function() {
    if (this.inf) return this;
    var e = this.y.redAdd(this.y);
    if (e.cmpn(0) === 0) return this.curve.point(null, null);
    var n = this.curve.a, r = this.x.redSqr(), i = e.redInvm(), s = r.redAdd(r).redIAdd(r).redIAdd(n).redMul(i), o = s.redSqr().redISub(this.x.redAdd(this.x)), a = s.redMul(this.x.redSub(o)).redISub(this.y);
    return this.curve.point(o, a);
  };
  On.prototype.getX = function() {
    return this.x.fromRed();
  };
  On.prototype.getY = function() {
    return this.y.fromRed();
  };
  On.prototype.mul = function(e) {
    return e = new De(e, 16), this.isInfinity() ? this : this._hasDoubles(e) ? this.curve._fixedNafMul(this, e) : this.curve.endo ? this.curve._endoWnafMulAdd([
      this
    ], [
      e
    ]) : this.curve._wnafMul(this, e);
  };
  On.prototype.mulAdd = function(e, n, r) {
    var i = [
      this,
      n
    ], s = [
      e,
      r
    ];
    return this.curve.endo ? this.curve._endoWnafMulAdd(i, s) : this.curve._wnafMulAdd(1, i, s, 2);
  };
  On.prototype.jmulAdd = function(e, n, r) {
    var i = [
      this,
      n
    ], s = [
      e,
      r
    ];
    return this.curve.endo ? this.curve._endoWnafMulAdd(i, s, true) : this.curve._wnafMulAdd(1, i, s, 2, true);
  };
  On.prototype.eq = function(e) {
    return this === e || this.inf === e.inf && (this.inf || this.x.cmp(e.x) === 0 && this.y.cmp(e.y) === 0);
  };
  On.prototype.neg = function(e) {
    if (this.inf) return this;
    var n = this.curve.point(this.x, this.y.redNeg());
    if (e && this.precomputed) {
      var r = this.precomputed, i = function(s) {
        return s.neg();
      };
      n.precomputed = {
        naf: r.naf && {
          wnd: r.naf.wnd,
          points: r.naf.points.map(i)
        },
        doubles: r.doubles && {
          step: r.doubles.step,
          points: r.doubles.points.map(i)
        }
      };
    }
    return n;
  };
  On.prototype.toJ = function() {
    if (this.inf) return this.curve.jpoint(null, null, null);
    var e = this.curve.jpoint(this.x, this.y, this.curve.one);
    return e;
  };
  function Vn(t, e, n, r) {
    ja.BasePoint.call(this, t, "jacobian"), e === null && n === null && r === null ? (this.x = this.curve.one, this.y = this.curve.one, this.z = new De(0)) : (this.x = new De(e, 16), this.y = new De(n, 16), this.z = new De(r, 16)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.zOne = this.z === this.curve.one;
  }
  Qy(Vn, ja.BasePoint);
  $r.prototype.jpoint = function(e, n, r) {
    return new Vn(this, e, n, r);
  };
  Vn.prototype.toP = function() {
    if (this.isInfinity()) return this.curve.point(null, null);
    var e = this.z.redInvm(), n = e.redSqr(), r = this.x.redMul(n), i = this.y.redMul(n).redMul(e);
    return this.curve.point(r, i);
  };
  Vn.prototype.neg = function() {
    return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
  };
  Vn.prototype.add = function(e) {
    if (this.isInfinity()) return e;
    if (e.isInfinity()) return this;
    var n = e.z.redSqr(), r = this.z.redSqr(), i = this.x.redMul(n), s = e.x.redMul(r), o = this.y.redMul(n.redMul(e.z)), a = e.y.redMul(r.redMul(this.z)), c = i.redSub(s), l = o.redSub(a);
    if (c.cmpn(0) === 0) return l.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
    var u = c.redSqr(), f = u.redMul(c), d = i.redMul(u), m = l.redSqr().redIAdd(f).redISub(d).redISub(d), y = l.redMul(d.redISub(m)).redISub(o.redMul(f)), x = this.z.redMul(e.z).redMul(c);
    return this.curve.jpoint(m, y, x);
  };
  Vn.prototype.mixedAdd = function(e) {
    if (this.isInfinity()) return e.toJ();
    if (e.isInfinity()) return this;
    var n = this.z.redSqr(), r = this.x, i = e.x.redMul(n), s = this.y, o = e.y.redMul(n).redMul(this.z), a = r.redSub(i), c = s.redSub(o);
    if (a.cmpn(0) === 0) return c.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
    var l = a.redSqr(), u = l.redMul(a), f = r.redMul(l), d = c.redSqr().redIAdd(u).redISub(f).redISub(f), m = c.redMul(f.redISub(d)).redISub(s.redMul(u)), y = this.z.redMul(a);
    return this.curve.jpoint(d, m, y);
  };
  Vn.prototype.dblp = function(e) {
    if (e === 0) return this;
    if (this.isInfinity()) return this;
    if (!e) return this.dbl();
    var n;
    if (this.curve.zeroA || this.curve.threeA) {
      var r = this;
      for (n = 0; n < e; n++) r = r.dbl();
      return r;
    }
    var i = this.curve.a, s = this.curve.tinv, o = this.x, a = this.y, c = this.z, l = c.redSqr().redSqr(), u = a.redAdd(a);
    for (n = 0; n < e; n++) {
      var f = o.redSqr(), d = u.redSqr(), m = d.redSqr(), y = f.redAdd(f).redIAdd(f).redIAdd(i.redMul(l)), x = o.redMul(d), w = y.redSqr().redISub(x.redAdd(x)), R = x.redISub(w), O = y.redMul(R);
      O = O.redIAdd(O).redISub(m);
      var B = u.redMul(c);
      n + 1 < e && (l = l.redMul(m)), o = w, c = B, u = O;
    }
    return this.curve.jpoint(o, u.redMul(s), c);
  };
  Vn.prototype.dbl = function() {
    return this.isInfinity() ? this : this.curve.zeroA ? this._zeroDbl() : this.curve.threeA ? this._threeDbl() : this._dbl();
  };
  Vn.prototype._zeroDbl = function() {
    var e, n, r;
    if (this.zOne) {
      var i = this.x.redSqr(), s = this.y.redSqr(), o = s.redSqr(), a = this.x.redAdd(s).redSqr().redISub(i).redISub(o);
      a = a.redIAdd(a);
      var c = i.redAdd(i).redIAdd(i), l = c.redSqr().redISub(a).redISub(a), u = o.redIAdd(o);
      u = u.redIAdd(u), u = u.redIAdd(u), e = l, n = c.redMul(a.redISub(l)).redISub(u), r = this.y.redAdd(this.y);
    } else {
      var f = this.x.redSqr(), d = this.y.redSqr(), m = d.redSqr(), y = this.x.redAdd(d).redSqr().redISub(f).redISub(m);
      y = y.redIAdd(y);
      var x = f.redAdd(f).redIAdd(f), w = x.redSqr(), R = m.redIAdd(m);
      R = R.redIAdd(R), R = R.redIAdd(R), e = w.redISub(y).redISub(y), n = x.redMul(y.redISub(e)).redISub(R), r = this.y.redMul(this.z), r = r.redIAdd(r);
    }
    return this.curve.jpoint(e, n, r);
  };
  Vn.prototype._threeDbl = function() {
    var e, n, r;
    if (this.zOne) {
      var i = this.x.redSqr(), s = this.y.redSqr(), o = s.redSqr(), a = this.x.redAdd(s).redSqr().redISub(i).redISub(o);
      a = a.redIAdd(a);
      var c = i.redAdd(i).redIAdd(i).redIAdd(this.curve.a), l = c.redSqr().redISub(a).redISub(a);
      e = l;
      var u = o.redIAdd(o);
      u = u.redIAdd(u), u = u.redIAdd(u), n = c.redMul(a.redISub(l)).redISub(u), r = this.y.redAdd(this.y);
    } else {
      var f = this.z.redSqr(), d = this.y.redSqr(), m = this.x.redMul(d), y = this.x.redSub(f).redMul(this.x.redAdd(f));
      y = y.redAdd(y).redIAdd(y);
      var x = m.redIAdd(m);
      x = x.redIAdd(x);
      var w = x.redAdd(x);
      e = y.redSqr().redISub(w), r = this.y.redAdd(this.z).redSqr().redISub(d).redISub(f);
      var R = d.redSqr();
      R = R.redIAdd(R), R = R.redIAdd(R), R = R.redIAdd(R), n = y.redMul(x.redISub(e)).redISub(R);
    }
    return this.curve.jpoint(e, n, r);
  };
  Vn.prototype._dbl = function() {
    var e = this.curve.a, n = this.x, r = this.y, i = this.z, s = i.redSqr().redSqr(), o = n.redSqr(), a = r.redSqr(), c = o.redAdd(o).redIAdd(o).redIAdd(e.redMul(s)), l = n.redAdd(n);
    l = l.redIAdd(l);
    var u = l.redMul(a), f = c.redSqr().redISub(u.redAdd(u)), d = u.redISub(f), m = a.redSqr();
    m = m.redIAdd(m), m = m.redIAdd(m), m = m.redIAdd(m);
    var y = c.redMul(d).redISub(m), x = r.redAdd(r).redMul(i);
    return this.curve.jpoint(f, y, x);
  };
  Vn.prototype.trpl = function() {
    if (!this.curve.zeroA) return this.dbl().add(this);
    var e = this.x.redSqr(), n = this.y.redSqr(), r = this.z.redSqr(), i = n.redSqr(), s = e.redAdd(e).redIAdd(e), o = s.redSqr(), a = this.x.redAdd(n).redSqr().redISub(e).redISub(i);
    a = a.redIAdd(a), a = a.redAdd(a).redIAdd(a), a = a.redISub(o);
    var c = a.redSqr(), l = i.redIAdd(i);
    l = l.redIAdd(l), l = l.redIAdd(l), l = l.redIAdd(l);
    var u = s.redIAdd(a).redSqr().redISub(o).redISub(c).redISub(l), f = n.redMul(u);
    f = f.redIAdd(f), f = f.redIAdd(f);
    var d = this.x.redMul(c).redISub(f);
    d = d.redIAdd(d), d = d.redIAdd(d);
    var m = this.y.redMul(u.redMul(l.redISub(u)).redISub(a.redMul(c)));
    m = m.redIAdd(m), m = m.redIAdd(m), m = m.redIAdd(m);
    var y = this.z.redAdd(a).redSqr().redISub(r).redISub(c);
    return this.curve.jpoint(d, m, y);
  };
  Vn.prototype.mul = function(e, n) {
    return e = new De(e, n), this.curve._wnafMul(this, e);
  };
  Vn.prototype.eq = function(e) {
    if (e.type === "affine") return this.eq(e.toJ());
    if (this === e) return true;
    var n = this.z.redSqr(), r = e.z.redSqr();
    if (this.x.redMul(r).redISub(e.x.redMul(n)).cmpn(0) !== 0) return false;
    var i = n.redMul(this.z), s = r.redMul(e.z);
    return this.y.redMul(s).redISub(e.y.redMul(i)).cmpn(0) === 0;
  };
  Vn.prototype.eqXToP = function(e) {
    var n = this.z.redSqr(), r = e.toRed(this.curve.red).redMul(n);
    if (this.x.cmp(r) === 0) return true;
    for (var i = e.clone(), s = this.curve.redN.redMul(n); ; ) {
      if (i.iadd(this.curve.n), i.cmp(this.curve.p) >= 0) return false;
      if (r.redIAdd(s), this.x.cmp(r) === 0) return true;
    }
  };
  Vn.prototype.inspect = function() {
    return this.isInfinity() ? "<EC JPoint Infinity>" : "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
  };
  Vn.prototype.isInfinity = function() {
    return this.z.cmpn(0) === 0;
  };
  var P0 = Nl(function(t, e) {
    var n = e;
    n.base = ja, n.short = wj, n.mont = null, n.edwards = null;
  }), _0 = Nl(function(t, e) {
    var n = e, r = Rr.assert;
    function i(a) {
      a.type === "short" ? this.curve = new P0.short(a) : a.type === "edwards" ? this.curve = new P0.edwards(a) : this.curve = new P0.mont(a), this.g = this.curve.g, this.n = this.curve.n, this.hash = a.hash, r(this.g.validate(), "Invalid curve"), r(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
    }
    n.PresetCurve = i;
    function s(a, c) {
      Object.defineProperty(n, a, {
        configurable: true,
        enumerable: true,
        get: function() {
          var l = new i(c);
          return Object.defineProperty(n, a, {
            configurable: true,
            enumerable: true,
            value: l
          }), l;
        }
      });
    }
    s("p192", {
      type: "short",
      prime: "p192",
      p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
      a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
      b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
      n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
      hash: hr.sha256,
      gRed: false,
      g: [
        "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012",
        "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"
      ]
    }), s("p224", {
      type: "short",
      prime: "p224",
      p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
      a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
      b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
      n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
      hash: hr.sha256,
      gRed: false,
      g: [
        "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
        "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"
      ]
    }), s("p256", {
      type: "short",
      prime: null,
      p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
      a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
      b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
      n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
      hash: hr.sha256,
      gRed: false,
      g: [
        "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
        "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"
      ]
    }), s("p384", {
      type: "short",
      prime: null,
      p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
      a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
      b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
      n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
      hash: hr.sha384,
      gRed: false,
      g: [
        "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
        "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
      ]
    }), s("p521", {
      type: "short",
      prime: null,
      p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
      a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
      b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
      n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
      hash: hr.sha512,
      gRed: false,
      g: [
        "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
        "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"
      ]
    }), s("curve25519", {
      type: "mont",
      prime: "p25519",
      p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
      a: "76d06",
      b: "1",
      n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
      hash: hr.sha256,
      gRed: false,
      g: [
        "9"
      ]
    }), s("ed25519", {
      type: "edwards",
      prime: "p25519",
      p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
      a: "-1",
      c: "1",
      d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
      n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
      hash: hr.sha256,
      gRed: false,
      g: [
        "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
        "6666666666666666666666666666666666666666666666666666666666666658"
      ]
    });
    var o;
    try {
      o = null.crash();
    } catch {
      o = void 0;
    }
    s("secp256k1", {
      type: "short",
      prime: "k256",
      p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
      a: "0",
      b: "7",
      n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
      h: "1",
      hash: hr.sha256,
      beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
      lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
      basis: [
        {
          a: "3086d221a7d46bcde86c90e49284eb15",
          b: "-e4437ed6010e88286f547fa90abfe4c3"
        },
        {
          a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
          b: "3086d221a7d46bcde86c90e49284eb15"
        }
      ],
      gRed: false,
      g: [
        "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
        "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
        o
      ]
    });
  });
  function Bo(t) {
    if (!(this instanceof Bo)) return new Bo(t);
    this.hash = t.hash, this.predResist = !!t.predResist, this.outLen = this.hash.outSize, this.minEntropy = t.minEntropy || this.hash.hmacStrength, this._reseed = null, this.reseedInterval = null, this.K = null, this.V = null;
    var e = xi.toArray(t.entropy, t.entropyEnc || "hex"), n = xi.toArray(t.nonce, t.nonceEnc || "hex"), r = xi.toArray(t.pers, t.persEnc || "hex");
    zy(e.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits"), this._init(e, n, r);
  }
  var y7 = Bo;
  Bo.prototype._init = function(e, n, r) {
    var i = e.concat(n).concat(r);
    this.K = new Array(this.outLen / 8), this.V = new Array(this.outLen / 8);
    for (var s = 0; s < this.V.length; s++) this.K[s] = 0, this.V[s] = 1;
    this._update(i), this._reseed = 1, this.reseedInterval = 281474976710656;
  };
  Bo.prototype._hmac = function() {
    return new hr.hmac(this.hash, this.K);
  };
  Bo.prototype._update = function(e) {
    var n = this._hmac().update(this.V).update([
      0
    ]);
    e && (n = n.update(e)), this.K = n.digest(), this.V = this._hmac().update(this.V).digest(), e && (this.K = this._hmac().update(this.V).update([
      1
    ]).update(e).digest(), this.V = this._hmac().update(this.V).digest());
  };
  Bo.prototype.reseed = function(e, n, r, i) {
    typeof n != "string" && (i = r, r = n, n = null), e = xi.toArray(e, n), r = xi.toArray(r, i), zy(e.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits"), this._update(e.concat(r || [])), this._reseed = 1;
  };
  Bo.prototype.generate = function(e, n, r, i) {
    if (this._reseed > this.reseedInterval) throw new Error("Reseed is required");
    typeof n != "string" && (i = r, r = n, n = null), r && (r = xi.toArray(r, i || "hex"), this._update(r));
    for (var s = []; s.length < e; ) this.V = this._hmac().update(this.V).digest(), s = s.concat(this.V);
    var o = s.slice(0, e);
    return this._update(r), this._reseed++, xi.encode(o, n);
  };
  var i1 = Rr.assert;
  function Yn(t, e) {
    this.ec = t, this.priv = null, this.pub = null, e.priv && this._importPrivate(e.priv, e.privEnc), e.pub && this._importPublic(e.pub, e.pubEnc);
  }
  var jy = Yn;
  Yn.fromPublic = function(e, n, r) {
    return n instanceof Yn ? n : new Yn(e, {
      pub: n,
      pubEnc: r
    });
  };
  Yn.fromPrivate = function(e, n, r) {
    return n instanceof Yn ? n : new Yn(e, {
      priv: n,
      privEnc: r
    });
  };
  Yn.prototype.validate = function() {
    var e = this.getPublic();
    return e.isInfinity() ? {
      result: false,
      reason: "Invalid public key"
    } : e.validate() ? e.mul(this.ec.curve.n).isInfinity() ? {
      result: true,
      reason: null
    } : {
      result: false,
      reason: "Public key * N != O"
    } : {
      result: false,
      reason: "Public key is not a point"
    };
  };
  Yn.prototype.getPublic = function(e, n) {
    return typeof e == "string" && (n = e, e = null), this.pub || (this.pub = this.ec.g.mul(this.priv)), n ? this.pub.encode(n, e) : this.pub;
  };
  Yn.prototype.getPrivate = function(e) {
    return e === "hex" ? this.priv.toString(16, 2) : this.priv;
  };
  Yn.prototype._importPrivate = function(e, n) {
    this.priv = new De(e, n || 16), this.priv = this.priv.umod(this.ec.curve.n);
  };
  Yn.prototype._importPublic = function(e, n) {
    if (e.x || e.y) {
      this.ec.curve.type === "mont" ? i1(e.x, "Need x coordinate") : (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") && i1(e.x && e.y, "Need both x and y coordinate"), this.pub = this.ec.curve.point(e.x, e.y);
      return;
    }
    this.pub = this.ec.curve.decodePoint(e, n);
  };
  Yn.prototype.derive = function(e) {
    return e.validate() || i1(e.validate(), "public point not validated"), e.mul(this.priv).getX();
  };
  Yn.prototype.sign = function(e, n, r) {
    return this.ec.sign(e, this, n, r);
  };
  Yn.prototype.verify = function(e, n, r) {
    return this.ec.verify(e, n, this, void 0, r);
  };
  Yn.prototype.inspect = function() {
    return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
  };
  var vj = Rr.assert;
  function Sh(t, e) {
    if (t instanceof Sh) return t;
    this._importDER(t, e) || (vj(t.r && t.s, "Signature without r or s"), this.r = new De(t.r, 16), this.s = new De(t.s, 16), t.recoveryParam === void 0 ? this.recoveryParam = null : this.recoveryParam = t.recoveryParam);
  }
  var Th = Sh;
  function Ej() {
    this.place = 0;
  }
  function Tg(t, e) {
    var n = t[e.place++];
    if (!(n & 128)) return n;
    var r = n & 15;
    if (r === 0 || r > 4 || t[e.place] === 0) return false;
    for (var i = 0, s = 0, o = e.place; s < r; s++, o++) i <<= 8, i |= t[o], i >>>= 0;
    return i <= 127 ? false : (e.place = o, i);
  }
  function Vw(t) {
    for (var e = 0, n = t.length - 1; !t[e] && !(t[e + 1] & 128) && e < n; ) e++;
    return e === 0 ? t : t.slice(e);
  }
  Sh.prototype._importDER = function(e, n) {
    e = Rr.toArray(e, n);
    var r = new Ej();
    if (e[r.place++] !== 48) return false;
    var i = Tg(e, r);
    if (i === false || i + r.place !== e.length || e[r.place++] !== 2) return false;
    var s = Tg(e, r);
    if (s === false || e[r.place] & 128) return false;
    var o = e.slice(r.place, s + r.place);
    if (r.place += s, e[r.place++] !== 2) return false;
    var a = Tg(e, r);
    if (a === false || e.length !== a + r.place || e[r.place] & 128) return false;
    var c = e.slice(r.place, a + r.place);
    if (o[0] === 0) if (o[1] & 128) o = o.slice(1);
    else return false;
    if (c[0] === 0) if (c[1] & 128) c = c.slice(1);
    else return false;
    return this.r = new De(o), this.s = new De(c), this.recoveryParam = null, true;
  };
  function Cg(t, e) {
    if (e < 128) {
      t.push(e);
      return;
    }
    var n = 1 + (Math.log(e) / Math.LN2 >>> 3);
    for (t.push(n | 128); --n; ) t.push(e >>> (n << 3) & 255);
    t.push(e);
  }
  Sh.prototype.toDER = function(e) {
    var n = this.r.toArray(), r = this.s.toArray();
    for (n[0] & 128 && (n = [
      0
    ].concat(n)), r[0] & 128 && (r = [
      0
    ].concat(r)), n = Vw(n), r = Vw(r); !r[0] && !(r[1] & 128); ) r = r.slice(1);
    var i = [
      2
    ];
    Cg(i, n.length), i = i.concat(n), i.push(2), Cg(i, r.length);
    var s = i.concat(r), o = [
      48
    ];
    return Cg(o, s.length), o = o.concat(s), Rr.encode(o, e);
  };
  var Sj = function() {
    throw new Error("unsupported");
  }, fa = Rr.assert;
  function Yr(t) {
    if (!(this instanceof Yr)) return new Yr(t);
    typeof t == "string" && (fa(Object.prototype.hasOwnProperty.call(_0, t), "Unknown curve " + t), t = _0[t]), t instanceof _0.PresetCurve && (t = {
      curve: t
    }), this.curve = t.curve.curve, this.n = this.curve.n, this.nh = this.n.ushrn(1), this.g = this.curve.g, this.g = t.curve.g, this.g.precompute(t.curve.n.bitLength() + 1), this.hash = t.hash || t.curve.hash;
  }
  var Tj = Yr;
  Yr.prototype.keyPair = function(e) {
    return new jy(this, e);
  };
  Yr.prototype.keyFromPrivate = function(e, n) {
    return jy.fromPrivate(this, e, n);
  };
  Yr.prototype.keyFromPublic = function(e, n) {
    return jy.fromPublic(this, e, n);
  };
  Yr.prototype.genKeyPair = function(e) {
    e || (e = {});
    for (var n = new y7({
      hash: this.hash,
      pers: e.pers,
      persEnc: e.persEnc || "utf8",
      entropy: e.entropy || Sj(this.hash.hmacStrength),
      entropyEnc: e.entropy && e.entropyEnc || "utf8",
      nonce: this.n.toArray()
    }), r = this.n.byteLength(), i = this.n.sub(new De(2)); ; ) {
      var s = new De(n.generate(r));
      if (!(s.cmp(i) > 0)) return s.iaddn(1), this.keyFromPrivate(s);
    }
  };
  Yr.prototype._truncateToN = function(e, n, r) {
    var i;
    if (De.isBN(e) || typeof e == "number") e = new De(e, 16), i = e.byteLength();
    else if (typeof e == "object") i = e.length, e = new De(e, 16);
    else {
      var s = e.toString();
      i = s.length + 1 >>> 1, e = new De(s, 16);
    }
    typeof r != "number" && (r = i * 8);
    var o = r - this.n.bitLength();
    return o > 0 && (e = e.ushrn(o)), !n && e.cmp(this.n) >= 0 ? e.sub(this.n) : e;
  };
  Yr.prototype.sign = function(e, n, r, i) {
    if (typeof r == "object" && (i = r, r = null), i || (i = {}), typeof e != "string" && typeof e != "number" && !De.isBN(e)) {
      fa(typeof e == "object" && e && typeof e.length == "number", "Expected message to be an array-like, a hex string, or a BN instance"), fa(e.length >>> 0 === e.length);
      for (var s = 0; s < e.length; s++) fa((e[s] & 255) === e[s]);
    }
    n = this.keyFromPrivate(n, r), e = this._truncateToN(e, false, i.msgBitLength), fa(!e.isNeg(), "Can not sign a negative message");
    var o = this.n.byteLength(), a = n.getPrivate().toArray("be", o), c = e.toArray("be", o);
    fa(new De(c).eq(e), "Can not sign message");
    for (var l = new y7({
      hash: this.hash,
      entropy: a,
      nonce: c,
      pers: i.pers,
      persEnc: i.persEnc || "utf8"
    }), u = this.n.sub(new De(1)), f = 0; ; f++) {
      var d = i.k ? i.k(f) : new De(l.generate(this.n.byteLength()));
      if (d = this._truncateToN(d, true), !(d.cmpn(1) <= 0 || d.cmp(u) >= 0)) {
        var m = this.g.mul(d);
        if (!m.isInfinity()) {
          var y = m.getX(), x = y.umod(this.n);
          if (x.cmpn(0) !== 0) {
            var w = d.invm(this.n).mul(x.mul(n.getPrivate()).iadd(e));
            if (w = w.umod(this.n), w.cmpn(0) !== 0) {
              var R = (m.getY().isOdd() ? 1 : 0) | (y.cmp(x) !== 0 ? 2 : 0);
              return i.canonical && w.cmp(this.nh) > 0 && (w = this.n.sub(w), R ^= 1), new Th({
                r: x,
                s: w,
                recoveryParam: R
              });
            }
          }
        }
      }
    }
  };
  Yr.prototype.verify = function(e, n, r, i, s) {
    s || (s = {}), e = this._truncateToN(e, false, s.msgBitLength), r = this.keyFromPublic(r, i), n = new Th(n, "hex");
    var o = n.r, a = n.s;
    if (o.cmpn(1) < 0 || o.cmp(this.n) >= 0 || a.cmpn(1) < 0 || a.cmp(this.n) >= 0) return false;
    var c = a.invm(this.n), l = c.mul(e).umod(this.n), u = c.mul(o).umod(this.n), f;
    return this.curve._maxwellTrick ? (f = this.g.jmulAdd(l, r.getPublic(), u), f.isInfinity() ? false : f.eqXToP(o)) : (f = this.g.mulAdd(l, r.getPublic(), u), f.isInfinity() ? false : f.getX().umod(this.n).cmp(o) === 0);
  };
  Yr.prototype.recoverPubKey = function(t, e, n, r) {
    fa((3 & n) === n, "The recovery param is more than two bits"), e = new Th(e, r);
    var i = this.n, s = new De(t), o = e.r, a = e.s, c = n & 1, l = n >> 1;
    if (o.cmp(this.curve.p.umod(this.curve.n)) >= 0 && l) throw new Error("Unable to find sencond key candinate");
    l ? o = this.curve.pointFromX(o.add(this.curve.n), c) : o = this.curve.pointFromX(o, c);
    var u = e.r.invm(i), f = i.sub(s).mul(u).umod(i), d = a.mul(u).umod(i);
    return this.g.mulAdd(f, o, d);
  };
  Yr.prototype.getKeyRecoveryParam = function(t, e, n, r) {
    if (e = new Th(e, r), e.recoveryParam !== null) return e.recoveryParam;
    for (var i = 0; i < 4; i++) {
      var s;
      try {
        s = this.recoverPubKey(t, e, i);
      } catch {
        continue;
      }
      if (s.eq(n)) return i;
    }
    throw new Error("Unable to find valid recovery factor");
  };
  var Cj = Nl(function(t, e) {
    var n = e;
    n.version = "6.6.1", n.utils = Rr, n.rand = function() {
      throw new Error("unsupported");
    }, n.curve = P0, n.curves = _0, n.ec = Tj, n.eddsa = null;
  }), Ij = Cj.ec;
  const Pj = "signing-key/5.8.0", s1 = new oe(Pj);
  let Ig = null;
  function Ui() {
    return Ig || (Ig = new Ij("secp256k1")), Ig;
  }
  class Ca {
    constructor(e) {
      ge(this, "curve", "secp256k1"), ge(this, "privateKey", Ee(e)), ns(this.privateKey) !== 32 && s1.throwArgumentError("invalid private key", "privateKey", "[[ REDACTED ]]");
      const n = Ui().keyFromPrivate(Ae(this.privateKey));
      ge(this, "publicKey", "0x" + n.getPublic(false, "hex")), ge(this, "compressedPublicKey", "0x" + n.getPublic(true, "hex")), ge(this, "_isSigningKey", true);
    }
    _addPoint(e) {
      const n = Ui().keyFromPublic(Ae(this.publicKey)), r = Ui().keyFromPublic(Ae(e));
      return "0x" + n.pub.add(r.pub).encodeCompressed("hex");
    }
    signDigest(e) {
      const n = Ui().keyFromPrivate(Ae(this.privateKey)), r = Ae(e);
      r.length !== 32 && s1.throwArgumentError("bad digest length", "digest", e);
      const i = n.sign(r, {
        canonical: true
      });
      return Qa({
        recoveryParam: i.recoveryParam,
        r: xt("0x" + i.r.toString(16), 32),
        s: xt("0x" + i.s.toString(16), 32)
      });
    }
    computeSharedSecret(e) {
      const n = Ui().keyFromPrivate(Ae(this.privateKey)), r = Ui().keyFromPublic(Ae(Jy(e)));
      return xt("0x" + n.derive(r.getPublic()).toString(16), 32);
    }
    static isSigningKey(e) {
      return !!(e && e._isSigningKey);
    }
  }
  function b7(t, e) {
    const n = Qa(e), r = {
      r: Ae(n.r),
      s: Ae(n.s)
    };
    return "0x" + Ui().recoverPubKey(Ae(t), r, n.recoveryParam).encode("hex", false);
  }
  function Jy(t, e) {
    const n = Ae(t);
    if (n.length === 32) {
      const r = new Ca(n);
      return e ? "0x" + Ui().keyFromPrivate(n).getPublic(true, "hex") : r.publicKey;
    } else {
      if (n.length === 33) return e ? Ee(n) : "0x" + Ui().keyFromPublic(n).getPublic(false, "hex");
      if (n.length === 65) return e ? "0x" + Ui().keyFromPublic(n).getPublic(true, "hex") : Ee(n);
    }
    return s1.throwArgumentError("invalid public or private key", "key", "[REDACTED]");
  }
  const _j = Object.freeze(Object.defineProperty({
    __proto__: null,
    SigningKey: Ca,
    computePublicKey: Jy,
    recoverPublicKey: b7
  }, Symbol.toStringTag, {
    value: "Module"
  })), Rj = "transactions/5.8.0", Wn = new oe(Rj);
  var o1;
  (function(t) {
    t[t.legacy = 0] = "legacy", t[t.eip2930 = 1] = "eip2930", t[t.eip1559 = 2] = "eip1559";
  })(o1 || (o1 = {}));
  function Ky(t) {
    return t === "0x" ? null : pt(t);
  }
  function Jn(t) {
    return t === "0x" ? R8 : ve.from(t);
  }
  const Nj = [
    {
      name: "nonce",
      maxLength: 32,
      numeric: true
    },
    {
      name: "gasPrice",
      maxLength: 32,
      numeric: true
    },
    {
      name: "gasLimit",
      maxLength: 32,
      numeric: true
    },
    {
      name: "to",
      length: 20
    },
    {
      name: "value",
      maxLength: 32,
      numeric: true
    },
    {
      name: "data"
    }
  ], Oj = {
    chainId: true,
    data: true,
    gasLimit: true,
    gasPrice: true,
    nonce: true,
    to: true,
    type: true,
    value: true
  };
  function Po(t) {
    const e = Jy(t);
    return pt(ln(mt(ln(e, 1)), 12));
  }
  function If(t, e) {
    return Po(b7(Ae(t), e));
  }
  function Er(t, e) {
    const n = qi(ve.from(t).toHexString());
    return n.length > 32 && Wn.throwArgumentError("invalid length for " + e, "transaction:" + e, t), n;
  }
  function Pg(t, e) {
    return {
      address: pt(t),
      storageKeys: (e || []).map((n, r) => (ns(n) !== 32 && Wn.throwArgumentError("invalid access list storageKey", `accessList[${t}:${r}]`, n), n.toLowerCase()))
    };
  }
  function Ja(t) {
    if (Array.isArray(t)) return t.map((n, r) => Array.isArray(n) ? (n.length > 2 && Wn.throwArgumentError("access list expected to be [ address, storageKeys[] ]", `value[${r}]`, n), Pg(n[0], n[1])) : Pg(n.address, n.storageKeys));
    const e = Object.keys(t).map((n) => {
      const r = t[n].reduce((i, s) => (i[s] = true, i), {});
      return Pg(n, Object.keys(r).sort());
    });
    return e.sort((n, r) => n.address.localeCompare(r.address)), e;
  }
  function x7(t) {
    return Ja(t).map((e) => [
      e.address,
      e.storageKeys
    ]);
  }
  function A7(t, e) {
    if (t.gasPrice != null) {
      const r = ve.from(t.gasPrice), i = ve.from(t.maxFeePerGas || 0);
      r.eq(i) || Wn.throwArgumentError("mismatch EIP-1559 gasPrice != maxFeePerGas", "tx", {
        gasPrice: r,
        maxFeePerGas: i
      });
    }
    const n = [
      Er(t.chainId || 0, "chainId"),
      Er(t.nonce || 0, "nonce"),
      Er(t.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"),
      Er(t.maxFeePerGas || 0, "maxFeePerGas"),
      Er(t.gasLimit || 0, "gasLimit"),
      t.to != null ? pt(t.to) : "0x",
      Er(t.value || 0, "value"),
      t.data || "0x",
      x7(t.accessList || [])
    ];
    if (e) {
      const r = Qa(e);
      n.push(Er(r.recoveryParam, "recoveryParam")), n.push(qi(r.r)), n.push(qi(r.s));
    }
    return nr([
      "0x02",
      ka(n)
    ]);
  }
  function w7(t, e) {
    const n = [
      Er(t.chainId || 0, "chainId"),
      Er(t.nonce || 0, "nonce"),
      Er(t.gasPrice || 0, "gasPrice"),
      Er(t.gasLimit || 0, "gasLimit"),
      t.to != null ? pt(t.to) : "0x",
      Er(t.value || 0, "value"),
      t.data || "0x",
      x7(t.accessList || [])
    ];
    if (e) {
      const r = Qa(e);
      n.push(Er(r.recoveryParam, "recoveryParam")), n.push(qi(r.r)), n.push(qi(r.s));
    }
    return nr([
      "0x01",
      ka(n)
    ]);
  }
  function Bj(t, e) {
    Oy(t, Oj);
    const n = [];
    Nj.forEach(function(o) {
      let a = t[o.name] || [];
      const c = {};
      o.numeric && (c.hexPad = "left"), a = Ae(Ee(a, c)), o.length && a.length !== o.length && a.length > 0 && Wn.throwArgumentError("invalid length for " + o.name, "transaction:" + o.name, a), o.maxLength && (a = qi(a), a.length > o.maxLength && Wn.throwArgumentError("invalid length for " + o.name, "transaction:" + o.name, a)), n.push(Ee(a));
    });
    let r = 0;
    if (t.chainId != null ? (r = t.chainId, typeof r != "number" && Wn.throwArgumentError("invalid transaction.chainId", "transaction", t)) : e && !Ef(e) && e.v > 28 && (r = Math.floor((e.v - 35) / 2)), r !== 0 && (n.push(Ee(r)), n.push("0x"), n.push("0x")), !e) return ka(n);
    const i = Qa(e);
    let s = 27 + i.recoveryParam;
    return r !== 0 ? (n.pop(), n.pop(), n.pop(), s += r * 2 + 8, i.v > 28 && i.v !== s && Wn.throwArgumentError("transaction.chainId/signature.v mismatch", "signature", e)) : i.v !== s && Wn.throwArgumentError("transaction.chainId/signature.v mismatch", "signature", e), n.push(Ee(s)), n.push(qi(Ae(i.r))), n.push(qi(Ae(i.s))), ka(n);
  }
  function a1(t, e) {
    if (t.type == null || t.type === 0) return t.accessList != null && Wn.throwArgumentError("untyped transactions do not support accessList; include type: 1", "transaction", t), Bj(t, e);
    switch (t.type) {
      case 1:
        return w7(t, e);
      case 2:
        return A7(t, e);
    }
    return Wn.throwError(`unsupported transaction type: ${t.type}`, oe.errors.UNSUPPORTED_OPERATION, {
      operation: "serializeTransaction",
      transactionType: t.type
    });
  }
  function v7(t, e, n) {
    try {
      const r = Jn(e[0]).toNumber();
      if (r !== 0 && r !== 1) throw new Error("bad recid");
      t.v = r;
    } catch {
      Wn.throwArgumentError("invalid v for transaction type: 1", "v", e[0]);
    }
    t.r = xt(e[1], 32), t.s = xt(e[2], 32);
    try {
      const r = mt(n(t));
      t.from = If(r, {
        r: t.r,
        s: t.s,
        recoveryParam: t.v
      });
    } catch {
    }
  }
  function Mj(t) {
    const e = Ah(t.slice(1));
    e.length !== 9 && e.length !== 12 && Wn.throwArgumentError("invalid component count for transaction type: 2", "payload", Ee(t));
    const n = Jn(e[2]), r = Jn(e[3]), i = {
      type: 2,
      chainId: Jn(e[0]).toNumber(),
      nonce: Jn(e[1]).toNumber(),
      maxPriorityFeePerGas: n,
      maxFeePerGas: r,
      gasPrice: null,
      gasLimit: Jn(e[4]),
      to: Ky(e[5]),
      value: Jn(e[6]),
      data: e[7],
      accessList: Ja(e[8])
    };
    return e.length === 9 || (i.hash = mt(t), v7(i, e.slice(9), A7)), i;
  }
  function kj(t) {
    const e = Ah(t.slice(1));
    e.length !== 8 && e.length !== 11 && Wn.throwArgumentError("invalid component count for transaction type: 1", "payload", Ee(t));
    const n = {
      type: 1,
      chainId: Jn(e[0]).toNumber(),
      nonce: Jn(e[1]).toNumber(),
      gasPrice: Jn(e[2]),
      gasLimit: Jn(e[3]),
      to: Ky(e[4]),
      value: Jn(e[5]),
      data: e[6],
      accessList: Ja(e[7])
    };
    return e.length === 8 || (n.hash = mt(t), v7(n, e.slice(8), w7)), n;
  }
  function Fj(t) {
    const e = Ah(t);
    e.length !== 9 && e.length !== 6 && Wn.throwArgumentError("invalid raw transaction", "rawTransaction", t);
    const n = {
      nonce: Jn(e[0]).toNumber(),
      gasPrice: Jn(e[1]),
      gasLimit: Jn(e[2]),
      to: Ky(e[3]),
      value: Jn(e[4]),
      data: e[5],
      chainId: 0
    };
    if (e.length === 6) return n;
    try {
      n.v = ve.from(e[6]).toNumber();
    } catch {
      return n;
    }
    if (n.r = xt(e[7], 32), n.s = xt(e[8], 32), ve.from(n.r).isZero() && ve.from(n.s).isZero()) n.chainId = n.v, n.v = 0;
    else {
      n.chainId = Math.floor((n.v - 35) / 2), n.chainId < 0 && (n.chainId = 0);
      let r = n.v - 27;
      const i = e.slice(0, 6);
      n.chainId !== 0 && (i.push(Ee(n.chainId)), i.push("0x"), i.push("0x"), r -= n.chainId * 2 + 8);
      const s = mt(ka(i));
      try {
        n.from = If(s, {
          r: Ee(n.r),
          s: Ee(n.s),
          recoveryParam: r
        });
      } catch {
      }
      n.hash = mt(t);
    }
    return n.type = null, n;
  }
  function E7(t) {
    const e = Ae(t);
    if (e[0] > 127) return Fj(e);
    switch (e[0]) {
      case 1:
        return kj(e);
      case 2:
        return Mj(e);
    }
    return Wn.throwError(`unsupported transaction type: ${e[0]}`, oe.errors.UNSUPPORTED_OPERATION, {
      operation: "parseTransaction",
      transactionType: e[0]
    });
  }
  const Lj = Object.freeze(Object.defineProperty({
    __proto__: null,
    get TransactionTypes() {
      return o1;
    },
    accessListify: Ja,
    computeAddress: Po,
    parse: E7,
    recoverAddress: If,
    serialize: a1
  }, Symbol.toStringTag, {
    value: "Module"
  })), Dj = "contracts/5.8.0";
  var La = function(t, e, n, r) {
    function i(s) {
      return s instanceof n ? s : new n(function(o) {
        o(s);
      });
    }
    return new (n || (n = Promise))(function(s, o) {
      function a(u) {
        try {
          l(r.next(u));
        } catch (f) {
          o(f);
        }
      }
      function c(u) {
        try {
          l(r.throw(u));
        } catch (f) {
          o(f);
        }
      }
      function l(u) {
        u.done ? s(u.value) : i(u.value).then(a, c);
      }
      l((r = r.apply(t, e || [])).next());
    });
  };
  const on = new oe(Dj);
  function xd(t, e) {
    return La(this, void 0, void 0, function* () {
      const n = yield e;
      typeof n != "string" && on.throwArgumentError("invalid address or ENS name", "name", n);
      try {
        return pt(n);
      } catch {
      }
      t || on.throwError("a provider or signer is needed to resolve ENS names", oe.errors.UNSUPPORTED_OPERATION, {
        operation: "resolveName"
      });
      const r = yield t.resolveName(n);
      return r == null && on.throwArgumentError("resolver or addr is not configured for ENS name", "name", n), r;
    });
  }
  function R0(t, e, n) {
    return La(this, void 0, void 0, function* () {
      return Array.isArray(n) ? yield Promise.all(n.map((r, i) => R0(t, Array.isArray(e) ? e[i] : e[r.name], r))) : n.type === "address" ? yield xd(t, e) : n.type === "tuple" ? yield R0(t, e, n.components) : n.baseType === "array" ? Array.isArray(e) ? yield Promise.all(e.map((r) => R0(t, r, n.arrayChildren))) : Promise.reject(on.makeError("invalid value for array", oe.errors.INVALID_ARGUMENT, {
        argument: "value",
        value: e
      })) : e;
    });
  }
  function Ch(t, e, n) {
    return La(this, void 0, void 0, function* () {
      let r = {};
      n.length === e.inputs.length + 1 && typeof n[n.length - 1] == "object" && (r = bn(n.pop())), on.checkArgumentCount(n.length, e.inputs.length, "passed to contract"), t.signer ? r.from ? r.from = tn({
        override: xd(t.signer, r.from),
        signer: t.signer.getAddress()
      }).then((l) => La(this, void 0, void 0, function* () {
        return pt(l.signer) !== l.override && on.throwError("Contract with a Signer cannot override from", oe.errors.UNSUPPORTED_OPERATION, {
          operation: "overrides.from"
        }), l.override;
      })) : r.from = t.signer.getAddress() : r.from && (r.from = xd(t.provider, r.from));
      const i = yield tn({
        args: R0(t.signer || t.provider, n, e.inputs),
        address: t.resolvedAddress,
        overrides: tn(r) || {}
      }), s = t.interface.encodeFunctionData(e, i.args), o = {
        data: s,
        to: i.address
      }, a = i.overrides;
      if (a.nonce != null && (o.nonce = ve.from(a.nonce).toNumber()), a.gasLimit != null && (o.gasLimit = ve.from(a.gasLimit)), a.gasPrice != null && (o.gasPrice = ve.from(a.gasPrice)), a.maxFeePerGas != null && (o.maxFeePerGas = ve.from(a.maxFeePerGas)), a.maxPriorityFeePerGas != null && (o.maxPriorityFeePerGas = ve.from(a.maxPriorityFeePerGas)), a.from != null && (o.from = a.from), a.type != null && (o.type = a.type), a.accessList != null && (o.accessList = Ja(a.accessList)), o.gasLimit == null && e.gas != null) {
        let l = 21e3;
        const u = Ae(s);
        for (let f = 0; f < u.length; f++) l += 4, u[f] && (l += 64);
        o.gasLimit = ve.from(e.gas).add(l);
      }
      if (a.value) {
        const l = ve.from(a.value);
        !l.isZero() && !e.payable && on.throwError("non-payable method cannot override value", oe.errors.UNSUPPORTED_OPERATION, {
          operation: "overrides.value",
          value: r.value
        }), o.value = l;
      }
      a.customData && (o.customData = bn(a.customData)), a.ccipReadEnabled && (o.ccipReadEnabled = !!a.ccipReadEnabled), delete r.nonce, delete r.gasLimit, delete r.gasPrice, delete r.from, delete r.value, delete r.type, delete r.accessList, delete r.maxFeePerGas, delete r.maxPriorityFeePerGas, delete r.customData, delete r.ccipReadEnabled;
      const c = Object.keys(r).filter((l) => r[l] != null);
      return c.length && on.throwError(`cannot override ${c.map((l) => JSON.stringify(l)).join(",")}`, oe.errors.UNSUPPORTED_OPERATION, {
        operation: "overrides",
        overrides: c
      }), o;
    });
  }
  function Uj(t, e) {
    return function(...n) {
      return Ch(t, e, n);
    };
  }
  function Hj(t, e) {
    const n = t.signer || t.provider;
    return function(...r) {
      return La(this, void 0, void 0, function* () {
        n || on.throwError("estimate require a provider or signer", oe.errors.UNSUPPORTED_OPERATION, {
          operation: "estimateGas"
        });
        const i = yield Ch(t, e, r);
        return yield n.estimateGas(i);
      });
    };
  }
  function Gj(t, e) {
    const n = e.wait.bind(e);
    e.wait = (r) => n(r).then((i) => (i.events = i.logs.map((s) => {
      let o = rs(s), a = null;
      try {
        a = t.interface.parseLog(s);
      } catch {
      }
      return a && (o.args = a.args, o.decode = (c, l) => t.interface.decodeEventLog(a.eventFragment, c, l), o.event = a.name, o.eventSignature = a.signature), o.removeListener = () => t.provider, o.getBlock = () => t.provider.getBlock(i.blockHash), o.getTransaction = () => t.provider.getTransaction(i.transactionHash), o.getTransactionReceipt = () => Promise.resolve(i), o;
    }), i));
  }
  function S7(t, e, n) {
    const r = t.signer || t.provider;
    return function(...i) {
      return La(this, void 0, void 0, function* () {
        let s;
        if (i.length === e.inputs.length + 1 && typeof i[i.length - 1] == "object") {
          const c = bn(i.pop());
          c.blockTag != null && (s = yield c.blockTag), delete c.blockTag, i.push(c);
        }
        t.deployTransaction != null && (yield t._deployed(s));
        const o = yield Ch(t, e, i), a = yield r.call(o, s);
        try {
          let c = t.interface.decodeFunctionResult(e, a);
          return n && e.outputs.length === 1 && (c = c[0]), c;
        } catch (c) {
          throw c.code === oe.errors.CALL_EXCEPTION && (c.address = t.address, c.args = i, c.transaction = o), c;
        }
      });
    };
  }
  function Vj(t, e) {
    return function(...n) {
      return La(this, void 0, void 0, function* () {
        t.signer || on.throwError("sending a transaction requires a signer", oe.errors.UNSUPPORTED_OPERATION, {
          operation: "sendTransaction"
        }), t.deployTransaction != null && (yield t._deployed());
        const r = yield Ch(t, e, n), i = yield t.signer.sendTransaction(r);
        return Gj(t, i), i;
      });
    };
  }
  function zw(t, e, n) {
    return e.constant ? S7(t, e, n) : Vj(t, e);
  }
  function T7(t) {
    return t.address && (t.topics == null || t.topics.length === 0) ? "*" : (t.address || "*") + "@" + (t.topics ? t.topics.map((e) => Array.isArray(e) ? e.join("|") : e).join(":") : "");
  }
  class Xu {
    constructor(e, n) {
      ge(this, "tag", e), ge(this, "filter", n), this._listeners = [];
    }
    addListener(e, n) {
      this._listeners.push({
        listener: e,
        once: n
      });
    }
    removeListener(e) {
      let n = false;
      this._listeners = this._listeners.filter((r) => n || r.listener !== e ? true : (n = true, false));
    }
    removeAllListeners() {
      this._listeners = [];
    }
    listeners() {
      return this._listeners.map((e) => e.listener);
    }
    listenerCount() {
      return this._listeners.length;
    }
    run(e) {
      const n = this.listenerCount();
      return this._listeners = this._listeners.filter((r) => {
        const i = e.slice();
        return setTimeout(() => {
          r.listener.apply(this, i);
        }, 0), !r.once;
      }), n;
    }
    prepareEvent(e) {
    }
    getEmit(e) {
      return [
        e
      ];
    }
  }
  class zj extends Xu {
    constructor() {
      super("error", null);
    }
  }
  class Qw extends Xu {
    constructor(e, n, r, i) {
      const s = {
        address: e
      };
      let o = n.getEventTopic(r);
      i ? (o !== i[0] && on.throwArgumentError("topic mismatch", "topics", i), s.topics = i.slice()) : s.topics = [
        o
      ], super(T7(s), s), ge(this, "address", e), ge(this, "interface", n), ge(this, "fragment", r);
    }
    prepareEvent(e) {
      super.prepareEvent(e), e.event = this.fragment.name, e.eventSignature = this.fragment.format(), e.decode = (n, r) => this.interface.decodeEventLog(this.fragment, n, r);
      try {
        e.args = this.interface.decodeEventLog(this.fragment, e.data, e.topics);
      } catch (n) {
        e.args = null, e.decodeError = n;
      }
    }
    getEmit(e) {
      const n = v8(e.args);
      if (n.length) throw n[0].error;
      const r = (e.args || []).slice();
      return r.push(e), r;
    }
  }
  class jw extends Xu {
    constructor(e, n) {
      super("*", {
        address: e
      }), ge(this, "address", e), ge(this, "interface", n);
    }
    prepareEvent(e) {
      super.prepareEvent(e);
      try {
        const n = this.interface.parseLog(e);
        e.event = n.name, e.eventSignature = n.signature, e.decode = (r, i) => this.interface.decodeEventLog(n.eventFragment, r, i), e.args = n.args;
      } catch {
      }
    }
  }
  class Qj {
    constructor(e, n, r) {
      ge(this, "interface", bi(new.target, "getInterface")(n)), r == null ? (ge(this, "provider", null), ge(this, "signer", null)) : Il.isSigner(r) ? (ge(this, "provider", r.provider || null), ge(this, "signer", r)) : Tf.isProvider(r) ? (ge(this, "provider", r), ge(this, "signer", null)) : on.throwArgumentError("invalid signer or provider", "signerOrProvider", r), ge(this, "callStatic", {}), ge(this, "estimateGas", {}), ge(this, "functions", {}), ge(this, "populateTransaction", {}), ge(this, "filters", {});
      {
        const o = {};
        Object.keys(this.interface.events).forEach((a) => {
          const c = this.interface.events[a];
          ge(this.filters, a, (...l) => ({
            address: this.address,
            topics: this.interface.encodeFilterTopics(c, l)
          })), o[c.name] || (o[c.name] = []), o[c.name].push(a);
        }), Object.keys(o).forEach((a) => {
          const c = o[a];
          c.length === 1 ? ge(this.filters, a, this.filters[c[0]]) : on.warn(`Duplicate definition of ${a} (${c.join(", ")})`);
        });
      }
      if (ge(this, "_runningEvents", {}), ge(this, "_wrappedEmits", {}), e == null && on.throwArgumentError("invalid contract address or ENS name", "addressOrName", e), ge(this, "address", e), this.provider) ge(this, "resolvedAddress", xd(this.provider, e));
      else try {
        ge(this, "resolvedAddress", Promise.resolve(pt(e)));
      } catch {
        on.throwError("provider is required to use ENS name as contract address", oe.errors.UNSUPPORTED_OPERATION, {
          operation: "new Contract"
        });
      }
      this.resolvedAddress.catch((o) => {
      });
      const i = {}, s = {};
      Object.keys(this.interface.functions).forEach((o) => {
        const a = this.interface.functions[o];
        if (s[o]) {
          on.warn(`Duplicate ABI entry for ${JSON.stringify(o)}`);
          return;
        }
        s[o] = true;
        {
          const c = a.name;
          i[`%${c}`] || (i[`%${c}`] = []), i[`%${c}`].push(o);
        }
        this[o] == null && ge(this, o, zw(this, a, true)), this.functions[o] == null && ge(this.functions, o, zw(this, a, false)), this.callStatic[o] == null && ge(this.callStatic, o, S7(this, a, true)), this.populateTransaction[o] == null && ge(this.populateTransaction, o, Uj(this, a)), this.estimateGas[o] == null && ge(this.estimateGas, o, Hj(this, a));
      }), Object.keys(i).forEach((o) => {
        const a = i[o];
        if (a.length > 1) return;
        o = o.substring(1);
        const c = a[0];
        try {
          this[o] == null && ge(this, o, this[c]);
        } catch {
        }
        this.functions[o] == null && ge(this.functions, o, this.functions[c]), this.callStatic[o] == null && ge(this.callStatic, o, this.callStatic[c]), this.populateTransaction[o] == null && ge(this.populateTransaction, o, this.populateTransaction[c]), this.estimateGas[o] == null && ge(this.estimateGas, o, this.estimateGas[c]);
      });
    }
    static getContractAddress(e) {
      return ky(e);
    }
    static getInterface(e) {
      return e1.isInterface(e) ? e : new e1(e);
    }
    deployed() {
      return this._deployed();
    }
    _deployed(e) {
      return this._deployedPromise || (this.deployTransaction ? this._deployedPromise = this.deployTransaction.wait().then(() => this) : this._deployedPromise = this.provider.getCode(this.address, e).then((n) => (n === "0x" && on.throwError("contract not deployed", oe.errors.UNSUPPORTED_OPERATION, {
        contractAddress: this.address,
        operation: "getDeployed"
      }), this))), this._deployedPromise;
    }
    fallback(e) {
      this.signer || on.throwError("sending a transactions require a signer", oe.errors.UNSUPPORTED_OPERATION, {
        operation: "sendTransaction(fallback)"
      });
      const n = bn(e || {});
      return [
        "from",
        "to"
      ].forEach(function(r) {
        n[r] != null && on.throwError("cannot override " + r, oe.errors.UNSUPPORTED_OPERATION, {
          operation: r
        });
      }), n.to = this.resolvedAddress, this.deployed().then(() => this.signer.sendTransaction(n));
    }
    connect(e) {
      typeof e == "string" && (e = new Vy(e, this.provider));
      const n = new this.constructor(this.address, this.interface, e);
      return this.deployTransaction && ge(n, "deployTransaction", this.deployTransaction), n;
    }
    attach(e) {
      return new this.constructor(e, this.interface, this.signer || this.provider);
    }
    static isIndexed(e) {
      return md.isIndexed(e);
    }
    _normalizeRunningEvent(e) {
      return this._runningEvents[e.tag] ? this._runningEvents[e.tag] : e;
    }
    _getRunningEvent(e) {
      if (typeof e == "string") {
        if (e === "error") return this._normalizeRunningEvent(new zj());
        if (e === "event") return this._normalizeRunningEvent(new Xu("event", null));
        if (e === "*") return this._normalizeRunningEvent(new jw(this.address, this.interface));
        const n = this.interface.getEvent(e);
        return this._normalizeRunningEvent(new Qw(this.address, this.interface, n));
      }
      if (e.topics && e.topics.length > 0) {
        try {
          const r = e.topics[0];
          if (typeof r != "string") throw new Error("invalid topic");
          const i = this.interface.getEvent(r);
          return this._normalizeRunningEvent(new Qw(this.address, this.interface, i, e.topics));
        } catch {
        }
        const n = {
          address: this.address,
          topics: e.topics
        };
        return this._normalizeRunningEvent(new Xu(T7(n), n));
      }
      return this._normalizeRunningEvent(new jw(this.address, this.interface));
    }
    _checkRunningEvents(e) {
      if (e.listenerCount() === 0) {
        delete this._runningEvents[e.tag];
        const n = this._wrappedEmits[e.tag];
        n && e.filter && (this.provider.off(e.filter, n), delete this._wrappedEmits[e.tag]);
      }
    }
    _wrapEvent(e, n, r) {
      const i = rs(n);
      return i.removeListener = () => {
        r && (e.removeListener(r), this._checkRunningEvents(e));
      }, i.getBlock = () => this.provider.getBlock(n.blockHash), i.getTransaction = () => this.provider.getTransaction(n.transactionHash), i.getTransactionReceipt = () => this.provider.getTransactionReceipt(n.transactionHash), e.prepareEvent(i), i;
    }
    _addEventListener(e, n, r) {
      if (this.provider || on.throwError("events require a provider or a signer with a provider", oe.errors.UNSUPPORTED_OPERATION, {
        operation: "once"
      }), e.addListener(n, r), this._runningEvents[e.tag] = e, !this._wrappedEmits[e.tag]) {
        const i = (s) => {
          let o = this._wrapEvent(e, s, n);
          if (o.decodeError == null) try {
            const a = e.getEmit(o);
            this.emit(e.filter, ...a);
          } catch (a) {
            o.decodeError = a.error;
          }
          e.filter != null && this.emit("event", o), o.decodeError != null && this.emit("error", o.decodeError, o);
        };
        this._wrappedEmits[e.tag] = i, e.filter != null && this.provider.on(e.filter, i);
      }
    }
    queryFilter(e, n, r) {
      const i = this._getRunningEvent(e), s = bn(i.filter);
      return typeof n == "string" && st(n, 32) ? (r != null && on.throwArgumentError("cannot specify toBlock with blockhash", "toBlock", r), s.blockHash = n) : (s.fromBlock = n ?? 0, s.toBlock = r ?? "latest"), this.provider.getLogs(s).then((o) => o.map((a) => this._wrapEvent(i, a, null)));
    }
    on(e, n) {
      return this._addEventListener(this._getRunningEvent(e), n, false), this;
    }
    once(e, n) {
      return this._addEventListener(this._getRunningEvent(e), n, true), this;
    }
    emit(e, ...n) {
      if (!this.provider) return false;
      const r = this._getRunningEvent(e), i = r.run(n) > 0;
      return this._checkRunningEvents(r), i;
    }
    listenerCount(e) {
      return this.provider ? e == null ? Object.keys(this._runningEvents).reduce((n, r) => n + this._runningEvents[r].listenerCount(), 0) : this._getRunningEvent(e).listenerCount() : 0;
    }
    listeners(e) {
      if (!this.provider) return [];
      if (e == null) {
        const n = [];
        for (let r in this._runningEvents) this._runningEvents[r].listeners().forEach((i) => {
          n.push(i);
        });
        return n;
      }
      return this._getRunningEvent(e).listeners();
    }
    removeAllListeners(e) {
      if (!this.provider) return this;
      if (e == null) {
        for (const r in this._runningEvents) {
          const i = this._runningEvents[r];
          i.removeAllListeners(), this._checkRunningEvents(i);
        }
        return this;
      }
      const n = this._getRunningEvent(e);
      return n.removeAllListeners(), this._checkRunningEvents(n), this;
    }
    off(e, n) {
      if (!this.provider) return this;
      const r = this._getRunningEvent(e);
      return r.removeListener(n), this._checkRunningEvents(r), this;
    }
    removeListener(e, n) {
      return this.off(e, n);
    }
  }
  class jj extends Qj {
  }
  class Wy {
    constructor(e) {
      ge(this, "alphabet", e), ge(this, "base", e.length), ge(this, "_alphabetMap", {}), ge(this, "_leader", e.charAt(0));
      for (let n = 0; n < e.length; n++) this._alphabetMap[e.charAt(n)] = n;
    }
    encode(e) {
      let n = Ae(e);
      if (n.length === 0) return "";
      let r = [
        0
      ];
      for (let s = 0; s < n.length; ++s) {
        let o = n[s];
        for (let a = 0; a < r.length; ++a) o += r[a] << 8, r[a] = o % this.base, o = o / this.base | 0;
        for (; o > 0; ) r.push(o % this.base), o = o / this.base | 0;
      }
      let i = "";
      for (let s = 0; n[s] === 0 && s < n.length - 1; ++s) i += this._leader;
      for (let s = r.length - 1; s >= 0; --s) i += this.alphabet[r[s]];
      return i;
    }
    decode(e) {
      if (typeof e != "string") throw new TypeError("Expected String");
      let n = [];
      if (e.length === 0) return new Uint8Array(n);
      n.push(0);
      for (let r = 0; r < e.length; r++) {
        let i = this._alphabetMap[e[r]];
        if (i === void 0) throw new Error("Non-base" + this.base + " character");
        let s = i;
        for (let o = 0; o < n.length; ++o) s += n[o] * this.base, n[o] = s & 255, s >>= 8;
        for (; s > 0; ) n.push(s & 255), s >>= 8;
      }
      for (let r = 0; e[r] === this._leader && r < e.length - 1; ++r) n.push(0);
      return Ae(new Uint8Array(n.reverse()));
    }
  }
  const Jj = new Wy("abcdefghijklmnopqrstuvwxyz234567"), pl = new Wy("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"), Kj = Object.freeze(Object.defineProperty({
    __proto__: null,
    Base32: Jj,
    Base58: pl,
    BaseX: Wy
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  var gl;
  (function(t) {
    t.sha256 = "sha256", t.sha512 = "sha512";
  })(gl || (gl = {}));
  const Wj = "sha2/5.8.0", qj = new oe(Wj);
  function C7(t) {
    return "0x" + hr.ripemd160().update(Ae(t)).digest("hex");
  }
  function Gs(t) {
    return "0x" + hr.sha256().update(Ae(t)).digest("hex");
  }
  function Yj(t) {
    return "0x" + hr.sha512().update(Ae(t)).digest("hex");
  }
  function Zu(t, e, n) {
    return gl[t] || qj.throwError("unsupported algorithm " + t, oe.errors.UNSUPPORTED_OPERATION, {
      operation: "hmac",
      algorithm: t
    }), "0x" + hr.hmac(hr[t], Ae(e)).update(Ae(n)).digest("hex");
  }
  const Xj = Object.freeze(Object.defineProperty({
    __proto__: null,
    get SupportedAlgorithm() {
      return gl;
    },
    computeHmac: Zu,
    ripemd160: C7,
    sha256: Gs,
    sha512: Yj
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  function qy(t, e, n, r, i) {
    t = Ae(t), e = Ae(e);
    let s, o = 1;
    const a = new Uint8Array(r), c = new Uint8Array(e.length + 4);
    c.set(e);
    let l, u;
    for (let f = 1; f <= o; f++) {
      c[e.length] = f >> 24 & 255, c[e.length + 1] = f >> 16 & 255, c[e.length + 2] = f >> 8 & 255, c[e.length + 3] = f & 255;
      let d = Ae(Zu(i, t, c));
      s || (s = d.length, u = new Uint8Array(s), o = Math.ceil(r / s), l = r - (o - 1) * s), u.set(d);
      for (let x = 1; x < n; x++) {
        d = Ae(Zu(i, t, d));
        for (let w = 0; w < s; w++) u[w] ^= d[w];
      }
      const m = (f - 1) * s, y = f === o ? l : s;
      a.set(Ae(u).slice(0, y), m);
    }
    return Ee(a);
  }
  const Zj = "wordlists/5.8.0", $j = new oe(Zj);
  class Pf {
    constructor(e) {
      $j.checkAbstract(new.target, Pf), ge(this, "locale", e);
    }
    split(e) {
      return e.toLowerCase().split(/ +/g);
    }
    join(e) {
      return e.join(" ");
    }
    static check(e) {
      const n = [];
      for (let r = 0; r < 2048; r++) {
        const i = e.getWord(r);
        if (r !== e.getWordIndex(i)) return "0x";
        n.push(i);
      }
      return vo(n.join(`
`) + `
`);
    }
    static register(e, n) {
      n || (n = e.locale);
    }
  }
  const eJ = "AbandonAbilityAbleAboutAboveAbsentAbsorbAbstractAbsurdAbuseAccessAccidentAccountAccuseAchieveAcidAcousticAcquireAcrossActActionActorActressActualAdaptAddAddictAddressAdjustAdmitAdultAdvanceAdviceAerobicAffairAffordAfraidAgainAgeAgentAgreeAheadAimAirAirportAisleAlarmAlbumAlcoholAlertAlienAllAlleyAllowAlmostAloneAlphaAlreadyAlsoAlterAlwaysAmateurAmazingAmongAmountAmusedAnalystAnchorAncientAngerAngleAngryAnimalAnkleAnnounceAnnualAnotherAnswerAntennaAntiqueAnxietyAnyApartApologyAppearAppleApproveAprilArchArcticAreaArenaArgueArmArmedArmorArmyAroundArrangeArrestArriveArrowArtArtefactArtistArtworkAskAspectAssaultAssetAssistAssumeAsthmaAthleteAtomAttackAttendAttitudeAttractAuctionAuditAugustAuntAuthorAutoAutumnAverageAvocadoAvoidAwakeAwareAwayAwesomeAwfulAwkwardAxisBabyBachelorBaconBadgeBagBalanceBalconyBallBambooBananaBannerBarBarelyBargainBarrelBaseBasicBasketBattleBeachBeanBeautyBecauseBecomeBeefBeforeBeginBehaveBehindBelieveBelowBeltBenchBenefitBestBetrayBetterBetweenBeyondBicycleBidBikeBindBiologyBirdBirthBitterBlackBladeBlameBlanketBlastBleakBlessBlindBloodBlossomBlouseBlueBlurBlushBoardBoatBodyBoilBombBoneBonusBookBoostBorderBoringBorrowBossBottomBounceBoxBoyBracketBrainBrandBrassBraveBreadBreezeBrickBridgeBriefBrightBringBriskBroccoliBrokenBronzeBroomBrotherBrownBrushBubbleBuddyBudgetBuffaloBuildBulbBulkBulletBundleBunkerBurdenBurgerBurstBusBusinessBusyButterBuyerBuzzCabbageCabinCableCactusCageCakeCallCalmCameraCampCanCanalCancelCandyCannonCanoeCanvasCanyonCapableCapitalCaptainCarCarbonCardCargoCarpetCarryCartCaseCashCasinoCastleCasualCatCatalogCatchCategoryCattleCaughtCauseCautionCaveCeilingCeleryCementCensusCenturyCerealCertainChairChalkChampionChangeChaosChapterChargeChaseChatCheapCheckCheeseChefCherryChestChickenChiefChildChimneyChoiceChooseChronicChuckleChunkChurnCigarCinnamonCircleCitizenCityCivilClaimClapClarifyClawClayCleanClerkCleverClickClientCliffClimbClinicClipClockClogCloseClothCloudClownClubClumpClusterClutchCoachCoastCoconutCodeCoffeeCoilCoinCollectColorColumnCombineComeComfortComicCommonCompanyConcertConductConfirmCongressConnectConsiderControlConvinceCookCoolCopperCopyCoralCoreCornCorrectCostCottonCouchCountryCoupleCourseCousinCoverCoyoteCrackCradleCraftCramCraneCrashCraterCrawlCrazyCreamCreditCreekCrewCricketCrimeCrispCriticCropCrossCrouchCrowdCrucialCruelCruiseCrumbleCrunchCrushCryCrystalCubeCultureCupCupboardCuriousCurrentCurtainCurveCushionCustomCuteCycleDadDamageDampDanceDangerDaringDashDaughterDawnDayDealDebateDebrisDecadeDecemberDecideDeclineDecorateDecreaseDeerDefenseDefineDefyDegreeDelayDeliverDemandDemiseDenialDentistDenyDepartDependDepositDepthDeputyDeriveDescribeDesertDesignDeskDespairDestroyDetailDetectDevelopDeviceDevoteDiagramDialDiamondDiaryDiceDieselDietDifferDigitalDignityDilemmaDinnerDinosaurDirectDirtDisagreeDiscoverDiseaseDishDismissDisorderDisplayDistanceDivertDivideDivorceDizzyDoctorDocumentDogDollDolphinDomainDonateDonkeyDonorDoorDoseDoubleDoveDraftDragonDramaDrasticDrawDreamDressDriftDrillDrinkDripDriveDropDrumDryDuckDumbDuneDuringDustDutchDutyDwarfDynamicEagerEagleEarlyEarnEarthEasilyEastEasyEchoEcologyEconomyEdgeEditEducateEffortEggEightEitherElbowElderElectricElegantElementElephantElevatorEliteElseEmbarkEmbodyEmbraceEmergeEmotionEmployEmpowerEmptyEnableEnactEndEndlessEndorseEnemyEnergyEnforceEngageEngineEnhanceEnjoyEnlistEnoughEnrichEnrollEnsureEnterEntireEntryEnvelopeEpisodeEqualEquipEraEraseErodeErosionErrorEruptEscapeEssayEssenceEstateEternalEthicsEvidenceEvilEvokeEvolveExactExampleExcessExchangeExciteExcludeExcuseExecuteExerciseExhaustExhibitExileExistExitExoticExpandExpectExpireExplainExposeExpressExtendExtraEyeEyebrowFabricFaceFacultyFadeFaintFaithFallFalseFameFamilyFamousFanFancyFantasyFarmFashionFatFatalFatherFatigueFaultFavoriteFeatureFebruaryFederalFeeFeedFeelFemaleFenceFestivalFetchFeverFewFiberFictionFieldFigureFileFilmFilterFinalFindFineFingerFinishFireFirmFirstFiscalFishFitFitnessFixFlagFlameFlashFlatFlavorFleeFlightFlipFloatFlockFloorFlowerFluidFlushFlyFoamFocusFogFoilFoldFollowFoodFootForceForestForgetForkFortuneForumForwardFossilFosterFoundFoxFragileFrameFrequentFreshFriendFringeFrogFrontFrostFrownFrozenFruitFuelFunFunnyFurnaceFuryFutureGadgetGainGalaxyGalleryGameGapGarageGarbageGardenGarlicGarmentGasGaspGateGatherGaugeGazeGeneralGeniusGenreGentleGenuineGestureGhostGiantGiftGiggleGingerGiraffeGirlGiveGladGlanceGlareGlassGlideGlimpseGlobeGloomGloryGloveGlowGlueGoatGoddessGoldGoodGooseGorillaGospelGossipGovernGownGrabGraceGrainGrantGrapeGrassGravityGreatGreenGridGriefGritGroceryGroupGrowGruntGuardGuessGuideGuiltGuitarGunGymHabitHairHalfHammerHamsterHandHappyHarborHardHarshHarvestHatHaveHawkHazardHeadHealthHeartHeavyHedgehogHeightHelloHelmetHelpHenHeroHiddenHighHillHintHipHireHistoryHobbyHockeyHoldHoleHolidayHollowHomeHoneyHoodHopeHornHorrorHorseHospitalHostHotelHourHoverHubHugeHumanHumbleHumorHundredHungryHuntHurdleHurryHurtHusbandHybridIceIconIdeaIdentifyIdleIgnoreIllIllegalIllnessImageImitateImmenseImmuneImpactImposeImproveImpulseInchIncludeIncomeIncreaseIndexIndicateIndoorIndustryInfantInflictInformInhaleInheritInitialInjectInjuryInmateInnerInnocentInputInquiryInsaneInsectInsideInspireInstallIntactInterestIntoInvestInviteInvolveIronIslandIsolateIssueItemIvoryJacketJaguarJarJazzJealousJeansJellyJewelJobJoinJokeJourneyJoyJudgeJuiceJumpJungleJuniorJunkJustKangarooKeenKeepKetchupKeyKickKidKidneyKindKingdomKissKitKitchenKiteKittenKiwiKneeKnifeKnockKnowLabLabelLaborLadderLadyLakeLampLanguageLaptopLargeLaterLatinLaughLaundryLavaLawLawnLawsuitLayerLazyLeaderLeafLearnLeaveLectureLeftLegLegalLegendLeisureLemonLendLengthLensLeopardLessonLetterLevelLiarLibertyLibraryLicenseLifeLiftLightLikeLimbLimitLinkLionLiquidListLittleLiveLizardLoadLoanLobsterLocalLockLogicLonelyLongLoopLotteryLoudLoungeLoveLoyalLuckyLuggageLumberLunarLunchLuxuryLyricsMachineMadMagicMagnetMaidMailMainMajorMakeMammalManManageMandateMangoMansionManualMapleMarbleMarchMarginMarineMarketMarriageMaskMassMasterMatchMaterialMathMatrixMatterMaximumMazeMeadowMeanMeasureMeatMechanicMedalMediaMelodyMeltMemberMemoryMentionMenuMercyMergeMeritMerryMeshMessageMetalMethodMiddleMidnightMilkMillionMimicMindMinimumMinorMinuteMiracleMirrorMiseryMissMistakeMixMixedMixtureMobileModelModifyMomMomentMonitorMonkeyMonsterMonthMoonMoralMoreMorningMosquitoMotherMotionMotorMountainMouseMoveMovieMuchMuffinMuleMultiplyMuscleMuseumMushroomMusicMustMutualMyselfMysteryMythNaiveNameNapkinNarrowNastyNationNatureNearNeckNeedNegativeNeglectNeitherNephewNerveNestNetNetworkNeutralNeverNewsNextNiceNightNobleNoiseNomineeNoodleNormalNorthNoseNotableNoteNothingNoticeNovelNowNuclearNumberNurseNutOakObeyObjectObligeObscureObserveObtainObviousOccurOceanOctoberOdorOffOfferOfficeOftenOilOkayOldOliveOlympicOmitOnceOneOnionOnlineOnlyOpenOperaOpinionOpposeOptionOrangeOrbitOrchardOrderOrdinaryOrganOrientOriginalOrphanOstrichOtherOutdoorOuterOutputOutsideOvalOvenOverOwnOwnerOxygenOysterOzonePactPaddlePagePairPalacePalmPandaPanelPanicPantherPaperParadeParentParkParrotPartyPassPatchPathPatientPatrolPatternPausePavePaymentPeacePeanutPearPeasantPelicanPenPenaltyPencilPeoplePepperPerfectPermitPersonPetPhonePhotoPhrasePhysicalPianoPicnicPicturePiecePigPigeonPillPilotPinkPioneerPipePistolPitchPizzaPlacePlanetPlasticPlatePlayPleasePledgePluckPlugPlungePoemPoetPointPolarPolePolicePondPonyPoolPopularPortionPositionPossiblePostPotatoPotteryPovertyPowderPowerPracticePraisePredictPreferPreparePresentPrettyPreventPricePridePrimaryPrintPriorityPrisonPrivatePrizeProblemProcessProduceProfitProgramProjectPromoteProofPropertyProsperProtectProudProvidePublicPuddingPullPulpPulsePumpkinPunchPupilPuppyPurchasePurityPurposePursePushPutPuzzlePyramidQualityQuantumQuarterQuestionQuickQuitQuizQuoteRabbitRaccoonRaceRackRadarRadioRailRainRaiseRallyRampRanchRandomRangeRapidRareRateRatherRavenRawRazorReadyRealReasonRebelRebuildRecallReceiveRecipeRecordRecycleReduceReflectReformRefuseRegionRegretRegularRejectRelaxReleaseReliefRelyRemainRememberRemindRemoveRenderRenewRentReopenRepairRepeatReplaceReportRequireRescueResembleResistResourceResponseResultRetireRetreatReturnReunionRevealReviewRewardRhythmRibRibbonRiceRichRideRidgeRifleRightRigidRingRiotRippleRiskRitualRivalRiverRoadRoastRobotRobustRocketRomanceRoofRookieRoomRoseRotateRoughRoundRouteRoyalRubberRudeRugRuleRunRunwayRuralSadSaddleSadnessSafeSailSaladSalmonSalonSaltSaluteSameSampleSandSatisfySatoshiSauceSausageSaveSayScaleScanScareScatterSceneSchemeSchoolScienceScissorsScorpionScoutScrapScreenScriptScrubSeaSearchSeasonSeatSecondSecretSectionSecuritySeedSeekSegmentSelectSellSeminarSeniorSenseSentenceSeriesServiceSessionSettleSetupSevenShadowShaftShallowShareShedShellSheriffShieldShiftShineShipShiverShockShoeShootShopShortShoulderShoveShrimpShrugShuffleShySiblingSickSideSiegeSightSignSilentSilkSillySilverSimilarSimpleSinceSingSirenSisterSituateSixSizeSkateSketchSkiSkillSkinSkirtSkullSlabSlamSleepSlenderSliceSlideSlightSlimSloganSlotSlowSlushSmallSmartSmileSmokeSmoothSnackSnakeSnapSniffSnowSoapSoccerSocialSockSodaSoftSolarSoldierSolidSolutionSolveSomeoneSongSoonSorrySortSoulSoundSoupSourceSouthSpaceSpareSpatialSpawnSpeakSpecialSpeedSpellSpendSphereSpiceSpiderSpikeSpinSpiritSplitSpoilSponsorSpoonSportSpotSpraySpreadSpringSpySquareSqueezeSquirrelStableStadiumStaffStageStairsStampStandStartStateStaySteakSteelStemStepStereoStickStillStingStockStomachStoneStoolStoryStoveStrategyStreetStrikeStrongStruggleStudentStuffStumbleStyleSubjectSubmitSubwaySuccessSuchSuddenSufferSugarSuggestSuitSummerSunSunnySunsetSuperSupplySupremeSureSurfaceSurgeSurpriseSurroundSurveySuspectSustainSwallowSwampSwapSwarmSwearSweetSwiftSwimSwingSwitchSwordSymbolSymptomSyrupSystemTableTackleTagTailTalentTalkTankTapeTargetTaskTasteTattooTaxiTeachTeamTellTenTenantTennisTentTermTestTextThankThatThemeThenTheoryThereTheyThingThisThoughtThreeThriveThrowThumbThunderTicketTideTigerTiltTimberTimeTinyTipTiredTissueTitleToastTobaccoTodayToddlerToeTogetherToiletTokenTomatoTomorrowToneTongueTonightToolToothTopTopicToppleTorchTornadoTortoiseTossTotalTouristTowardTowerTownToyTrackTradeTrafficTragicTrainTransferTrapTrashTravelTrayTreatTreeTrendTrialTribeTrickTriggerTrimTripTrophyTroubleTruckTrueTrulyTrumpetTrustTruthTryTubeTuitionTumbleTunaTunnelTurkeyTurnTurtleTwelveTwentyTwiceTwinTwistTwoTypeTypicalUglyUmbrellaUnableUnawareUncleUncoverUnderUndoUnfairUnfoldUnhappyUniformUniqueUnitUniverseUnknownUnlockUntilUnusualUnveilUpdateUpgradeUpholdUponUpperUpsetUrbanUrgeUsageUseUsedUsefulUselessUsualUtilityVacantVacuumVagueValidValleyValveVanVanishVaporVariousVastVaultVehicleVelvetVendorVentureVenueVerbVerifyVersionVeryVesselVeteranViableVibrantViciousVictoryVideoViewVillageVintageViolinVirtualVirusVisaVisitVisualVitalVividVocalVoiceVoidVolcanoVolumeVoteVoyageWageWagonWaitWalkWallWalnutWantWarfareWarmWarriorWashWaspWasteWaterWaveWayWealthWeaponWearWeaselWeatherWebWeddingWeekendWeirdWelcomeWestWetWhaleWhatWheatWheelWhenWhereWhipWhisperWideWidthWifeWildWillWinWindowWineWingWinkWinnerWinterWireWisdomWiseWishWitnessWolfWomanWonderWoodWoolWordWorkWorldWorryWorthWrapWreckWrestleWristWriteWrongYardYearYellowYouYoungYouthZebraZeroZoneZoo";
  let Eu = null;
  function Jw(t) {
    if (Eu == null && (Eu = eJ.replace(/([A-Z])/g, " $1").toLowerCase().substring(1).split(" "), Pf.check(t) !== "0x3c8acc1e7b08d8e76f9fda015ef48dc8c710a73cb7e0f77b2c18a9b5a7adde60")) throw Eu = null, new Error("BIP39 Wordlist for en (English) FAILED");
  }
  class tJ extends Pf {
    constructor() {
      super("en");
    }
    getWord(e) {
      return Jw(this), Eu[e];
    }
    getWordIndex(e) {
      return Jw(this), Eu.indexOf(e);
    }
  }
  const I7 = new tJ();
  Pf.register(I7);
  const Kw = {
    en: I7
  }, nJ = "hdnode/5.8.0", $u = new oe(nJ), rJ = ve.from("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"), iJ = gn("Bitcoin seed"), bc = 2147483648;
  function P7(t) {
    return (1 << t) - 1 << 8 - t;
  }
  function sJ(t) {
    return (1 << t) - 1;
  }
  function i0(t) {
    return xt(Ee(t), 32);
  }
  function Ww(t) {
    return pl.encode(Et([
      t,
      ln(Gs(Gs(t)), 0, 4)
    ]));
  }
  function Yy(t) {
    if (t == null) return Kw.en;
    if (typeof t == "string") {
      const e = Kw[t];
      return e == null && $u.throwArgumentError("unknown locale", "wordlist", t), e;
    }
    return t;
  }
  const ic = {}, ml = "m/44'/60'/0'/0/0";
  class Sr {
    constructor(e, n, r, i, s, o, a, c) {
      if (e !== ic) throw new Error("HDNode constructor cannot be called directly");
      if (n) {
        const l = new Ca(n);
        ge(this, "privateKey", l.privateKey), ge(this, "publicKey", l.compressedPublicKey);
      } else ge(this, "privateKey", null), ge(this, "publicKey", Ee(r));
      ge(this, "parentFingerprint", i), ge(this, "fingerprint", ln(C7(Gs(this.publicKey)), 0, 4)), ge(this, "address", Po(this.publicKey)), ge(this, "chainCode", s), ge(this, "index", o), ge(this, "depth", a), c == null ? (ge(this, "mnemonic", null), ge(this, "path", null)) : typeof c == "string" ? (ge(this, "mnemonic", null), ge(this, "path", c)) : (ge(this, "mnemonic", c), ge(this, "path", c.path));
    }
    get extendedKey() {
      if (this.depth >= 256) throw new Error("Depth too large!");
      return Ww(Et([
        this.privateKey != null ? "0x0488ADE4" : "0x0488B21E",
        Ee(this.depth),
        this.parentFingerprint,
        xt(Ee(this.index), 4),
        this.chainCode,
        this.privateKey != null ? Et([
          "0x00",
          this.privateKey
        ]) : this.publicKey
      ]));
    }
    neuter() {
      return new Sr(ic, null, this.publicKey, this.parentFingerprint, this.chainCode, this.index, this.depth, this.path);
    }
    _derive(e) {
      if (e > 4294967295) throw new Error("invalid index - " + String(e));
      let n = this.path;
      n && (n += "/" + (e & ~bc));
      const r = new Uint8Array(37);
      if (e & bc) {
        if (!this.privateKey) throw new Error("cannot derive child of neutered node");
        r.set(Ae(this.privateKey), 1), n && (n += "'");
      } else r.set(Ae(this.publicKey));
      for (let f = 24; f >= 0; f -= 8) r[33 + (f >> 3)] = e >> 24 - f & 255;
      const i = Ae(Zu(gl.sha512, this.chainCode, r)), s = i.slice(0, 32), o = i.slice(32);
      let a = null, c = null;
      this.privateKey ? a = i0(ve.from(s).add(this.privateKey).mod(rJ)) : c = new Ca(Ee(s))._addPoint(this.publicKey);
      let l = n;
      const u = this.mnemonic;
      return u && (l = Object.freeze({
        phrase: u.phrase,
        path: n,
        locale: u.locale || "en"
      })), new Sr(ic, a, c, this.fingerprint, i0(o), e, this.depth + 1, l);
    }
    derivePath(e) {
      const n = e.split("/");
      if (n.length === 0 || n[0] === "m" && this.depth !== 0) throw new Error("invalid path - " + e);
      n[0] === "m" && n.shift();
      let r = this;
      for (let i = 0; i < n.length; i++) {
        const s = n[i];
        if (s.match(/^[0-9]+'$/)) {
          const o = parseInt(s.substring(0, s.length - 1));
          if (o >= bc) throw new Error("invalid path index - " + s);
          r = r._derive(bc + o);
        } else if (s.match(/^[0-9]+$/)) {
          const o = parseInt(s);
          if (o >= bc) throw new Error("invalid path index - " + s);
          r = r._derive(o);
        } else throw new Error("invalid path component - " + s);
      }
      return r;
    }
    static _fromSeed(e, n) {
      const r = Ae(e);
      if (r.length < 16 || r.length > 64) throw new Error("invalid seed");
      const i = Ae(Zu(gl.sha512, iJ, r));
      return new Sr(ic, i0(i.slice(0, 32)), null, "0x00000000", i0(i.slice(32)), 0, 0, n);
    }
    static fromMnemonic(e, n, r) {
      return r = Yy(r), e = Ph(Ih(e, r), r), Sr._fromSeed(_7(e, n), {
        phrase: e,
        path: "m",
        locale: r.locale
      });
    }
    static fromSeed(e) {
      return Sr._fromSeed(e, null);
    }
    static fromExtendedKey(e) {
      const n = pl.decode(e);
      (n.length !== 82 || Ww(n.slice(0, 78)) !== e) && $u.throwArgumentError("invalid extended key", "extendedKey", "[REDACTED]");
      const r = n[4], i = Ee(n.slice(5, 9)), s = parseInt(Ee(n.slice(9, 13)).substring(2), 16), o = Ee(n.slice(13, 45)), a = n.slice(45, 78);
      switch (Ee(n.slice(0, 4))) {
        case "0x0488b21e":
        case "0x043587cf":
          return new Sr(ic, null, Ee(a), i, o, s, r, null);
        case "0x0488ade4":
        case "0x04358394 ":
          if (a[0] !== 0) break;
          return new Sr(ic, Ee(a.slice(1)), null, i, o, s, r, null);
      }
      return $u.throwArgumentError("invalid extended key", "extendedKey", "[REDACTED]");
    }
  }
  function _7(t, e) {
    e || (e = "");
    const n = gn("mnemonic" + e, is.NFKD);
    return qy(gn(t, is.NFKD), n, 2048, 64, "sha512");
  }
  function Ih(t, e) {
    e = Yy(e), $u.checkNormalize();
    const n = e.split(t);
    if (n.length % 3 !== 0) throw new Error("invalid mnemonic");
    const r = Ae(new Uint8Array(Math.ceil(11 * n.length / 8)));
    let i = 0;
    for (let l = 0; l < n.length; l++) {
      let u = e.getWordIndex(n[l].normalize("NFKD"));
      if (u === -1) throw new Error("invalid mnemonic");
      for (let f = 0; f < 11; f++) u & 1 << 10 - f && (r[i >> 3] |= 1 << 7 - i % 8), i++;
    }
    const s = 32 * n.length / 3, o = n.length / 3, a = P7(o);
    if ((Ae(Gs(r.slice(0, s / 8)))[0] & a) !== (r[r.length - 1] & a)) throw new Error("invalid checksum");
    return Ee(r.slice(0, s / 8));
  }
  function Ph(t, e) {
    if (e = Yy(e), t = Ae(t), t.length % 4 !== 0 || t.length < 16 || t.length > 32) throw new Error("invalid entropy");
    const n = [
      0
    ];
    let r = 11;
    for (let o = 0; o < t.length; o++) r > 8 ? (n[n.length - 1] <<= 8, n[n.length - 1] |= t[o], r -= 8) : (n[n.length - 1] <<= r, n[n.length - 1] |= t[o] >> 8 - r, n.push(t[o] & sJ(8 - r)), r += 3);
    const i = t.length / 4, s = Ae(Gs(t))[0] & P7(i);
    return n[n.length - 1] <<= i, n[n.length - 1] |= s >> 8 - i, e.join(n.map((o) => e.getWord(o)));
  }
  function oJ(t, e) {
    try {
      return Ih(t, e), true;
    } catch {
    }
    return false;
  }
  function aJ(t) {
    return (typeof t != "number" || t < 0 || t >= bc || t % 1) && $u.throwArgumentError("invalid account index", "index", t), `m/44'/60'/${t}'/0/0`;
  }
  const cJ = Object.freeze(Object.defineProperty({
    __proto__: null,
    HDNode: Sr,
    defaultPath: ml,
    entropyToMnemonic: Ph,
    getAccountPath: aJ,
    isValidMnemonic: oJ,
    mnemonicToEntropy: Ih,
    mnemonicToSeed: _7
  }, Symbol.toStringTag, {
    value: "Module"
  })), lJ = "random/5.8.0", c1 = new oe(lJ);
  function uJ() {
    if (typeof self < "u") return self;
    if (typeof window < "u") return window;
    if (typeof global < "u") return global;
    throw new Error("unable to locate global object");
  }
  const qw = uJ();
  let N0 = qw.crypto || qw.msCrypto;
  (!N0 || !N0.getRandomValues) && (c1.warn("WARNING: Missing strong random number source"), N0 = {
    getRandomValues: function(t) {
      return c1.throwError("no secure random source avaialble", oe.errors.UNSUPPORTED_OPERATION, {
        operation: "crypto.getRandomValues"
      });
    }
  });
  function Ic(t) {
    (t <= 0 || t > 1024 || t % 1 || t != t) && c1.throwArgumentError("invalid length", "length", t);
    const e = new Uint8Array(t);
    return N0.getRandomValues(e), Ae(e);
  }
  function fJ(t) {
    t = t.slice();
    for (let e = t.length - 1; e > 0; e--) {
      const n = Math.floor(Math.random() * (e + 1)), r = t[e];
      t[e] = t[n], t[n] = r;
    }
    return t;
  }
  const dJ = Object.freeze(Object.defineProperty({
    __proto__: null,
    randomBytes: Ic,
    shuffled: fJ
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  var R7 = {
    exports: {}
  };
  (function(t, e) {
    (function(n) {
      function r(T) {
        return parseInt(T) === T;
      }
      function i(T) {
        if (!r(T.length)) return false;
        for (var g = 0; g < T.length; g++) if (!r(T[g]) || T[g] < 0 || T[g] > 255) return false;
        return true;
      }
      function s(T, g) {
        if (T.buffer && ArrayBuffer.isView(T) && T.name === "Uint8Array") return g && (T.slice ? T = T.slice() : T = Array.prototype.slice.call(T)), T;
        if (Array.isArray(T)) {
          if (!i(T)) throw new Error("Array contains invalid value: " + T);
          return new Uint8Array(T);
        }
        if (r(T.length) && i(T)) return new Uint8Array(T);
        throw new Error("unsupported array-like object");
      }
      function o(T) {
        return new Uint8Array(T);
      }
      function a(T, g, F, ee, E) {
        (ee != null || E != null) && (T.slice ? T = T.slice(ee, E) : T = Array.prototype.slice.call(T, ee, E)), g.set(T, F);
      }
      var c = /* @__PURE__ */ function() {
        function T(F) {
          var ee = [], E = 0;
          for (F = encodeURI(F); E < F.length; ) {
            var Z = F.charCodeAt(E++);
            Z === 37 ? (ee.push(parseInt(F.substr(E, 2), 16)), E += 2) : ee.push(Z);
          }
          return s(ee);
        }
        function g(F) {
          for (var ee = [], E = 0; E < F.length; ) {
            var Z = F[E];
            Z < 128 ? (ee.push(String.fromCharCode(Z)), E++) : Z > 191 && Z < 224 ? (ee.push(String.fromCharCode((Z & 31) << 6 | F[E + 1] & 63)), E += 2) : (ee.push(String.fromCharCode((Z & 15) << 12 | (F[E + 1] & 63) << 6 | F[E + 2] & 63)), E += 3);
          }
          return ee.join("");
        }
        return {
          toBytes: T,
          fromBytes: g
        };
      }(), l = /* @__PURE__ */ function() {
        function T(ee) {
          for (var E = [], Z = 0; Z < ee.length; Z += 2) E.push(parseInt(ee.substr(Z, 2), 16));
          return E;
        }
        var g = "0123456789abcdef";
        function F(ee) {
          for (var E = [], Z = 0; Z < ee.length; Z++) {
            var k = ee[Z];
            E.push(g[(k & 240) >> 4] + g[k & 15]);
          }
          return E.join("");
        }
        return {
          toBytes: T,
          fromBytes: F
        };
      }(), u = {
        16: 10,
        24: 12,
        32: 14
      }, f = [
        1,
        2,
        4,
        8,
        16,
        32,
        64,
        128,
        27,
        54,
        108,
        216,
        171,
        77,
        154,
        47,
        94,
        188,
        99,
        198,
        151,
        53,
        106,
        212,
        179,
        125,
        250,
        239,
        197,
        145
      ], d = [
        99,
        124,
        119,
        123,
        242,
        107,
        111,
        197,
        48,
        1,
        103,
        43,
        254,
        215,
        171,
        118,
        202,
        130,
        201,
        125,
        250,
        89,
        71,
        240,
        173,
        212,
        162,
        175,
        156,
        164,
        114,
        192,
        183,
        253,
        147,
        38,
        54,
        63,
        247,
        204,
        52,
        165,
        229,
        241,
        113,
        216,
        49,
        21,
        4,
        199,
        35,
        195,
        24,
        150,
        5,
        154,
        7,
        18,
        128,
        226,
        235,
        39,
        178,
        117,
        9,
        131,
        44,
        26,
        27,
        110,
        90,
        160,
        82,
        59,
        214,
        179,
        41,
        227,
        47,
        132,
        83,
        209,
        0,
        237,
        32,
        252,
        177,
        91,
        106,
        203,
        190,
        57,
        74,
        76,
        88,
        207,
        208,
        239,
        170,
        251,
        67,
        77,
        51,
        133,
        69,
        249,
        2,
        127,
        80,
        60,
        159,
        168,
        81,
        163,
        64,
        143,
        146,
        157,
        56,
        245,
        188,
        182,
        218,
        33,
        16,
        255,
        243,
        210,
        205,
        12,
        19,
        236,
        95,
        151,
        68,
        23,
        196,
        167,
        126,
        61,
        100,
        93,
        25,
        115,
        96,
        129,
        79,
        220,
        34,
        42,
        144,
        136,
        70,
        238,
        184,
        20,
        222,
        94,
        11,
        219,
        224,
        50,
        58,
        10,
        73,
        6,
        36,
        92,
        194,
        211,
        172,
        98,
        145,
        149,
        228,
        121,
        231,
        200,
        55,
        109,
        141,
        213,
        78,
        169,
        108,
        86,
        244,
        234,
        101,
        122,
        174,
        8,
        186,
        120,
        37,
        46,
        28,
        166,
        180,
        198,
        232,
        221,
        116,
        31,
        75,
        189,
        139,
        138,
        112,
        62,
        181,
        102,
        72,
        3,
        246,
        14,
        97,
        53,
        87,
        185,
        134,
        193,
        29,
        158,
        225,
        248,
        152,
        17,
        105,
        217,
        142,
        148,
        155,
        30,
        135,
        233,
        206,
        85,
        40,
        223,
        140,
        161,
        137,
        13,
        191,
        230,
        66,
        104,
        65,
        153,
        45,
        15,
        176,
        84,
        187,
        22
      ], m = [
        82,
        9,
        106,
        213,
        48,
        54,
        165,
        56,
        191,
        64,
        163,
        158,
        129,
        243,
        215,
        251,
        124,
        227,
        57,
        130,
        155,
        47,
        255,
        135,
        52,
        142,
        67,
        68,
        196,
        222,
        233,
        203,
        84,
        123,
        148,
        50,
        166,
        194,
        35,
        61,
        238,
        76,
        149,
        11,
        66,
        250,
        195,
        78,
        8,
        46,
        161,
        102,
        40,
        217,
        36,
        178,
        118,
        91,
        162,
        73,
        109,
        139,
        209,
        37,
        114,
        248,
        246,
        100,
        134,
        104,
        152,
        22,
        212,
        164,
        92,
        204,
        93,
        101,
        182,
        146,
        108,
        112,
        72,
        80,
        253,
        237,
        185,
        218,
        94,
        21,
        70,
        87,
        167,
        141,
        157,
        132,
        144,
        216,
        171,
        0,
        140,
        188,
        211,
        10,
        247,
        228,
        88,
        5,
        184,
        179,
        69,
        6,
        208,
        44,
        30,
        143,
        202,
        63,
        15,
        2,
        193,
        175,
        189,
        3,
        1,
        19,
        138,
        107,
        58,
        145,
        17,
        65,
        79,
        103,
        220,
        234,
        151,
        242,
        207,
        206,
        240,
        180,
        230,
        115,
        150,
        172,
        116,
        34,
        231,
        173,
        53,
        133,
        226,
        249,
        55,
        232,
        28,
        117,
        223,
        110,
        71,
        241,
        26,
        113,
        29,
        41,
        197,
        137,
        111,
        183,
        98,
        14,
        170,
        24,
        190,
        27,
        252,
        86,
        62,
        75,
        198,
        210,
        121,
        32,
        154,
        219,
        192,
        254,
        120,
        205,
        90,
        244,
        31,
        221,
        168,
        51,
        136,
        7,
        199,
        49,
        177,
        18,
        16,
        89,
        39,
        128,
        236,
        95,
        96,
        81,
        127,
        169,
        25,
        181,
        74,
        13,
        45,
        229,
        122,
        159,
        147,
        201,
        156,
        239,
        160,
        224,
        59,
        77,
        174,
        42,
        245,
        176,
        200,
        235,
        187,
        60,
        131,
        83,
        153,
        97,
        23,
        43,
        4,
        126,
        186,
        119,
        214,
        38,
        225,
        105,
        20,
        99,
        85,
        33,
        12,
        125
      ], y = [
        3328402341,
        4168907908,
        4000806809,
        4135287693,
        4294111757,
        3597364157,
        3731845041,
        2445657428,
        1613770832,
        33620227,
        3462883241,
        1445669757,
        3892248089,
        3050821474,
        1303096294,
        3967186586,
        2412431941,
        528646813,
        2311702848,
        4202528135,
        4026202645,
        2992200171,
        2387036105,
        4226871307,
        1101901292,
        3017069671,
        1604494077,
        1169141738,
        597466303,
        1403299063,
        3832705686,
        2613100635,
        1974974402,
        3791519004,
        1033081774,
        1277568618,
        1815492186,
        2118074177,
        4126668546,
        2211236943,
        1748251740,
        1369810420,
        3521504564,
        4193382664,
        3799085459,
        2883115123,
        1647391059,
        706024767,
        134480908,
        2512897874,
        1176707941,
        2646852446,
        806885416,
        932615841,
        168101135,
        798661301,
        235341577,
        605164086,
        461406363,
        3756188221,
        3454790438,
        1311188841,
        2142417613,
        3933566367,
        302582043,
        495158174,
        1479289972,
        874125870,
        907746093,
        3698224818,
        3025820398,
        1537253627,
        2756858614,
        1983593293,
        3084310113,
        2108928974,
        1378429307,
        3722699582,
        1580150641,
        327451799,
        2790478837,
        3117535592,
        0,
        3253595436,
        1075847264,
        3825007647,
        2041688520,
        3059440621,
        3563743934,
        2378943302,
        1740553945,
        1916352843,
        2487896798,
        2555137236,
        2958579944,
        2244988746,
        3151024235,
        3320835882,
        1336584933,
        3992714006,
        2252555205,
        2588757463,
        1714631509,
        293963156,
        2319795663,
        3925473552,
        67240454,
        4269768577,
        2689618160,
        2017213508,
        631218106,
        1269344483,
        2723238387,
        1571005438,
        2151694528,
        93294474,
        1066570413,
        563977660,
        1882732616,
        4059428100,
        1673313503,
        2008463041,
        2950355573,
        1109467491,
        537923632,
        3858759450,
        4260623118,
        3218264685,
        2177748300,
        403442708,
        638784309,
        3287084079,
        3193921505,
        899127202,
        2286175436,
        773265209,
        2479146071,
        1437050866,
        4236148354,
        2050833735,
        3362022572,
        3126681063,
        840505643,
        3866325909,
        3227541664,
        427917720,
        2655997905,
        2749160575,
        1143087718,
        1412049534,
        999329963,
        193497219,
        2353415882,
        3354324521,
        1807268051,
        672404540,
        2816401017,
        3160301282,
        369822493,
        2916866934,
        3688947771,
        1681011286,
        1949973070,
        336202270,
        2454276571,
        201721354,
        1210328172,
        3093060836,
        2680341085,
        3184776046,
        1135389935,
        3294782118,
        965841320,
        831886756,
        3554993207,
        4068047243,
        3588745010,
        2345191491,
        1849112409,
        3664604599,
        26054028,
        2983581028,
        2622377682,
        1235855840,
        3630984372,
        2891339514,
        4092916743,
        3488279077,
        3395642799,
        4101667470,
        1202630377,
        268961816,
        1874508501,
        4034427016,
        1243948399,
        1546530418,
        941366308,
        1470539505,
        1941222599,
        2546386513,
        3421038627,
        2715671932,
        3899946140,
        1042226977,
        2521517021,
        1639824860,
        227249030,
        260737669,
        3765465232,
        2084453954,
        1907733956,
        3429263018,
        2420656344,
        100860677,
        4160157185,
        470683154,
        3261161891,
        1781871967,
        2924959737,
        1773779408,
        394692241,
        2579611992,
        974986535,
        664706745,
        3655459128,
        3958962195,
        731420851,
        571543859,
        3530123707,
        2849626480,
        126783113,
        865375399,
        765172662,
        1008606754,
        361203602,
        3387549984,
        2278477385,
        2857719295,
        1344809080,
        2782912378,
        59542671,
        1503764984,
        160008576,
        437062935,
        1707065306,
        3622233649,
        2218934982,
        3496503480,
        2185314755,
        697932208,
        1512910199,
        504303377,
        2075177163,
        2824099068,
        1841019862,
        739644986
      ], x = [
        2781242211,
        2230877308,
        2582542199,
        2381740923,
        234877682,
        3184946027,
        2984144751,
        1418839493,
        1348481072,
        50462977,
        2848876391,
        2102799147,
        434634494,
        1656084439,
        3863849899,
        2599188086,
        1167051466,
        2636087938,
        1082771913,
        2281340285,
        368048890,
        3954334041,
        3381544775,
        201060592,
        3963727277,
        1739838676,
        4250903202,
        3930435503,
        3206782108,
        4149453988,
        2531553906,
        1536934080,
        3262494647,
        484572669,
        2923271059,
        1783375398,
        1517041206,
        1098792767,
        49674231,
        1334037708,
        1550332980,
        4098991525,
        886171109,
        150598129,
        2481090929,
        1940642008,
        1398944049,
        1059722517,
        201851908,
        1385547719,
        1699095331,
        1587397571,
        674240536,
        2704774806,
        252314885,
        3039795866,
        151914247,
        908333586,
        2602270848,
        1038082786,
        651029483,
        1766729511,
        3447698098,
        2682942837,
        454166793,
        2652734339,
        1951935532,
        775166490,
        758520603,
        3000790638,
        4004797018,
        4217086112,
        4137964114,
        1299594043,
        1639438038,
        3464344499,
        2068982057,
        1054729187,
        1901997871,
        2534638724,
        4121318227,
        1757008337,
        0,
        750906861,
        1614815264,
        535035132,
        3363418545,
        3988151131,
        3201591914,
        1183697867,
        3647454910,
        1265776953,
        3734260298,
        3566750796,
        3903871064,
        1250283471,
        1807470800,
        717615087,
        3847203498,
        384695291,
        3313910595,
        3617213773,
        1432761139,
        2484176261,
        3481945413,
        283769337,
        100925954,
        2180939647,
        4037038160,
        1148730428,
        3123027871,
        3813386408,
        4087501137,
        4267549603,
        3229630528,
        2315620239,
        2906624658,
        3156319645,
        1215313976,
        82966005,
        3747855548,
        3245848246,
        1974459098,
        1665278241,
        807407632,
        451280895,
        251524083,
        1841287890,
        1283575245,
        337120268,
        891687699,
        801369324,
        3787349855,
        2721421207,
        3431482436,
        959321879,
        1469301956,
        4065699751,
        2197585534,
        1199193405,
        2898814052,
        3887750493,
        724703513,
        2514908019,
        2696962144,
        2551808385,
        3516813135,
        2141445340,
        1715741218,
        2119445034,
        2872807568,
        2198571144,
        3398190662,
        700968686,
        3547052216,
        1009259540,
        2041044702,
        3803995742,
        487983883,
        1991105499,
        1004265696,
        1449407026,
        1316239930,
        504629770,
        3683797321,
        168560134,
        1816667172,
        3837287516,
        1570751170,
        1857934291,
        4014189740,
        2797888098,
        2822345105,
        2754712981,
        936633572,
        2347923833,
        852879335,
        1133234376,
        1500395319,
        3084545389,
        2348912013,
        1689376213,
        3533459022,
        3762923945,
        3034082412,
        4205598294,
        133428468,
        634383082,
        2949277029,
        2398386810,
        3913789102,
        403703816,
        3580869306,
        2297460856,
        1867130149,
        1918643758,
        607656988,
        4049053350,
        3346248884,
        1368901318,
        600565992,
        2090982877,
        2632479860,
        557719327,
        3717614411,
        3697393085,
        2249034635,
        2232388234,
        2430627952,
        1115438654,
        3295786421,
        2865522278,
        3633334344,
        84280067,
        33027830,
        303828494,
        2747425121,
        1600795957,
        4188952407,
        3496589753,
        2434238086,
        1486471617,
        658119965,
        3106381470,
        953803233,
        334231800,
        3005978776,
        857870609,
        3151128937,
        1890179545,
        2298973838,
        2805175444,
        3056442267,
        574365214,
        2450884487,
        550103529,
        1233637070,
        4289353045,
        2018519080,
        2057691103,
        2399374476,
        4166623649,
        2148108681,
        387583245,
        3664101311,
        836232934,
        3330556482,
        3100665960,
        3280093505,
        2955516313,
        2002398509,
        287182607,
        3413881008,
        4238890068,
        3597515707,
        975967766
      ], w = [
        1671808611,
        2089089148,
        2006576759,
        2072901243,
        4061003762,
        1807603307,
        1873927791,
        3310653893,
        810573872,
        16974337,
        1739181671,
        729634347,
        4263110654,
        3613570519,
        2883997099,
        1989864566,
        3393556426,
        2191335298,
        3376449993,
        2106063485,
        4195741690,
        1508618841,
        1204391495,
        4027317232,
        2917941677,
        3563566036,
        2734514082,
        2951366063,
        2629772188,
        2767672228,
        1922491506,
        3227229120,
        3082974647,
        4246528509,
        2477669779,
        644500518,
        911895606,
        1061256767,
        4144166391,
        3427763148,
        878471220,
        2784252325,
        3845444069,
        4043897329,
        1905517169,
        3631459288,
        827548209,
        356461077,
        67897348,
        3344078279,
        593839651,
        3277757891,
        405286936,
        2527147926,
        84871685,
        2595565466,
        118033927,
        305538066,
        2157648768,
        3795705826,
        3945188843,
        661212711,
        2999812018,
        1973414517,
        152769033,
        2208177539,
        745822252,
        439235610,
        455947803,
        1857215598,
        1525593178,
        2700827552,
        1391895634,
        994932283,
        3596728278,
        3016654259,
        695947817,
        3812548067,
        795958831,
        2224493444,
        1408607827,
        3513301457,
        0,
        3979133421,
        543178784,
        4229948412,
        2982705585,
        1542305371,
        1790891114,
        3410398667,
        3201918910,
        961245753,
        1256100938,
        1289001036,
        1491644504,
        3477767631,
        3496721360,
        4012557807,
        2867154858,
        4212583931,
        1137018435,
        1305975373,
        861234739,
        2241073541,
        1171229253,
        4178635257,
        33948674,
        2139225727,
        1357946960,
        1011120188,
        2679776671,
        2833468328,
        1374921297,
        2751356323,
        1086357568,
        2408187279,
        2460827538,
        2646352285,
        944271416,
        4110742005,
        3168756668,
        3066132406,
        3665145818,
        560153121,
        271589392,
        4279952895,
        4077846003,
        3530407890,
        3444343245,
        202643468,
        322250259,
        3962553324,
        1608629855,
        2543990167,
        1154254916,
        389623319,
        3294073796,
        2817676711,
        2122513534,
        1028094525,
        1689045092,
        1575467613,
        422261273,
        1939203699,
        1621147744,
        2174228865,
        1339137615,
        3699352540,
        577127458,
        712922154,
        2427141008,
        2290289544,
        1187679302,
        3995715566,
        3100863416,
        339486740,
        3732514782,
        1591917662,
        186455563,
        3681988059,
        3762019296,
        844522546,
        978220090,
        169743370,
        1239126601,
        101321734,
        611076132,
        1558493276,
        3260915650,
        3547250131,
        2901361580,
        1655096418,
        2443721105,
        2510565781,
        3828863972,
        2039214713,
        3878868455,
        3359869896,
        928607799,
        1840765549,
        2374762893,
        3580146133,
        1322425422,
        2850048425,
        1823791212,
        1459268694,
        4094161908,
        3928346602,
        1706019429,
        2056189050,
        2934523822,
        135794696,
        3134549946,
        2022240376,
        628050469,
        779246638,
        472135708,
        2800834470,
        3032970164,
        3327236038,
        3894660072,
        3715932637,
        1956440180,
        522272287,
        1272813131,
        3185336765,
        2340818315,
        2323976074,
        1888542832,
        1044544574,
        3049550261,
        1722469478,
        1222152264,
        50660867,
        4127324150,
        236067854,
        1638122081,
        895445557,
        1475980887,
        3117443513,
        2257655686,
        3243809217,
        489110045,
        2662934430,
        3778599393,
        4162055160,
        2561878936,
        288563729,
        1773916777,
        3648039385,
        2391345038,
        2493985684,
        2612407707,
        505560094,
        2274497927,
        3911240169,
        3460925390,
        1442818645,
        678973480,
        3749357023,
        2358182796,
        2717407649,
        2306869641,
        219617805,
        3218761151,
        3862026214,
        1120306242,
        1756942440,
        1103331905,
        2578459033,
        762796589,
        252780047,
        2966125488,
        1425844308,
        3151392187,
        372911126
      ], R = [
        1667474886,
        2088535288,
        2004326894,
        2071694838,
        4075949567,
        1802223062,
        1869591006,
        3318043793,
        808472672,
        16843522,
        1734846926,
        724270422,
        4278065639,
        3621216949,
        2880169549,
        1987484396,
        3402253711,
        2189597983,
        3385409673,
        2105378810,
        4210693615,
        1499065266,
        1195886990,
        4042263547,
        2913856577,
        3570689971,
        2728590687,
        2947541573,
        2627518243,
        2762274643,
        1920112356,
        3233831835,
        3082273397,
        4261223649,
        2475929149,
        640051788,
        909531756,
        1061110142,
        4160160501,
        3435941763,
        875846760,
        2779116625,
        3857003729,
        4059105529,
        1903268834,
        3638064043,
        825316194,
        353713962,
        67374088,
        3351728789,
        589522246,
        3284360861,
        404236336,
        2526454071,
        84217610,
        2593830191,
        117901582,
        303183396,
        2155911963,
        3806477791,
        3958056653,
        656894286,
        2998062463,
        1970642922,
        151591698,
        2206440989,
        741110872,
        437923380,
        454765878,
        1852748508,
        1515908788,
        2694904667,
        1381168804,
        993742198,
        3604373943,
        3014905469,
        690584402,
        3823320797,
        791638366,
        2223281939,
        1398011302,
        3520161977,
        0,
        3991743681,
        538992704,
        4244381667,
        2981218425,
        1532751286,
        1785380564,
        3419096717,
        3200178535,
        960056178,
        1246420628,
        1280103576,
        1482221744,
        3486468741,
        3503319995,
        4025428677,
        2863326543,
        4227536621,
        1128514950,
        1296947098,
        859002214,
        2240123921,
        1162203018,
        4193849577,
        33687044,
        2139062782,
        1347481760,
        1010582648,
        2678045221,
        2829640523,
        1364325282,
        2745433693,
        1077985408,
        2408548869,
        2459086143,
        2644360225,
        943212656,
        4126475505,
        3166494563,
        3065430391,
        3671750063,
        555836226,
        269496352,
        4294908645,
        4092792573,
        3537006015,
        3452783745,
        202118168,
        320025894,
        3974901699,
        1600119230,
        2543297077,
        1145359496,
        387397934,
        3301201811,
        2812801621,
        2122220284,
        1027426170,
        1684319432,
        1566435258,
        421079858,
        1936954854,
        1616945344,
        2172753945,
        1330631070,
        3705438115,
        572679748,
        707427924,
        2425400123,
        2290647819,
        1179044492,
        4008585671,
        3099120491,
        336870440,
        3739122087,
        1583276732,
        185277718,
        3688593069,
        3772791771,
        842159716,
        976899700,
        168435220,
        1229577106,
        101059084,
        606366792,
        1549591736,
        3267517855,
        3553849021,
        2897014595,
        1650632388,
        2442242105,
        2509612081,
        3840161747,
        2038008818,
        3890688725,
        3368567691,
        926374254,
        1835907034,
        2374863873,
        3587531953,
        1313788572,
        2846482505,
        1819063512,
        1448540844,
        4109633523,
        3941213647,
        1701162954,
        2054852340,
        2930698567,
        134748176,
        3132806511,
        2021165296,
        623210314,
        774795868,
        471606328,
        2795958615,
        3031746419,
        3334885783,
        3907527627,
        3722280097,
        1953799400,
        522133822,
        1263263126,
        3183336545,
        2341176845,
        2324333839,
        1886425312,
        1044267644,
        3048588401,
        1718004428,
        1212733584,
        50529542,
        4143317495,
        235803164,
        1633788866,
        892690282,
        1465383342,
        3115962473,
        2256965911,
        3250673817,
        488449850,
        2661202215,
        3789633753,
        4177007595,
        2560144171,
        286339874,
        1768537042,
        3654906025,
        2391705863,
        2492770099,
        2610673197,
        505291324,
        2273808917,
        3924369609,
        3469625735,
        1431699370,
        673740880,
        3755965093,
        2358021891,
        2711746649,
        2307489801,
        218961690,
        3217021541,
        3873845719,
        1111672452,
        1751693520,
        1094828930,
        2576986153,
        757954394,
        252645662,
        2964376443,
        1414855848,
        3149649517,
        370555436
      ], O = [
        1374988112,
        2118214995,
        437757123,
        975658646,
        1001089995,
        530400753,
        2902087851,
        1273168787,
        540080725,
        2910219766,
        2295101073,
        4110568485,
        1340463100,
        3307916247,
        641025152,
        3043140495,
        3736164937,
        632953703,
        1172967064,
        1576976609,
        3274667266,
        2169303058,
        2370213795,
        1809054150,
        59727847,
        361929877,
        3211623147,
        2505202138,
        3569255213,
        1484005843,
        1239443753,
        2395588676,
        1975683434,
        4102977912,
        2572697195,
        666464733,
        3202437046,
        4035489047,
        3374361702,
        2110667444,
        1675577880,
        3843699074,
        2538681184,
        1649639237,
        2976151520,
        3144396420,
        4269907996,
        4178062228,
        1883793496,
        2403728665,
        2497604743,
        1383856311,
        2876494627,
        1917518562,
        3810496343,
        1716890410,
        3001755655,
        800440835,
        2261089178,
        3543599269,
        807962610,
        599762354,
        33778362,
        3977675356,
        2328828971,
        2809771154,
        4077384432,
        1315562145,
        1708848333,
        101039829,
        3509871135,
        3299278474,
        875451293,
        2733856160,
        92987698,
        2767645557,
        193195065,
        1080094634,
        1584504582,
        3178106961,
        1042385657,
        2531067453,
        3711829422,
        1306967366,
        2438237621,
        1908694277,
        67556463,
        1615861247,
        429456164,
        3602770327,
        2302690252,
        1742315127,
        2968011453,
        126454664,
        3877198648,
        2043211483,
        2709260871,
        2084704233,
        4169408201,
        0,
        159417987,
        841739592,
        504459436,
        1817866830,
        4245618683,
        260388950,
        1034867998,
        908933415,
        168810852,
        1750902305,
        2606453969,
        607530554,
        202008497,
        2472011535,
        3035535058,
        463180190,
        2160117071,
        1641816226,
        1517767529,
        470948374,
        3801332234,
        3231722213,
        1008918595,
        303765277,
        235474187,
        4069246893,
        766945465,
        337553864,
        1475418501,
        2943682380,
        4003061179,
        2743034109,
        4144047775,
        1551037884,
        1147550661,
        1543208500,
        2336434550,
        3408119516,
        3069049960,
        3102011747,
        3610369226,
        1113818384,
        328671808,
        2227573024,
        2236228733,
        3535486456,
        2935566865,
        3341394285,
        496906059,
        3702665459,
        226906860,
        2009195472,
        733156972,
        2842737049,
        294930682,
        1206477858,
        2835123396,
        2700099354,
        1451044056,
        573804783,
        2269728455,
        3644379585,
        2362090238,
        2564033334,
        2801107407,
        2776292904,
        3669462566,
        1068351396,
        742039012,
        1350078989,
        1784663195,
        1417561698,
        4136440770,
        2430122216,
        775550814,
        2193862645,
        2673705150,
        1775276924,
        1876241833,
        3475313331,
        3366754619,
        270040487,
        3902563182,
        3678124923,
        3441850377,
        1851332852,
        3969562369,
        2203032232,
        3868552805,
        2868897406,
        566021896,
        4011190502,
        3135740889,
        1248802510,
        3936291284,
        699432150,
        832877231,
        708780849,
        3332740144,
        899835584,
        1951317047,
        4236429990,
        3767586992,
        866637845,
        4043610186,
        1106041591,
        2144161806,
        395441711,
        1984812685,
        1139781709,
        3433712980,
        3835036895,
        2664543715,
        1282050075,
        3240894392,
        1181045119,
        2640243204,
        25965917,
        4203181171,
        4211818798,
        3009879386,
        2463879762,
        3910161971,
        1842759443,
        2597806476,
        933301370,
        1509430414,
        3943906441,
        3467192302,
        3076639029,
        3776767469,
        2051518780,
        2631065433,
        1441952575,
        404016761,
        1942435775,
        1408749034,
        1610459739,
        3745345300,
        2017778566,
        3400528769,
        3110650942,
        941896748,
        3265478751,
        371049330,
        3168937228,
        675039627,
        4279080257,
        967311729,
        135050206,
        3635733660,
        1683407248,
        2076935265,
        3576870512,
        1215061108,
        3501741890
      ], B = [
        1347548327,
        1400783205,
        3273267108,
        2520393566,
        3409685355,
        4045380933,
        2880240216,
        2471224067,
        1428173050,
        4138563181,
        2441661558,
        636813900,
        4233094615,
        3620022987,
        2149987652,
        2411029155,
        1239331162,
        1730525723,
        2554718734,
        3781033664,
        46346101,
        310463728,
        2743944855,
        3328955385,
        3875770207,
        2501218972,
        3955191162,
        3667219033,
        768917123,
        3545789473,
        692707433,
        1150208456,
        1786102409,
        2029293177,
        1805211710,
        3710368113,
        3065962831,
        401639597,
        1724457132,
        3028143674,
        409198410,
        2196052529,
        1620529459,
        1164071807,
        3769721975,
        2226875310,
        486441376,
        2499348523,
        1483753576,
        428819965,
        2274680428,
        3075636216,
        598438867,
        3799141122,
        1474502543,
        711349675,
        129166120,
        53458370,
        2592523643,
        2782082824,
        4063242375,
        2988687269,
        3120694122,
        1559041666,
        730517276,
        2460449204,
        4042459122,
        2706270690,
        3446004468,
        3573941694,
        533804130,
        2328143614,
        2637442643,
        2695033685,
        839224033,
        1973745387,
        957055980,
        2856345839,
        106852767,
        1371368976,
        4181598602,
        1033297158,
        2933734917,
        1179510461,
        3046200461,
        91341917,
        1862534868,
        4284502037,
        605657339,
        2547432937,
        3431546947,
        2003294622,
        3182487618,
        2282195339,
        954669403,
        3682191598,
        1201765386,
        3917234703,
        3388507166,
        0,
        2198438022,
        1211247597,
        2887651696,
        1315723890,
        4227665663,
        1443857720,
        507358933,
        657861945,
        1678381017,
        560487590,
        3516619604,
        975451694,
        2970356327,
        261314535,
        3535072918,
        2652609425,
        1333838021,
        2724322336,
        1767536459,
        370938394,
        182621114,
        3854606378,
        1128014560,
        487725847,
        185469197,
        2918353863,
        3106780840,
        3356761769,
        2237133081,
        1286567175,
        3152976349,
        4255350624,
        2683765030,
        3160175349,
        3309594171,
        878443390,
        1988838185,
        3704300486,
        1756818940,
        1673061617,
        3403100636,
        272786309,
        1075025698,
        545572369,
        2105887268,
        4174560061,
        296679730,
        1841768865,
        1260232239,
        4091327024,
        3960309330,
        3497509347,
        1814803222,
        2578018489,
        4195456072,
        575138148,
        3299409036,
        446754879,
        3629546796,
        4011996048,
        3347532110,
        3252238545,
        4270639778,
        915985419,
        3483825537,
        681933534,
        651868046,
        2755636671,
        3828103837,
        223377554,
        2607439820,
        1649704518,
        3270937875,
        3901806776,
        1580087799,
        4118987695,
        3198115200,
        2087309459,
        2842678573,
        3016697106,
        1003007129,
        2802849917,
        1860738147,
        2077965243,
        164439672,
        4100872472,
        32283319,
        2827177882,
        1709610350,
        2125135846,
        136428751,
        3874428392,
        3652904859,
        3460984630,
        3572145929,
        3593056380,
        2939266226,
        824852259,
        818324884,
        3224740454,
        930369212,
        2801566410,
        2967507152,
        355706840,
        1257309336,
        4148292826,
        243256656,
        790073846,
        2373340630,
        1296297904,
        1422699085,
        3756299780,
        3818836405,
        457992840,
        3099667487,
        2135319889,
        77422314,
        1560382517,
        1945798516,
        788204353,
        1521706781,
        1385356242,
        870912086,
        325965383,
        2358957921,
        2050466060,
        2388260884,
        2313884476,
        4006521127,
        901210569,
        3990953189,
        1014646705,
        1503449823,
        1062597235,
        2031621326,
        3212035895,
        3931371469,
        1533017514,
        350174575,
        2256028891,
        2177544179,
        1052338372,
        741876788,
        1606591296,
        1914052035,
        213705253,
        2334669897,
        1107234197,
        1899603969,
        3725069491,
        2631447780,
        2422494913,
        1635502980,
        1893020342,
        1950903388,
        1120974935
      ], M = [
        2807058932,
        1699970625,
        2764249623,
        1586903591,
        1808481195,
        1173430173,
        1487645946,
        59984867,
        4199882800,
        1844882806,
        1989249228,
        1277555970,
        3623636965,
        3419915562,
        1149249077,
        2744104290,
        1514790577,
        459744698,
        244860394,
        3235995134,
        1963115311,
        4027744588,
        2544078150,
        4190530515,
        1608975247,
        2627016082,
        2062270317,
        1507497298,
        2200818878,
        567498868,
        1764313568,
        3359936201,
        2305455554,
        2037970062,
        1047239e3,
        1910319033,
        1337376481,
        2904027272,
        2892417312,
        984907214,
        1243112415,
        830661914,
        861968209,
        2135253587,
        2011214180,
        2927934315,
        2686254721,
        731183368,
        1750626376,
        4246310725,
        1820824798,
        4172763771,
        3542330227,
        48394827,
        2404901663,
        2871682645,
        671593195,
        3254988725,
        2073724613,
        145085239,
        2280796200,
        2779915199,
        1790575107,
        2187128086,
        472615631,
        3029510009,
        4075877127,
        3802222185,
        4107101658,
        3201631749,
        1646252340,
        4270507174,
        1402811438,
        1436590835,
        3778151818,
        3950355702,
        3963161475,
        4020912224,
        2667994737,
        273792366,
        2331590177,
        104699613,
        95345982,
        3175501286,
        2377486676,
        1560637892,
        3564045318,
        369057872,
        4213447064,
        3919042237,
        1137477952,
        2658625497,
        1119727848,
        2340947849,
        1530455833,
        4007360968,
        172466556,
        266959938,
        516552836,
        0,
        2256734592,
        3980931627,
        1890328081,
        1917742170,
        4294704398,
        945164165,
        3575528878,
        958871085,
        3647212047,
        2787207260,
        1423022939,
        775562294,
        1739656202,
        3876557655,
        2530391278,
        2443058075,
        3310321856,
        547512796,
        1265195639,
        437656594,
        3121275539,
        719700128,
        3762502690,
        387781147,
        218828297,
        3350065803,
        2830708150,
        2848461854,
        428169201,
        122466165,
        3720081049,
        1627235199,
        648017665,
        4122762354,
        1002783846,
        2117360635,
        695634755,
        3336358691,
        4234721005,
        4049844452,
        3704280881,
        2232435299,
        574624663,
        287343814,
        612205898,
        1039717051,
        840019705,
        2708326185,
        793451934,
        821288114,
        1391201670,
        3822090177,
        376187827,
        3113855344,
        1224348052,
        1679968233,
        2361698556,
        1058709744,
        752375421,
        2431590963,
        1321699145,
        3519142200,
        2734591178,
        188127444,
        2177869557,
        3727205754,
        2384911031,
        3215212461,
        2648976442,
        2450346104,
        3432737375,
        1180849278,
        331544205,
        3102249176,
        4150144569,
        2952102595,
        2159976285,
        2474404304,
        766078933,
        313773861,
        2570832044,
        2108100632,
        1668212892,
        3145456443,
        2013908262,
        418672217,
        3070356634,
        2594734927,
        1852171925,
        3867060991,
        3473416636,
        3907448597,
        2614737639,
        919489135,
        164948639,
        2094410160,
        2997825956,
        590424639,
        2486224549,
        1723872674,
        3157750862,
        3399941250,
        3501252752,
        3625268135,
        2555048196,
        3673637356,
        1343127501,
        4130281361,
        3599595085,
        2957853679,
        1297403050,
        81781910,
        3051593425,
        2283490410,
        532201772,
        1367295589,
        3926170974,
        895287692,
        1953757831,
        1093597963,
        492483431,
        3528626907,
        1446242576,
        1192455638,
        1636604631,
        209336225,
        344873464,
        1015671571,
        669961897,
        3375740769,
        3857572124,
        2973530695,
        3747192018,
        1933530610,
        3464042516,
        935293895,
        3454686199,
        2858115069,
        1863638845,
        3683022916,
        4085369519,
        3292445032,
        875313188,
        1080017571,
        3279033885,
        621591778,
        1233856572,
        2504130317,
        24197544,
        3017672716,
        3835484340,
        3247465558,
        2220981195,
        3060847922,
        1551124588,
        1463996600
      ], D = [
        4104605777,
        1097159550,
        396673818,
        660510266,
        2875968315,
        2638606623,
        4200115116,
        3808662347,
        821712160,
        1986918061,
        3430322568,
        38544885,
        3856137295,
        718002117,
        893681702,
        1654886325,
        2975484382,
        3122358053,
        3926825029,
        4274053469,
        796197571,
        1290801793,
        1184342925,
        3556361835,
        2405426947,
        2459735317,
        1836772287,
        1381620373,
        3196267988,
        1948373848,
        3764988233,
        3385345166,
        3263785589,
        2390325492,
        1480485785,
        3111247143,
        3780097726,
        2293045232,
        548169417,
        3459953789,
        3746175075,
        439452389,
        1362321559,
        1400849762,
        1685577905,
        1806599355,
        2174754046,
        137073913,
        1214797936,
        1174215055,
        3731654548,
        2079897426,
        1943217067,
        1258480242,
        529487843,
        1437280870,
        3945269170,
        3049390895,
        3313212038,
        923313619,
        679998e3,
        3215307299,
        57326082,
        377642221,
        3474729866,
        2041877159,
        133361907,
        1776460110,
        3673476453,
        96392454,
        878845905,
        2801699524,
        777231668,
        4082475170,
        2330014213,
        4142626212,
        2213296395,
        1626319424,
        1906247262,
        1846563261,
        562755902,
        3708173718,
        1040559837,
        3871163981,
        1418573201,
        3294430577,
        114585348,
        1343618912,
        2566595609,
        3186202582,
        1078185097,
        3651041127,
        3896688048,
        2307622919,
        425408743,
        3371096953,
        2081048481,
        1108339068,
        2216610296,
        0,
        2156299017,
        736970802,
        292596766,
        1517440620,
        251657213,
        2235061775,
        2933202493,
        758720310,
        265905162,
        1554391400,
        1532285339,
        908999204,
        174567692,
        1474760595,
        4002861748,
        2610011675,
        3234156416,
        3693126241,
        2001430874,
        303699484,
        2478443234,
        2687165888,
        585122620,
        454499602,
        151849742,
        2345119218,
        3064510765,
        514443284,
        4044981591,
        1963412655,
        2581445614,
        2137062819,
        19308535,
        1928707164,
        1715193156,
        4219352155,
        1126790795,
        600235211,
        3992742070,
        3841024952,
        836553431,
        1669664834,
        2535604243,
        3323011204,
        1243905413,
        3141400786,
        4180808110,
        698445255,
        2653899549,
        2989552604,
        2253581325,
        3252932727,
        3004591147,
        1891211689,
        2487810577,
        3915653703,
        4237083816,
        4030667424,
        2100090966,
        865136418,
        1229899655,
        953270745,
        3399679628,
        3557504664,
        4118925222,
        2061379749,
        3079546586,
        2915017791,
        983426092,
        2022837584,
        1607244650,
        2118541908,
        2366882550,
        3635996816,
        972512814,
        3283088770,
        1568718495,
        3499326569,
        3576539503,
        621982671,
        2895723464,
        410887952,
        2623762152,
        1002142683,
        645401037,
        1494807662,
        2595684844,
        1335535747,
        2507040230,
        4293295786,
        3167684641,
        367585007,
        3885750714,
        1865862730,
        2668221674,
        2960971305,
        2763173681,
        1059270954,
        2777952454,
        2724642869,
        1320957812,
        2194319100,
        2429595872,
        2815956275,
        77089521,
        3973773121,
        3444575871,
        2448830231,
        1305906550,
        4021308739,
        2857194700,
        2516901860,
        3518358430,
        1787304780,
        740276417,
        1699839814,
        1592394909,
        2352307457,
        2272556026,
        188821243,
        1729977011,
        3687994002,
        274084841,
        3594982253,
        3613494426,
        2701949495,
        4162096729,
        322734571,
        2837966542,
        1640576439,
        484830689,
        1202797690,
        3537852828,
        4067639125,
        349075736,
        3342319475,
        4157467219,
        4255800159,
        1030690015,
        1155237496,
        2951971274,
        1757691577,
        607398968,
        2738905026,
        499347990,
        3794078908,
        1011452712,
        227885567,
        2818666809,
        213114376,
        3034881240,
        1455525988,
        3414450555,
        850817237,
        1817998408,
        3092726480
      ], H = [
        0,
        235474187,
        470948374,
        303765277,
        941896748,
        908933415,
        607530554,
        708780849,
        1883793496,
        2118214995,
        1817866830,
        1649639237,
        1215061108,
        1181045119,
        1417561698,
        1517767529,
        3767586992,
        4003061179,
        4236429990,
        4069246893,
        3635733660,
        3602770327,
        3299278474,
        3400528769,
        2430122216,
        2664543715,
        2362090238,
        2193862645,
        2835123396,
        2801107407,
        3035535058,
        3135740889,
        3678124923,
        3576870512,
        3341394285,
        3374361702,
        3810496343,
        3977675356,
        4279080257,
        4043610186,
        2876494627,
        2776292904,
        3076639029,
        3110650942,
        2472011535,
        2640243204,
        2403728665,
        2169303058,
        1001089995,
        899835584,
        666464733,
        699432150,
        59727847,
        226906860,
        530400753,
        294930682,
        1273168787,
        1172967064,
        1475418501,
        1509430414,
        1942435775,
        2110667444,
        1876241833,
        1641816226,
        2910219766,
        2743034109,
        2976151520,
        3211623147,
        2505202138,
        2606453969,
        2302690252,
        2269728455,
        3711829422,
        3543599269,
        3240894392,
        3475313331,
        3843699074,
        3943906441,
        4178062228,
        4144047775,
        1306967366,
        1139781709,
        1374988112,
        1610459739,
        1975683434,
        2076935265,
        1775276924,
        1742315127,
        1034867998,
        866637845,
        566021896,
        800440835,
        92987698,
        193195065,
        429456164,
        395441711,
        1984812685,
        2017778566,
        1784663195,
        1683407248,
        1315562145,
        1080094634,
        1383856311,
        1551037884,
        101039829,
        135050206,
        437757123,
        337553864,
        1042385657,
        807962610,
        573804783,
        742039012,
        2531067453,
        2564033334,
        2328828971,
        2227573024,
        2935566865,
        2700099354,
        3001755655,
        3168937228,
        3868552805,
        3902563182,
        4203181171,
        4102977912,
        3736164937,
        3501741890,
        3265478751,
        3433712980,
        1106041591,
        1340463100,
        1576976609,
        1408749034,
        2043211483,
        2009195472,
        1708848333,
        1809054150,
        832877231,
        1068351396,
        766945465,
        599762354,
        159417987,
        126454664,
        361929877,
        463180190,
        2709260871,
        2943682380,
        3178106961,
        3009879386,
        2572697195,
        2538681184,
        2236228733,
        2336434550,
        3509871135,
        3745345300,
        3441850377,
        3274667266,
        3910161971,
        3877198648,
        4110568485,
        4211818798,
        2597806476,
        2497604743,
        2261089178,
        2295101073,
        2733856160,
        2902087851,
        3202437046,
        2968011453,
        3936291284,
        3835036895,
        4136440770,
        4169408201,
        3535486456,
        3702665459,
        3467192302,
        3231722213,
        2051518780,
        1951317047,
        1716890410,
        1750902305,
        1113818384,
        1282050075,
        1584504582,
        1350078989,
        168810852,
        67556463,
        371049330,
        404016761,
        841739592,
        1008918595,
        775550814,
        540080725,
        3969562369,
        3801332234,
        4035489047,
        4269907996,
        3569255213,
        3669462566,
        3366754619,
        3332740144,
        2631065433,
        2463879762,
        2160117071,
        2395588676,
        2767645557,
        2868897406,
        3102011747,
        3069049960,
        202008497,
        33778362,
        270040487,
        504459436,
        875451293,
        975658646,
        675039627,
        641025152,
        2084704233,
        1917518562,
        1615861247,
        1851332852,
        1147550661,
        1248802510,
        1484005843,
        1451044056,
        933301370,
        967311729,
        733156972,
        632953703,
        260388950,
        25965917,
        328671808,
        496906059,
        1206477858,
        1239443753,
        1543208500,
        1441952575,
        2144161806,
        1908694277,
        1675577880,
        1842759443,
        3610369226,
        3644379585,
        3408119516,
        3307916247,
        4011190502,
        3776767469,
        4077384432,
        4245618683,
        2809771154,
        2842737049,
        3144396420,
        3043140495,
        2673705150,
        2438237621,
        2203032232,
        2370213795
      ], q = [
        0,
        185469197,
        370938394,
        487725847,
        741876788,
        657861945,
        975451694,
        824852259,
        1483753576,
        1400783205,
        1315723890,
        1164071807,
        1950903388,
        2135319889,
        1649704518,
        1767536459,
        2967507152,
        3152976349,
        2801566410,
        2918353863,
        2631447780,
        2547432937,
        2328143614,
        2177544179,
        3901806776,
        3818836405,
        4270639778,
        4118987695,
        3299409036,
        3483825537,
        3535072918,
        3652904859,
        2077965243,
        1893020342,
        1841768865,
        1724457132,
        1474502543,
        1559041666,
        1107234197,
        1257309336,
        598438867,
        681933534,
        901210569,
        1052338372,
        261314535,
        77422314,
        428819965,
        310463728,
        3409685355,
        3224740454,
        3710368113,
        3593056380,
        3875770207,
        3960309330,
        4045380933,
        4195456072,
        2471224067,
        2554718734,
        2237133081,
        2388260884,
        3212035895,
        3028143674,
        2842678573,
        2724322336,
        4138563181,
        4255350624,
        3769721975,
        3955191162,
        3667219033,
        3516619604,
        3431546947,
        3347532110,
        2933734917,
        2782082824,
        3099667487,
        3016697106,
        2196052529,
        2313884476,
        2499348523,
        2683765030,
        1179510461,
        1296297904,
        1347548327,
        1533017514,
        1786102409,
        1635502980,
        2087309459,
        2003294622,
        507358933,
        355706840,
        136428751,
        53458370,
        839224033,
        957055980,
        605657339,
        790073846,
        2373340630,
        2256028891,
        2607439820,
        2422494913,
        2706270690,
        2856345839,
        3075636216,
        3160175349,
        3573941694,
        3725069491,
        3273267108,
        3356761769,
        4181598602,
        4063242375,
        4011996048,
        3828103837,
        1033297158,
        915985419,
        730517276,
        545572369,
        296679730,
        446754879,
        129166120,
        213705253,
        1709610350,
        1860738147,
        1945798516,
        2029293177,
        1239331162,
        1120974935,
        1606591296,
        1422699085,
        4148292826,
        4233094615,
        3781033664,
        3931371469,
        3682191598,
        3497509347,
        3446004468,
        3328955385,
        2939266226,
        2755636671,
        3106780840,
        2988687269,
        2198438022,
        2282195339,
        2501218972,
        2652609425,
        1201765386,
        1286567175,
        1371368976,
        1521706781,
        1805211710,
        1620529459,
        2105887268,
        1988838185,
        533804130,
        350174575,
        164439672,
        46346101,
        870912086,
        954669403,
        636813900,
        788204353,
        2358957921,
        2274680428,
        2592523643,
        2441661558,
        2695033685,
        2880240216,
        3065962831,
        3182487618,
        3572145929,
        3756299780,
        3270937875,
        3388507166,
        4174560061,
        4091327024,
        4006521127,
        3854606378,
        1014646705,
        930369212,
        711349675,
        560487590,
        272786309,
        457992840,
        106852767,
        223377554,
        1678381017,
        1862534868,
        1914052035,
        2031621326,
        1211247597,
        1128014560,
        1580087799,
        1428173050,
        32283319,
        182621114,
        401639597,
        486441376,
        768917123,
        651868046,
        1003007129,
        818324884,
        1503449823,
        1385356242,
        1333838021,
        1150208456,
        1973745387,
        2125135846,
        1673061617,
        1756818940,
        2970356327,
        3120694122,
        2802849917,
        2887651696,
        2637442643,
        2520393566,
        2334669897,
        2149987652,
        3917234703,
        3799141122,
        4284502037,
        4100872472,
        3309594171,
        3460984630,
        3545789473,
        3629546796,
        2050466060,
        1899603969,
        1814803222,
        1730525723,
        1443857720,
        1560382517,
        1075025698,
        1260232239,
        575138148,
        692707433,
        878443390,
        1062597235,
        243256656,
        91341917,
        409198410,
        325965383,
        3403100636,
        3252238545,
        3704300486,
        3620022987,
        3874428392,
        3990953189,
        4042459122,
        4227665663,
        2460449204,
        2578018489,
        2226875310,
        2411029155,
        3198115200,
        3046200461,
        2827177882,
        2743944855
      ], S = [
        0,
        218828297,
        437656594,
        387781147,
        875313188,
        958871085,
        775562294,
        590424639,
        1750626376,
        1699970625,
        1917742170,
        2135253587,
        1551124588,
        1367295589,
        1180849278,
        1265195639,
        3501252752,
        3720081049,
        3399941250,
        3350065803,
        3835484340,
        3919042237,
        4270507174,
        4085369519,
        3102249176,
        3051593425,
        2734591178,
        2952102595,
        2361698556,
        2177869557,
        2530391278,
        2614737639,
        3145456443,
        3060847922,
        2708326185,
        2892417312,
        2404901663,
        2187128086,
        2504130317,
        2555048196,
        3542330227,
        3727205754,
        3375740769,
        3292445032,
        3876557655,
        3926170974,
        4246310725,
        4027744588,
        1808481195,
        1723872674,
        1910319033,
        2094410160,
        1608975247,
        1391201670,
        1173430173,
        1224348052,
        59984867,
        244860394,
        428169201,
        344873464,
        935293895,
        984907214,
        766078933,
        547512796,
        1844882806,
        1627235199,
        2011214180,
        2062270317,
        1507497298,
        1423022939,
        1137477952,
        1321699145,
        95345982,
        145085239,
        532201772,
        313773861,
        830661914,
        1015671571,
        731183368,
        648017665,
        3175501286,
        2957853679,
        2807058932,
        2858115069,
        2305455554,
        2220981195,
        2474404304,
        2658625497,
        3575528878,
        3625268135,
        3473416636,
        3254988725,
        3778151818,
        3963161475,
        4213447064,
        4130281361,
        3599595085,
        3683022916,
        3432737375,
        3247465558,
        3802222185,
        4020912224,
        4172763771,
        4122762354,
        3201631749,
        3017672716,
        2764249623,
        2848461854,
        2331590177,
        2280796200,
        2431590963,
        2648976442,
        104699613,
        188127444,
        472615631,
        287343814,
        840019705,
        1058709744,
        671593195,
        621591778,
        1852171925,
        1668212892,
        1953757831,
        2037970062,
        1514790577,
        1463996600,
        1080017571,
        1297403050,
        3673637356,
        3623636965,
        3235995134,
        3454686199,
        4007360968,
        3822090177,
        4107101658,
        4190530515,
        2997825956,
        3215212461,
        2830708150,
        2779915199,
        2256734592,
        2340947849,
        2627016082,
        2443058075,
        172466556,
        122466165,
        273792366,
        492483431,
        1047239e3,
        861968209,
        612205898,
        695634755,
        1646252340,
        1863638845,
        2013908262,
        1963115311,
        1446242576,
        1530455833,
        1277555970,
        1093597963,
        1636604631,
        1820824798,
        2073724613,
        1989249228,
        1436590835,
        1487645946,
        1337376481,
        1119727848,
        164948639,
        81781910,
        331544205,
        516552836,
        1039717051,
        821288114,
        669961897,
        719700128,
        2973530695,
        3157750862,
        2871682645,
        2787207260,
        2232435299,
        2283490410,
        2667994737,
        2450346104,
        3647212047,
        3564045318,
        3279033885,
        3464042516,
        3980931627,
        3762502690,
        4150144569,
        4199882800,
        3070356634,
        3121275539,
        2904027272,
        2686254721,
        2200818878,
        2384911031,
        2570832044,
        2486224549,
        3747192018,
        3528626907,
        3310321856,
        3359936201,
        3950355702,
        3867060991,
        4049844452,
        4234721005,
        1739656202,
        1790575107,
        2108100632,
        1890328081,
        1402811438,
        1586903591,
        1233856572,
        1149249077,
        266959938,
        48394827,
        369057872,
        418672217,
        1002783846,
        919489135,
        567498868,
        752375421,
        209336225,
        24197544,
        376187827,
        459744698,
        945164165,
        895287692,
        574624663,
        793451934,
        1679968233,
        1764313568,
        2117360635,
        1933530610,
        1343127501,
        1560637892,
        1243112415,
        1192455638,
        3704280881,
        3519142200,
        3336358691,
        3419915562,
        3907448597,
        3857572124,
        4075877127,
        4294704398,
        3029510009,
        3113855344,
        2927934315,
        2744104290,
        2159976285,
        2377486676,
        2594734927,
        2544078150
      ], P = [
        0,
        151849742,
        303699484,
        454499602,
        607398968,
        758720310,
        908999204,
        1059270954,
        1214797936,
        1097159550,
        1517440620,
        1400849762,
        1817998408,
        1699839814,
        2118541908,
        2001430874,
        2429595872,
        2581445614,
        2194319100,
        2345119218,
        3034881240,
        3186202582,
        2801699524,
        2951971274,
        3635996816,
        3518358430,
        3399679628,
        3283088770,
        4237083816,
        4118925222,
        4002861748,
        3885750714,
        1002142683,
        850817237,
        698445255,
        548169417,
        529487843,
        377642221,
        227885567,
        77089521,
        1943217067,
        2061379749,
        1640576439,
        1757691577,
        1474760595,
        1592394909,
        1174215055,
        1290801793,
        2875968315,
        2724642869,
        3111247143,
        2960971305,
        2405426947,
        2253581325,
        2638606623,
        2487810577,
        3808662347,
        3926825029,
        4044981591,
        4162096729,
        3342319475,
        3459953789,
        3576539503,
        3693126241,
        1986918061,
        2137062819,
        1685577905,
        1836772287,
        1381620373,
        1532285339,
        1078185097,
        1229899655,
        1040559837,
        923313619,
        740276417,
        621982671,
        439452389,
        322734571,
        137073913,
        19308535,
        3871163981,
        4021308739,
        4104605777,
        4255800159,
        3263785589,
        3414450555,
        3499326569,
        3651041127,
        2933202493,
        2815956275,
        3167684641,
        3049390895,
        2330014213,
        2213296395,
        2566595609,
        2448830231,
        1305906550,
        1155237496,
        1607244650,
        1455525988,
        1776460110,
        1626319424,
        2079897426,
        1928707164,
        96392454,
        213114376,
        396673818,
        514443284,
        562755902,
        679998e3,
        865136418,
        983426092,
        3708173718,
        3557504664,
        3474729866,
        3323011204,
        4180808110,
        4030667424,
        3945269170,
        3794078908,
        2507040230,
        2623762152,
        2272556026,
        2390325492,
        2975484382,
        3092726480,
        2738905026,
        2857194700,
        3973773121,
        3856137295,
        4274053469,
        4157467219,
        3371096953,
        3252932727,
        3673476453,
        3556361835,
        2763173681,
        2915017791,
        3064510765,
        3215307299,
        2156299017,
        2307622919,
        2459735317,
        2610011675,
        2081048481,
        1963412655,
        1846563261,
        1729977011,
        1480485785,
        1362321559,
        1243905413,
        1126790795,
        878845905,
        1030690015,
        645401037,
        796197571,
        274084841,
        425408743,
        38544885,
        188821243,
        3613494426,
        3731654548,
        3313212038,
        3430322568,
        4082475170,
        4200115116,
        3780097726,
        3896688048,
        2668221674,
        2516901860,
        2366882550,
        2216610296,
        3141400786,
        2989552604,
        2837966542,
        2687165888,
        1202797690,
        1320957812,
        1437280870,
        1554391400,
        1669664834,
        1787304780,
        1906247262,
        2022837584,
        265905162,
        114585348,
        499347990,
        349075736,
        736970802,
        585122620,
        972512814,
        821712160,
        2595684844,
        2478443234,
        2293045232,
        2174754046,
        3196267988,
        3079546586,
        2895723464,
        2777952454,
        3537852828,
        3687994002,
        3234156416,
        3385345166,
        4142626212,
        4293295786,
        3841024952,
        3992742070,
        174567692,
        57326082,
        410887952,
        292596766,
        777231668,
        660510266,
        1011452712,
        893681702,
        1108339068,
        1258480242,
        1343618912,
        1494807662,
        1715193156,
        1865862730,
        1948373848,
        2100090966,
        2701949495,
        2818666809,
        3004591147,
        3122358053,
        2235061775,
        2352307457,
        2535604243,
        2653899549,
        3915653703,
        3764988233,
        4219352155,
        4067639125,
        3444575871,
        3294430577,
        3746175075,
        3594982253,
        836553431,
        953270745,
        600235211,
        718002117,
        367585007,
        484830689,
        133361907,
        251657213,
        2041877159,
        1891211689,
        1806599355,
        1654886325,
        1568718495,
        1418573201,
        1335535747,
        1184342925
      ];
      function L(T) {
        for (var g = [], F = 0; F < T.length; F += 4) g.push(T[F] << 24 | T[F + 1] << 16 | T[F + 2] << 8 | T[F + 3]);
        return g;
      }
      var K = function(T) {
        if (!(this instanceof K)) throw Error("AES must be instanitated with `new`");
        Object.defineProperty(this, "key", {
          value: s(T, true)
        }), this._prepare();
      };
      K.prototype._prepare = function() {
        var T = u[this.key.length];
        if (T == null) throw new Error("invalid key size (must be 16, 24 or 32 bytes)");
        this._Ke = [], this._Kd = [];
        for (var g = 0; g <= T; g++) this._Ke.push([
          0,
          0,
          0,
          0
        ]), this._Kd.push([
          0,
          0,
          0,
          0
        ]);
        for (var F = (T + 1) * 4, ee = this.key.length / 4, E = L(this.key), Z, g = 0; g < ee; g++) Z = g >> 2, this._Ke[Z][g % 4] = E[g], this._Kd[T - Z][g % 4] = E[g];
        for (var k = 0, X = ee, $; X < F; ) {
          if ($ = E[ee - 1], E[0] ^= d[$ >> 16 & 255] << 24 ^ d[$ >> 8 & 255] << 16 ^ d[$ & 255] << 8 ^ d[$ >> 24 & 255] ^ f[k] << 24, k += 1, ee != 8) for (var g = 1; g < ee; g++) E[g] ^= E[g - 1];
          else {
            for (var g = 1; g < ee / 2; g++) E[g] ^= E[g - 1];
            $ = E[ee / 2 - 1], E[ee / 2] ^= d[$ & 255] ^ d[$ >> 8 & 255] << 8 ^ d[$ >> 16 & 255] << 16 ^ d[$ >> 24 & 255] << 24;
            for (var g = ee / 2 + 1; g < ee; g++) E[g] ^= E[g - 1];
          }
          for (var g = 0, ce, fe; g < ee && X < F; ) ce = X >> 2, fe = X % 4, this._Ke[ce][fe] = E[g], this._Kd[T - ce][fe] = E[g++], X++;
        }
        for (var ce = 1; ce < T; ce++) for (var fe = 0; fe < 4; fe++) $ = this._Kd[ce][fe], this._Kd[ce][fe] = H[$ >> 24 & 255] ^ q[$ >> 16 & 255] ^ S[$ >> 8 & 255] ^ P[$ & 255];
      }, K.prototype.encrypt = function(T) {
        if (T.length != 16) throw new Error("invalid plaintext size (must be 16 bytes)");
        for (var g = this._Ke.length - 1, F = [
          0,
          0,
          0,
          0
        ], ee = L(T), E = 0; E < 4; E++) ee[E] ^= this._Ke[0][E];
        for (var Z = 1; Z < g; Z++) {
          for (var E = 0; E < 4; E++) F[E] = y[ee[E] >> 24 & 255] ^ x[ee[(E + 1) % 4] >> 16 & 255] ^ w[ee[(E + 2) % 4] >> 8 & 255] ^ R[ee[(E + 3) % 4] & 255] ^ this._Ke[Z][E];
          ee = F.slice();
        }
        for (var k = o(16), X, E = 0; E < 4; E++) X = this._Ke[g][E], k[4 * E] = (d[ee[E] >> 24 & 255] ^ X >> 24) & 255, k[4 * E + 1] = (d[ee[(E + 1) % 4] >> 16 & 255] ^ X >> 16) & 255, k[4 * E + 2] = (d[ee[(E + 2) % 4] >> 8 & 255] ^ X >> 8) & 255, k[4 * E + 3] = (d[ee[(E + 3) % 4] & 255] ^ X) & 255;
        return k;
      }, K.prototype.decrypt = function(T) {
        if (T.length != 16) throw new Error("invalid ciphertext size (must be 16 bytes)");
        for (var g = this._Kd.length - 1, F = [
          0,
          0,
          0,
          0
        ], ee = L(T), E = 0; E < 4; E++) ee[E] ^= this._Kd[0][E];
        for (var Z = 1; Z < g; Z++) {
          for (var E = 0; E < 4; E++) F[E] = O[ee[E] >> 24 & 255] ^ B[ee[(E + 3) % 4] >> 16 & 255] ^ M[ee[(E + 2) % 4] >> 8 & 255] ^ D[ee[(E + 1) % 4] & 255] ^ this._Kd[Z][E];
          ee = F.slice();
        }
        for (var k = o(16), X, E = 0; E < 4; E++) X = this._Kd[g][E], k[4 * E] = (m[ee[E] >> 24 & 255] ^ X >> 24) & 255, k[4 * E + 1] = (m[ee[(E + 3) % 4] >> 16 & 255] ^ X >> 16) & 255, k[4 * E + 2] = (m[ee[(E + 2) % 4] >> 8 & 255] ^ X >> 8) & 255, k[4 * E + 3] = (m[ee[(E + 1) % 4] & 255] ^ X) & 255;
        return k;
      };
      var z = function(T) {
        if (!(this instanceof z)) throw Error("AES must be instanitated with `new`");
        this.description = "Electronic Code Block", this.name = "ecb", this._aes = new K(T);
      };
      z.prototype.encrypt = function(T) {
        if (T = s(T), T.length % 16 !== 0) throw new Error("invalid plaintext size (must be multiple of 16 bytes)");
        for (var g = o(T.length), F = o(16), ee = 0; ee < T.length; ee += 16) a(T, F, 0, ee, ee + 16), F = this._aes.encrypt(F), a(F, g, ee);
        return g;
      }, z.prototype.decrypt = function(T) {
        if (T = s(T), T.length % 16 !== 0) throw new Error("invalid ciphertext size (must be multiple of 16 bytes)");
        for (var g = o(T.length), F = o(16), ee = 0; ee < T.length; ee += 16) a(T, F, 0, ee, ee + 16), F = this._aes.decrypt(F), a(F, g, ee);
        return g;
      };
      var I = function(T, g) {
        if (!(this instanceof I)) throw Error("AES must be instanitated with `new`");
        if (this.description = "Cipher Block Chaining", this.name = "cbc", !g) g = o(16);
        else if (g.length != 16) throw new Error("invalid initialation vector size (must be 16 bytes)");
        this._lastCipherblock = s(g, true), this._aes = new K(T);
      };
      I.prototype.encrypt = function(T) {
        if (T = s(T), T.length % 16 !== 0) throw new Error("invalid plaintext size (must be multiple of 16 bytes)");
        for (var g = o(T.length), F = o(16), ee = 0; ee < T.length; ee += 16) {
          a(T, F, 0, ee, ee + 16);
          for (var E = 0; E < 16; E++) F[E] ^= this._lastCipherblock[E];
          this._lastCipherblock = this._aes.encrypt(F), a(this._lastCipherblock, g, ee);
        }
        return g;
      }, I.prototype.decrypt = function(T) {
        if (T = s(T), T.length % 16 !== 0) throw new Error("invalid ciphertext size (must be multiple of 16 bytes)");
        for (var g = o(T.length), F = o(16), ee = 0; ee < T.length; ee += 16) {
          a(T, F, 0, ee, ee + 16), F = this._aes.decrypt(F);
          for (var E = 0; E < 16; E++) g[ee + E] = F[E] ^ this._lastCipherblock[E];
          a(T, this._lastCipherblock, 0, ee, ee + 16);
        }
        return g;
      };
      var h = function(T, g, F) {
        if (!(this instanceof h)) throw Error("AES must be instanitated with `new`");
        if (this.description = "Cipher Feedback", this.name = "cfb", !g) g = o(16);
        else if (g.length != 16) throw new Error("invalid initialation vector size (must be 16 size)");
        F || (F = 1), this.segmentSize = F, this._shiftRegister = s(g, true), this._aes = new K(T);
      };
      h.prototype.encrypt = function(T) {
        if (T.length % this.segmentSize != 0) throw new Error("invalid plaintext size (must be segmentSize bytes)");
        for (var g = s(T, true), F, ee = 0; ee < g.length; ee += this.segmentSize) {
          F = this._aes.encrypt(this._shiftRegister);
          for (var E = 0; E < this.segmentSize; E++) g[ee + E] ^= F[E];
          a(this._shiftRegister, this._shiftRegister, 0, this.segmentSize), a(g, this._shiftRegister, 16 - this.segmentSize, ee, ee + this.segmentSize);
        }
        return g;
      }, h.prototype.decrypt = function(T) {
        if (T.length % this.segmentSize != 0) throw new Error("invalid ciphertext size (must be segmentSize bytes)");
        for (var g = s(T, true), F, ee = 0; ee < g.length; ee += this.segmentSize) {
          F = this._aes.encrypt(this._shiftRegister);
          for (var E = 0; E < this.segmentSize; E++) g[ee + E] ^= F[E];
          a(this._shiftRegister, this._shiftRegister, 0, this.segmentSize), a(T, this._shiftRegister, 16 - this.segmentSize, ee, ee + this.segmentSize);
        }
        return g;
      };
      var p = function(T, g) {
        if (!(this instanceof p)) throw Error("AES must be instanitated with `new`");
        if (this.description = "Output Feedback", this.name = "ofb", !g) g = o(16);
        else if (g.length != 16) throw new Error("invalid initialation vector size (must be 16 bytes)");
        this._lastPrecipher = s(g, true), this._lastPrecipherIndex = 16, this._aes = new K(T);
      };
      p.prototype.encrypt = function(T) {
        for (var g = s(T, true), F = 0; F < g.length; F++) this._lastPrecipherIndex === 16 && (this._lastPrecipher = this._aes.encrypt(this._lastPrecipher), this._lastPrecipherIndex = 0), g[F] ^= this._lastPrecipher[this._lastPrecipherIndex++];
        return g;
      }, p.prototype.decrypt = p.prototype.encrypt;
      var A = function(T) {
        if (!(this instanceof A)) throw Error("Counter must be instanitated with `new`");
        T !== 0 && !T && (T = 1), typeof T == "number" ? (this._counter = o(16), this.setValue(T)) : this.setBytes(T);
      };
      A.prototype.setValue = function(T) {
        if (typeof T != "number" || parseInt(T) != T) throw new Error("invalid counter value (must be an integer)");
        for (var g = 15; g >= 0; --g) this._counter[g] = T % 256, T = T >> 8;
      }, A.prototype.setBytes = function(T) {
        if (T = s(T, true), T.length != 16) throw new Error("invalid counter bytes size (must be 16 bytes)");
        this._counter = T;
      }, A.prototype.increment = function() {
        for (var T = 15; T >= 0; T--) if (this._counter[T] === 255) this._counter[T] = 0;
        else {
          this._counter[T]++;
          break;
        }
      };
      var C = function(T, g) {
        if (!(this instanceof C)) throw Error("AES must be instanitated with `new`");
        this.description = "Counter", this.name = "ctr", g instanceof A || (g = new A(g)), this._counter = g, this._remainingCounter = null, this._remainingCounterIndex = 16, this._aes = new K(T);
      };
      C.prototype.encrypt = function(T) {
        for (var g = s(T, true), F = 0; F < g.length; F++) this._remainingCounterIndex === 16 && (this._remainingCounter = this._aes.encrypt(this._counter._counter), this._remainingCounterIndex = 0, this._counter.increment()), g[F] ^= this._remainingCounter[this._remainingCounterIndex++];
        return g;
      }, C.prototype.decrypt = C.prototype.encrypt;
      function N(T) {
        T = s(T, true);
        var g = 16 - T.length % 16, F = o(T.length + g);
        a(T, F);
        for (var ee = T.length; ee < F.length; ee++) F[ee] = g;
        return F;
      }
      function U(T) {
        if (T = s(T, true), T.length < 16) throw new Error("PKCS#7 invalid length");
        var g = T[T.length - 1];
        if (g > 16) throw new Error("PKCS#7 padding byte out of range");
        for (var F = T.length - g, ee = 0; ee < g; ee++) if (T[F + ee] !== g) throw new Error("PKCS#7 invalid padding byte");
        var E = o(F);
        return a(T, E, 0, 0, F), E;
      }
      var Y = {
        AES: K,
        Counter: A,
        ModeOfOperation: {
          ecb: z,
          cbc: I,
          cfb: h,
          ofb: p,
          ctr: C
        },
        utils: {
          hex: l,
          utf8: c
        },
        padding: {
          pkcs7: {
            pad: N,
            strip: U
          }
        },
        _arrayTest: {
          coerceArray: s,
          createArray: o,
          copyArray: a
        }
      };
      t.exports = Y;
    })();
  })(R7);
  var hJ = R7.exports;
  const Ji = Js(hJ), N7 = "json-wallets/5.8.0";
  function Ia(t) {
    return typeof t == "string" && t.substring(0, 2) !== "0x" && (t = "0x" + t), Ae(t);
  }
  function Kl(t, e) {
    for (t = String(t); t.length < e; ) t = "0" + t;
    return t;
  }
  function Xy(t) {
    return typeof t == "string" ? gn(t, is.NFKC) : Ae(t);
  }
  function an(t, e) {
    let n = t;
    const r = e.toLowerCase().split("/");
    for (let i = 0; i < r.length; i++) {
      let s = null;
      for (const o in n) if (o.toLowerCase() === r[i]) {
        s = n[o];
        break;
      }
      if (s === null) return null;
      n = s;
    }
    return n;
  }
  function pJ(t) {
    const e = Ae(t);
    e[6] = e[6] & 15 | 64, e[8] = e[8] & 63 | 128;
    const n = Ee(e);
    return [
      n.substring(2, 10),
      n.substring(10, 14),
      n.substring(14, 18),
      n.substring(18, 22),
      n.substring(22, 34)
    ].join("-");
  }
  const gJ = new oe(N7);
  class mJ extends Uo {
    isCrowdsaleAccount(e) {
      return !!(e && e._isCrowdsaleAccount);
    }
  }
  function Zy(t, e) {
    const n = JSON.parse(t);
    e = Xy(e);
    const r = pt(an(n, "ethaddr")), i = Ia(an(n, "encseed"));
    (!i || i.length % 16 !== 0) && gJ.throwArgumentError("invalid encseed", "json", t);
    const s = Ae(qy(e, e, 2e3, 32, "sha256")).slice(0, 16), o = i.slice(0, 16), a = i.slice(16), c = new Ji.ModeOfOperation.cbc(s, o), l = Ji.padding.pkcs7.strip(Ae(c.decrypt(a)));
    let u = "";
    for (let m = 0; m < l.length; m++) u += String.fromCharCode(l[m]);
    const f = gn(u), d = mt(f);
    return new mJ({
      _isCrowdsaleAccount: true,
      address: r,
      privateKey: d
    });
  }
  function _h(t) {
    let e = null;
    try {
      e = JSON.parse(t);
    } catch {
      return false;
    }
    return e.encseed && e.ethaddr;
  }
  function Rh(t) {
    let e = null;
    try {
      e = JSON.parse(t);
    } catch {
      return false;
    }
    return !(!e.version || parseInt(e.version) !== e.version || parseInt(e.version) !== 3);
  }
  function yJ(t) {
    if (_h(t)) try {
      return pt(JSON.parse(t).ethaddr);
    } catch {
      return null;
    }
    if (Rh(t)) try {
      return pt(JSON.parse(t).address);
    } catch {
      return null;
    }
    return null;
  }
  var O7 = {
    exports: {}
  };
  (function(t, e) {
    (function(n) {
      function i(x) {
        const w = new Uint32Array([
          1116352408,
          1899447441,
          3049323471,
          3921009573,
          961987163,
          1508970993,
          2453635748,
          2870763221,
          3624381080,
          310598401,
          607225278,
          1426881987,
          1925078388,
          2162078206,
          2614888103,
          3248222580,
          3835390401,
          4022224774,
          264347078,
          604807628,
          770255983,
          1249150122,
          1555081692,
          1996064986,
          2554220882,
          2821834349,
          2952996808,
          3210313671,
          3336571891,
          3584528711,
          113926993,
          338241895,
          666307205,
          773529912,
          1294757372,
          1396182291,
          1695183700,
          1986661051,
          2177026350,
          2456956037,
          2730485921,
          2820302411,
          3259730800,
          3345764771,
          3516065817,
          3600352804,
          4094571909,
          275423344,
          430227734,
          506948616,
          659060556,
          883997877,
          958139571,
          1322822218,
          1537002063,
          1747873779,
          1955562222,
          2024104815,
          2227730452,
          2361852424,
          2428436474,
          2756734187,
          3204031479,
          3329325298
        ]);
        let R = 1779033703, O = 3144134277, B = 1013904242, M = 2773480762, D = 1359893119, H = 2600822924, q = 528734635, S = 1541459225;
        const P = new Uint32Array(64);
        function L(C) {
          let N = 0, U = C.length;
          for (; U >= 64; ) {
            let Y = R, T = O, g = B, F = M, ee = D, E = H, Z = q, k = S, X, $, ce, fe, G;
            for ($ = 0; $ < 16; $++) ce = N + $ * 4, P[$] = (C[ce] & 255) << 24 | (C[ce + 1] & 255) << 16 | (C[ce + 2] & 255) << 8 | C[ce + 3] & 255;
            for ($ = 16; $ < 64; $++) X = P[$ - 2], fe = (X >>> 17 | X << 15) ^ (X >>> 19 | X << 13) ^ X >>> 10, X = P[$ - 15], G = (X >>> 7 | X << 25) ^ (X >>> 18 | X << 14) ^ X >>> 3, P[$] = (fe + P[$ - 7] | 0) + (G + P[$ - 16] | 0) | 0;
            for ($ = 0; $ < 64; $++) fe = (((ee >>> 6 | ee << 26) ^ (ee >>> 11 | ee << 21) ^ (ee >>> 25 | ee << 7)) + (ee & E ^ ~ee & Z) | 0) + (k + (w[$] + P[$] | 0) | 0) | 0, G = ((Y >>> 2 | Y << 30) ^ (Y >>> 13 | Y << 19) ^ (Y >>> 22 | Y << 10)) + (Y & T ^ Y & g ^ T & g) | 0, k = Z, Z = E, E = ee, ee = F + fe | 0, F = g, g = T, T = Y, Y = fe + G | 0;
            R = R + Y | 0, O = O + T | 0, B = B + g | 0, M = M + F | 0, D = D + ee | 0, H = H + E | 0, q = q + Z | 0, S = S + k | 0, N += 64, U -= 64;
          }
        }
        L(x);
        let K, z = x.length % 64, I = x.length / 536870912 | 0, h = x.length << 3, p = z < 56 ? 56 : 120, A = x.slice(x.length - z, x.length);
        for (A.push(128), K = z + 1; K < p; K++) A.push(0);
        return A.push(I >>> 24 & 255), A.push(I >>> 16 & 255), A.push(I >>> 8 & 255), A.push(I >>> 0 & 255), A.push(h >>> 24 & 255), A.push(h >>> 16 & 255), A.push(h >>> 8 & 255), A.push(h >>> 0 & 255), L(A), [
          R >>> 24 & 255,
          R >>> 16 & 255,
          R >>> 8 & 255,
          R >>> 0 & 255,
          O >>> 24 & 255,
          O >>> 16 & 255,
          O >>> 8 & 255,
          O >>> 0 & 255,
          B >>> 24 & 255,
          B >>> 16 & 255,
          B >>> 8 & 255,
          B >>> 0 & 255,
          M >>> 24 & 255,
          M >>> 16 & 255,
          M >>> 8 & 255,
          M >>> 0 & 255,
          D >>> 24 & 255,
          D >>> 16 & 255,
          D >>> 8 & 255,
          D >>> 0 & 255,
          H >>> 24 & 255,
          H >>> 16 & 255,
          H >>> 8 & 255,
          H >>> 0 & 255,
          q >>> 24 & 255,
          q >>> 16 & 255,
          q >>> 8 & 255,
          q >>> 0 & 255,
          S >>> 24 & 255,
          S >>> 16 & 255,
          S >>> 8 & 255,
          S >>> 0 & 255
        ];
      }
      function s(x, w, R) {
        x = x.length <= 64 ? x : i(x);
        const O = 64 + w.length + 4, B = new Array(O), M = new Array(64);
        let D, H = [];
        for (D = 0; D < 64; D++) B[D] = 54;
        for (D = 0; D < x.length; D++) B[D] ^= x[D];
        for (D = 0; D < w.length; D++) B[64 + D] = w[D];
        for (D = O - 4; D < O; D++) B[D] = 0;
        for (D = 0; D < 64; D++) M[D] = 92;
        for (D = 0; D < x.length; D++) M[D] ^= x[D];
        function q() {
          for (let S = O - 1; S >= O - 4; S--) {
            if (B[S]++, B[S] <= 255) return;
            B[S] = 0;
          }
        }
        for (; R >= 32; ) q(), H = H.concat(i(M.concat(i(B)))), R -= 32;
        return R > 0 && (q(), H = H.concat(i(M.concat(i(B))).slice(0, R))), H;
      }
      function o(x, w, R, O, B) {
        let M;
        for (u(x, (2 * R - 1) * 16, B, 0, 16), M = 0; M < 2 * R; M++) l(x, M * 16, B, 16), c(B, O), u(B, 0, x, w + M * 16, 16);
        for (M = 0; M < R; M++) u(x, w + M * 2 * 16, x, M * 16, 16);
        for (M = 0; M < R; M++) u(x, w + (M * 2 + 1) * 16, x, (M + R) * 16, 16);
      }
      function a(x, w) {
        return x << w | x >>> 32 - w;
      }
      function c(x, w) {
        u(x, 0, w, 0, 16);
        for (let R = 8; R > 0; R -= 2) w[4] ^= a(w[0] + w[12], 7), w[8] ^= a(w[4] + w[0], 9), w[12] ^= a(w[8] + w[4], 13), w[0] ^= a(w[12] + w[8], 18), w[9] ^= a(w[5] + w[1], 7), w[13] ^= a(w[9] + w[5], 9), w[1] ^= a(w[13] + w[9], 13), w[5] ^= a(w[1] + w[13], 18), w[14] ^= a(w[10] + w[6], 7), w[2] ^= a(w[14] + w[10], 9), w[6] ^= a(w[2] + w[14], 13), w[10] ^= a(w[6] + w[2], 18), w[3] ^= a(w[15] + w[11], 7), w[7] ^= a(w[3] + w[15], 9), w[11] ^= a(w[7] + w[3], 13), w[15] ^= a(w[11] + w[7], 18), w[1] ^= a(w[0] + w[3], 7), w[2] ^= a(w[1] + w[0], 9), w[3] ^= a(w[2] + w[1], 13), w[0] ^= a(w[3] + w[2], 18), w[6] ^= a(w[5] + w[4], 7), w[7] ^= a(w[6] + w[5], 9), w[4] ^= a(w[7] + w[6], 13), w[5] ^= a(w[4] + w[7], 18), w[11] ^= a(w[10] + w[9], 7), w[8] ^= a(w[11] + w[10], 9), w[9] ^= a(w[8] + w[11], 13), w[10] ^= a(w[9] + w[8], 18), w[12] ^= a(w[15] + w[14], 7), w[13] ^= a(w[12] + w[15], 9), w[14] ^= a(w[13] + w[12], 13), w[15] ^= a(w[14] + w[13], 18);
        for (let R = 0; R < 16; ++R) x[R] += w[R];
      }
      function l(x, w, R, O) {
        for (let B = 0; B < O; B++) R[B] ^= x[w + B];
      }
      function u(x, w, R, O, B) {
        for (; B--; ) R[O++] = x[w++];
      }
      function f(x) {
        if (!x || typeof x.length != "number") return false;
        for (let w = 0; w < x.length; w++) {
          const R = x[w];
          if (typeof R != "number" || R % 1 || R < 0 || R >= 256) return false;
        }
        return true;
      }
      function d(x, w) {
        if (typeof x != "number" || x % 1) throw new Error("invalid " + w);
        return x;
      }
      function m(x, w, R, O, B, M, D) {
        if (R = d(R, "N"), O = d(O, "r"), B = d(B, "p"), M = d(M, "dkLen"), R === 0 || R & R - 1) throw new Error("N must be power of 2");
        if (R > 2147483647 / 128 / O) throw new Error("N too large");
        if (O > 2147483647 / 128 / B) throw new Error("r too large");
        if (!f(x)) throw new Error("password must be an array or buffer");
        if (x = Array.prototype.slice.call(x), !f(w)) throw new Error("salt must be an array or buffer");
        w = Array.prototype.slice.call(w);
        let H = s(x, w, B * 128 * O);
        const q = new Uint32Array(B * 32 * O);
        for (let ee = 0; ee < q.length; ee++) {
          const E = ee * 4;
          q[ee] = (H[E + 3] & 255) << 24 | (H[E + 2] & 255) << 16 | (H[E + 1] & 255) << 8 | (H[E + 0] & 255) << 0;
        }
        const S = new Uint32Array(64 * O), P = new Uint32Array(32 * O * R), L = 32 * O, K = new Uint32Array(16), z = new Uint32Array(16), I = B * R * 2;
        let h = 0, p = null, A = false, C = 0, N = 0, U, Y;
        const T = D ? parseInt(1e3 / O) : 4294967295, g = typeof setImmediate < "u" ? setImmediate : setTimeout, F = function() {
          if (A) return D(new Error("cancelled"), h / I);
          let ee;
          switch (C) {
            case 0:
              Y = N * 32 * O, u(q, Y, S, 0, L), C = 1, U = 0;
            case 1:
              ee = R - U, ee > T && (ee = T);
              for (let Z = 0; Z < ee; Z++) u(S, 0, P, (U + Z) * L, L), o(S, L, O, K, z);
              if (U += ee, h += ee, D) {
                const Z = parseInt(1e3 * h / I);
                if (Z !== p) {
                  if (A = D(null, h / I), A) break;
                  p = Z;
                }
              }
              if (U < R) break;
              U = 0, C = 2;
            case 2:
              ee = R - U, ee > T && (ee = T);
              for (let Z = 0; Z < ee; Z++) {
                const k = (2 * O - 1) * 16, X = S[k] & R - 1;
                l(P, X * L, S, L), o(S, L, O, K, z);
              }
              if (U += ee, h += ee, D) {
                const Z = parseInt(1e3 * h / I);
                if (Z !== p) {
                  if (A = D(null, h / I), A) break;
                  p = Z;
                }
              }
              if (U < R) break;
              if (u(S, 0, q, Y, L), N++, N < B) {
                C = 0;
                break;
              }
              H = [];
              for (let Z = 0; Z < q.length; Z++) H.push(q[Z] >> 0 & 255), H.push(q[Z] >> 8 & 255), H.push(q[Z] >> 16 & 255), H.push(q[Z] >> 24 & 255);
              const E = s(x, H, M);
              return D && D(null, 1, E), E;
          }
          D && g(F);
        };
        if (!D) for (; ; ) {
          const ee = F();
          if (ee != null) return ee;
        }
        F();
      }
      const y = {
        scrypt: function(x, w, R, O, B, M, D) {
          return new Promise(function(H, q) {
            let S = 0;
            D && D(0), m(x, w, R, O, B, M, function(P, L, K) {
              if (P) q(P);
              else if (K) D && S !== 1 && D(1), H(new Uint8Array(K));
              else if (D && L !== S) return S = L, D(L);
            });
          });
        },
        syncScrypt: function(x, w, R, O, B, M) {
          return new Uint8Array(m(x, w, R, O, B, M));
        }
      };
      t.exports = y;
    })();
  })(O7);
  var bJ = O7.exports;
  const $y = Js(bJ);
  var xJ = function(t, e, n, r) {
    function i(s) {
      return s instanceof n ? s : new n(function(o) {
        o(s);
      });
    }
    return new (n || (n = Promise))(function(s, o) {
      function a(u) {
        try {
          l(r.next(u));
        } catch (f) {
          o(f);
        }
      }
      function c(u) {
        try {
          l(r.throw(u));
        } catch (f) {
          o(f);
        }
      }
      function l(u) {
        u.done ? s(u.value) : i(u.value).then(a, c);
      }
      l((r = r.apply(t, e || [])).next());
    });
  };
  const l1 = new oe(N7);
  function Yw(t) {
    return t != null && t.mnemonic && t.mnemonic.phrase;
  }
  class AJ extends Uo {
    isKeystoreAccount(e) {
      return !!(e && e._isKeystoreAccount);
    }
  }
  function wJ(t, e, n) {
    if (an(t, "crypto/cipher") === "aes-128-ctr") {
      const i = Ia(an(t, "crypto/cipherparams/iv")), s = new Ji.Counter(i), o = new Ji.ModeOfOperation.ctr(e, s);
      return Ae(o.decrypt(n));
    }
    return null;
  }
  function B7(t, e) {
    const n = Ia(an(t, "crypto/ciphertext"));
    if (Ee(mt(Et([
      e.slice(16, 32),
      n
    ]))).substring(2) !== an(t, "crypto/mac").toLowerCase()) throw new Error("invalid password");
    const i = wJ(t, e.slice(0, 16), n);
    i || l1.throwError("unsupported cipher", oe.errors.UNSUPPORTED_OPERATION, {
      operation: "decrypt"
    });
    const s = e.slice(32, 64), o = Po(i);
    if (t.address) {
      let c = t.address.toLowerCase();
      if (c.substring(0, 2) !== "0x" && (c = "0x" + c), pt(c) !== o) throw new Error("address mismatch");
    }
    const a = {
      _isKeystoreAccount: true,
      address: o,
      privateKey: Ee(i)
    };
    if (an(t, "x-ethers/version") === "0.1") {
      const c = Ia(an(t, "x-ethers/mnemonicCiphertext")), l = Ia(an(t, "x-ethers/mnemonicCounter")), u = new Ji.Counter(l), f = new Ji.ModeOfOperation.ctr(s, u), d = an(t, "x-ethers/path") || ml, m = an(t, "x-ethers/locale") || "en", y = Ae(f.decrypt(c));
      try {
        const x = Ph(y, m), w = Sr.fromMnemonic(x, null, m).derivePath(d);
        if (w.privateKey != a.privateKey) throw new Error("mnemonic mismatch");
        a.mnemonic = w.mnemonic;
      } catch (x) {
        if (x.code !== oe.errors.INVALID_ARGUMENT || x.argument !== "wordlist") throw x;
      }
    }
    return new AJ(a);
  }
  function M7(t, e, n, r, i) {
    return Ae(qy(t, e, n, r, i));
  }
  function vJ(t, e, n, r, i) {
    return Promise.resolve(M7(t, e, n, r, i));
  }
  function k7(t, e, n, r, i) {
    const s = Xy(e), o = an(t, "crypto/kdf");
    if (o && typeof o == "string") {
      const a = function(c, l) {
        return l1.throwArgumentError("invalid key-derivation function parameters", c, l);
      };
      if (o.toLowerCase() === "scrypt") {
        const c = Ia(an(t, "crypto/kdfparams/salt")), l = parseInt(an(t, "crypto/kdfparams/n")), u = parseInt(an(t, "crypto/kdfparams/r")), f = parseInt(an(t, "crypto/kdfparams/p"));
        (!l || !u || !f) && a("kdf", o), l & l - 1 && a("N", l);
        const d = parseInt(an(t, "crypto/kdfparams/dklen"));
        return d !== 32 && a("dklen", d), r(s, c, l, u, f, 64, i);
      } else if (o.toLowerCase() === "pbkdf2") {
        const c = Ia(an(t, "crypto/kdfparams/salt"));
        let l = null;
        const u = an(t, "crypto/kdfparams/prf");
        u === "hmac-sha256" ? l = "sha256" : u === "hmac-sha512" ? l = "sha512" : a("prf", u);
        const f = parseInt(an(t, "crypto/kdfparams/c")), d = parseInt(an(t, "crypto/kdfparams/dklen"));
        return d !== 32 && a("dklen", d), n(s, c, f, d, l);
      }
    }
    return l1.throwArgumentError("unsupported key-derivation function", "kdf", o);
  }
  function F7(t, e) {
    const n = JSON.parse(t), r = k7(n, e, M7, $y.syncScrypt);
    return B7(n, r);
  }
  function L7(t, e, n) {
    return xJ(this, void 0, void 0, function* () {
      const r = JSON.parse(t), i = yield k7(r, e, vJ, $y.scrypt, n);
      return B7(r, i);
    });
  }
  function D7(t, e, n, r) {
    try {
      if (pt(t.address) !== Po(t.privateKey)) throw new Error("address/privateKey mismatch");
      if (Yw(t)) {
        const w = t.mnemonic;
        if (Sr.fromMnemonic(w.phrase, null, w.locale).derivePath(w.path || ml).privateKey != t.privateKey) throw new Error("mnemonic mismatch");
      }
    } catch (w) {
      return Promise.reject(w);
    }
    typeof n == "function" && !r && (r = n, n = {}), n || (n = {});
    const i = Ae(t.privateKey), s = Xy(e);
    let o = null, a = null, c = null;
    if (Yw(t)) {
      const w = t.mnemonic;
      o = Ae(Ih(w.phrase, w.locale || "en")), a = w.path || ml, c = w.locale || "en";
    }
    let l = n.client;
    l || (l = "ethers.js");
    let u = null;
    n.salt ? u = Ae(n.salt) : u = Ic(32);
    let f = null;
    if (n.iv) {
      if (f = Ae(n.iv), f.length !== 16) throw new Error("invalid iv");
    } else f = Ic(16);
    let d = null;
    if (n.uuid) {
      if (d = Ae(n.uuid), d.length !== 16) throw new Error("invalid uuid");
    } else d = Ic(16);
    let m = 1 << 17, y = 8, x = 1;
    return n.scrypt && (n.scrypt.N && (m = n.scrypt.N), n.scrypt.r && (y = n.scrypt.r), n.scrypt.p && (x = n.scrypt.p)), $y.scrypt(s, u, m, y, x, 64, r).then((w) => {
      w = Ae(w);
      const R = w.slice(0, 16), O = w.slice(16, 32), B = w.slice(32, 64), M = new Ji.Counter(f), D = new Ji.ModeOfOperation.ctr(R, M), H = Ae(D.encrypt(i)), q = mt(Et([
        O,
        H
      ])), S = {
        address: t.address.substring(2).toLowerCase(),
        id: pJ(d),
        version: 3,
        crypto: {
          cipher: "aes-128-ctr",
          cipherparams: {
            iv: Ee(f).substring(2)
          },
          ciphertext: Ee(H).substring(2),
          kdf: "scrypt",
          kdfparams: {
            salt: Ee(u).substring(2),
            n: m,
            dklen: 32,
            p: x,
            r: y
          },
          mac: q.substring(2)
        }
      };
      if (o) {
        const P = Ic(16), L = new Ji.Counter(P), K = new Ji.ModeOfOperation.ctr(B, L), z = Ae(K.encrypt(o)), I = /* @__PURE__ */ new Date(), h = I.getUTCFullYear() + "-" + Kl(I.getUTCMonth() + 1, 2) + "-" + Kl(I.getUTCDate(), 2) + "T" + Kl(I.getUTCHours(), 2) + "-" + Kl(I.getUTCMinutes(), 2) + "-" + Kl(I.getUTCSeconds(), 2) + ".0Z";
        S["x-ethers"] = {
          client: l,
          gethFilename: "UTC--" + h + "--" + S.address,
          mnemonicCounter: Ee(P).substring(2),
          mnemonicCiphertext: Ee(z).substring(2),
          path: a,
          locale: c,
          version: "0.1"
        };
      }
      return JSON.stringify(S);
    });
  }
  function U7(t, e, n) {
    if (_h(t)) {
      n && n(0);
      const r = Zy(t, e);
      return n && n(1), Promise.resolve(r);
    }
    return Rh(t) ? L7(t, e, n) : Promise.reject(new Error("invalid JSON wallet"));
  }
  function H7(t, e) {
    if (_h(t)) return Zy(t, e);
    if (Rh(t)) return F7(t, e);
    throw new Error("invalid JSON wallet");
  }
  const EJ = Object.freeze(Object.defineProperty({
    __proto__: null,
    decryptCrowdsale: Zy,
    decryptJsonWallet: U7,
    decryptJsonWalletSync: H7,
    decryptKeystore: L7,
    decryptKeystoreSync: F7,
    encryptKeystore: D7,
    getJsonWalletAddress: yJ,
    isCrowdsaleWallet: _h,
    isKeystoreWallet: Rh
  }, Symbol.toStringTag, {
    value: "Module"
  })), SJ = "wallet/5.8.0";
  var Xw = function(t, e, n, r) {
    function i(s) {
      return s instanceof n ? s : new n(function(o) {
        o(s);
      });
    }
    return new (n || (n = Promise))(function(s, o) {
      function a(u) {
        try {
          l(r.next(u));
        } catch (f) {
          o(f);
        }
      }
      function c(u) {
        try {
          l(r.throw(u));
        } catch (f) {
          o(f);
        }
      }
      function l(u) {
        u.done ? s(u.value) : i(u.value).then(a, c);
      }
      l((r = r.apply(t, e || [])).next());
    });
  };
  const sc = new oe(SJ);
  function TJ(t) {
    return t != null && st(t.privateKey, 32) && t.address != null;
  }
  function CJ(t) {
    const e = t.mnemonic;
    return e && e.phrase;
  }
  class da extends Il {
    constructor(e, n) {
      if (super(), TJ(e)) {
        const r = new Ca(e.privateKey);
        if (ge(this, "_signingKey", () => r), ge(this, "address", Po(this.publicKey)), this.address !== pt(e.address) && sc.throwArgumentError("privateKey/address mismatch", "privateKey", "[REDACTED]"), CJ(e)) {
          const i = e.mnemonic;
          ge(this, "_mnemonic", () => ({
            phrase: i.phrase,
            path: i.path || ml,
            locale: i.locale || "en"
          }));
          const s = this.mnemonic, o = Sr.fromMnemonic(s.phrase, null, s.locale).derivePath(s.path);
          Po(o.privateKey) !== this.address && sc.throwArgumentError("mnemonic/address mismatch", "privateKey", "[REDACTED]");
        } else ge(this, "_mnemonic", () => null);
      } else {
        if (Ca.isSigningKey(e)) e.curve !== "secp256k1" && sc.throwArgumentError("unsupported curve; must be secp256k1", "privateKey", "[REDACTED]"), ge(this, "_signingKey", () => e);
        else {
          typeof e == "string" && e.match(/^[0-9a-f]*$/i) && e.length === 64 && (e = "0x" + e);
          const r = new Ca(e);
          ge(this, "_signingKey", () => r);
        }
        ge(this, "_mnemonic", () => null), ge(this, "address", Po(this.publicKey));
      }
      n && !Tf.isProvider(n) && sc.throwArgumentError("invalid provider", "provider", n), ge(this, "provider", n || null);
    }
    get mnemonic() {
      return this._mnemonic();
    }
    get privateKey() {
      return this._signingKey().privateKey;
    }
    get publicKey() {
      return this._signingKey().publicKey;
    }
    getAddress() {
      return Promise.resolve(this.address);
    }
    connect(e) {
      return new da(this, e);
    }
    signTransaction(e) {
      return tn(e).then((n) => {
        n.from != null && (pt(n.from) !== this.address && sc.throwArgumentError("transaction from address mismatch", "transaction.from", e.from), delete n.from);
        const r = this._signingKey().signDigest(mt(a1(n)));
        return a1(n, r);
      });
    }
    signMessage(e) {
      return Xw(this, void 0, void 0, function* () {
        return Xm(this._signingKey().signDigest(Gy(e)));
      });
    }
    _signTypedData(e, n, r) {
      return Xw(this, void 0, void 0, function* () {
        const i = yield Mn.resolveNames(e, n, r, (s) => (this.provider == null && sc.throwError("cannot resolve ENS names without a provider", oe.errors.UNSUPPORTED_OPERATION, {
          operation: "resolveName",
          value: s
        }), this.provider.resolveName(s)));
        return Xm(this._signingKey().signDigest(Mn.hash(i.domain, n, i.value)));
      });
    }
    encrypt(e, n, r) {
      if (typeof n == "function" && !r && (r = n, n = {}), r && typeof r != "function") throw new Error("invalid callback");
      return n || (n = {}), D7(this, e, n, r);
    }
    static createRandom(e) {
      let n = Ic(16);
      e || (e = {}), e.extraEntropy && (n = Ae(ln(mt(Et([
        n,
        e.extraEntropy
      ])), 0, 16)));
      const r = Ph(n, e.locale);
      return da.fromMnemonic(r, e.path, e.locale);
    }
    static fromEncryptedJson(e, n, r) {
      return U7(e, n, r).then((i) => new da(i));
    }
    static fromEncryptedJsonSync(e, n) {
      return new da(H7(e, n));
    }
    static fromMnemonic(e, n, r) {
      return n || (n = ml), new da(Sr.fromMnemonic(e, null, r).derivePath(n));
    }
  }
  function IJ(t, e) {
    return If(Gy(t), e);
  }
  function PJ(t, e, n, r) {
    return If(Mn.hash(t, e, n), r);
  }
  const _J = Object.freeze(Object.defineProperty({
    __proto__: null,
    Wallet: da,
    verifyMessage: IJ,
    verifyTypedData: PJ
  }, Symbol.toStringTag, {
    value: "Module"
  })), RJ = "networks/5.8.0", Zw = new oe(RJ);
  function NJ(t) {
    return t && typeof t.renetwork == "function";
  }
  function ui(t) {
    const e = function(n, r) {
      r == null && (r = {});
      const i = [];
      if (n.InfuraProvider && r.infura !== "-") try {
        i.push(new n.InfuraProvider(t, r.infura));
      } catch {
      }
      if (n.EtherscanProvider && r.etherscan !== "-") try {
        i.push(new n.EtherscanProvider(t, r.etherscan));
      } catch {
      }
      if (n.AlchemyProvider && r.alchemy !== "-") try {
        i.push(new n.AlchemyProvider(t, r.alchemy));
      } catch {
      }
      if (n.PocketProvider && r.pocket !== "-") {
        const s = [
          "goerli",
          "ropsten",
          "rinkeby",
          "sepolia"
        ];
        try {
          const o = new n.PocketProvider(t, r.pocket);
          o.network && s.indexOf(o.network.name) === -1 && i.push(o);
        } catch {
        }
      }
      if (n.CloudflareProvider && r.cloudflare !== "-") try {
        i.push(new n.CloudflareProvider(t));
      } catch {
      }
      if (n.AnkrProvider && r.ankr !== "-") try {
        const s = [
          "ropsten"
        ], o = new n.AnkrProvider(t, r.ankr);
        o.network && s.indexOf(o.network.name) === -1 && i.push(o);
      } catch {
      }
      if (n.QuickNodeProvider && r.quicknode !== "-") try {
        i.push(new n.QuickNodeProvider(t, r.quicknode));
      } catch {
      }
      if (i.length === 0) return null;
      if (n.FallbackProvider) {
        let s = 1;
        return r.quorum != null ? s = r.quorum : t === "homestead" && (s = 2), new n.FallbackProvider(i, s);
      }
      return i[0];
    };
    return e.renetwork = function(n) {
      return ui(n);
    }, e;
  }
  function Ad(t, e) {
    const n = function(r, i) {
      return r.JsonRpcProvider ? new r.JsonRpcProvider(t, e) : null;
    };
    return n.renetwork = function(r) {
      return Ad(t, r);
    }, n;
  }
  const $w = {
    chainId: 1,
    ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
    name: "homestead",
    _defaultProvider: ui("homestead")
  }, ev = {
    chainId: 3,
    ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
    name: "ropsten",
    _defaultProvider: ui("ropsten")
  }, tv = {
    chainId: 63,
    name: "classicMordor",
    _defaultProvider: Ad("https://www.ethercluster.com/mordor", "classicMordor")
  }, s0 = {
    unspecified: {
      chainId: 0,
      name: "unspecified"
    },
    homestead: $w,
    mainnet: $w,
    morden: {
      chainId: 2,
      name: "morden"
    },
    ropsten: ev,
    testnet: ev,
    rinkeby: {
      chainId: 4,
      ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
      name: "rinkeby",
      _defaultProvider: ui("rinkeby")
    },
    kovan: {
      chainId: 42,
      name: "kovan",
      _defaultProvider: ui("kovan")
    },
    goerli: {
      chainId: 5,
      ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
      name: "goerli",
      _defaultProvider: ui("goerli")
    },
    kintsugi: {
      chainId: 1337702,
      name: "kintsugi"
    },
    sepolia: {
      chainId: 11155111,
      ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
      name: "sepolia",
      _defaultProvider: ui("sepolia")
    },
    holesky: {
      chainId: 17e3,
      name: "holesky",
      _defaultProvider: ui("holesky")
    },
    classic: {
      chainId: 61,
      name: "classic",
      _defaultProvider: Ad("https://www.ethercluster.com/etc", "classic")
    },
    classicMorden: {
      chainId: 62,
      name: "classicMorden"
    },
    classicMordor: tv,
    classicTestnet: tv,
    classicKotti: {
      chainId: 6,
      name: "classicKotti",
      _defaultProvider: Ad("https://www.ethercluster.com/kotti", "classicKotti")
    },
    xdai: {
      chainId: 100,
      name: "xdai"
    },
    matic: {
      chainId: 137,
      name: "matic",
      _defaultProvider: ui("matic")
    },
    maticmum: {
      chainId: 80001,
      name: "maticmum",
      _defaultProvider: ui("maticmum")
    },
    optimism: {
      chainId: 10,
      name: "optimism",
      _defaultProvider: ui("optimism")
    },
    "optimism-kovan": {
      chainId: 69,
      name: "optimism-kovan"
    },
    "optimism-goerli": {
      chainId: 420,
      name: "optimism-goerli"
    },
    "optimism-sepolia": {
      chainId: 11155420,
      name: "optimism-sepolia"
    },
    arbitrum: {
      chainId: 42161,
      name: "arbitrum"
    },
    "arbitrum-rinkeby": {
      chainId: 421611,
      name: "arbitrum-rinkeby"
    },
    "arbitrum-goerli": {
      chainId: 421613,
      name: "arbitrum-goerli"
    },
    "arbitrum-sepolia": {
      chainId: 421614,
      name: "arbitrum-sepolia"
    },
    bnb: {
      chainId: 56,
      name: "bnb"
    },
    bnbt: {
      chainId: 97,
      name: "bnbt"
    }
  };
  function OJ(t) {
    if (t == null) return null;
    if (typeof t == "number") {
      for (const r in s0) {
        const i = s0[r];
        if (i.chainId === t) return {
          name: i.name,
          chainId: i.chainId,
          ensAddress: i.ensAddress || null,
          _defaultProvider: i._defaultProvider || null
        };
      }
      return {
        chainId: t,
        name: "unknown"
      };
    }
    if (typeof t == "string") {
      const r = s0[t];
      return r == null ? null : {
        name: r.name,
        chainId: r.chainId,
        ensAddress: r.ensAddress,
        _defaultProvider: r._defaultProvider || null
      };
    }
    const e = s0[t.name];
    if (!e) return typeof t.chainId != "number" && Zw.throwArgumentError("invalid network chainId", "network", t), t;
    t.chainId !== 0 && t.chainId !== e.chainId && Zw.throwArgumentError("network chainId mismatch", "network", t);
    let n = t._defaultProvider || null;
    return n == null && e._defaultProvider && (NJ(e._defaultProvider) ? n = e._defaultProvider.renetwork(t) : n = e._defaultProvider), {
      name: t.name,
      chainId: e.chainId,
      ensAddress: t.ensAddress || e.ensAddress || null,
      _defaultProvider: n
    };
  }
  const BJ = "web/5.8.0";
  var MJ = function(t, e, n, r) {
    function i(s) {
      return s instanceof n ? s : new n(function(o) {
        o(s);
      });
    }
    return new (n || (n = Promise))(function(s, o) {
      function a(u) {
        try {
          l(r.next(u));
        } catch (f) {
          o(f);
        }
      }
      function c(u) {
        try {
          l(r.throw(u));
        } catch (f) {
          o(f);
        }
      }
      function l(u) {
        u.done ? s(u.value) : i(u.value).then(a, c);
      }
      l((r = r.apply(t, e || [])).next());
    });
  };
  function kJ(t, e) {
    return MJ(this, void 0, void 0, function* () {
      e == null && (e = {});
      const n = {
        method: e.method || "GET",
        headers: e.headers || {},
        body: e.body || void 0
      };
      if (e.skipFetchSetup !== true && (n.mode = "cors", n.cache = "no-cache", n.credentials = "same-origin", n.redirect = "follow", n.referrer = "client"), e.fetchOptions != null) {
        const o = e.fetchOptions;
        o.mode && (n.mode = o.mode), o.cache && (n.cache = o.cache), o.credentials && (n.credentials = o.credentials), o.redirect && (n.redirect = o.redirect), o.referrer && (n.referrer = o.referrer);
      }
      const r = yield fetch(t, n), i = yield r.arrayBuffer(), s = {};
      return r.headers.forEach ? r.headers.forEach((o, a) => {
        s[a.toLowerCase()] = o;
      }) : r.headers.keys().forEach((o) => {
        s[o.toLowerCase()] = r.headers.get(o);
      }), {
        headers: s,
        statusCode: r.status,
        statusMessage: r.statusText,
        body: Ae(new Uint8Array(i))
      };
    });
  }
  var FJ = function(t, e, n, r) {
    function i(s) {
      return s instanceof n ? s : new n(function(o) {
        o(s);
      });
    }
    return new (n || (n = Promise))(function(s, o) {
      function a(u) {
        try {
          l(r.next(u));
        } catch (f) {
          o(f);
        }
      }
      function c(u) {
        try {
          l(r.throw(u));
        } catch (f) {
          o(f);
        }
      }
      function l(u) {
        u.done ? s(u.value) : i(u.value).then(a, c);
      }
      l((r = r.apply(t, e || [])).next());
    });
  };
  const oi = new oe(BJ);
  function nv(t) {
    return new Promise((e) => {
      setTimeout(e, t);
    });
  }
  function co(t, e) {
    if (t == null) return null;
    if (typeof t == "string") return t;
    if (Ef(t)) {
      if (e && (e.split("/")[0] === "text" || e.split(";")[0].trim() === "application/json")) try {
        return Ho(t);
      } catch {
      }
      return Ee(t);
    }
    return t;
  }
  function LJ(t) {
    return gn(t.replace(/%([0-9a-f][0-9a-f])/gi, (e, n) => String.fromCharCode(parseInt(n, 16))));
  }
  function G7(t, e, n) {
    const r = typeof t == "object" && t.throttleLimit != null ? t.throttleLimit : 12;
    oi.assertArgument(r > 0 && r % 1 === 0, "invalid connection throttle limit", "connection.throttleLimit", r);
    const i = typeof t == "object" ? t.throttleCallback : null, s = typeof t == "object" && typeof t.throttleSlotInterval == "number" ? t.throttleSlotInterval : 100;
    oi.assertArgument(s > 0 && s % 1 === 0, "invalid connection throttle slot interval", "connection.throttleSlotInterval", s);
    const o = typeof t == "object" ? !!t.errorPassThrough : false, a = {};
    let c = null;
    const l = {
      method: "GET"
    };
    let u = false, f = 2 * 60 * 1e3;
    if (typeof t == "string") c = t;
    else if (typeof t == "object") {
      if ((t == null || t.url == null) && oi.throwArgumentError("missing URL", "connection.url", t), c = t.url, typeof t.timeout == "number" && t.timeout > 0 && (f = t.timeout), t.headers) for (const R in t.headers) a[R.toLowerCase()] = {
        key: R,
        value: String(t.headers[R])
      }, [
        "if-none-match",
        "if-modified-since"
      ].indexOf(R.toLowerCase()) >= 0 && (u = true);
      if (l.allowGzip = !!t.allowGzip, t.user != null && t.password != null) {
        c.substring(0, 6) !== "https:" && t.allowInsecureAuthentication !== true && oi.throwError("basic authentication requires a secure https url", oe.errors.INVALID_ARGUMENT, {
          argument: "url",
          url: c,
          user: t.user,
          password: "[REDACTED]"
        });
        const R = t.user + ":" + t.password;
        a.authorization = {
          key: "Authorization",
          value: "Basic " + Hy(gn(R))
        };
      }
      t.skipFetchSetup != null && (l.skipFetchSetup = !!t.skipFetchSetup), t.fetchOptions != null && (l.fetchOptions = bn(t.fetchOptions));
    }
    const d = new RegExp("^data:([^;:]*)?(;base64)?,(.*)$", "i"), m = c ? c.match(d) : null;
    if (m) try {
      const R = {
        statusCode: 200,
        statusMessage: "OK",
        headers: {
          "content-type": m[1] || "text/plain"
        },
        body: m[2] ? Uy(m[3]) : LJ(m[3])
      };
      let O = R.body;
      return n && (O = n(R.body, R)), Promise.resolve(O);
    } catch (R) {
      oi.throwError("processing response error", oe.errors.SERVER_ERROR, {
        body: co(m[1], m[2]),
        error: R,
        requestBody: null,
        requestMethod: "GET",
        url: c
      });
    }
    e && (l.method = "POST", l.body = e, a["content-type"] == null && (a["content-type"] = {
      key: "Content-Type",
      value: "application/octet-stream"
    }), a["content-length"] == null && (a["content-length"] = {
      key: "Content-Length",
      value: String(e.length)
    }));
    const y = {};
    Object.keys(a).forEach((R) => {
      const O = a[R];
      y[O.key] = O.value;
    }), l.headers = y;
    const x = function() {
      let R = null;
      return {
        promise: new Promise(function(M, D) {
          f && (R = setTimeout(() => {
            R != null && (R = null, D(oi.makeError("timeout", oe.errors.TIMEOUT, {
              requestBody: co(l.body, y["content-type"]),
              requestMethod: l.method,
              timeout: f,
              url: c
            })));
          }, f));
        }),
        cancel: function() {
          R != null && (clearTimeout(R), R = null);
        }
      };
    }(), w = function() {
      return FJ(this, void 0, void 0, function* () {
        for (let R = 0; R < r; R++) {
          let O = null;
          try {
            if (O = yield kJ(c, l), R < r) {
              if (O.statusCode === 301 || O.statusCode === 302) {
                const M = O.headers.location || "";
                if (l.method === "GET" && M.match(/^https:/)) {
                  c = O.headers.location;
                  continue;
                }
              } else if (O.statusCode === 429) {
                let M = true;
                if (i && (M = yield i(R, c)), M) {
                  let D = 0;
                  const H = O.headers["retry-after"];
                  typeof H == "string" && H.match(/^[1-9][0-9]*$/) ? D = parseInt(H) * 1e3 : D = s * parseInt(String(Math.random() * Math.pow(2, R))), yield nv(D);
                  continue;
                }
              }
            }
          } catch (M) {
            O = M.response, O == null && (x.cancel(), oi.throwError("missing response", oe.errors.SERVER_ERROR, {
              requestBody: co(l.body, y["content-type"]),
              requestMethod: l.method,
              serverError: M,
              url: c
            }));
          }
          let B = O.body;
          if (u && O.statusCode === 304 ? B = null : !o && (O.statusCode < 200 || O.statusCode >= 300) && (x.cancel(), oi.throwError("bad response", oe.errors.SERVER_ERROR, {
            status: O.statusCode,
            headers: O.headers,
            body: co(B, O.headers ? O.headers["content-type"] : null),
            requestBody: co(l.body, y["content-type"]),
            requestMethod: l.method,
            url: c
          })), n) try {
            const M = yield n(B, O);
            return x.cancel(), M;
          } catch (M) {
            if (M.throttleRetry && R < r) {
              let D = true;
              if (i && (D = yield i(R, c)), D) {
                const H = s * parseInt(String(Math.random() * Math.pow(2, R)));
                yield nv(H);
                continue;
              }
            }
            x.cancel(), oi.throwError("processing response error", oe.errors.SERVER_ERROR, {
              body: co(B, O.headers ? O.headers["content-type"] : null),
              error: M,
              requestBody: co(l.body, y["content-type"]),
              requestMethod: l.method,
              url: c
            });
          }
          return x.cancel(), B;
        }
        return oi.throwError("failed response", oe.errors.SERVER_ERROR, {
          requestBody: co(l.body, y["content-type"]),
          requestMethod: l.method,
          url: c
        });
      });
    }();
    return Promise.race([
      x.promise,
      w
    ]);
  }
  function Nh(t, e, n) {
    let r = (s, o) => {
      let a = null;
      if (s != null) try {
        a = JSON.parse(Ho(s));
      } catch (c) {
        oi.throwError("invalid JSON", oe.errors.SERVER_ERROR, {
          body: s,
          error: c
        });
      }
      return n && (a = n(a, o)), a;
    }, i = null;
    if (e != null) {
      i = gn(e);
      const s = typeof t == "string" ? {
        url: t
      } : bn(t);
      s.headers ? Object.keys(s.headers).filter((a) => a.toLowerCase() === "content-type").length !== 0 || (s.headers = bn(s.headers), s.headers["content-type"] = "application/json") : s.headers = {
        "content-type": "application/json"
      }, t = s;
    }
    return G7(t, i, r);
  }
  function Pc(t, e) {
    return e || (e = {}), e = bn(e), e.floor == null && (e.floor = 0), e.ceiling == null && (e.ceiling = 1e4), e.interval == null && (e.interval = 250), new Promise(function(n, r) {
      let i = null, s = false;
      const o = () => s ? false : (s = true, i && clearTimeout(i), true);
      e.timeout && (i = setTimeout(() => {
        o() && r(new Error("timeout"));
      }, e.timeout));
      const a = e.retryLimit;
      let c = 0;
      function l() {
        return t().then(function(u) {
          if (u !== void 0) o() && n(u);
          else if (e.oncePoll) e.oncePoll.once("poll", l);
          else if (e.onceBlock) e.onceBlock.once("block", l);
          else if (!s) {
            if (c++, c > a) {
              o() && r(new Error("retry limit reached"));
              return;
            }
            let f = e.interval * parseInt(String(Math.random() * Math.pow(2, c)));
            f < e.floor && (f = e.floor), f > e.ceiling && (f = e.ceiling), setTimeout(l, f);
          }
          return null;
        }, function(u) {
          o() && r(u);
        });
      }
      l();
    });
  }
  const DJ = Object.freeze(Object.defineProperty({
    __proto__: null,
    _fetchData: G7,
    fetchJson: Nh,
    poll: Pc
  }, Symbol.toStringTag, {
    value: "Module"
  }));
  var wd = "qpzry9x8gf2tvdw0s3jn54khce6mua7l", u1 = {};
  for (var o0 = 0; o0 < wd.length; o0++) {
    var _g = wd.charAt(o0);
    if (u1[_g] !== void 0) throw new TypeError(_g + " is ambiguous");
    u1[_g] = o0;
  }
  function Qc(t) {
    var e = t >> 25;
    return (t & 33554431) << 5 ^ -(e >> 0 & 1) & 996825010 ^ -(e >> 1 & 1) & 642813549 ^ -(e >> 2 & 1) & 513874426 ^ -(e >> 3 & 1) & 1027748829 ^ -(e >> 4 & 1) & 705979059;
  }
  function V7(t) {
    for (var e = 1, n = 0; n < t.length; ++n) {
      var r = t.charCodeAt(n);
      if (r < 33 || r > 126) return "Invalid prefix (" + t + ")";
      e = Qc(e) ^ r >> 5;
    }
    for (e = Qc(e), n = 0; n < t.length; ++n) {
      var i = t.charCodeAt(n);
      e = Qc(e) ^ i & 31;
    }
    return e;
  }
  function UJ(t, e, n) {
    if (n = n || 90, t.length + 7 + e.length > n) throw new TypeError("Exceeds length limit");
    t = t.toLowerCase();
    var r = V7(t);
    if (typeof r == "string") throw new Error(r);
    for (var i = t + "1", s = 0; s < e.length; ++s) {
      var o = e[s];
      if (o >> 5) throw new Error("Non 5-bit word");
      r = Qc(r) ^ o, i += wd.charAt(o);
    }
    for (s = 0; s < 6; ++s) r = Qc(r);
    for (r ^= 1, s = 0; s < 6; ++s) {
      var a = r >> (5 - s) * 5 & 31;
      i += wd.charAt(a);
    }
    return i;
  }
  function z7(t, e) {
    if (e = e || 90, t.length < 8) return t + " too short";
    if (t.length > e) return "Exceeds length limit";
    var n = t.toLowerCase(), r = t.toUpperCase();
    if (t !== n && t !== r) return "Mixed-case string " + t;
    t = n;
    var i = t.lastIndexOf("1");
    if (i === -1) return "No separator character for " + t;
    if (i === 0) return "Missing prefix for " + t;
    var s = t.slice(0, i), o = t.slice(i + 1);
    if (o.length < 6) return "Data too short";
    var a = V7(s);
    if (typeof a == "string") return a;
    for (var c = [], l = 0; l < o.length; ++l) {
      var u = o.charAt(l), f = u1[u];
      if (f === void 0) return "Unknown character " + u;
      a = Qc(a) ^ f, !(l + 6 >= o.length) && c.push(f);
    }
    return a !== 1 ? "Invalid checksum for " + t : {
      prefix: s,
      words: c
    };
  }
  function HJ() {
    var t = z7.apply(null, arguments);
    if (typeof t == "object") return t;
  }
  function GJ(t) {
    var e = z7.apply(null, arguments);
    if (typeof e == "object") return e;
    throw new Error(e);
  }
  function Oh(t, e, n, r) {
    for (var i = 0, s = 0, o = (1 << n) - 1, a = [], c = 0; c < t.length; ++c) for (i = i << e | t[c], s += e; s >= n; ) s -= n, a.push(i >> s & o);
    if (r) s > 0 && a.push(i << n - s & o);
    else {
      if (s >= e) return "Excess padding";
      if (i << n - s & o) return "Non-zero padding";
    }
    return a;
  }
  function VJ(t) {
    var e = Oh(t, 8, 5, true);
    if (Array.isArray(e)) return e;
  }
  function zJ(t) {
    var e = Oh(t, 8, 5, true);
    if (Array.isArray(e)) return e;
    throw new Error(e);
  }
  function QJ(t) {
    var e = Oh(t, 5, 8, false);
    if (Array.isArray(e)) return e;
  }
  function jJ(t) {
    var e = Oh(t, 5, 8, false);
    if (Array.isArray(e)) return e;
    throw new Error(e);
  }
  var JJ = {
    decodeUnsafe: HJ,
    decode: GJ,
    encode: UJ,
    toWordsUnsafe: VJ,
    toWords: zJ,
    fromWordsUnsafe: QJ,
    fromWords: jJ
  };
  const rv = Js(JJ), Bh = "providers/5.8.0", Wl = new oe(Bh);
  class _e {
    constructor() {
      this.formats = this.getDefaultFormats();
    }
    getDefaultFormats() {
      const e = {}, n = this.address.bind(this), r = this.bigNumber.bind(this), i = this.blockTag.bind(this), s = this.data.bind(this), o = this.hash.bind(this), a = this.hex.bind(this), c = this.number.bind(this), l = this.type.bind(this), u = (f) => this.data(f, true);
      return e.transaction = {
        hash: o,
        type: l,
        accessList: _e.allowNull(this.accessList.bind(this), null),
        blockHash: _e.allowNull(o, null),
        blockNumber: _e.allowNull(c, null),
        transactionIndex: _e.allowNull(c, null),
        confirmations: _e.allowNull(c, null),
        from: n,
        gasPrice: _e.allowNull(r),
        maxPriorityFeePerGas: _e.allowNull(r),
        maxFeePerGas: _e.allowNull(r),
        gasLimit: r,
        to: _e.allowNull(n, null),
        value: r,
        nonce: c,
        data: s,
        r: _e.allowNull(this.uint256),
        s: _e.allowNull(this.uint256),
        v: _e.allowNull(c),
        creates: _e.allowNull(n, null),
        raw: _e.allowNull(s)
      }, e.transactionRequest = {
        from: _e.allowNull(n),
        nonce: _e.allowNull(c),
        gasLimit: _e.allowNull(r),
        gasPrice: _e.allowNull(r),
        maxPriorityFeePerGas: _e.allowNull(r),
        maxFeePerGas: _e.allowNull(r),
        to: _e.allowNull(n),
        value: _e.allowNull(r),
        data: _e.allowNull(u),
        type: _e.allowNull(c),
        accessList: _e.allowNull(this.accessList.bind(this), null)
      }, e.receiptLog = {
        transactionIndex: c,
        blockNumber: c,
        transactionHash: o,
        address: n,
        topics: _e.arrayOf(o),
        data: s,
        logIndex: c,
        blockHash: o
      }, e.receipt = {
        to: _e.allowNull(this.address, null),
        from: _e.allowNull(this.address, null),
        contractAddress: _e.allowNull(n, null),
        transactionIndex: c,
        root: _e.allowNull(a),
        gasUsed: r,
        logsBloom: _e.allowNull(s),
        blockHash: o,
        transactionHash: o,
        logs: _e.arrayOf(this.receiptLog.bind(this)),
        blockNumber: c,
        confirmations: _e.allowNull(c, null),
        cumulativeGasUsed: r,
        effectiveGasPrice: _e.allowNull(r),
        status: _e.allowNull(c),
        type: l
      }, e.block = {
        hash: _e.allowNull(o),
        parentHash: o,
        number: c,
        timestamp: c,
        nonce: _e.allowNull(a),
        difficulty: this.difficulty.bind(this),
        gasLimit: r,
        gasUsed: r,
        miner: _e.allowNull(n),
        extraData: s,
        transactions: _e.allowNull(_e.arrayOf(o)),
        baseFeePerGas: _e.allowNull(r)
      }, e.blockWithTransactions = bn(e.block), e.blockWithTransactions.transactions = _e.allowNull(_e.arrayOf(this.transactionResponse.bind(this))), e.filter = {
        fromBlock: _e.allowNull(i, void 0),
        toBlock: _e.allowNull(i, void 0),
        blockHash: _e.allowNull(o, void 0),
        address: _e.allowNull(n, void 0),
        topics: _e.allowNull(this.topics.bind(this), void 0)
      }, e.filterLog = {
        blockNumber: _e.allowNull(c),
        blockHash: _e.allowNull(o),
        transactionIndex: c,
        removed: _e.allowNull(this.boolean.bind(this)),
        address: n,
        data: _e.allowFalsish(s, "0x"),
        topics: _e.arrayOf(o),
        transactionHash: o,
        logIndex: c
      }, e;
    }
    accessList(e) {
      return Ja(e || []);
    }
    number(e) {
      return e === "0x" ? 0 : ve.from(e).toNumber();
    }
    type(e) {
      return e === "0x" || e == null ? 0 : ve.from(e).toNumber();
    }
    bigNumber(e) {
      return ve.from(e);
    }
    boolean(e) {
      if (typeof e == "boolean") return e;
      if (typeof e == "string") {
        if (e = e.toLowerCase(), e === "true") return true;
        if (e === "false") return false;
      }
      throw new Error("invalid boolean - " + e);
    }
    hex(e, n) {
      return typeof e == "string" && (!n && e.substring(0, 2) !== "0x" && (e = "0x" + e), st(e)) ? e.toLowerCase() : Wl.throwArgumentError("invalid hash", "value", e);
    }
    data(e, n) {
      const r = this.hex(e, n);
      if (r.length % 2 !== 0) throw new Error("invalid data; odd-length - " + e);
      return r;
    }
    address(e) {
      return pt(e);
    }
    callAddress(e) {
      if (!st(e, 32)) return null;
      const n = pt(ln(e, 12));
      return n === IV ? null : n;
    }
    contractAddress(e) {
      return ky(e);
    }
    blockTag(e) {
      if (e == null) return "latest";
      if (e === "earliest") return "0x0";
      switch (e) {
        case "earliest":
          return "0x0";
        case "latest":
        case "pending":
        case "safe":
        case "finalized":
          return e;
      }
      if (typeof e == "number" || st(e)) return xh(e);
      throw new Error("invalid blockTag");
    }
    hash(e, n) {
      const r = this.hex(e, n);
      return ns(r) !== 32 ? Wl.throwArgumentError("invalid hash", "value", e) : r;
    }
    difficulty(e) {
      if (e == null) return null;
      const n = ve.from(e);
      try {
        return n.toNumber();
      } catch {
      }
      return null;
    }
    uint256(e) {
      if (!st(e)) throw new Error("invalid uint256");
      return xt(e, 32);
    }
    _block(e, n) {
      e.author != null && e.miner == null && (e.miner = e.author);
      const r = e._difficulty != null ? e._difficulty : e.difficulty, i = _e.check(n, e);
      return i._difficulty = r == null ? null : ve.from(r), i;
    }
    block(e) {
      return this._block(e, this.formats.block);
    }
    blockWithTransactions(e) {
      return this._block(e, this.formats.blockWithTransactions);
    }
    transactionRequest(e) {
      return _e.check(this.formats.transactionRequest, e);
    }
    transactionResponse(e) {
      e.gas != null && e.gasLimit == null && (e.gasLimit = e.gas), e.to && ve.from(e.to).isZero() && (e.to = "0x0000000000000000000000000000000000000000"), e.input != null && e.data == null && (e.data = e.input), e.to == null && e.creates == null && (e.creates = this.contractAddress(e)), (e.type === 1 || e.type === 2) && e.accessList == null && (e.accessList = []);
      const n = _e.check(this.formats.transaction, e);
      if (e.chainId != null) {
        let r = e.chainId;
        st(r) && (r = ve.from(r).toNumber()), n.chainId = r;
      } else {
        let r = e.networkId;
        r == null && n.v == null && (r = e.chainId), st(r) && (r = ve.from(r).toNumber()), typeof r != "number" && n.v != null && (r = (n.v - 35) / 2, r < 0 && (r = 0), r = parseInt(r)), typeof r != "number" && (r = 0), n.chainId = r;
      }
      return n.blockHash && n.blockHash.replace(/0/g, "") === "x" && (n.blockHash = null), n;
    }
    transaction(e) {
      return E7(e);
    }
    receiptLog(e) {
      return _e.check(this.formats.receiptLog, e);
    }
    receipt(e) {
      const n = _e.check(this.formats.receipt, e);
      if (n.root != null) if (n.root.length <= 4) {
        const r = ve.from(n.root).toNumber();
        r === 0 || r === 1 ? (n.status != null && n.status !== r && Wl.throwArgumentError("alt-root-status/status mismatch", "value", {
          root: n.root,
          status: n.status
        }), n.status = r, delete n.root) : Wl.throwArgumentError("invalid alt-root-status", "value.root", n.root);
      } else n.root.length !== 66 && Wl.throwArgumentError("invalid root hash", "value.root", n.root);
      return n.status != null && (n.byzantium = true), n;
    }
    topics(e) {
      return Array.isArray(e) ? e.map((n) => this.topics(n)) : e != null ? this.hash(e, true) : null;
    }
    filter(e) {
      return _e.check(this.formats.filter, e);
    }
    filterLog(e) {
      return _e.check(this.formats.filterLog, e);
    }
    static check(e, n) {
      const r = {};
      for (const i in e) try {
        const s = e[i](n[i]);
        s !== void 0 && (r[i] = s);
      } catch (s) {
        throw s.checkKey = i, s.checkValue = n[i], s;
      }
      return r;
    }
    static allowNull(e, n) {
      return function(r) {
        return r == null ? n : e(r);
      };
    }
    static allowFalsish(e, n) {
      return function(r) {
        return r ? e(r) : n;
      };
    }
    static arrayOf(e) {
      return function(n) {
        if (!Array.isArray(n)) throw new Error("not an array");
        const r = [];
        return n.forEach(function(i) {
          r.push(e(i));
        }), r;
      };
    }
  }
  var He = function(t, e, n, r) {
    function i(s) {
      return s instanceof n ? s : new n(function(o) {
        o(s);
      });
    }
    return new (n || (n = Promise))(function(s, o) {
      function a(u) {
        try {
          l(r.next(u));
        } catch (f) {
          o(f);
        }
      }
      function c(u) {
        try {
          l(r.throw(u));
        } catch (f) {
          o(f);
        }
      }
      function l(u) {
        u.done ? s(u.value) : i(u.value).then(a, c);
      }
      l((r = r.apply(t, e || [])).next());
    });
  };
  const qe = new oe(Bh), KJ = 10;
  function iv(t) {
    return t == null ? "null" : (ns(t) !== 32 && qe.throwArgumentError("invalid topic", "topic", t), t.toLowerCase());
  }
  function sv(t) {
    for (t = t.slice(); t.length > 0 && t[t.length - 1] == null; ) t.pop();
    return t.map((e) => {
      if (Array.isArray(e)) {
        const n = {};
        e.forEach((i) => {
          n[iv(i)] = true;
        });
        const r = Object.keys(n);
        return r.sort(), r.join("|");
      } else return iv(e);
    }).join("&");
  }
  function WJ(t) {
    return t === "" ? [] : t.split(/&/g).map((e) => {
      if (e === "") return [];
      const n = e.split("|").map((r) => r === "null" ? null : r);
      return n.length === 1 ? n[0] : n;
    });
  }
  function oc(t) {
    if (typeof t == "string") {
      if (t = t.toLowerCase(), ns(t) === 32) return "tx:" + t;
      if (t.indexOf(":") === -1) return t;
    } else {
      if (Array.isArray(t)) return "filter:*:" + sv(t);
      if (Gz.isForkEvent(t)) throw qe.warn("not implemented"), new Error("not implemented");
      if (t && typeof t == "object") return "filter:" + (t.address || "*") + ":" + sv(t.topics || []);
    }
    throw new Error("invalid event - " + t);
  }
  function ql() {
    return (/* @__PURE__ */ new Date()).getTime();
  }
  function ov(t) {
    return new Promise((e) => {
      setTimeout(e, t);
    });
  }
  const qJ = [
    "block",
    "network",
    "pending",
    "poll"
  ];
  let YJ = class {
    constructor(e, n, r) {
      ge(this, "tag", e), ge(this, "listener", n), ge(this, "once", r), this._lastBlockNumber = -2, this._inflight = false;
    }
    get event() {
      switch (this.type) {
        case "tx":
          return this.hash;
        case "filter":
          return this.filter;
      }
      return this.tag;
    }
    get type() {
      return this.tag.split(":")[0];
    }
    get hash() {
      const e = this.tag.split(":");
      return e[0] !== "tx" ? null : e[1];
    }
    get filter() {
      const e = this.tag.split(":");
      if (e[0] !== "filter") return null;
      const n = e[1], r = WJ(e[2]), i = {};
      return r.length > 0 && (i.topics = r), n && n !== "*" && (i.address = n), i;
    }
    pollable() {
      return this.tag.indexOf(":") >= 0 || qJ.indexOf(this.tag) >= 0;
    }
  };
  const XJ = {
    0: {
      symbol: "btc",
      p2pkh: 0,
      p2sh: 5,
      prefix: "bc"
    },
    2: {
      symbol: "ltc",
      p2pkh: 48,
      p2sh: 50,
      prefix: "ltc"
    },
    3: {
      symbol: "doge",
      p2pkh: 30,
      p2sh: 22
    },
    60: {
      symbol: "eth",
      ilk: "eth"
    },
    61: {
      symbol: "etc",
      ilk: "eth"
    },
    700: {
      symbol: "xdai",
      ilk: "eth"
    }
  };
  function Rg(t) {
    return xt(ve.from(t).toHexString(), 32);
  }
  function av(t) {
    return pl.encode(Et([
      t,
      ln(Gs(Gs(t)), 0, 4)
    ]));
  }
  const Q7 = new RegExp("^(ipfs)://(.*)$", "i"), cv = [
    new RegExp("^(https)://(.*)$", "i"),
    new RegExp("^(data):(.*)$", "i"),
    Q7,
    new RegExp("^eip155:[0-9]+/(erc[0-9]+):(.*)$", "i")
  ];
  function O0(t, e) {
    try {
      return Ho(ef(t, e));
    } catch {
    }
    return null;
  }
  function ef(t, e) {
    if (t === "0x") return null;
    const n = ve.from(ln(t, e, e + 32)).toNumber(), r = ve.from(ln(t, n, n + 32)).toNumber();
    return ln(t, n + 32, n + 32 + r);
  }
  function Ng(t) {
    return t.match(/^ipfs:\/\/ipfs\//i) ? t = t.substring(12) : t.match(/^ipfs:\/\//i) ? t = t.substring(7) : qe.throwArgumentError("unsupported IPFS format", "link", t), `https://gateway.ipfs.io/ipfs/${t}`;
  }
  function lv(t) {
    const e = Ae(t);
    if (e.length > 32) throw new Error("internal; should not happen");
    const n = new Uint8Array(32);
    return n.set(e, 32 - e.length), n;
  }
  function ZJ(t) {
    if (t.length % 32 === 0) return t;
    const e = new Uint8Array(Math.ceil(t.length / 32) * 32);
    return e.set(t), e;
  }
  function j7(t) {
    const e = [];
    let n = 0;
    for (let r = 0; r < t.length; r++) e.push(null), n += 32;
    for (let r = 0; r < t.length; r++) {
      const i = Ae(t[r]);
      e[r] = lv(n), e.push(lv(i.length)), e.push(ZJ(i)), n += 32 + Math.ceil(i.length / 32) * 32;
    }
    return nr(e);
  }
  class uv {
    constructor(e, n, r, i) {
      ge(this, "provider", e), ge(this, "name", r), ge(this, "address", e.formatter.address(n)), ge(this, "_resolvedAddress", i);
    }
    supportsWildcard() {
      return this._supportsEip2544 || (this._supportsEip2544 = this.provider.call({
        to: this.address,
        data: "0x01ffc9a79061b92300000000000000000000000000000000000000000000000000000000"
      }).then((e) => ve.from(e).eq(1)).catch((e) => {
        if (e.code === oe.errors.CALL_EXCEPTION) return false;
        throw this._supportsEip2544 = null, e;
      })), this._supportsEip2544;
    }
    _fetch(e, n) {
      return He(this, void 0, void 0, function* () {
        const r = {
          to: this.address,
          ccipReadEnabled: true,
          data: nr([
            e,
            vu(this.name),
            n || "0x"
          ])
        };
        let i = false;
        (yield this.supportsWildcard()) && (i = true, r.data = nr([
          "0x9061b923",
          j7([
            Q8(this.name),
            r.data
          ])
        ]));
        try {
          let s = yield this.provider.call(r);
          return Ae(s).length % 32 === 4 && qe.throwError("resolver threw error", oe.errors.CALL_EXCEPTION, {
            transaction: r,
            data: s
          }), i && (s = ef(s, 0)), s;
        } catch (s) {
          if (s.code === oe.errors.CALL_EXCEPTION) return null;
          throw s;
        }
      });
    }
    _fetchBytes(e, n) {
      return He(this, void 0, void 0, function* () {
        const r = yield this._fetch(e, n);
        return r != null ? ef(r, 0) : null;
      });
    }
    _getAddress(e, n) {
      const r = XJ[String(e)];
      if (r == null && qe.throwError(`unsupported coin type: ${e}`, oe.errors.UNSUPPORTED_OPERATION, {
        operation: `getAddress(${e})`
      }), r.ilk === "eth") return this.provider.formatter.address(n);
      const i = Ae(n);
      if (r.p2pkh != null) {
        const s = n.match(/^0x76a9([0-9a-f][0-9a-f])([0-9a-f]*)88ac$/);
        if (s) {
          const o = parseInt(s[1], 16);
          if (s[2].length === o * 2 && o >= 1 && o <= 75) return av(Et([
            [
              r.p2pkh
            ],
            "0x" + s[2]
          ]));
        }
      }
      if (r.p2sh != null) {
        const s = n.match(/^0xa9([0-9a-f][0-9a-f])([0-9a-f]*)87$/);
        if (s) {
          const o = parseInt(s[1], 16);
          if (s[2].length === o * 2 && o >= 1 && o <= 75) return av(Et([
            [
              r.p2sh
            ],
            "0x" + s[2]
          ]));
        }
      }
      if (r.prefix != null) {
        const s = i[1];
        let o = i[0];
        if (o === 0 ? s !== 20 && s !== 32 && (o = -1) : o = -1, o >= 0 && i.length === 2 + s && s >= 1 && s <= 75) {
          const a = rv.toWords(i.slice(2));
          return a.unshift(o), rv.encode(r.prefix, a);
        }
      }
      return null;
    }
    getAddress(e) {
      return He(this, void 0, void 0, function* () {
        if (e == null && (e = 60), e === 60) try {
          const i = yield this._fetch("0x3b3b57de");
          return i === "0x" || i === N8 ? null : this.provider.formatter.callAddress(i);
        } catch (i) {
          if (i.code === oe.errors.CALL_EXCEPTION) return null;
          throw i;
        }
        const n = yield this._fetchBytes("0xf1cb7e06", Rg(e));
        if (n == null || n === "0x") return null;
        const r = this._getAddress(e, n);
        return r == null && qe.throwError("invalid or unsupported coin data", oe.errors.UNSUPPORTED_OPERATION, {
          operation: `getAddress(${e})`,
          coinType: e,
          data: n
        }), r;
      });
    }
    getAvatar() {
      return He(this, void 0, void 0, function* () {
        const e = [
          {
            type: "name",
            content: this.name
          }
        ];
        try {
          const n = yield this.getText("avatar");
          if (n == null) return null;
          for (let r = 0; r < cv.length; r++) {
            const i = n.match(cv[r]);
            if (i == null) continue;
            const s = i[1].toLowerCase();
            switch (s) {
              case "https":
                return e.push({
                  type: "url",
                  content: n
                }), {
                  linkage: e,
                  url: n
                };
              case "data":
                return e.push({
                  type: "data",
                  content: n
                }), {
                  linkage: e,
                  url: n
                };
              case "ipfs":
                return e.push({
                  type: "ipfs",
                  content: n
                }), {
                  linkage: e,
                  url: Ng(n)
                };
              case "erc721":
              case "erc1155": {
                const o = s === "erc721" ? "0xc87b56dd" : "0x0e89341c";
                e.push({
                  type: s,
                  content: n
                });
                const a = this._resolvedAddress || (yield this.getAddress()), c = (i[2] || "").split("/");
                if (c.length !== 2) return null;
                const l = yield this.provider.formatter.address(c[0]), u = xt(ve.from(c[1]).toHexString(), 32);
                if (s === "erc721") {
                  const x = this.provider.formatter.callAddress(yield this.provider.call({
                    to: l,
                    data: nr([
                      "0x6352211e",
                      u
                    ])
                  }));
                  if (a !== x) return null;
                  e.push({
                    type: "owner",
                    content: x
                  });
                } else if (s === "erc1155") {
                  const x = ve.from(yield this.provider.call({
                    to: l,
                    data: nr([
                      "0x00fdd58e",
                      xt(a, 32),
                      u
                    ])
                  }));
                  if (x.isZero()) return null;
                  e.push({
                    type: "balance",
                    content: x.toString()
                  });
                }
                const f = {
                  to: this.provider.formatter.address(c[0]),
                  data: nr([
                    o,
                    u
                  ])
                };
                let d = O0(yield this.provider.call(f), 0);
                if (d == null) return null;
                e.push({
                  type: "metadata-url-base",
                  content: d
                }), s === "erc1155" && (d = d.replace("{id}", u.substring(2)), e.push({
                  type: "metadata-url-expanded",
                  content: d
                })), d.match(/^ipfs:/i) && (d = Ng(d)), e.push({
                  type: "metadata-url",
                  content: d
                });
                const m = yield Nh(d);
                if (!m) return null;
                e.push({
                  type: "metadata",
                  content: JSON.stringify(m)
                });
                let y = m.image;
                if (typeof y != "string") return null;
                if (!y.match(/^(https:\/\/|data:)/i)) {
                  if (y.match(Q7) == null) return null;
                  e.push({
                    type: "url-ipfs",
                    content: y
                  }), y = Ng(y);
                }
                return e.push({
                  type: "url",
                  content: y
                }), {
                  linkage: e,
                  url: y
                };
              }
            }
          }
        } catch {
        }
        return null;
      });
    }
    getContentHash() {
      return He(this, void 0, void 0, function* () {
        const e = yield this._fetchBytes("0xbc1c58d1");
        if (e == null || e === "0x") return null;
        const n = e.match(/^0xe3010170(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);
        if (n) {
          const o = parseInt(n[3], 16);
          if (n[4].length === o * 2) return "ipfs://" + pl.encode("0x" + n[1]);
        }
        const r = e.match(/^0xe5010172(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);
        if (r) {
          const o = parseInt(r[3], 16);
          if (r[4].length === o * 2) return "ipns://" + pl.encode("0x" + r[1]);
        }
        const i = e.match(/^0xe40101fa011b20([0-9a-f]*)$/);
        if (i && i[1].length === 32 * 2) return "bzz://" + i[1];
        const s = e.match(/^0x90b2c605([0-9a-f]*)$/);
        if (s && s[1].length === 34 * 2) {
          const o = {
            "=": "",
            "+": "-",
            "/": "_"
          };
          return "sia://" + Hy("0x" + s[1]).replace(/[=+\/]/g, (c) => o[c]);
        }
        return qe.throwError("invalid or unsupported content hash data", oe.errors.UNSUPPORTED_OPERATION, {
          operation: "getContentHash()",
          data: e
        });
      });
    }
    getText(e) {
      return He(this, void 0, void 0, function* () {
        let n = gn(e);
        n = Et([
          Rg(64),
          Rg(n.length),
          n
        ]), n.length % 32 !== 0 && (n = Et([
          n,
          xt("0x", 32 - e.length % 32)
        ]));
        const r = yield this._fetchBytes("0x59d1d43c", Ee(n));
        return r == null || r === "0x" ? null : Ho(r);
      });
    }
  }
  let Og = null, $J = 1;
  class eK extends Tf {
    constructor(e) {
      if (super(), this._events = [], this._emitted = {
        block: -2
      }, this.disableCcipRead = false, this.formatter = new.target.getFormatter(), ge(this, "anyNetwork", e === "any"), this.anyNetwork && (e = this.detectNetwork()), e instanceof Promise) this._networkPromise = e, e.catch((n) => {
      }), this._ready().catch((n) => {
      });
      else {
        const n = bi(new.target, "getNetwork")(e);
        n ? (ge(this, "_network", n), this.emit("network", n, null)) : qe.throwArgumentError("invalid network", "network", e);
      }
      this._maxInternalBlockNumber = -1024, this._lastBlockNumber = -2, this._maxFilterBlockRange = 10, this._pollingInterval = 4e3, this._fastQueryDate = 0;
    }
    _ready() {
      return He(this, void 0, void 0, function* () {
        if (this._network == null) {
          let e = null;
          if (this._networkPromise) try {
            e = yield this._networkPromise;
          } catch {
          }
          e == null && (e = yield this.detectNetwork()), e || qe.throwError("no network detected", oe.errors.UNKNOWN_ERROR, {}), this._network == null && (this.anyNetwork ? this._network = e : ge(this, "_network", e), this.emit("network", e, null));
        }
        return this._network;
      });
    }
    get ready() {
      return Pc(() => this._ready().then((e) => e, (e) => {
        if (!(e.code === oe.errors.NETWORK_ERROR && e.event === "noNetwork")) throw e;
      }));
    }
    static getFormatter() {
      return Og == null && (Og = new _e()), Og;
    }
    static getNetwork(e) {
      return OJ(e ?? "homestead");
    }
    ccipReadFetch(e, n, r) {
      return He(this, void 0, void 0, function* () {
        if (this.disableCcipRead || r.length === 0) return null;
        const i = e.to.toLowerCase(), s = n.toLowerCase(), o = [];
        for (let a = 0; a < r.length; a++) {
          const c = r[a], l = c.replace("{sender}", i).replace("{data}", s), u = c.indexOf("{data}") >= 0 ? null : JSON.stringify({
            data: s,
            sender: i
          }), f = yield Nh({
            url: l,
            errorPassThrough: true
          }, u, (m, y) => (m.status = y.statusCode, m));
          if (f.data) return f.data;
          const d = f.message || "unknown error";
          if (f.status >= 400 && f.status < 500) return qe.throwError(`response not found during CCIP fetch: ${d}`, oe.errors.SERVER_ERROR, {
            url: c,
            errorMessage: d
          });
          o.push(d);
        }
        return qe.throwError(`error encountered during CCIP fetch: ${o.map((a) => JSON.stringify(a)).join(", ")}`, oe.errors.SERVER_ERROR, {
          urls: r,
          errorMessages: o
        });
      });
    }
    _getInternalBlockNumber(e) {
      return He(this, void 0, void 0, function* () {
        if (yield this._ready(), e > 0) for (; this._internalBlockNumber; ) {
          const i = this._internalBlockNumber;
          try {
            const s = yield i;
            if (ql() - s.respTime <= e) return s.blockNumber;
            break;
          } catch {
            if (this._internalBlockNumber === i) break;
          }
        }
        const n = ql(), r = tn({
          blockNumber: this.perform("getBlockNumber", {}),
          networkError: this.getNetwork().then((i) => null, (i) => i)
        }).then(({ blockNumber: i, networkError: s }) => {
          if (s) throw this._internalBlockNumber === r && (this._internalBlockNumber = null), s;
          const o = ql();
          return i = ve.from(i).toNumber(), i < this._maxInternalBlockNumber && (i = this._maxInternalBlockNumber), this._maxInternalBlockNumber = i, this._setFastBlockNumber(i), {
            blockNumber: i,
            reqTime: n,
            respTime: o
          };
        });
        return this._internalBlockNumber = r, r.catch((i) => {
          this._internalBlockNumber === r && (this._internalBlockNumber = null);
        }), (yield r).blockNumber;
      });
    }
    poll() {
      return He(this, void 0, void 0, function* () {
        const e = $J++, n = [];
        let r = null;
        try {
          r = yield this._getInternalBlockNumber(100 + this.pollingInterval / 2);
        } catch (i) {
          this.emit("error", i);
          return;
        }
        if (this._setFastBlockNumber(r), this.emit("poll", e, r), r === this._lastBlockNumber) {
          this.emit("didPoll", e);
          return;
        }
        if (this._emitted.block === -2 && (this._emitted.block = r - 1), Math.abs(this._emitted.block - r) > 1e3) qe.warn(`network block skew detected; skipping block events (emitted=${this._emitted.block} blockNumber${r})`), this.emit("error", qe.makeError("network block skew detected", oe.errors.NETWORK_ERROR, {
          blockNumber: r,
          event: "blockSkew",
          previousBlockNumber: this._emitted.block
        })), this.emit("block", r);
        else for (let i = this._emitted.block + 1; i <= r; i++) this.emit("block", i);
        this._emitted.block !== r && (this._emitted.block = r, Object.keys(this._emitted).forEach((i) => {
          if (i === "block") return;
          const s = this._emitted[i];
          s !== "pending" && r - s > 12 && delete this._emitted[i];
        })), this._lastBlockNumber === -2 && (this._lastBlockNumber = r - 1), this._events.forEach((i) => {
          switch (i.type) {
            case "tx": {
              const s = i.hash;
              let o = this.getTransactionReceipt(s).then((a) => (!a || a.blockNumber == null || (this._emitted["t:" + s] = a.blockNumber, this.emit(s, a)), null)).catch((a) => {
                this.emit("error", a);
              });
              n.push(o);
              break;
            }
            case "filter": {
              if (!i._inflight) {
                i._inflight = true, i._lastBlockNumber === -2 && (i._lastBlockNumber = r - 1);
                const s = i.filter;
                s.fromBlock = i._lastBlockNumber + 1, s.toBlock = r;
                const o = s.toBlock - this._maxFilterBlockRange;
                o > s.fromBlock && (s.fromBlock = o), s.fromBlock < 0 && (s.fromBlock = 0);
                const a = this.getLogs(s).then((c) => {
                  i._inflight = false, c.length !== 0 && c.forEach((l) => {
                    l.blockNumber > i._lastBlockNumber && (i._lastBlockNumber = l.blockNumber), this._emitted["b:" + l.blockHash] = l.blockNumber, this._emitted["t:" + l.transactionHash] = l.blockNumber, this.emit(s, l);
                  });
                }).catch((c) => {
                  this.emit("error", c), i._inflight = false;
                });
                n.push(a);
              }
              break;
            }
          }
        }), this._lastBlockNumber = r, Promise.all(n).then(() => {
          this.emit("didPoll", e);
        }).catch((i) => {
          this.emit("error", i);
        });
      });
    }
    resetEventsBlock(e) {
      this._lastBlockNumber = e - 1, this.polling && this.poll();
    }
    get network() {
      return this._network;
    }
    detectNetwork() {
      return He(this, void 0, void 0, function* () {
        return qe.throwError("provider does not support network detection", oe.errors.UNSUPPORTED_OPERATION, {
          operation: "provider.detectNetwork"
        });
      });
    }
    getNetwork() {
      return He(this, void 0, void 0, function* () {
        const e = yield this._ready(), n = yield this.detectNetwork();
        if (e.chainId !== n.chainId) {
          if (this.anyNetwork) return this._network = n, this._lastBlockNumber = -2, this._fastBlockNumber = null, this._fastBlockNumberPromise = null, this._fastQueryDate = 0, this._emitted.block = -2, this._maxInternalBlockNumber = -1024, this._internalBlockNumber = null, this.emit("network", n, e), yield ov(0), this._network;
          const r = qe.makeError("underlying network changed", oe.errors.NETWORK_ERROR, {
            event: "changed",
            network: e,
            detectedNetwork: n
          });
          throw this.emit("error", r), r;
        }
        return e;
      });
    }
    get blockNumber() {
      return this._getInternalBlockNumber(100 + this.pollingInterval / 2).then((e) => {
        this._setFastBlockNumber(e);
      }, (e) => {
      }), this._fastBlockNumber != null ? this._fastBlockNumber : -1;
    }
    get polling() {
      return this._poller != null;
    }
    set polling(e) {
      e && !this._poller ? (this._poller = setInterval(() => {
        this.poll();
      }, this.pollingInterval), this._bootstrapPoll || (this._bootstrapPoll = setTimeout(() => {
        this.poll(), this._bootstrapPoll = setTimeout(() => {
          this._poller || this.poll(), this._bootstrapPoll = null;
        }, this.pollingInterval);
      }, 0))) : !e && this._poller && (clearInterval(this._poller), this._poller = null);
    }
    get pollingInterval() {
      return this._pollingInterval;
    }
    set pollingInterval(e) {
      if (typeof e != "number" || e <= 0 || parseInt(String(e)) != e) throw new Error("invalid polling interval");
      this._pollingInterval = e, this._poller && (clearInterval(this._poller), this._poller = setInterval(() => {
        this.poll();
      }, this._pollingInterval));
    }
    _getFastBlockNumber() {
      const e = ql();
      return e - this._fastQueryDate > 2 * this._pollingInterval && (this._fastQueryDate = e, this._fastBlockNumberPromise = this.getBlockNumber().then((n) => ((this._fastBlockNumber == null || n > this._fastBlockNumber) && (this._fastBlockNumber = n), this._fastBlockNumber))), this._fastBlockNumberPromise;
    }
    _setFastBlockNumber(e) {
      this._fastBlockNumber != null && e < this._fastBlockNumber || (this._fastQueryDate = ql(), (this._fastBlockNumber == null || e > this._fastBlockNumber) && (this._fastBlockNumber = e, this._fastBlockNumberPromise = Promise.resolve(e)));
    }
    waitForTransaction(e, n, r) {
      return He(this, void 0, void 0, function* () {
        return this._waitForTransaction(e, n ?? 1, r || 0, null);
      });
    }
    _waitForTransaction(e, n, r, i) {
      return He(this, void 0, void 0, function* () {
        const s = yield this.getTransactionReceipt(e);
        return (s ? s.confirmations : 0) >= n ? s : new Promise((o, a) => {
          const c = [];
          let l = false;
          const u = function() {
            return l ? true : (l = true, c.forEach((d) => {
              d();
            }), false);
          }, f = (d) => {
            d.confirmations < n || u() || o(d);
          };
          if (this.on(e, f), c.push(() => {
            this.removeListener(e, f);
          }), i) {
            let d = i.startBlock, m = null;
            const y = (x) => He(this, void 0, void 0, function* () {
              l || (yield ov(1e3), this.getTransactionCount(i.from).then((w) => He(this, void 0, void 0, function* () {
                if (!l) {
                  if (w <= i.nonce) d = x;
                  else {
                    {
                      const R = yield this.getTransaction(e);
                      if (R && R.blockNumber != null) return;
                    }
                    for (m == null && (m = d - 3, m < i.startBlock && (m = i.startBlock)); m <= x; ) {
                      if (l) return;
                      const R = yield this.getBlockWithTransactions(m);
                      for (let O = 0; O < R.transactions.length; O++) {
                        const B = R.transactions[O];
                        if (B.hash === e) return;
                        if (B.from === i.from && B.nonce === i.nonce) {
                          if (l) return;
                          const M = yield this.waitForTransaction(B.hash, n);
                          if (u()) return;
                          let D = "replaced";
                          B.data === i.data && B.to === i.to && B.value.eq(i.value) ? D = "repriced" : B.data === "0x" && B.from === B.to && B.value.isZero() && (D = "cancelled"), a(qe.makeError("transaction was replaced", oe.errors.TRANSACTION_REPLACED, {
                            cancelled: D === "replaced" || D === "cancelled",
                            reason: D,
                            replacement: this._wrapTransaction(B),
                            hash: e,
                            receipt: M
                          }));
                          return;
                        }
                      }
                      m++;
                    }
                  }
                  l || this.once("block", y);
                }
              }), (w) => {
                l || this.once("block", y);
              }));
            });
            if (l) return;
            this.once("block", y), c.push(() => {
              this.removeListener("block", y);
            });
          }
          if (typeof r == "number" && r > 0) {
            const d = setTimeout(() => {
              u() || a(qe.makeError("timeout exceeded", oe.errors.TIMEOUT, {
                timeout: r
              }));
            }, r);
            d.unref && d.unref(), c.push(() => {
              clearTimeout(d);
            });
          }
        });
      });
    }
    getBlockNumber() {
      return He(this, void 0, void 0, function* () {
        return this._getInternalBlockNumber(0);
      });
    }
    getGasPrice() {
      return He(this, void 0, void 0, function* () {
        yield this.getNetwork();
        const e = yield this.perform("getGasPrice", {});
        try {
          return ve.from(e);
        } catch (n) {
          return qe.throwError("bad result from backend", oe.errors.SERVER_ERROR, {
            method: "getGasPrice",
            result: e,
            error: n
          });
        }
      });
    }
    getBalance(e, n) {
      return He(this, void 0, void 0, function* () {
        yield this.getNetwork();
        const r = yield tn({
          address: this._getAddress(e),
          blockTag: this._getBlockTag(n)
        }), i = yield this.perform("getBalance", r);
        try {
          return ve.from(i);
        } catch (s) {
          return qe.throwError("bad result from backend", oe.errors.SERVER_ERROR, {
            method: "getBalance",
            params: r,
            result: i,
            error: s
          });
        }
      });
    }
    getTransactionCount(e, n) {
      return He(this, void 0, void 0, function* () {
        yield this.getNetwork();
        const r = yield tn({
          address: this._getAddress(e),
          blockTag: this._getBlockTag(n)
        }), i = yield this.perform("getTransactionCount", r);
        try {
          return ve.from(i).toNumber();
        } catch (s) {
          return qe.throwError("bad result from backend", oe.errors.SERVER_ERROR, {
            method: "getTransactionCount",
            params: r,
            result: i,
            error: s
          });
        }
      });
    }
    getCode(e, n) {
      return He(this, void 0, void 0, function* () {
        yield this.getNetwork();
        const r = yield tn({
          address: this._getAddress(e),
          blockTag: this._getBlockTag(n)
        }), i = yield this.perform("getCode", r);
        try {
          return Ee(i);
        } catch (s) {
          return qe.throwError("bad result from backend", oe.errors.SERVER_ERROR, {
            method: "getCode",
            params: r,
            result: i,
            error: s
          });
        }
      });
    }
    getStorageAt(e, n, r) {
      return He(this, void 0, void 0, function* () {
        yield this.getNetwork();
        const i = yield tn({
          address: this._getAddress(e),
          blockTag: this._getBlockTag(r),
          position: Promise.resolve(n).then((o) => xh(o))
        }), s = yield this.perform("getStorageAt", i);
        try {
          return Ee(s);
        } catch (o) {
          return qe.throwError("bad result from backend", oe.errors.SERVER_ERROR, {
            method: "getStorageAt",
            params: i,
            result: s,
            error: o
          });
        }
      });
    }
    _wrapTransaction(e, n, r) {
      if (n != null && ns(n) !== 32) throw new Error("invalid response - sendTransaction");
      const i = e;
      return n != null && e.hash !== n && qe.throwError("Transaction hash mismatch from Provider.sendTransaction.", oe.errors.UNKNOWN_ERROR, {
        expectedHash: e.hash,
        returnedHash: n
      }), i.wait = (s, o) => He(this, void 0, void 0, function* () {
        s == null && (s = 1), o == null && (o = 0);
        let a;
        s !== 0 && r != null && (a = {
          data: e.data,
          from: e.from,
          nonce: e.nonce,
          to: e.to,
          value: e.value,
          startBlock: r
        });
        const c = yield this._waitForTransaction(e.hash, s, o, a);
        return c == null && s === 0 ? null : (this._emitted["t:" + e.hash] = c.blockNumber, c.status === 0 && qe.throwError("transaction failed", oe.errors.CALL_EXCEPTION, {
          transactionHash: e.hash,
          transaction: e,
          receipt: c
        }), c);
      }), i;
    }
    sendTransaction(e) {
      return He(this, void 0, void 0, function* () {
        yield this.getNetwork();
        const n = yield Promise.resolve(e).then((s) => Ee(s)), r = this.formatter.transaction(e);
        r.confirmations == null && (r.confirmations = 0);
        const i = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
        try {
          const s = yield this.perform("sendTransaction", {
            signedTransaction: n
          });
          return this._wrapTransaction(r, s, i);
        } catch (s) {
          throw s.transaction = r, s.transactionHash = r.hash, s;
        }
      });
    }
    _getTransactionRequest(e) {
      return He(this, void 0, void 0, function* () {
        const n = yield e, r = {};
        return [
          "from",
          "to"
        ].forEach((i) => {
          n[i] != null && (r[i] = Promise.resolve(n[i]).then((s) => s ? this._getAddress(s) : null));
        }), [
          "gasLimit",
          "gasPrice",
          "maxFeePerGas",
          "maxPriorityFeePerGas",
          "value"
        ].forEach((i) => {
          n[i] != null && (r[i] = Promise.resolve(n[i]).then((s) => s ? ve.from(s) : null));
        }), [
          "type"
        ].forEach((i) => {
          n[i] != null && (r[i] = Promise.resolve(n[i]).then((s) => s ?? null));
        }), n.accessList && (r.accessList = this.formatter.accessList(n.accessList)), [
          "data"
        ].forEach((i) => {
          n[i] != null && (r[i] = Promise.resolve(n[i]).then((s) => s ? Ee(s) : null));
        }), this.formatter.transactionRequest(yield tn(r));
      });
    }
    _getFilter(e) {
      return He(this, void 0, void 0, function* () {
        e = yield e;
        const n = {};
        return e.address != null && (n.address = this._getAddress(e.address)), [
          "blockHash",
          "topics"
        ].forEach((r) => {
          e[r] != null && (n[r] = e[r]);
        }), [
          "fromBlock",
          "toBlock"
        ].forEach((r) => {
          e[r] != null && (n[r] = this._getBlockTag(e[r]));
        }), this.formatter.filter(yield tn(n));
      });
    }
    _call(e, n, r) {
      return He(this, void 0, void 0, function* () {
        r >= KJ && qe.throwError("CCIP read exceeded maximum redirections", oe.errors.SERVER_ERROR, {
          redirects: r,
          transaction: e
        });
        const i = e.to, s = yield this.perform("call", {
          transaction: e,
          blockTag: n
        });
        if (r >= 0 && n === "latest" && i != null && s.substring(0, 10) === "0x556f1830" && ns(s) % 32 === 4) try {
          const o = ln(s, 4), a = ln(o, 0, 32);
          ve.from(a).eq(i) || qe.throwError("CCIP Read sender did not match", oe.errors.CALL_EXCEPTION, {
            name: "OffchainLookup",
            signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
            transaction: e,
            data: s
          });
          const c = [], l = ve.from(ln(o, 32, 64)).toNumber(), u = ve.from(ln(o, l, l + 32)).toNumber(), f = ln(o, l + 32);
          for (let R = 0; R < u; R++) {
            const O = O0(f, R * 32);
            O == null && qe.throwError("CCIP Read contained corrupt URL string", oe.errors.CALL_EXCEPTION, {
              name: "OffchainLookup",
              signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
              transaction: e,
              data: s
            }), c.push(O);
          }
          const d = ef(o, 64);
          ve.from(ln(o, 100, 128)).isZero() || qe.throwError("CCIP Read callback selector included junk", oe.errors.CALL_EXCEPTION, {
            name: "OffchainLookup",
            signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
            transaction: e,
            data: s
          });
          const m = ln(o, 96, 100), y = ef(o, 128), x = yield this.ccipReadFetch(e, d, c);
          x == null && qe.throwError("CCIP Read disabled or provided no URLs", oe.errors.CALL_EXCEPTION, {
            name: "OffchainLookup",
            signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
            transaction: e,
            data: s
          });
          const w = {
            to: i,
            data: nr([
              m,
              j7([
                x,
                y
              ])
            ])
          };
          return this._call(w, n, r + 1);
        } catch (o) {
          if (o.code === oe.errors.SERVER_ERROR) throw o;
        }
        try {
          return Ee(s);
        } catch (o) {
          return qe.throwError("bad result from backend", oe.errors.SERVER_ERROR, {
            method: "call",
            params: {
              transaction: e,
              blockTag: n
            },
            result: s,
            error: o
          });
        }
      });
    }
    call(e, n) {
      return He(this, void 0, void 0, function* () {
        yield this.getNetwork();
        const r = yield tn({
          transaction: this._getTransactionRequest(e),
          blockTag: this._getBlockTag(n),
          ccipReadEnabled: Promise.resolve(e.ccipReadEnabled)
        });
        return this._call(r.transaction, r.blockTag, r.ccipReadEnabled ? 0 : -1);
      });
    }
    estimateGas(e) {
      return He(this, void 0, void 0, function* () {
        yield this.getNetwork();
        const n = yield tn({
          transaction: this._getTransactionRequest(e)
        }), r = yield this.perform("estimateGas", n);
        try {
          return ve.from(r);
        } catch (i) {
          return qe.throwError("bad result from backend", oe.errors.SERVER_ERROR, {
            method: "estimateGas",
            params: n,
            result: r,
            error: i
          });
        }
      });
    }
    _getAddress(e) {
      return He(this, void 0, void 0, function* () {
        e = yield e, typeof e != "string" && qe.throwArgumentError("invalid address or ENS name", "name", e);
        const n = yield this.resolveName(e);
        return n == null && qe.throwError("ENS name not configured", oe.errors.UNSUPPORTED_OPERATION, {
          operation: `resolveName(${JSON.stringify(e)})`
        }), n;
      });
    }
    _getBlock(e, n) {
      return He(this, void 0, void 0, function* () {
        yield this.getNetwork(), e = yield e;
        let r = -128;
        const i = {
          includeTransactions: !!n
        };
        if (st(e, 32)) i.blockHash = e;
        else try {
          i.blockTag = yield this._getBlockTag(e), st(i.blockTag) && (r = parseInt(i.blockTag.substring(2), 16));
        } catch {
          qe.throwArgumentError("invalid block hash or block tag", "blockHashOrBlockTag", e);
        }
        return Pc(() => He(this, void 0, void 0, function* () {
          const s = yield this.perform("getBlock", i);
          if (s == null) return i.blockHash != null && this._emitted["b:" + i.blockHash] == null || i.blockTag != null && r > this._emitted.block ? null : void 0;
          if (n) {
            let o = null;
            for (let c = 0; c < s.transactions.length; c++) {
              const l = s.transactions[c];
              if (l.blockNumber == null) l.confirmations = 0;
              else if (l.confirmations == null) {
                o == null && (o = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval));
                let u = o - l.blockNumber + 1;
                u <= 0 && (u = 1), l.confirmations = u;
              }
            }
            const a = this.formatter.blockWithTransactions(s);
            return a.transactions = a.transactions.map((c) => this._wrapTransaction(c)), a;
          }
          return this.formatter.block(s);
        }), {
          oncePoll: this
        });
      });
    }
    getBlock(e) {
      return this._getBlock(e, false);
    }
    getBlockWithTransactions(e) {
      return this._getBlock(e, true);
    }
    getTransaction(e) {
      return He(this, void 0, void 0, function* () {
        yield this.getNetwork(), e = yield e;
        const n = {
          transactionHash: this.formatter.hash(e, true)
        };
        return Pc(() => He(this, void 0, void 0, function* () {
          const r = yield this.perform("getTransaction", n);
          if (r == null) return this._emitted["t:" + e] == null ? null : void 0;
          const i = this.formatter.transactionResponse(r);
          if (i.blockNumber == null) i.confirmations = 0;
          else if (i.confirmations == null) {
            let o = (yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval)) - i.blockNumber + 1;
            o <= 0 && (o = 1), i.confirmations = o;
          }
          return this._wrapTransaction(i);
        }), {
          oncePoll: this
        });
      });
    }
    getTransactionReceipt(e) {
      return He(this, void 0, void 0, function* () {
        yield this.getNetwork(), e = yield e;
        const n = {
          transactionHash: this.formatter.hash(e, true)
        };
        return Pc(() => He(this, void 0, void 0, function* () {
          const r = yield this.perform("getTransactionReceipt", n);
          if (r == null) return this._emitted["t:" + e] == null ? null : void 0;
          if (r.blockHash == null) return;
          const i = this.formatter.receipt(r);
          if (i.blockNumber == null) i.confirmations = 0;
          else if (i.confirmations == null) {
            let o = (yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval)) - i.blockNumber + 1;
            o <= 0 && (o = 1), i.confirmations = o;
          }
          return i;
        }), {
          oncePoll: this
        });
      });
    }
    getLogs(e) {
      return He(this, void 0, void 0, function* () {
        yield this.getNetwork();
        const n = yield tn({
          filter: this._getFilter(e)
        }), r = yield this.perform("getLogs", n);
        return r.forEach((i) => {
          i.removed == null && (i.removed = false);
        }), _e.arrayOf(this.formatter.filterLog.bind(this.formatter))(r);
      });
    }
    getEtherPrice() {
      return He(this, void 0, void 0, function* () {
        return yield this.getNetwork(), this.perform("getEtherPrice", {});
      });
    }
    _getBlockTag(e) {
      return He(this, void 0, void 0, function* () {
        if (e = yield e, typeof e == "number" && e < 0) {
          e % 1 && qe.throwArgumentError("invalid BlockTag", "blockTag", e);
          let n = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
          return n += e, n < 0 && (n = 0), this.formatter.blockTag(n);
        }
        return this.formatter.blockTag(e);
      });
    }
    getResolver(e) {
      return He(this, void 0, void 0, function* () {
        let n = e;
        for (; ; ) {
          if (n === "" || n === "." || e !== "eth" && n === "eth") return null;
          const r = yield this._getResolver(n, "getResolver");
          if (r != null) {
            const i = new uv(this, r, e);
            return n !== e && !(yield i.supportsWildcard()) ? null : i;
          }
          n = n.split(".").slice(1).join(".");
        }
      });
    }
    _getResolver(e, n) {
      return He(this, void 0, void 0, function* () {
        n == null && (n = "ENS");
        const r = yield this.getNetwork();
        r.ensAddress || qe.throwError("network does not support ENS", oe.errors.UNSUPPORTED_OPERATION, {
          operation: n,
          network: r.name
        });
        try {
          const i = yield this.call({
            to: r.ensAddress,
            data: "0x0178b8bf" + vu(e).substring(2)
          });
          return this.formatter.callAddress(i);
        } catch {
        }
        return null;
      });
    }
    resolveName(e) {
      return He(this, void 0, void 0, function* () {
        e = yield e;
        try {
          return Promise.resolve(this.formatter.address(e));
        } catch (r) {
          if (st(e)) throw r;
        }
        typeof e != "string" && qe.throwArgumentError("invalid ENS name", "name", e);
        const n = yield this.getResolver(e);
        return n ? yield n.getAddress() : null;
      });
    }
    lookupAddress(e) {
      return He(this, void 0, void 0, function* () {
        e = yield e, e = this.formatter.address(e);
        const n = e.substring(2).toLowerCase() + ".addr.reverse", r = yield this._getResolver(n, "lookupAddress");
        if (r == null) return null;
        const i = O0(yield this.call({
          to: r,
          data: "0x691f3431" + vu(n).substring(2)
        }), 0);
        return (yield this.resolveName(i)) != e ? null : i;
      });
    }
    getAvatar(e) {
      return He(this, void 0, void 0, function* () {
        let n = null;
        if (st(e)) {
          const s = this.formatter.address(e).substring(2).toLowerCase() + ".addr.reverse", o = yield this._getResolver(s, "getAvatar");
          if (!o) return null;
          n = new uv(this, o, s);
          try {
            const a = yield n.getAvatar();
            if (a) return a.url;
          } catch (a) {
            if (a.code !== oe.errors.CALL_EXCEPTION) throw a;
          }
          try {
            const a = O0(yield this.call({
              to: o,
              data: "0x691f3431" + vu(s).substring(2)
            }), 0);
            n = yield this.getResolver(a);
          } catch (a) {
            if (a.code !== oe.errors.CALL_EXCEPTION) throw a;
            return null;
          }
        } else if (n = yield this.getResolver(e), !n) return null;
        const r = yield n.getAvatar();
        return r == null ? null : r.url;
      });
    }
    perform(e, n) {
      return qe.throwError(e + " not implemented", oe.errors.NOT_IMPLEMENTED, {
        operation: e
      });
    }
    _startEvent(e) {
      this.polling = this._events.filter((n) => n.pollable()).length > 0;
    }
    _stopEvent(e) {
      this.polling = this._events.filter((n) => n.pollable()).length > 0;
    }
    _addEventListener(e, n, r) {
      const i = new YJ(oc(e), n, r);
      return this._events.push(i), this._startEvent(i), this;
    }
    on(e, n) {
      return this._addEventListener(e, n, false);
    }
    once(e, n) {
      return this._addEventListener(e, n, true);
    }
    emit(e, ...n) {
      let r = false, i = [], s = oc(e);
      return this._events = this._events.filter((o) => o.tag !== s ? true : (setTimeout(() => {
        o.listener.apply(this, n);
      }, 0), r = true, o.once ? (i.push(o), false) : true)), i.forEach((o) => {
        this._stopEvent(o);
      }), r;
    }
    listenerCount(e) {
      if (!e) return this._events.length;
      let n = oc(e);
      return this._events.filter((r) => r.tag === n).length;
    }
    listeners(e) {
      if (e == null) return this._events.map((r) => r.listener);
      let n = oc(e);
      return this._events.filter((r) => r.tag === n).map((r) => r.listener);
    }
    off(e, n) {
      if (n == null) return this.removeAllListeners(e);
      const r = [];
      let i = false, s = oc(e);
      return this._events = this._events.filter((o) => o.tag !== s || o.listener != n || i ? true : (i = true, r.push(o), false)), r.forEach((o) => {
        this._stopEvent(o);
      }), this;
    }
    removeAllListeners(e) {
      let n = [];
      if (e == null) n = this._events, this._events = [];
      else {
        const r = oc(e);
        this._events = this._events.filter((i) => i.tag !== r ? true : (n.push(i), false));
      }
      return n.forEach((r) => {
        this._stopEvent(r);
      }), this;
    }
  }
  var ws = function(t, e, n, r) {
    function i(s) {
      return s instanceof n ? s : new n(function(o) {
        o(s);
      });
    }
    return new (n || (n = Promise))(function(s, o) {
      function a(u) {
        try {
          l(r.next(u));
        } catch (f) {
          o(f);
        }
      }
      function c(u) {
        try {
          l(r.throw(u));
        } catch (f) {
          o(f);
        }
      }
      function l(u) {
        u.done ? s(u.value) : i(u.value).then(a, c);
      }
      l((r = r.apply(t, e || [])).next());
    });
  };
  const mn = new oe(Bh), tK = [
    "call",
    "estimateGas"
  ];
  function Su(t, e) {
    if (t == null) return null;
    if (typeof t.message == "string" && t.message.match("reverted")) {
      const n = st(t.data) ? t.data : null;
      if (!e || n) return {
        message: t.message,
        data: n
      };
    }
    if (typeof t == "object") {
      for (const n in t) {
        const r = Su(t[n], e);
        if (r) return r;
      }
      return null;
    }
    if (typeof t == "string") try {
      return Su(JSON.parse(t), e);
    } catch {
    }
    return null;
  }
  function J7(t, e, n) {
    const r = n.transaction || n.signedTransaction;
    if (t === "call") {
      const s = Su(e, true);
      if (s) return s.data;
      mn.throwError("missing revert data in call exception; Transaction reverted without a reason string", oe.errors.CALL_EXCEPTION, {
        data: "0x",
        transaction: r,
        error: e
      });
    }
    if (t === "estimateGas") {
      let s = Su(e.body, false);
      s == null && (s = Su(e, false)), s && mn.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", oe.errors.UNPREDICTABLE_GAS_LIMIT, {
        reason: s.message,
        method: t,
        transaction: r,
        error: e
      });
    }
    let i = e.message;
    throw e.code === oe.errors.SERVER_ERROR && e.error && typeof e.error.message == "string" ? i = e.error.message : typeof e.body == "string" ? i = e.body : typeof e.responseText == "string" && (i = e.responseText), i = (i || "").toLowerCase(), i.match(/insufficient funds|base fee exceeds gas limit|InsufficientFunds/i) && mn.throwError("insufficient funds for intrinsic transaction cost", oe.errors.INSUFFICIENT_FUNDS, {
      error: e,
      method: t,
      transaction: r
    }), i.match(/nonce (is )?too low/i) && mn.throwError("nonce has already been used", oe.errors.NONCE_EXPIRED, {
      error: e,
      method: t,
      transaction: r
    }), i.match(/replacement transaction underpriced|transaction gas price.*too low/i) && mn.throwError("replacement fee too low", oe.errors.REPLACEMENT_UNDERPRICED, {
      error: e,
      method: t,
      transaction: r
    }), i.match(/only replay-protected/i) && mn.throwError("legacy pre-eip-155 transactions not supported", oe.errors.UNSUPPORTED_OPERATION, {
      error: e,
      method: t,
      transaction: r
    }), tK.indexOf(t) >= 0 && i.match(/gas required exceeds allowance|always failing transaction|execution reverted|revert/) && mn.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", oe.errors.UNPREDICTABLE_GAS_LIMIT, {
      error: e,
      method: t,
      transaction: r
    }), e;
  }
  function fv(t) {
    return new Promise(function(e) {
      setTimeout(e, t);
    });
  }
  function nK(t) {
    if (t.error) {
      const e = new Error(t.error.message);
      throw e.code = t.error.code, e.data = t.error.data, e;
    }
    return t.result;
  }
  function Yl(t) {
    return t && t.toLowerCase();
  }
  const f1 = {};
  class K7 extends Il {
    constructor(e, n, r) {
      if (super(), e !== f1) throw new Error("do not call the JsonRpcSigner constructor directly; use provider.getSigner");
      ge(this, "provider", n), r == null && (r = 0), typeof r == "string" ? (ge(this, "_address", this.provider.formatter.address(r)), ge(this, "_index", null)) : typeof r == "number" ? (ge(this, "_index", r), ge(this, "_address", null)) : mn.throwArgumentError("invalid address or index", "addressOrIndex", r);
    }
    connect(e) {
      return mn.throwError("cannot alter JSON-RPC Signer connection", oe.errors.UNSUPPORTED_OPERATION, {
        operation: "connect"
      });
    }
    connectUnchecked() {
      return new rK(f1, this.provider, this._address || this._index);
    }
    getAddress() {
      return this._address ? Promise.resolve(this._address) : this.provider.send("eth_accounts", []).then((e) => (e.length <= this._index && mn.throwError("unknown account #" + this._index, oe.errors.UNSUPPORTED_OPERATION, {
        operation: "getAddress"
      }), this.provider.formatter.address(e[this._index])));
    }
    sendUncheckedTransaction(e) {
      e = bn(e);
      const n = this.getAddress().then((r) => (r && (r = r.toLowerCase()), r));
      if (e.gasLimit == null) {
        const r = bn(e);
        r.from = n, e.gasLimit = this.provider.estimateGas(r);
      }
      return e.to != null && (e.to = Promise.resolve(e.to).then((r) => ws(this, void 0, void 0, function* () {
        if (r == null) return null;
        const i = yield this.provider.resolveName(r);
        return i == null && mn.throwArgumentError("provided ENS name resolves to null", "tx.to", r), i;
      }))), tn({
        tx: tn(e),
        sender: n
      }).then(({ tx: r, sender: i }) => {
        r.from != null ? r.from.toLowerCase() !== i && mn.throwArgumentError("from address mismatch", "transaction", e) : r.from = i;
        const s = this.provider.constructor.hexlifyTransaction(r, {
          from: true
        });
        return this.provider.send("eth_sendTransaction", [
          s
        ]).then((o) => o, (o) => (typeof o.message == "string" && o.message.match(/user denied/i) && mn.throwError("user rejected transaction", oe.errors.ACTION_REJECTED, {
          action: "sendTransaction",
          transaction: r
        }), J7("sendTransaction", o, s)));
      });
    }
    signTransaction(e) {
      return mn.throwError("signing transactions is unsupported", oe.errors.UNSUPPORTED_OPERATION, {
        operation: "signTransaction"
      });
    }
    sendTransaction(e) {
      return ws(this, void 0, void 0, function* () {
        const n = yield this.provider._getInternalBlockNumber(100 + 2 * this.provider.pollingInterval), r = yield this.sendUncheckedTransaction(e);
        try {
          return yield Pc(() => ws(this, void 0, void 0, function* () {
            const i = yield this.provider.getTransaction(r);
            if (i !== null) return this.provider._wrapTransaction(i, r, n);
          }), {
            oncePoll: this.provider
          });
        } catch (i) {
          throw i.transactionHash = r, i;
        }
      });
    }
    signMessage(e) {
      return ws(this, void 0, void 0, function* () {
        const n = typeof e == "string" ? gn(e) : e, r = yield this.getAddress();
        try {
          return yield this.provider.send("personal_sign", [
            Ee(n),
            r.toLowerCase()
          ]);
        } catch (i) {
          throw typeof i.message == "string" && i.message.match(/user denied/i) && mn.throwError("user rejected signing", oe.errors.ACTION_REJECTED, {
            action: "signMessage",
            from: r,
            messageData: e
          }), i;
        }
      });
    }
    _legacySignMessage(e) {
      return ws(this, void 0, void 0, function* () {
        const n = typeof e == "string" ? gn(e) : e, r = yield this.getAddress();
        try {
          return yield this.provider.send("eth_sign", [
            r.toLowerCase(),
            Ee(n)
          ]);
        } catch (i) {
          throw typeof i.message == "string" && i.message.match(/user denied/i) && mn.throwError("user rejected signing", oe.errors.ACTION_REJECTED, {
            action: "_legacySignMessage",
            from: r,
            messageData: e
          }), i;
        }
      });
    }
    _signTypedData(e, n, r) {
      return ws(this, void 0, void 0, function* () {
        const i = yield Mn.resolveNames(e, n, r, (o) => this.provider.resolveName(o)), s = yield this.getAddress();
        try {
          return yield this.provider.send("eth_signTypedData_v4", [
            s.toLowerCase(),
            JSON.stringify(Mn.getPayload(i.domain, n, i.value))
          ]);
        } catch (o) {
          throw typeof o.message == "string" && o.message.match(/user denied/i) && mn.throwError("user rejected signing", oe.errors.ACTION_REJECTED, {
            action: "_signTypedData",
            from: s,
            messageData: {
              domain: i.domain,
              types: n,
              value: i.value
            }
          }), o;
        }
      });
    }
    unlock(e) {
      return ws(this, void 0, void 0, function* () {
        const n = this.provider, r = yield this.getAddress();
        return n.send("personal_unlockAccount", [
          r.toLowerCase(),
          e,
          null
        ]);
      });
    }
  }
  class rK extends K7 {
    sendTransaction(e) {
      return this.sendUncheckedTransaction(e).then((n) => ({
        hash: n,
        nonce: null,
        gasLimit: null,
        gasPrice: null,
        data: null,
        value: null,
        chainId: null,
        confirmations: 0,
        from: null,
        wait: (r) => this.provider.waitForTransaction(n, r)
      }));
    }
  }
  const iK = {
    chainId: true,
    data: true,
    gasLimit: true,
    gasPrice: true,
    nonce: true,
    to: true,
    value: true,
    type: true,
    accessList: true,
    maxFeePerGas: true,
    maxPriorityFeePerGas: true
  };
  class W7 extends eK {
    constructor(e, n) {
      let r = n;
      r == null && (r = new Promise((i, s) => {
        setTimeout(() => {
          this.detectNetwork().then((o) => {
            i(o);
          }, (o) => {
            s(o);
          });
        }, 0);
      })), super(r), e || (e = bi(this.constructor, "defaultUrl")()), typeof e == "string" ? ge(this, "connection", Object.freeze({
        url: e
      })) : ge(this, "connection", Object.freeze(bn(e))), this._nextId = 42;
    }
    get _cache() {
      return this._eventLoopCache == null && (this._eventLoopCache = {}), this._eventLoopCache;
    }
    static defaultUrl() {
      return "http://localhost:8545";
    }
    detectNetwork() {
      return this._cache.detectNetwork || (this._cache.detectNetwork = this._uncachedDetectNetwork(), setTimeout(() => {
        this._cache.detectNetwork = null;
      }, 0)), this._cache.detectNetwork;
    }
    _uncachedDetectNetwork() {
      return ws(this, void 0, void 0, function* () {
        yield fv(0);
        let e = null;
        try {
          e = yield this.send("eth_chainId", []);
        } catch {
          try {
            e = yield this.send("net_version", []);
          } catch {
          }
        }
        if (e != null) {
          const n = bi(this.constructor, "getNetwork");
          try {
            return n(ve.from(e).toNumber());
          } catch (r) {
            return mn.throwError("could not detect network", oe.errors.NETWORK_ERROR, {
              chainId: e,
              event: "invalidNetwork",
              serverError: r
            });
          }
        }
        return mn.throwError("could not detect network", oe.errors.NETWORK_ERROR, {
          event: "noNetwork"
        });
      });
    }
    getSigner(e) {
      return new K7(f1, this, e);
    }
    getUncheckedSigner(e) {
      return this.getSigner(e).connectUnchecked();
    }
    listAccounts() {
      return this.send("eth_accounts", []).then((e) => e.map((n) => this.formatter.address(n)));
    }
    send(e, n) {
      const r = {
        method: e,
        params: n,
        id: this._nextId++,
        jsonrpc: "2.0"
      };
      this.emit("debug", {
        action: "request",
        request: rs(r),
        provider: this
      });
      const i = [
        "eth_chainId",
        "eth_blockNumber"
      ].indexOf(e) >= 0;
      if (i && this._cache[e]) return this._cache[e];
      const s = Nh(this.connection, JSON.stringify(r), nK).then((o) => (this.emit("debug", {
        action: "response",
        request: r,
        response: o,
        provider: this
      }), o), (o) => {
        throw this.emit("debug", {
          action: "response",
          error: o,
          request: r,
          provider: this
        }), o;
      });
      return i && (this._cache[e] = s, setTimeout(() => {
        this._cache[e] = null;
      }, 0)), s;
    }
    prepareRequest(e, n) {
      switch (e) {
        case "getBlockNumber":
          return [
            "eth_blockNumber",
            []
          ];
        case "getGasPrice":
          return [
            "eth_gasPrice",
            []
          ];
        case "getBalance":
          return [
            "eth_getBalance",
            [
              Yl(n.address),
              n.blockTag
            ]
          ];
        case "getTransactionCount":
          return [
            "eth_getTransactionCount",
            [
              Yl(n.address),
              n.blockTag
            ]
          ];
        case "getCode":
          return [
            "eth_getCode",
            [
              Yl(n.address),
              n.blockTag
            ]
          ];
        case "getStorageAt":
          return [
            "eth_getStorageAt",
            [
              Yl(n.address),
              xt(n.position, 32),
              n.blockTag
            ]
          ];
        case "sendTransaction":
          return [
            "eth_sendRawTransaction",
            [
              n.signedTransaction
            ]
          ];
        case "getBlock":
          return n.blockTag ? [
            "eth_getBlockByNumber",
            [
              n.blockTag,
              !!n.includeTransactions
            ]
          ] : n.blockHash ? [
            "eth_getBlockByHash",
            [
              n.blockHash,
              !!n.includeTransactions
            ]
          ] : null;
        case "getTransaction":
          return [
            "eth_getTransactionByHash",
            [
              n.transactionHash
            ]
          ];
        case "getTransactionReceipt":
          return [
            "eth_getTransactionReceipt",
            [
              n.transactionHash
            ]
          ];
        case "call":
          return [
            "eth_call",
            [
              bi(this.constructor, "hexlifyTransaction")(n.transaction, {
                from: true
              }),
              n.blockTag
            ]
          ];
        case "estimateGas":
          return [
            "eth_estimateGas",
            [
              bi(this.constructor, "hexlifyTransaction")(n.transaction, {
                from: true
              })
            ]
          ];
        case "getLogs":
          return n.filter && n.filter.address != null && (n.filter.address = Yl(n.filter.address)), [
            "eth_getLogs",
            [
              n.filter
            ]
          ];
      }
      return null;
    }
    perform(e, n) {
      return ws(this, void 0, void 0, function* () {
        if (e === "call" || e === "estimateGas") {
          const i = n.transaction;
          if (i && i.type != null && ve.from(i.type).isZero() && i.maxFeePerGas == null && i.maxPriorityFeePerGas == null) {
            const s = yield this.getFeeData();
            s.maxFeePerGas == null && s.maxPriorityFeePerGas == null && (n = bn(n), n.transaction = bn(i), delete n.transaction.type);
          }
        }
        const r = this.prepareRequest(e, n);
        r == null && mn.throwError(e + " not implemented", oe.errors.NOT_IMPLEMENTED, {
          operation: e
        });
        try {
          return yield this.send(r[0], r[1]);
        } catch (i) {
          return J7(e, i, n);
        }
      });
    }
    _startEvent(e) {
      e.tag === "pending" && this._startPending(), super._startEvent(e);
    }
    _startPending() {
      if (this._pendingFilter != null) return;
      const e = this, n = this.send("eth_newPendingTransactionFilter", []);
      this._pendingFilter = n, n.then(function(r) {
        function i() {
          e.send("eth_getFilterChanges", [
            r
          ]).then(function(s) {
            if (e._pendingFilter != n) return null;
            let o = Promise.resolve();
            return s.forEach(function(a) {
              e._emitted["t:" + a.toLowerCase()] = "pending", o = o.then(function() {
                return e.getTransaction(a).then(function(c) {
                  return e.emit("pending", c), null;
                });
              });
            }), o.then(function() {
              return fv(1e3);
            });
          }).then(function() {
            if (e._pendingFilter != n) {
              e.send("eth_uninstallFilter", [
                r
              ]);
              return;
            }
            return setTimeout(function() {
              i();
            }, 0), null;
          }).catch((s) => {
          });
        }
        return i(), r;
      }).catch((r) => {
      });
    }
    _stopEvent(e) {
      e.tag === "pending" && this.listenerCount("pending") === 0 && (this._pendingFilter = null), super._stopEvent(e);
    }
    static hexlifyTransaction(e, n) {
      const r = bn(iK);
      if (n) for (const s in n) n[s] && (r[s] = true);
      Oy(e, r);
      const i = {};
      return [
        "chainId",
        "gasLimit",
        "gasPrice",
        "type",
        "maxFeePerGas",
        "maxPriorityFeePerGas",
        "nonce",
        "value"
      ].forEach(function(s) {
        if (e[s] == null) return;
        const o = xh(ve.from(e[s]));
        s === "gasLimit" && (s = "gas"), i[s] = o;
      }), [
        "from",
        "to",
        "data"
      ].forEach(function(s) {
        e[s] != null && (i[s] = Ee(e[s]));
      }), e.accessList && (i.accessList = Ja(e.accessList)), i;
    }
  }
  const dv = new oe(Bh);
  let sK = 1;
  function hv(t, e) {
    const n = "Web3LegacyFetcher";
    return function(r, i) {
      const s = {
        method: r,
        params: i,
        id: sK++,
        jsonrpc: "2.0"
      };
      return new Promise((o, a) => {
        this.emit("debug", {
          action: "request",
          fetcher: n,
          request: rs(s),
          provider: this
        }), e(s, (c, l) => {
          if (c) return this.emit("debug", {
            action: "response",
            fetcher: n,
            error: c,
            request: s,
            provider: this
          }), a(c);
          if (this.emit("debug", {
            action: "response",
            fetcher: n,
            request: s,
            response: l,
            provider: this
          }), l.error) {
            const u = new Error(l.error.message);
            return u.code = l.error.code, u.data = l.error.data, a(u);
          }
          o(l.result);
        });
      });
    };
  }
  function oK(t) {
    return function(e, n) {
      n == null && (n = []);
      const r = {
        method: e,
        params: n
      };
      return this.emit("debug", {
        action: "request",
        fetcher: "Eip1193Fetcher",
        request: rs(r),
        provider: this
      }), t.request(r).then((i) => (this.emit("debug", {
        action: "response",
        fetcher: "Eip1193Fetcher",
        request: r,
        response: i,
        provider: this
      }), i), (i) => {
        throw this.emit("debug", {
          action: "response",
          fetcher: "Eip1193Fetcher",
          request: r,
          error: i,
          provider: this
        }), i;
      });
    };
  }
  class aK extends W7 {
    constructor(e, n) {
      e == null && dv.throwArgumentError("missing provider", "provider", e);
      let r = null, i = null, s = null;
      typeof e == "function" ? (r = "unknown:", i = e) : (r = e.host || e.path || "", !r && e.isMetaMask && (r = "metamask"), s = e, e.request ? (r === "" && (r = "eip-1193:"), i = oK(e)) : e.sendAsync ? i = hv(e, e.sendAsync.bind(e)) : e.send ? i = hv(e, e.send.bind(e)) : dv.throwArgumentError("unsupported provider", "provider", e), r || (r = "unknown:")), super(r, n), ge(this, "jsonRpcFetchFunc", i), ge(this, "provider", s);
    }
    send(e, n) {
      return this.jsonRpcFetchFunc(e, n);
    }
  }
  const cK = "solidity/5.8.0", lK = new RegExp("^bytes([0-9]+)$"), uK = new RegExp("^(u?int)([0-9]*)$"), fK = new RegExp("^(.*)\\[([0-9]*)\\]$"), dK = "0000000000000000000000000000000000000000000000000000000000000000", xc = new oe(cK);
  function q7(t, e, n) {
    switch (t) {
      case "address":
        return n ? xu(e, 32) : Ae(e);
      case "string":
        return gn(e);
      case "bytes":
        return Ae(e);
      case "bool":
        return e = e ? "0x01" : "0x00", n ? xu(e, 32) : Ae(e);
    }
    let r = t.match(uK);
    if (r) {
      let i = parseInt(r[2] || "256");
      return (r[2] && String(i) !== r[2] || i % 8 !== 0 || i === 0 || i > 256) && xc.throwArgumentError("invalid number type", "type", t), n && (i = 256), e = ve.from(e).toTwos(i), xu(e, i / 8);
    }
    if (r = t.match(lK), r) {
      const i = parseInt(r[1]);
      return (String(i) !== r[1] || i === 0 || i > 32) && xc.throwArgumentError("invalid bytes type", "type", t), Ae(e).byteLength !== i && xc.throwArgumentError(`invalid value for ${t}`, "value", e), n ? Ae((e + dK).substring(0, 66)) : e;
    }
    if (r = t.match(fK), r && Array.isArray(e)) {
      const i = r[1];
      parseInt(r[2] || String(e.length)) != e.length && xc.throwArgumentError(`invalid array length for ${t}`, "value", e);
      const o = [];
      return e.forEach(function(a) {
        o.push(q7(i, a, true));
      }), Et(o);
    }
    return xc.throwArgumentError("invalid type", "type", t);
  }
  function eb(t, e) {
    t.length != e.length && xc.throwArgumentError("wrong number of values; expected ${ types.length }", "values", e);
    const n = [];
    return t.forEach(function(r, i) {
      n.push(q7(r, e[i]));
    }), Ee(Et(n));
  }
  function hK(t, e) {
    return mt(eb(t, e));
  }
  function pK(t, e) {
    return Gs(eb(t, e));
  }
  const gK = Object.freeze(Object.defineProperty({
    __proto__: null,
    keccak256: hK,
    pack: eb,
    sha256: pK
  }, Symbol.toStringTag, {
    value: "Module"
  })), mK = "units/5.8.0", Y7 = new oe(mK), X7 = [
    "wei",
    "kwei",
    "mwei",
    "gwei",
    "szabo",
    "finney",
    "ether"
  ];
  function yK(t) {
    const e = String(t).split(".");
    (e.length > 2 || !e[0].match(/^-?[0-9]*$/) || e[1] && !e[1].match(/^[0-9]*$/) || t === "." || t === "-.") && Y7.throwArgumentError("invalid value", "value", t);
    let n = e[0], r = "";
    for (n.substring(0, 1) === "-" && (r = "-", n = n.substring(1)); n.substring(0, 1) === "0"; ) n = n.substring(1);
    n === "" && (n = "0");
    let i = "";
    for (e.length === 2 && (i = "." + (e[1] || "0")); i.length > 2 && i[i.length - 1] === "0"; ) i = i.substring(0, i.length - 1);
    const s = [];
    for (; n.length; ) if (n.length <= 3) {
      s.unshift(n);
      break;
    } else {
      const o = n.length - 3;
      s.unshift(n.substring(o)), n = n.substring(0, o);
    }
    return r + s.join(",") + i;
  }
  function Z7(t, e) {
    if (typeof e == "string") {
      const n = X7.indexOf(e);
      n !== -1 && (e = 3 * n);
    }
    return C0(t, e ?? 18);
  }
  function Mh(t, e) {
    if (typeof t != "string" && Y7.throwArgumentError("value must be a string", "value", t), typeof e == "string") {
      const n = X7.indexOf(e);
      n !== -1 && (e = 3 * n);
    }
    return Oi(t, e ?? 18);
  }
  function bK(t) {
    return Z7(t, 18);
  }
  function xK(t) {
    return Mh(t, 18);
  }
  const AK = Object.freeze(Object.defineProperty({
    __proto__: null,
    commify: yK,
    formatEther: bK,
    formatUnits: Z7,
    parseEther: xK,
    parseUnits: Mh
  }, Symbol.toStringTag, {
    value: "Module"
  })), pv = (t) => ({
    success: false,
    result: t
  }), gv = (t) => ({
    success: true,
    result: t
  }), wK = (t, e = 1e3) => t.mul(ve.from(1e4).add(ve.from(e))).div(ve.from(1e4));
  var $7 = {};
  const vK = sn(Lz), EK = sn(xV), SK = sn(tz), TK = sn(Kj), CK = sn(KG), IK = sn(Mz), PK = sn(cJ), _K = sn(EJ), RK = sn(uV), NK = sn(jG), mv = sn(Xj), OK = sn(gK), BK = sn(dJ), MK = sn(nV), kK = sn(dV), FK = sn(_j), yv = sn(XV), LK = sn(Lj), DK = sn(AK), UK = sn(_J), HK = sn(DJ);
  (function(t) {
    var e = Cr && Cr.__createBinding || (Object.create ? function(K, z, I, h) {
      h === void 0 && (h = I), Object.defineProperty(K, h, {
        enumerable: true,
        get: function() {
          return z[I];
        }
      });
    } : function(K, z, I, h) {
      h === void 0 && (h = I), K[h] = z[I];
    }), n = Cr && Cr.__setModuleDefault || (Object.create ? function(K, z) {
      Object.defineProperty(K, "default", {
        enumerable: true,
        value: z
      });
    } : function(K, z) {
      K.default = z;
    }), r = Cr && Cr.__importStar || function(K) {
      if (K && K.__esModule) return K;
      var z = {};
      if (K != null) for (var I in K) I !== "default" && Object.prototype.hasOwnProperty.call(K, I) && e(z, K, I);
      return n(z, K), z;
    };
    Object.defineProperty(t, "__esModule", {
      value: true
    }), t.formatBytes32String = t.Utf8ErrorFuncs = t.toUtf8String = t.toUtf8CodePoints = t.toUtf8Bytes = t._toEscapedUtf8String = t.nameprep = t.hexDataSlice = t.hexDataLength = t.hexZeroPad = t.hexValue = t.hexStripZeros = t.hexConcat = t.isHexString = t.hexlify = t.base64 = t.base58 = t.TransactionDescription = t.LogDescription = t.Interface = t.SigningKey = t.HDNode = t.defaultPath = t.isBytesLike = t.isBytes = t.zeroPad = t.stripZeros = t.concat = t.arrayify = t.shallowCopy = t.resolveProperties = t.getStatic = t.defineReadOnly = t.deepCopy = t.checkProperties = t.poll = t.fetchJson = t._fetchData = t.RLP = t.Logger = t.checkResultErrors = t.FormatTypes = t.ParamType = t.FunctionFragment = t.EventFragment = t.ErrorFragment = t.ConstructorFragment = t.Fragment = t.defaultAbiCoder = t.AbiCoder = void 0, t.Indexed = t.Utf8ErrorReason = t.UnicodeNormalizationForm = t.SupportedAlgorithm = t.mnemonicToSeed = t.isValidMnemonic = t.entropyToMnemonic = t.mnemonicToEntropy = t.getAccountPath = t.verifyTypedData = t.verifyMessage = t.recoverPublicKey = t.computePublicKey = t.recoverAddress = t.computeAddress = t.getJsonWalletAddress = t.TransactionTypes = t.serializeTransaction = t.parseTransaction = t.accessListify = t.joinSignature = t.splitSignature = t.soliditySha256 = t.solidityKeccak256 = t.solidityPack = t.shuffled = t.randomBytes = t.sha512 = t.sha256 = t.ripemd160 = t.keccak256 = t.computeHmac = t.commify = t.parseUnits = t.formatUnits = t.parseEther = t.formatEther = t.isAddress = t.getCreate2Address = t.getContractAddress = t.getIcapAddress = t.getAddress = t._TypedDataEncoder = t.id = t.isValidName = t.namehash = t.hashMessage = t.dnsEncode = t.parseBytes32String = void 0;
    var i = vK;
    Object.defineProperty(t, "AbiCoder", {
      enumerable: true,
      get: function() {
        return i.AbiCoder;
      }
    }), Object.defineProperty(t, "checkResultErrors", {
      enumerable: true,
      get: function() {
        return i.checkResultErrors;
      }
    }), Object.defineProperty(t, "ConstructorFragment", {
      enumerable: true,
      get: function() {
        return i.ConstructorFragment;
      }
    }), Object.defineProperty(t, "defaultAbiCoder", {
      enumerable: true,
      get: function() {
        return i.defaultAbiCoder;
      }
    }), Object.defineProperty(t, "ErrorFragment", {
      enumerable: true,
      get: function() {
        return i.ErrorFragment;
      }
    }), Object.defineProperty(t, "EventFragment", {
      enumerable: true,
      get: function() {
        return i.EventFragment;
      }
    }), Object.defineProperty(t, "FormatTypes", {
      enumerable: true,
      get: function() {
        return i.FormatTypes;
      }
    }), Object.defineProperty(t, "Fragment", {
      enumerable: true,
      get: function() {
        return i.Fragment;
      }
    }), Object.defineProperty(t, "FunctionFragment", {
      enumerable: true,
      get: function() {
        return i.FunctionFragment;
      }
    }), Object.defineProperty(t, "Indexed", {
      enumerable: true,
      get: function() {
        return i.Indexed;
      }
    }), Object.defineProperty(t, "Interface", {
      enumerable: true,
      get: function() {
        return i.Interface;
      }
    }), Object.defineProperty(t, "LogDescription", {
      enumerable: true,
      get: function() {
        return i.LogDescription;
      }
    }), Object.defineProperty(t, "ParamType", {
      enumerable: true,
      get: function() {
        return i.ParamType;
      }
    }), Object.defineProperty(t, "TransactionDescription", {
      enumerable: true,
      get: function() {
        return i.TransactionDescription;
      }
    });
    var s = EK;
    Object.defineProperty(t, "getAddress", {
      enumerable: true,
      get: function() {
        return s.getAddress;
      }
    }), Object.defineProperty(t, "getCreate2Address", {
      enumerable: true,
      get: function() {
        return s.getCreate2Address;
      }
    }), Object.defineProperty(t, "getContractAddress", {
      enumerable: true,
      get: function() {
        return s.getContractAddress;
      }
    }), Object.defineProperty(t, "getIcapAddress", {
      enumerable: true,
      get: function() {
        return s.getIcapAddress;
      }
    }), Object.defineProperty(t, "isAddress", {
      enumerable: true,
      get: function() {
        return s.isAddress;
      }
    });
    var o = r(SK);
    t.base64 = o;
    var a = TK;
    Object.defineProperty(t, "base58", {
      enumerable: true,
      get: function() {
        return a.Base58;
      }
    });
    var c = CK;
    Object.defineProperty(t, "arrayify", {
      enumerable: true,
      get: function() {
        return c.arrayify;
      }
    }), Object.defineProperty(t, "concat", {
      enumerable: true,
      get: function() {
        return c.concat;
      }
    }), Object.defineProperty(t, "hexConcat", {
      enumerable: true,
      get: function() {
        return c.hexConcat;
      }
    }), Object.defineProperty(t, "hexDataSlice", {
      enumerable: true,
      get: function() {
        return c.hexDataSlice;
      }
    }), Object.defineProperty(t, "hexDataLength", {
      enumerable: true,
      get: function() {
        return c.hexDataLength;
      }
    }), Object.defineProperty(t, "hexlify", {
      enumerable: true,
      get: function() {
        return c.hexlify;
      }
    }), Object.defineProperty(t, "hexStripZeros", {
      enumerable: true,
      get: function() {
        return c.hexStripZeros;
      }
    }), Object.defineProperty(t, "hexValue", {
      enumerable: true,
      get: function() {
        return c.hexValue;
      }
    }), Object.defineProperty(t, "hexZeroPad", {
      enumerable: true,
      get: function() {
        return c.hexZeroPad;
      }
    }), Object.defineProperty(t, "isBytes", {
      enumerable: true,
      get: function() {
        return c.isBytes;
      }
    }), Object.defineProperty(t, "isBytesLike", {
      enumerable: true,
      get: function() {
        return c.isBytesLike;
      }
    }), Object.defineProperty(t, "isHexString", {
      enumerable: true,
      get: function() {
        return c.isHexString;
      }
    }), Object.defineProperty(t, "joinSignature", {
      enumerable: true,
      get: function() {
        return c.joinSignature;
      }
    }), Object.defineProperty(t, "zeroPad", {
      enumerable: true,
      get: function() {
        return c.zeroPad;
      }
    }), Object.defineProperty(t, "splitSignature", {
      enumerable: true,
      get: function() {
        return c.splitSignature;
      }
    }), Object.defineProperty(t, "stripZeros", {
      enumerable: true,
      get: function() {
        return c.stripZeros;
      }
    });
    var l = IK;
    Object.defineProperty(t, "_TypedDataEncoder", {
      enumerable: true,
      get: function() {
        return l._TypedDataEncoder;
      }
    }), Object.defineProperty(t, "dnsEncode", {
      enumerable: true,
      get: function() {
        return l.dnsEncode;
      }
    }), Object.defineProperty(t, "hashMessage", {
      enumerable: true,
      get: function() {
        return l.hashMessage;
      }
    }), Object.defineProperty(t, "id", {
      enumerable: true,
      get: function() {
        return l.id;
      }
    }), Object.defineProperty(t, "isValidName", {
      enumerable: true,
      get: function() {
        return l.isValidName;
      }
    }), Object.defineProperty(t, "namehash", {
      enumerable: true,
      get: function() {
        return l.namehash;
      }
    });
    var u = PK;
    Object.defineProperty(t, "defaultPath", {
      enumerable: true,
      get: function() {
        return u.defaultPath;
      }
    }), Object.defineProperty(t, "entropyToMnemonic", {
      enumerable: true,
      get: function() {
        return u.entropyToMnemonic;
      }
    }), Object.defineProperty(t, "getAccountPath", {
      enumerable: true,
      get: function() {
        return u.getAccountPath;
      }
    }), Object.defineProperty(t, "HDNode", {
      enumerable: true,
      get: function() {
        return u.HDNode;
      }
    }), Object.defineProperty(t, "isValidMnemonic", {
      enumerable: true,
      get: function() {
        return u.isValidMnemonic;
      }
    }), Object.defineProperty(t, "mnemonicToEntropy", {
      enumerable: true,
      get: function() {
        return u.mnemonicToEntropy;
      }
    }), Object.defineProperty(t, "mnemonicToSeed", {
      enumerable: true,
      get: function() {
        return u.mnemonicToSeed;
      }
    });
    var f = _K;
    Object.defineProperty(t, "getJsonWalletAddress", {
      enumerable: true,
      get: function() {
        return f.getJsonWalletAddress;
      }
    });
    var d = RK;
    Object.defineProperty(t, "keccak256", {
      enumerable: true,
      get: function() {
        return d.keccak256;
      }
    });
    var m = NK;
    Object.defineProperty(t, "Logger", {
      enumerable: true,
      get: function() {
        return m.Logger;
      }
    });
    var y = mv;
    Object.defineProperty(t, "computeHmac", {
      enumerable: true,
      get: function() {
        return y.computeHmac;
      }
    }), Object.defineProperty(t, "ripemd160", {
      enumerable: true,
      get: function() {
        return y.ripemd160;
      }
    }), Object.defineProperty(t, "sha256", {
      enumerable: true,
      get: function() {
        return y.sha256;
      }
    }), Object.defineProperty(t, "sha512", {
      enumerable: true,
      get: function() {
        return y.sha512;
      }
    });
    var x = OK;
    Object.defineProperty(t, "solidityKeccak256", {
      enumerable: true,
      get: function() {
        return x.keccak256;
      }
    }), Object.defineProperty(t, "solidityPack", {
      enumerable: true,
      get: function() {
        return x.pack;
      }
    }), Object.defineProperty(t, "soliditySha256", {
      enumerable: true,
      get: function() {
        return x.sha256;
      }
    });
    var w = BK;
    Object.defineProperty(t, "randomBytes", {
      enumerable: true,
      get: function() {
        return w.randomBytes;
      }
    }), Object.defineProperty(t, "shuffled", {
      enumerable: true,
      get: function() {
        return w.shuffled;
      }
    });
    var R = MK;
    Object.defineProperty(t, "checkProperties", {
      enumerable: true,
      get: function() {
        return R.checkProperties;
      }
    }), Object.defineProperty(t, "deepCopy", {
      enumerable: true,
      get: function() {
        return R.deepCopy;
      }
    }), Object.defineProperty(t, "defineReadOnly", {
      enumerable: true,
      get: function() {
        return R.defineReadOnly;
      }
    }), Object.defineProperty(t, "getStatic", {
      enumerable: true,
      get: function() {
        return R.getStatic;
      }
    }), Object.defineProperty(t, "resolveProperties", {
      enumerable: true,
      get: function() {
        return R.resolveProperties;
      }
    }), Object.defineProperty(t, "shallowCopy", {
      enumerable: true,
      get: function() {
        return R.shallowCopy;
      }
    });
    var O = r(kK);
    t.RLP = O;
    var B = FK;
    Object.defineProperty(t, "computePublicKey", {
      enumerable: true,
      get: function() {
        return B.computePublicKey;
      }
    }), Object.defineProperty(t, "recoverPublicKey", {
      enumerable: true,
      get: function() {
        return B.recoverPublicKey;
      }
    }), Object.defineProperty(t, "SigningKey", {
      enumerable: true,
      get: function() {
        return B.SigningKey;
      }
    });
    var M = yv;
    Object.defineProperty(t, "formatBytes32String", {
      enumerable: true,
      get: function() {
        return M.formatBytes32String;
      }
    }), Object.defineProperty(t, "nameprep", {
      enumerable: true,
      get: function() {
        return M.nameprep;
      }
    }), Object.defineProperty(t, "parseBytes32String", {
      enumerable: true,
      get: function() {
        return M.parseBytes32String;
      }
    }), Object.defineProperty(t, "_toEscapedUtf8String", {
      enumerable: true,
      get: function() {
        return M._toEscapedUtf8String;
      }
    }), Object.defineProperty(t, "toUtf8Bytes", {
      enumerable: true,
      get: function() {
        return M.toUtf8Bytes;
      }
    }), Object.defineProperty(t, "toUtf8CodePoints", {
      enumerable: true,
      get: function() {
        return M.toUtf8CodePoints;
      }
    }), Object.defineProperty(t, "toUtf8String", {
      enumerable: true,
      get: function() {
        return M.toUtf8String;
      }
    }), Object.defineProperty(t, "Utf8ErrorFuncs", {
      enumerable: true,
      get: function() {
        return M.Utf8ErrorFuncs;
      }
    });
    var D = LK;
    Object.defineProperty(t, "accessListify", {
      enumerable: true,
      get: function() {
        return D.accessListify;
      }
    }), Object.defineProperty(t, "computeAddress", {
      enumerable: true,
      get: function() {
        return D.computeAddress;
      }
    }), Object.defineProperty(t, "parseTransaction", {
      enumerable: true,
      get: function() {
        return D.parse;
      }
    }), Object.defineProperty(t, "recoverAddress", {
      enumerable: true,
      get: function() {
        return D.recoverAddress;
      }
    }), Object.defineProperty(t, "serializeTransaction", {
      enumerable: true,
      get: function() {
        return D.serialize;
      }
    }), Object.defineProperty(t, "TransactionTypes", {
      enumerable: true,
      get: function() {
        return D.TransactionTypes;
      }
    });
    var H = DK;
    Object.defineProperty(t, "commify", {
      enumerable: true,
      get: function() {
        return H.commify;
      }
    }), Object.defineProperty(t, "formatEther", {
      enumerable: true,
      get: function() {
        return H.formatEther;
      }
    }), Object.defineProperty(t, "parseEther", {
      enumerable: true,
      get: function() {
        return H.parseEther;
      }
    }), Object.defineProperty(t, "formatUnits", {
      enumerable: true,
      get: function() {
        return H.formatUnits;
      }
    }), Object.defineProperty(t, "parseUnits", {
      enumerable: true,
      get: function() {
        return H.parseUnits;
      }
    });
    var q = UK;
    Object.defineProperty(t, "verifyMessage", {
      enumerable: true,
      get: function() {
        return q.verifyMessage;
      }
    }), Object.defineProperty(t, "verifyTypedData", {
      enumerable: true,
      get: function() {
        return q.verifyTypedData;
      }
    });
    var S = HK;
    Object.defineProperty(t, "_fetchData", {
      enumerable: true,
      get: function() {
        return S._fetchData;
      }
    }), Object.defineProperty(t, "fetchJson", {
      enumerable: true,
      get: function() {
        return S.fetchJson;
      }
    }), Object.defineProperty(t, "poll", {
      enumerable: true,
      get: function() {
        return S.poll;
      }
    });
    var P = mv;
    Object.defineProperty(t, "SupportedAlgorithm", {
      enumerable: true,
      get: function() {
        return P.SupportedAlgorithm;
      }
    });
    var L = yv;
    Object.defineProperty(t, "UnicodeNormalizationForm", {
      enumerable: true,
      get: function() {
        return L.UnicodeNormalizationForm;
      }
    }), Object.defineProperty(t, "Utf8ErrorReason", {
      enumerable: true,
      get: function() {
        return L.Utf8ErrorReason;
      }
    });
  })($7);
  function GK(t, e = 18) {
    return typeof t == "number" && (t = t + ""), Mh(t, e);
  }
  let VK, zK, e9, QK, jK, JK, KK;
  VK = (t = GK(0), e = 18, n = 18) => {
    const r = t.mod(ve.from(10).pow(n - e)), i = $7.formatUnits(t.sub(r), n);
    return i === "0.0" ? "0" : i;
  };
  zK = ({ providerUrl: t }) => {
    let e;
    try {
      e = new aK(window.ethereum);
    } catch {
      e = new W7(t);
    }
    const n = e.getSigner();
    return (i, s) => {
      const a = {
        gasPrice: Mh("1", "gwei")
      }, c = n, l = new jj(s, i, c);
      function u() {
      }
      const f = new u();
      return f.read = async (d, m, ...y) => {
        try {
          const x = await l[d](...y);
          return m ? +VK(x) : x;
        } catch {
        }
      }, f.writeGas = async (d, ...m) => {
        try {
          const y = await l.estimateGas[d](...m), x = await (await l[d](...m, {
            gasLimit: wK(y, 1e3),
            ...a
          })).wait();
          return gv(x);
        } catch (y) {
          return pv(y);
        }
      }, f.write = async (d, ...m) => {
        try {
          const y = await (await l[d](...m, a)).wait();
          return gv(y);
        } catch (y) {
          return pv(y);
        }
      }, f;
    };
  };
  jq = zK({
    providerUrl: ts.provider
  });
  e9 = [
    {
      anonymous: false,
      inputs: [
        {
          indexed: false,
          internalType: "address",
          name: "previousAdmin",
          type: "address"
        },
        {
          indexed: false,
          internalType: "address",
          name: "newAdmin",
          type: "address"
        }
      ],
      name: "AdminChanged",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "beacon",
          type: "address"
        }
      ],
      name: "BeaconUpgraded",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: false,
          internalType: "uint8",
          name: "version",
          type: "uint8"
        }
      ],
      name: "Initialized",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: false,
          internalType: "address",
          name: "from",
          type: "address"
        },
        {
          indexed: false,
          internalType: "address",
          name: "merchant",
          type: "address"
        },
        {
          indexed: false,
          internalType: "uint256",
          name: "_type",
          type: "uint256"
        },
        {
          indexed: false,
          internalType: "uint256",
          name: "amount",
          type: "uint256"
        }
      ],
      name: "LogContributeChange",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: false,
          internalType: "address",
          name: "addr",
          type: "address"
        },
        {
          indexed: false,
          internalType: "bool",
          name: "add",
          type: "bool"
        },
        {
          indexed: false,
          internalType: "uint256",
          name: "amount",
          type: "uint256"
        },
        {
          indexed: false,
          internalType: "uint256",
          name: "now",
          type: "uint256"
        }
      ],
      name: "LogPointBalanceChange",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "parent",
          type: "address"
        }
      ],
      name: "LogRegister",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "bytes32",
          name: "role",
          type: "bytes32"
        },
        {
          indexed: true,
          internalType: "bytes32",
          name: "previousAdminRole",
          type: "bytes32"
        },
        {
          indexed: true,
          internalType: "bytes32",
          name: "newAdminRole",
          type: "bytes32"
        }
      ],
      name: "RoleAdminChanged",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "bytes32",
          name: "role",
          type: "bytes32"
        },
        {
          indexed: true,
          internalType: "address",
          name: "account",
          type: "address"
        },
        {
          indexed: true,
          internalType: "address",
          name: "sender",
          type: "address"
        }
      ],
      name: "RoleGranted",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "bytes32",
          name: "role",
          type: "bytes32"
        },
        {
          indexed: true,
          internalType: "address",
          name: "account",
          type: "address"
        },
        {
          indexed: true,
          internalType: "address",
          name: "sender",
          type: "address"
        }
      ],
      name: "RoleRevoked",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "implementation",
          type: "address"
        }
      ],
      name: "Upgraded",
      type: "event"
    },
    {
      inputs: [],
      name: "CONTRIBUTE_ROLE",
      outputs: [
        {
          internalType: "bytes32",
          name: "",
          type: "bytes32"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "DEFAULT_ADMIN_ROLE",
      outputs: [
        {
          internalType: "bytes32",
          name: "",
          type: "bytes32"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "MALL_ROLE",
      outputs: [
        {
          internalType: "bytes32",
          name: "",
          type: "bytes32"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "OPERATOR_ROLE",
      outputs: [
        {
          internalType: "bytes32",
          name: "",
          type: "bytes32"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "ORACLE_ROLE",
      outputs: [
        {
          internalType: "bytes32",
          name: "",
          type: "bytes32"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "RATE_ROLE",
      outputs: [
        {
          internalType: "bytes32",
          name: "",
          type: "bytes32"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "RELEASE_ROLE",
      outputs: [
        {
          internalType: "bytes32",
          name: "",
          type: "bytes32"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      name: "agentLevelDiffRate",
      outputs: [
        {
          internalType: "uint16",
          name: "",
          type: "uint16"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "",
          type: "address"
        }
      ],
      name: "agentLevels",
      outputs: [
        {
          internalType: "uint8",
          name: "",
          type: "uint8"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "buyMember",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "addr",
          type: "address"
        },
        {
          internalType: "uint256",
          name: "amount",
          type: "uint256"
        }
      ],
      name: "contributeAdd",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "",
          type: "address"
        }
      ],
      name: "contributeAdds",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "",
          type: "address"
        }
      ],
      name: "contributeLastTimes",
      outputs: [
        {
          internalType: "uint32",
          name: "",
          type: "uint32"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "",
          type: "address"
        }
      ],
      name: "contributeSpeedUps",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "",
          type: "address"
        }
      ],
      name: "contributes",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "dao",
      outputs: [
        {
          internalType: "address",
          name: "",
          type: "address"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "addr",
          type: "address"
        },
        {
          internalType: "uint256",
          name: "amount",
          type: "uint256"
        }
      ],
      name: "daoPointTransfer",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "addr",
          type: "address"
        },
        {
          internalType: "uint256",
          name: "amount",
          type: "uint256"
        }
      ],
      name: "daoPointTransfer2",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint16",
          name: "",
          type: "uint16"
        }
      ],
      name: "daysResRate",
      outputs: [
        {
          internalType: "uint32",
          name: "",
          type: "uint32"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "deposit",
      outputs: [
        {
          internalType: "address",
          name: "",
          type: "address"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "exchangePool",
      outputs: [
        {
          internalType: "address",
          name: "",
          type: "address"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "fsage",
      outputs: [
        {
          internalType: "address",
          name: "",
          type: "address"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "bytes32",
          name: "role",
          type: "bytes32"
        }
      ],
      name: "getRoleAdmin",
      outputs: [
        {
          internalType: "bytes32",
          name: "",
          type: "bytes32"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "bytes32",
          name: "role",
          type: "bytes32"
        },
        {
          internalType: "address",
          name: "account",
          type: "address"
        }
      ],
      name: "grantRole",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "bytes32",
          name: "role",
          type: "bytes32"
        },
        {
          internalType: "address",
          name: "account",
          type: "address"
        }
      ],
      name: "hasRole",
      outputs: [
        {
          internalType: "bool",
          name: "",
          type: "bool"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint16",
          name: "",
          type: "uint16"
        }
      ],
      name: "hoursResRate",
      outputs: [
        {
          internalType: "uint32",
          name: "",
          type: "uint32"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "initialize",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      name: "levelDiffRate",
      outputs: [
        {
          internalType: "uint16",
          name: "",
          type: "uint16"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "mai",
      outputs: [
        {
          internalType: "address",
          name: "",
          type: "address"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      name: "majorLevelDiffRate",
      outputs: [
        {
          internalType: "uint16",
          name: "",
          type: "uint16"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "",
          type: "address"
        }
      ],
      name: "majorLevels",
      outputs: [
        {
          internalType: "uint8",
          name: "",
          type: "uint8"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "",
          type: "address"
        }
      ],
      name: "memberLevels",
      outputs: [
        {
          internalType: "uint8",
          name: "",
          type: "uint8"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "memberPrice",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "",
          type: "address"
        }
      ],
      name: "members",
      outputs: [
        {
          internalType: "bool",
          name: "",
          type: "bool"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "merchantDiscountMax",
      outputs: [
        {
          internalType: "uint16",
          name: "",
          type: "uint16"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "merchantDiscountMin",
      outputs: [
        {
          internalType: "uint16",
          name: "",
          type: "uint16"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "",
          type: "address"
        }
      ],
      name: "merchantDiscounts",
      outputs: [
        {
          internalType: "uint16",
          name: "",
          type: "uint16"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "merchant",
          type: "address"
        },
        {
          internalType: "uint256",
          name: "merchantContribute",
          type: "uint256"
        }
      ],
      name: "merchantWithdrawMaiFromMall",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "",
          type: "address"
        }
      ],
      name: "merchants",
      outputs: [
        {
          internalType: "bool",
          name: "",
          type: "bool"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "metabill",
      outputs: [
        {
          internalType: "address",
          name: "",
          type: "address"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "mintOrOtc",
      outputs: [
        {
          internalType: "bool",
          name: "",
          type: "bool"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "musd",
      outputs: [
        {
          internalType: "address",
          name: "",
          type: "address"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "",
          type: "address"
        }
      ],
      name: "parents",
      outputs: [
        {
          internalType: "address",
          name: "",
          type: "address"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "point",
      outputs: [
        {
          internalType: "address",
          name: "",
          type: "address"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "amount",
          type: "uint256"
        }
      ],
      name: "pointBack",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "",
          type: "address"
        }
      ],
      name: "pointBalances",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "addr",
          type: "address"
        },
        {
          internalType: "uint256",
          name: "amount",
          type: "uint256"
        }
      ],
      name: "pointCancelManager",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [],
      name: "pointFeeReceiver",
      outputs: [
        {
          internalType: "address",
          name: "",
          type: "address"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "amount",
          type: "uint256"
        }
      ],
      name: "pointMint",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [],
      name: "pointRate",
      outputs: [
        {
          internalType: "uint16",
          name: "",
          type: "uint16"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address[]",
          name: "addrs",
          type: "address[]"
        }
      ],
      name: "pointReleaseBatch",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "addr",
          type: "address"
        }
      ],
      name: "pointReleasePending",
      outputs: [
        {
          internalType: "uint256",
          name: "remainBalance",
          type: "uint256"
        },
        {
          internalType: "uint32",
          name: "remainSecond",
          type: "uint32"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "addr",
          type: "address"
        },
        {
          internalType: "uint256",
          name: "amount",
          type: "uint256"
        }
      ],
      name: "pointSubmitManager",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "amount",
          type: "uint256"
        }
      ],
      name: "pointToMai",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [],
      name: "pointToMember",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "amount",
          type: "uint256"
        },
        {
          internalType: "uint256",
          name: "target",
          type: "uint256"
        }
      ],
      name: "pointWithdraw",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [],
      name: "proxiableUUID",
      outputs: [
        {
          internalType: "bytes32",
          name: "",
          type: "bytes32"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "addr",
          type: "address"
        }
      ],
      name: "register",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "bytes32",
          name: "role",
          type: "bytes32"
        },
        {
          internalType: "address",
          name: "account",
          type: "address"
        }
      ],
      name: "renounceRole",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "bytes32",
          name: "role",
          type: "bytes32"
        },
        {
          internalType: "address",
          name: "account",
          type: "address"
        }
      ],
      name: "revokeRole",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "addr",
          type: "address"
        }
      ],
      name: "setDepositAddr",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "member",
          type: "address"
        },
        {
          internalType: "uint8",
          name: "level",
          type: "uint8"
        }
      ],
      name: "setMemberLevel",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "merchant",
          type: "address"
        },
        {
          internalType: "bool",
          name: "result",
          type: "bool"
        },
        {
          internalType: "uint16",
          name: "discount",
          type: "uint16"
        }
      ],
      name: "setMerchant",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint16",
          name: "discount",
          type: "uint16"
        }
      ],
      name: "setMerchantDiscount",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint16",
          name: "rate",
          type: "uint16"
        }
      ],
      name: "setPointRate",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "bytes4",
          name: "interfaceId",
          type: "bytes4"
        }
      ],
      name: "supportsInterface",
      outputs: [
        {
          internalType: "bool",
          name: "",
          type: "bool"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "merchant",
          type: "address"
        },
        {
          internalType: "uint256",
          name: "amount",
          type: "uint256"
        },
        {
          internalType: "address",
          name: "benefit",
          type: "address"
        }
      ],
      name: "trade",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "consumer",
          type: "address"
        },
        {
          internalType: "address",
          name: "merchant",
          type: "address"
        },
        {
          internalType: "uint256",
          name: "merchantContribute",
          type: "uint256"
        }
      ],
      name: "tradeBei",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [],
      name: "tradeContributeDaoRate",
      outputs: [
        {
          internalType: "uint16",
          name: "",
          type: "uint16"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "tradeContributeSelfRate",
      outputs: [
        {
          internalType: "uint16",
          name: "",
          type: "uint16"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "consumer",
          type: "address"
        },
        {
          internalType: "address",
          name: "merchant",
          type: "address"
        },
        {
          internalType: "uint256",
          name: "amount",
          type: "uint256"
        }
      ],
      name: "tradeDeposit",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "",
          type: "address"
        }
      ],
      name: "tradeFlows",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "tradeMemberContributeLimit",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      name: "tradeMerchantRewardRate",
      outputs: [
        {
          internalType: "uint16",
          name: "",
          type: "uint16"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "merchant",
          type: "address"
        },
        {
          internalType: "uint256",
          name: "amount",
          type: "uint256"
        },
        {
          internalType: "address",
          name: "benefit",
          type: "address"
        }
      ],
      name: "tradeOffline",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      name: "tradeRewardRate",
      outputs: [
        {
          internalType: "uint16",
          name: "",
          type: "uint16"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "merchant",
          type: "address"
        },
        {
          internalType: "address",
          name: "benefit",
          type: "address"
        },
        {
          internalType: "uint256",
          name: "merchantContribute",
          type: "uint256"
        }
      ],
      name: "tradeWithUsdt",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "newImplementation",
          type: "address"
        }
      ],
      name: "upgradeTo",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "newImplementation",
          type: "address"
        },
        {
          internalType: "bytes",
          name: "data",
          type: "bytes"
        }
      ],
      name: "upgradeToAndCall",
      outputs: [],
      stateMutability: "payable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "consumer",
          type: "address"
        },
        {
          internalType: "uint256",
          name: "merchantContribute",
          type: "uint256"
        }
      ],
      name: "userWithdrawMaiFromMall",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    }
  ];
  QK = [
    {
      inputs: [],
      name: "AccessControlBadConfirmation",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "account",
          type: "address"
        },
        {
          internalType: "bytes32",
          name: "neededRole",
          type: "bytes32"
        }
      ],
      name: "AccessControlUnauthorizedAccount",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "target",
          type: "address"
        }
      ],
      name: "AddressEmptyCode",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "account",
          type: "address"
        }
      ],
      name: "AddressInsufficientBalance",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "implementation",
          type: "address"
        }
      ],
      name: "ERC1967InvalidImplementation",
      type: "error"
    },
    {
      inputs: [],
      name: "ERC1967NonPayable",
      type: "error"
    },
    {
      inputs: [],
      name: "FailedInnerCall",
      type: "error"
    },
    {
      inputs: [],
      name: "InvalidInitialization",
      type: "error"
    },
    {
      inputs: [],
      name: "NotInitializing",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "token",
          type: "address"
        }
      ],
      name: "SafeERC20FailedOperation",
      type: "error"
    },
    {
      inputs: [],
      name: "UUPSUnauthorizedCallContext",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "bytes32",
          name: "slot",
          type: "bytes32"
        }
      ],
      name: "UUPSUnsupportedProxiableUUID",
      type: "error"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "uint256",
          name: "id",
          type: "uint256"
        }
      ],
      name: "Cancel",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: false,
          internalType: "uint64",
          name: "version",
          type: "uint64"
        }
      ],
      name: "Initialized",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "uint256",
          name: "id",
          type: "uint256"
        }
      ],
      name: "LoanHandler",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "uint256",
          name: "id",
          type: "uint256"
        },
        {
          indexed: false,
          internalType: "uint256",
          name: "depositAmount",
          type: "uint256"
        },
        {
          indexed: false,
          internalType: "uint256",
          name: "amount",
          type: "uint256"
        },
        {
          indexed: false,
          internalType: "enum P2PConst.InterestType",
          name: "interestType",
          type: "uint8"
        },
        {
          indexed: false,
          internalType: "uint16",
          name: "cycle",
          type: "uint16"
        },
        {
          indexed: false,
          internalType: "uint256",
          name: "annualizedInterestRate",
          type: "uint256"
        },
        {
          indexed: false,
          internalType: "enum P2PConst.DepositType",
          name: "depositType",
          type: "uint8"
        },
        {
          indexed: false,
          internalType: "string",
          name: "tags",
          type: "string"
        }
      ],
      name: "ReleaseLoan",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "uint256",
          name: "id",
          type: "uint256"
        },
        {
          indexed: false,
          internalType: "uint256",
          name: "interest",
          type: "uint256"
        },
        {
          indexed: false,
          internalType: "uint256",
          name: "overdueInterest",
          type: "uint256"
        },
        {
          indexed: false,
          internalType: "uint256",
          name: "unlockedLp",
          type: "uint256"
        }
      ],
      name: "Repay",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "uint256",
          name: "id",
          type: "uint256"
        },
        {
          indexed: false,
          internalType: "uint256",
          name: "pricipal",
          type: "uint256"
        },
        {
          indexed: false,
          internalType: "uint256",
          name: "interest",
          type: "uint256"
        },
        {
          indexed: false,
          internalType: "uint256",
          name: "unlockLp",
          type: "uint256"
        }
      ],
      name: "RepayPricipal",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "bytes32",
          name: "role",
          type: "bytes32"
        },
        {
          indexed: true,
          internalType: "bytes32",
          name: "previousAdminRole",
          type: "bytes32"
        },
        {
          indexed: true,
          internalType: "bytes32",
          name: "newAdminRole",
          type: "bytes32"
        }
      ],
      name: "RoleAdminChanged",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "bytes32",
          name: "role",
          type: "bytes32"
        },
        {
          indexed: true,
          internalType: "address",
          name: "account",
          type: "address"
        },
        {
          indexed: true,
          internalType: "address",
          name: "sender",
          type: "address"
        }
      ],
      name: "RoleGranted",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "bytes32",
          name: "role",
          type: "bytes32"
        },
        {
          indexed: true,
          internalType: "address",
          name: "account",
          type: "address"
        },
        {
          indexed: true,
          internalType: "address",
          name: "sender",
          type: "address"
        }
      ],
      name: "RoleRevoked",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "implementation",
          type: "address"
        }
      ],
      name: "Upgraded",
      type: "event"
    },
    {
      inputs: [],
      name: "DAY_SECOND",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "DEFAULT_ADMIN_ROLE",
      outputs: [
        {
          internalType: "bytes32",
          name: "",
          type: "bytes32"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "MONTH",
      outputs: [
        {
          internalType: "uint8",
          name: "",
          type: "uint8"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "UPGRADE_INTERFACE_VERSION",
      outputs: [
        {
          internalType: "string",
          name: "",
          type: "string"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "id",
          type: "uint256"
        }
      ],
      name: "calcOverdueInterest",
      outputs: [
        {
          internalType: "uint256",
          name: "overdueInterest",
          type: "uint256"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "id",
          type: "uint256"
        }
      ],
      name: "calcRepayAmount",
      outputs: [
        {
          internalType: "uint256",
          name: "principal",
          type: "uint256"
        },
        {
          internalType: "uint256",
          name: "interest",
          type: "uint256"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "id",
          type: "uint256"
        }
      ],
      name: "cancel",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [],
      name: "currentDay",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "getParams",
      outputs: [
        {
          internalType: "uint256",
          name: "serviceFee_",
          type: "uint256"
        },
        {
          internalType: "uint256",
          name: "managementFee_",
          type: "uint256"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "bytes32",
          name: "role",
          type: "bytes32"
        }
      ],
      name: "getRoleAdmin",
      outputs: [
        {
          internalType: "bytes32",
          name: "",
          type: "bytes32"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "addr",
          type: "address"
        }
      ],
      name: "getUserLoans",
      outputs: [
        {
          internalType: "uint256[]",
          name: "",
          type: "uint256[]"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "bytes32",
          name: "role",
          type: "bytes32"
        },
        {
          internalType: "address",
          name: "account",
          type: "address"
        }
      ],
      name: "grantRole",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "bytes32",
          name: "role",
          type: "bytes32"
        },
        {
          internalType: "address",
          name: "account",
          type: "address"
        }
      ],
      name: "hasRole",
      outputs: [
        {
          internalType: "bool",
          name: "",
          type: "bool"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "initialize",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "id",
          type: "uint256"
        }
      ],
      name: "loanHandler",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      name: "loans",
      outputs: [
        {
          internalType: "uint256",
          name: "amount",
          type: "uint256"
        },
        {
          internalType: "uint256",
          name: "originalAmount",
          type: "uint256"
        },
        {
          internalType: "uint256",
          name: "paidAmount",
          type: "uint256"
        },
        {
          internalType: "uint256",
          name: "depositAmount",
          type: "uint256"
        },
        {
          internalType: "uint256",
          name: "unlockedLp",
          type: "uint256"
        },
        {
          internalType: "uint256",
          name: "nextPaymentTime",
          type: "uint256"
        },
        {
          internalType: "uint256",
          name: "annualizedInterestRate",
          type: "uint256"
        },
        {
          internalType: "address",
          name: "releaser",
          type: "address"
        },
        {
          internalType: "address",
          name: "loaner",
          type: "address"
        },
        {
          internalType: "enum P2PConst.InterestType",
          name: "interestType",
          type: "uint8"
        },
        {
          internalType: "uint8",
          name: "paidCount",
          type: "uint8"
        },
        {
          internalType: "uint16",
          name: "cycle",
          type: "uint16"
        },
        {
          internalType: "enum P2PConst.DepositType",
          name: "depositType",
          type: "uint8"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "proxiableUUID",
      outputs: [
        {
          internalType: "bytes32",
          name: "",
          type: "bytes32"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "amount",
          type: "uint256"
        },
        {
          internalType: "uint256",
          name: "depositAmount",
          type: "uint256"
        },
        {
          internalType: "enum P2PConst.InterestType",
          name: "interestType",
          type: "uint8"
        },
        {
          internalType: "uint16",
          name: "cycle",
          type: "uint16"
        },
        {
          internalType: "uint256",
          name: "annualizedInterestRate",
          type: "uint256"
        },
        {
          internalType: "enum P2PConst.DepositType",
          name: "depositType",
          type: "uint8"
        },
        {
          internalType: "string",
          name: "tags",
          type: "string"
        }
      ],
      name: "releaseLoan",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "bytes32",
          name: "role",
          type: "bytes32"
        },
        {
          internalType: "address",
          name: "callerConfirmation",
          type: "address"
        }
      ],
      name: "renounceRole",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "id",
          type: "uint256"
        }
      ],
      name: "repay",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint256[]",
          name: "ids",
          type: "uint256[]"
        }
      ],
      name: "repayBatch",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "id",
          type: "uint256"
        },
        {
          internalType: "uint256",
          name: "amount",
          type: "uint256"
        }
      ],
      name: "repayPrincipal",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "bytes32",
          name: "role",
          type: "bytes32"
        },
        {
          internalType: "address",
          name: "account",
          type: "address"
        }
      ],
      name: "revokeRole",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "serviceFee_",
          type: "uint256"
        },
        {
          internalType: "uint256",
          name: "managementFee_",
          type: "uint256"
        },
        {
          internalType: "address",
          name: "feeAddress_",
          type: "address"
        }
      ],
      name: "setParams",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "amount",
          type: "uint256"
        }
      ],
      name: "setServiceFee",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "bytes4",
          name: "interfaceId",
          type: "bytes4"
        }
      ],
      name: "supportsInterface",
      outputs: [
        {
          internalType: "bool",
          name: "",
          type: "bool"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "newImplementation",
          type: "address"
        },
        {
          internalType: "bytes",
          name: "data",
          type: "bytes"
        }
      ],
      name: "upgradeToAndCall",
      outputs: [],
      stateMutability: "payable",
      type: "function"
    }
  ];
  jK = [
    {
      inputs: [],
      name: "AccessControlBadConfirmation",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "account",
          type: "address"
        },
        {
          internalType: "bytes32",
          name: "neededRole",
          type: "bytes32"
        }
      ],
      name: "AccessControlUnauthorizedAccount",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "target",
          type: "address"
        }
      ],
      name: "AddressEmptyCode",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "account",
          type: "address"
        }
      ],
      name: "AddressInsufficientBalance",
      type: "error"
    },
    {
      inputs: [],
      name: "AddressNotRegist",
      type: "error"
    },
    {
      inputs: [],
      name: "AmountInsufficient",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "implementation",
          type: "address"
        }
      ],
      name: "ERC1967InvalidImplementation",
      type: "error"
    },
    {
      inputs: [],
      name: "ERC1967NonPayable",
      type: "error"
    },
    {
      inputs: [],
      name: "FailedInnerCall",
      type: "error"
    },
    {
      inputs: [],
      name: "InvalidInitialization",
      type: "error"
    },
    {
      inputs: [],
      name: "NotInitializing",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "token",
          type: "address"
        }
      ],
      name: "SafeERC20FailedOperation",
      type: "error"
    },
    {
      inputs: [],
      name: "UUPSUnauthorizedCallContext",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "bytes32",
          name: "slot",
          type: "bytes32"
        }
      ],
      name: "UUPSUnsupportedProxiableUUID",
      type: "error"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: false,
          internalType: "uint64",
          name: "version",
          type: "uint64"
        }
      ],
      name: "Initialized",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "uint256",
          name: "id",
          type: "uint256"
        },
        {
          indexed: true,
          internalType: "uint256",
          name: "type_",
          type: "uint256"
        },
        {
          indexed: false,
          internalType: "uint256",
          name: "month",
          type: "uint256"
        },
        {
          indexed: false,
          internalType: "uint256",
          name: "current",
          type: "uint256"
        },
        {
          indexed: false,
          internalType: "uint256",
          name: "amount",
          type: "uint256"
        }
      ],
      name: "LogBei",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "uint256",
          name: "_type",
          type: "uint256"
        },
        {
          indexed: true,
          internalType: "uint256",
          name: "userId",
          type: "uint256"
        },
        {
          indexed: false,
          internalType: "uint256",
          name: "amountWmai",
          type: "uint256"
        },
        {
          indexed: false,
          internalType: "uint256",
          name: "amountMc",
          type: "uint256"
        },
        {
          indexed: false,
          internalType: "uint256",
          name: "liquidity",
          type: "uint256"
        }
      ],
      name: "LogLpStake",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "bytes32",
          name: "role",
          type: "bytes32"
        },
        {
          indexed: true,
          internalType: "bytes32",
          name: "previousAdminRole",
          type: "bytes32"
        },
        {
          indexed: true,
          internalType: "bytes32",
          name: "newAdminRole",
          type: "bytes32"
        }
      ],
      name: "RoleAdminChanged",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "bytes32",
          name: "role",
          type: "bytes32"
        },
        {
          indexed: true,
          internalType: "address",
          name: "account",
          type: "address"
        },
        {
          indexed: true,
          internalType: "address",
          name: "sender",
          type: "address"
        }
      ],
      name: "RoleGranted",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "bytes32",
          name: "role",
          type: "bytes32"
        },
        {
          indexed: true,
          internalType: "address",
          name: "account",
          type: "address"
        },
        {
          indexed: true,
          internalType: "address",
          name: "sender",
          type: "address"
        }
      ],
      name: "RoleRevoked",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "implementation",
          type: "address"
        }
      ],
      name: "Upgraded",
      type: "event"
    },
    {
      inputs: [],
      name: "DAY_SECOND",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "DEFAULT_ADMIN_ROLE",
      outputs: [
        {
          internalType: "bytes32",
          name: "",
          type: "bytes32"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "OPERATOR_ROLE",
      outputs: [
        {
          internalType: "bytes32",
          name: "",
          type: "bytes32"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "ORDER_MANAGER_ROLE",
      outputs: [
        {
          internalType: "bytes32",
          name: "",
          type: "bytes32"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "UPGRADE_INTERFACE_VERSION",
      outputs: [
        {
          internalType: "string",
          name: "",
          type: "string"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "awardWmai",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "merchant",
          type: "address"
        },
        {
          internalType: "uint256",
          name: "orderId",
          type: "uint256"
        },
        {
          internalType: "uint256",
          name: "amount",
          type: "uint256"
        },
        {
          internalType: "uint256",
          name: "creditOfMc",
          type: "uint256"
        }
      ],
      name: "clearForceOfMaiOrLp",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      name: "credits",
      outputs: [
        {
          internalType: "uint256",
          name: "maiTotal",
          type: "uint256"
        },
        {
          internalType: "uint256",
          name: "jieTotal",
          type: "uint256"
        },
        {
          internalType: "uint256",
          name: "maiRemain",
          type: "uint256"
        },
        {
          internalType: "uint256",
          name: "jieRemain",
          type: "uint256"
        },
        {
          internalType: "uint256",
          name: "huaPending",
          type: "uint256"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "account",
          type: "address"
        },
        {
          internalType: "uint256",
          name: "value",
          type: "uint256"
        }
      ],
      name: "depositFor",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "amountWmai",
          type: "uint256"
        },
        {
          internalType: "uint256",
          name: "amountMc",
          type: "uint256"
        }
      ],
      name: "depositForPancake",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "amount",
          type: "uint256"
        }
      ],
      name: "depositLp",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "bytes32",
          name: "role",
          type: "bytes32"
        }
      ],
      name: "getRoleAdmin",
      outputs: [
        {
          internalType: "bytes32",
          name: "",
          type: "bytes32"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "bytes32",
          name: "role",
          type: "bytes32"
        },
        {
          internalType: "address",
          name: "account",
          type: "address"
        }
      ],
      name: "grantRole",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "bytes32",
          name: "role",
          type: "bytes32"
        },
        {
          internalType: "address",
          name: "account",
          type: "address"
        }
      ],
      name: "hasRole",
      outputs: [
        {
          internalType: "bool",
          name: "",
          type: "bool"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "initialize",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "id",
          type: "uint256"
        }
      ],
      name: "jieRewards",
      outputs: [
        {
          internalType: "uint256",
          name: "mc",
          type: "uint256"
        },
        {
          internalType: "uint256",
          name: "mai",
          type: "uint256"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint256[]",
          name: "ids",
          type: "uint256[]"
        },
        {
          internalType: "uint256[]",
          name: "amounts",
          type: "uint256[]"
        }
      ],
      name: "maiRewardWeek",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint256[]",
          name: "ids",
          type: "uint256[]"
        },
        {
          internalType: "uint256[]",
          name: "amounts",
          type: "uint256[]"
        }
      ],
      name: "mcRewardMonth",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint256[]",
          name: "ids",
          type: "uint256[]"
        },
        {
          internalType: "uint256[]",
          name: "amounts",
          type: "uint256[]"
        }
      ],
      name: "mcRewardWeek",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "userId",
          type: "uint256"
        }
      ],
      name: "merchantCriditOrderLpLock",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "userId",
          type: "uint256"
        }
      ],
      name: "pendingLp",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "amount",
          type: "uint256"
        }
      ],
      name: "pledgeMai",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [],
      name: "proxiableUUID",
      outputs: [
        {
          internalType: "bytes32",
          name: "",
          type: "bytes32"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "addr",
          type: "address"
        }
      ],
      name: "queryId",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "bytes32",
          name: "role",
          type: "bytes32"
        },
        {
          internalType: "address",
          name: "callerConfirmation",
          type: "address"
        }
      ],
      name: "renounceRole",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [],
      name: "restakeLp",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "bytes32",
          name: "role",
          type: "bytes32"
        },
        {
          internalType: "address",
          name: "account",
          type: "address"
        }
      ],
      name: "revokeRole",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "limit",
          type: "uint256"
        }
      ],
      name: "setJieRewardSumMax",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "amount",
          type: "uint256"
        }
      ],
      name: "setMaiRewardWeekSumMax",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "amount",
          type: "uint256"
        }
      ],
      name: "setMcRewardMonthSumMax",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint256[]",
          name: "orderIds",
          type: "uint256[]"
        }
      ],
      name: "setMerchantCreditOrderIsLockMaiBatch",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "bytes4",
          name: "interfaceId",
          type: "bytes4"
        }
      ],
      name: "supportsInterface",
      outputs: [
        {
          internalType: "bool",
          name: "",
          type: "bool"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "totalLp",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "addr",
          type: "address"
        },
        {
          internalType: "uint256",
          name: "amount",
          type: "uint256"
        }
      ],
      name: "tryLockLpFromP2P",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "merchant",
          type: "address"
        },
        {
          internalType: "uint256",
          name: "amount",
          type: "uint256"
        },
        {
          internalType: "uint256",
          name: "orderId",
          type: "uint256"
        }
      ],
      name: "tryLockLpOrMaiOfMc",
      outputs: [
        {
          internalType: "uint256",
          name: "lock",
          type: "uint256"
        }
      ],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "addr",
          type: "address"
        },
        {
          internalType: "uint256",
          name: "amount",
          type: "uint256"
        }
      ],
      name: "unLockLpFromP2P",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "merchant",
          type: "address"
        },
        {
          internalType: "uint256",
          name: "orderId",
          type: "uint256"
        },
        {
          internalType: "uint256",
          name: "amount",
          type: "uint256"
        },
        {
          internalType: "uint256",
          name: "creditOfMc",
          type: "uint256"
        }
      ],
      name: "unLockOfMaiOrLp",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "newImplementation",
          type: "address"
        },
        {
          internalType: "bytes",
          name: "data",
          type: "bytes"
        }
      ],
      name: "upgradeToAndCall",
      outputs: [],
      stateMutability: "payable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "userId",
          type: "uint256"
        }
      ],
      name: "userLpLockFromP2P",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "userId",
          type: "uint256"
        }
      ],
      name: "userTotalLp",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "userId",
          type: "uint256"
        }
      ],
      name: "userWmaiwithdrawable",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "amount",
          type: "uint256"
        }
      ],
      name: "withdrawLp",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "amount",
          type: "uint256"
        }
      ],
      name: "withdrawMai",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "token",
          type: "address"
        },
        {
          internalType: "uint256",
          name: "amount",
          type: "uint256"
        },
        {
          internalType: "bool",
          name: "toFmcp",
          type: "bool"
        }
      ],
      name: "withdrawReward",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "account",
          type: "address"
        },
        {
          internalType: "uint256",
          name: "value",
          type: "uint256"
        }
      ],
      name: "withdrawTo",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "amount",
          type: "uint256"
        }
      ],
      name: "withdrawWmai",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    }
  ];
  JK = [
    {
      anonymous: false,
      inputs: [
        {
          indexed: false,
          internalType: "uint8",
          name: "version",
          type: "uint8"
        }
      ],
      name: "Initialized",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "bytes32",
          name: "role",
          type: "bytes32"
        },
        {
          indexed: true,
          internalType: "bytes32",
          name: "previousAdminRole",
          type: "bytes32"
        },
        {
          indexed: true,
          internalType: "bytes32",
          name: "newAdminRole",
          type: "bytes32"
        }
      ],
      name: "RoleAdminChanged",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "bytes32",
          name: "role",
          type: "bytes32"
        },
        {
          indexed: true,
          internalType: "address",
          name: "account",
          type: "address"
        },
        {
          indexed: true,
          internalType: "address",
          name: "sender",
          type: "address"
        }
      ],
      name: "RoleGranted",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "bytes32",
          name: "role",
          type: "bytes32"
        },
        {
          indexed: true,
          internalType: "address",
          name: "account",
          type: "address"
        },
        {
          indexed: true,
          internalType: "address",
          name: "sender",
          type: "address"
        }
      ],
      name: "RoleRevoked",
      type: "event"
    },
    {
      inputs: [],
      name: "DEFAULT_ADMIN_ROLE",
      outputs: [
        {
          internalType: "bytes32",
          name: "",
          type: "bytes32"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "OPERATOR_ROLE",
      outputs: [
        {
          internalType: "bytes32",
          name: "",
          type: "bytes32"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "token",
          type: "address"
        },
        {
          internalType: "uint8",
          name: "method",
          type: "uint8"
        },
        {
          internalType: "uint256",
          name: "amount",
          type: "uint256"
        }
      ],
      name: "deposit",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "bytes32",
          name: "role",
          type: "bytes32"
        }
      ],
      name: "getRoleAdmin",
      outputs: [
        {
          internalType: "bytes32",
          name: "",
          type: "bytes32"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "bytes32",
          name: "role",
          type: "bytes32"
        },
        {
          internalType: "uint256",
          name: "index",
          type: "uint256"
        }
      ],
      name: "getRoleMember",
      outputs: [
        {
          internalType: "address",
          name: "",
          type: "address"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "bytes32",
          name: "role",
          type: "bytes32"
        }
      ],
      name: "getRoleMemberCount",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "bytes32",
          name: "role",
          type: "bytes32"
        },
        {
          internalType: "address",
          name: "account",
          type: "address"
        }
      ],
      name: "grantRole",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "bytes32",
          name: "role",
          type: "bytes32"
        },
        {
          internalType: "address",
          name: "account",
          type: "address"
        }
      ],
      name: "hasRole",
      outputs: [
        {
          internalType: "bool",
          name: "",
          type: "bool"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "newInitPrice",
          type: "uint256"
        },
        {
          internalType: "address",
          name: "newMai",
          type: "address"
        }
      ],
      name: "init",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [],
      name: "initPrice",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "initialize",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [],
      name: "lastPrice",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "mai",
      outputs: [
        {
          internalType: "address",
          name: "",
          type: "address"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "bytes32",
          name: "role",
          type: "bytes32"
        },
        {
          internalType: "address",
          name: "account",
          type: "address"
        }
      ],
      name: "renounceRole",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "bytes32",
          name: "role",
          type: "bytes32"
        },
        {
          internalType: "address",
          name: "account",
          type: "address"
        }
      ],
      name: "revokeRole",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "",
          type: "address"
        },
        {
          internalType: "uint8",
          name: "",
          type: "uint8"
        }
      ],
      name: "scales",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "addr",
          type: "address"
        },
        {
          internalType: "uint8",
          name: "method",
          type: "uint8"
        },
        {
          internalType: "uint256",
          name: "scale",
          type: "uint256"
        }
      ],
      name: "setScale",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "bytes4",
          name: "interfaceId",
          type: "bytes4"
        }
      ],
      name: "supportsInterface",
      outputs: [
        {
          internalType: "bool",
          name: "",
          type: "bool"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "addr",
          type: "address"
        }
      ],
      name: "tokenAdd",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [],
      name: "tokenList",
      outputs: [
        {
          internalType: "address[]",
          name: "",
          type: "address[]"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "addr",
          type: "address"
        }
      ],
      name: "tokenRemove",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [],
      name: "totalUAmount",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "token",
          type: "address"
        },
        {
          internalType: "uint256",
          name: "amount",
          type: "uint256"
        }
      ],
      name: "withdraw",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    }
  ];
  KK = [
    {
      inputs: [],
      payable: false,
      stateMutability: "nonpayable",
      type: "constructor"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "owner",
          type: "address"
        },
        {
          indexed: true,
          internalType: "address",
          name: "spender",
          type: "address"
        },
        {
          indexed: false,
          internalType: "uint256",
          name: "value",
          type: "uint256"
        }
      ],
      name: "Approval",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "sender",
          type: "address"
        },
        {
          indexed: false,
          internalType: "uint256",
          name: "amount0",
          type: "uint256"
        },
        {
          indexed: false,
          internalType: "uint256",
          name: "amount1",
          type: "uint256"
        },
        {
          indexed: true,
          internalType: "address",
          name: "to",
          type: "address"
        }
      ],
      name: "Burn",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "sender",
          type: "address"
        },
        {
          indexed: false,
          internalType: "uint256",
          name: "amount0",
          type: "uint256"
        },
        {
          indexed: false,
          internalType: "uint256",
          name: "amount1",
          type: "uint256"
        }
      ],
      name: "Mint",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "sender",
          type: "address"
        },
        {
          indexed: false,
          internalType: "uint256",
          name: "amount0In",
          type: "uint256"
        },
        {
          indexed: false,
          internalType: "uint256",
          name: "amount1In",
          type: "uint256"
        },
        {
          indexed: false,
          internalType: "uint256",
          name: "amount0Out",
          type: "uint256"
        },
        {
          indexed: false,
          internalType: "uint256",
          name: "amount1Out",
          type: "uint256"
        },
        {
          indexed: true,
          internalType: "address",
          name: "to",
          type: "address"
        }
      ],
      name: "Swap",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: false,
          internalType: "uint112",
          name: "reserve0",
          type: "uint112"
        },
        {
          indexed: false,
          internalType: "uint112",
          name: "reserve1",
          type: "uint112"
        }
      ],
      name: "Sync",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "from",
          type: "address"
        },
        {
          indexed: true,
          internalType: "address",
          name: "to",
          type: "address"
        },
        {
          indexed: false,
          internalType: "uint256",
          name: "value",
          type: "uint256"
        }
      ],
      name: "Transfer",
      type: "event"
    },
    {
      constant: true,
      inputs: [],
      name: "DOMAIN_SEPARATOR",
      outputs: [
        {
          internalType: "bytes32",
          name: "",
          type: "bytes32"
        }
      ],
      payable: false,
      stateMutability: "view",
      type: "function"
    },
    {
      constant: true,
      inputs: [],
      name: "MINIMUM_LIQUIDITY",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      payable: false,
      stateMutability: "view",
      type: "function"
    },
    {
      constant: true,
      inputs: [],
      name: "PERMIT_TYPEHASH",
      outputs: [
        {
          internalType: "bytes32",
          name: "",
          type: "bytes32"
        }
      ],
      payable: false,
      stateMutability: "view",
      type: "function"
    },
    {
      constant: true,
      inputs: [
        {
          internalType: "address",
          name: "",
          type: "address"
        },
        {
          internalType: "address",
          name: "",
          type: "address"
        }
      ],
      name: "allowance",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      payable: false,
      stateMutability: "view",
      type: "function"
    },
    {
      constant: false,
      inputs: [
        {
          internalType: "address",
          name: "spender",
          type: "address"
        },
        {
          internalType: "uint256",
          name: "value",
          type: "uint256"
        }
      ],
      name: "approve",
      outputs: [
        {
          internalType: "bool",
          name: "",
          type: "bool"
        }
      ],
      payable: false,
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      constant: true,
      inputs: [
        {
          internalType: "address",
          name: "",
          type: "address"
        }
      ],
      name: "balanceOf",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      payable: false,
      stateMutability: "view",
      type: "function"
    },
    {
      constant: false,
      inputs: [
        {
          internalType: "address",
          name: "to",
          type: "address"
        }
      ],
      name: "burn",
      outputs: [
        {
          internalType: "uint256",
          name: "amount0",
          type: "uint256"
        },
        {
          internalType: "uint256",
          name: "amount1",
          type: "uint256"
        }
      ],
      payable: false,
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      constant: true,
      inputs: [],
      name: "decimals",
      outputs: [
        {
          internalType: "uint8",
          name: "",
          type: "uint8"
        }
      ],
      payable: false,
      stateMutability: "view",
      type: "function"
    },
    {
      constant: true,
      inputs: [],
      name: "factory",
      outputs: [
        {
          internalType: "address",
          name: "",
          type: "address"
        }
      ],
      payable: false,
      stateMutability: "view",
      type: "function"
    },
    {
      constant: true,
      inputs: [],
      name: "getReserves",
      outputs: [
        {
          internalType: "uint112",
          name: "_reserve0",
          type: "uint112"
        },
        {
          internalType: "uint112",
          name: "_reserve1",
          type: "uint112"
        },
        {
          internalType: "uint32",
          name: "_blockTimestampLast",
          type: "uint32"
        }
      ],
      payable: false,
      stateMutability: "view",
      type: "function"
    },
    {
      constant: false,
      inputs: [
        {
          internalType: "address",
          name: "_token0",
          type: "address"
        },
        {
          internalType: "address",
          name: "_token1",
          type: "address"
        }
      ],
      name: "initialize",
      outputs: [],
      payable: false,
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      constant: true,
      inputs: [],
      name: "kLast",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      payable: false,
      stateMutability: "view",
      type: "function"
    },
    {
      constant: false,
      inputs: [
        {
          internalType: "address",
          name: "to",
          type: "address"
        }
      ],
      name: "mint",
      outputs: [
        {
          internalType: "uint256",
          name: "liquidity",
          type: "uint256"
        }
      ],
      payable: false,
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      constant: true,
      inputs: [],
      name: "name",
      outputs: [
        {
          internalType: "string",
          name: "",
          type: "string"
        }
      ],
      payable: false,
      stateMutability: "view",
      type: "function"
    },
    {
      constant: true,
      inputs: [
        {
          internalType: "address",
          name: "",
          type: "address"
        }
      ],
      name: "nonces",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      payable: false,
      stateMutability: "view",
      type: "function"
    },
    {
      constant: false,
      inputs: [
        {
          internalType: "address",
          name: "owner",
          type: "address"
        },
        {
          internalType: "address",
          name: "spender",
          type: "address"
        },
        {
          internalType: "uint256",
          name: "value",
          type: "uint256"
        },
        {
          internalType: "uint256",
          name: "deadline",
          type: "uint256"
        },
        {
          internalType: "uint8",
          name: "v",
          type: "uint8"
        },
        {
          internalType: "bytes32",
          name: "r",
          type: "bytes32"
        },
        {
          internalType: "bytes32",
          name: "s",
          type: "bytes32"
        }
      ],
      name: "permit",
      outputs: [],
      payable: false,
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      constant: true,
      inputs: [],
      name: "price0CumulativeLast",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      payable: false,
      stateMutability: "view",
      type: "function"
    },
    {
      constant: true,
      inputs: [],
      name: "price1CumulativeLast",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      payable: false,
      stateMutability: "view",
      type: "function"
    },
    {
      constant: false,
      inputs: [
        {
          internalType: "address",
          name: "to",
          type: "address"
        }
      ],
      name: "skim",
      outputs: [],
      payable: false,
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      constant: false,
      inputs: [
        {
          internalType: "uint256",
          name: "amount0Out",
          type: "uint256"
        },
        {
          internalType: "uint256",
          name: "amount1Out",
          type: "uint256"
        },
        {
          internalType: "address",
          name: "to",
          type: "address"
        },
        {
          internalType: "bytes",
          name: "data",
          type: "bytes"
        }
      ],
      name: "swap",
      outputs: [],
      payable: false,
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      constant: true,
      inputs: [],
      name: "symbol",
      outputs: [
        {
          internalType: "string",
          name: "",
          type: "string"
        }
      ],
      payable: false,
      stateMutability: "view",
      type: "function"
    },
    {
      constant: false,
      inputs: [],
      name: "sync",
      outputs: [],
      payable: false,
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      constant: true,
      inputs: [],
      name: "token0",
      outputs: [
        {
          internalType: "address",
          name: "",
          type: "address"
        }
      ],
      payable: false,
      stateMutability: "view",
      type: "function"
    },
    {
      constant: true,
      inputs: [],
      name: "token1",
      outputs: [
        {
          internalType: "address",
          name: "",
          type: "address"
        }
      ],
      payable: false,
      stateMutability: "view",
      type: "function"
    },
    {
      constant: true,
      inputs: [],
      name: "totalSupply",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      payable: false,
      stateMutability: "view",
      type: "function"
    },
    {
      constant: false,
      inputs: [
        {
          internalType: "address",
          name: "to",
          type: "address"
        },
        {
          internalType: "uint256",
          name: "value",
          type: "uint256"
        }
      ],
      name: "transfer",
      outputs: [
        {
          internalType: "bool",
          name: "",
          type: "bool"
        }
      ],
      payable: false,
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      constant: false,
      inputs: [
        {
          internalType: "address",
          name: "from",
          type: "address"
        },
        {
          internalType: "address",
          name: "to",
          type: "address"
        },
        {
          internalType: "uint256",
          name: "value",
          type: "uint256"
        }
      ],
      name: "transferFrom",
      outputs: [
        {
          internalType: "bool",
          name: "",
          type: "bool"
        }
      ],
      payable: false,
      stateMutability: "nonpayable",
      type: "function"
    }
  ];
  let t9;
  t9 = window.ethereum ? new yo(window.ethereum) : null;
  let WK, qK, Ol, XK, ZK, $K, eW, tW, nW, rW, iW, sW, oW, aW, cW, lW;
  WK = await t9.getSigner();
  qK = EE("0.1", "gwei");
  YK = {
    gasPrice: qK
  };
  Ol = (t, e, n = true) => {
    const r = new Dc(e, t, WK);
    if (n) {
      const { accountStore: i } = ks();
      if (!i.isLogin) return;
    }
    return r;
  };
  XK = (t = ts.flashMall) => Ol(e9, t);
  Jq = (t = ts.loan) => Ol(QK, t);
  ZK = (t = ts.flashMall) => Ol(e9, t, false);
  Kq = (t = ts.bei) => Ol(jK, t);
  Wq = (t = ts.maiExchange) => Ol(JK, t);
  qq = (t = ts.LP) => Ol(KK, t);
  n9 = () => {
    const t = XK(), e = ZK();
    return {
      parents: async (s) => {
        var _a6;
        const o = (_a6 = _y()) == null ? void 0 : _a6.getCurrentAccount(), a = s || o;
        try {
          return await (e == null ? void 0 : e.parents(a)) !== nl;
        } catch {
          return true;
        }
      },
      register: async (s) => {
        try {
          const o = await (await t.register(s, YK)).wait();
          return ah(o);
        } catch (o) {
          return t5(o), Hc(o);
        }
      },
      mcoinRate: async () => {
        try {
          const s = await t.pointRate();
          return Number(s) / 1e3;
        } catch {
          return 0;
        }
      }
    };
  };
  $K = {
    class: "w-[80%] text-center bg-white rounded-lg mx-auto pb-5"
  };
  eW = {
    class: "h-[80px] flex justify-center items-center relative overflow-hidden"
  };
  tW = {
    class: "relative"
  };
  nW = Gn({
    __name: "RegisterPop",
    setup(t) {
      const { accountStore: e, reloadStore: n } = ks(), { parents: r, register: i } = n9(), s = FN(), o = Ze(null);
      xn(() => s, (f) => {
        f && (o.value = f.query.invite || "");
      }, {
        immediate: true,
        deep: true
      });
      const a = Ze(false), c = Ze(false), l = async () => {
        c.value = true;
        const f = await i(o.value);
        c.value = false, f.success && (n.reload(), u());
      }, u = async () => {
        e.account && (a.value = !await r());
      };
      return Si(() => {
        setTimeout(() => {
          u();
        }, 150);
      }), (f, d) => {
        const m = YI, y = o6, x = U1;
        return fi(), Hi(x, {
          show: a.value,
          "onUpdate:show": d[1] || (d[1] = (w) => a.value = w),
          style: {
            background: "transparent",
            width: "80%",
            "min-width": "280px",
            "max-width": "325px"
          },
          "close-on-click-overlay": false
        }, {
          default: jc(() => [
            d[3] || (d[3] = Qr("img", {
              src: Y6,
              class: "w-[105px] mx-auto mb-[-23px] relative z-10"
            }, null, -1)),
            Qr("div", $K, [
              Qr("div", eW, [
                d[2] || (d[2] = Qr("img", {
                  class: "absolute w-full h-full",
                  src: X6
                }, null, -1)),
                Qr("span", tW, Tu(f.$t("zhu-ce")), 1)
              ]),
              Te(m, {
                modelValue: o.value,
                "onUpdate:modelValue": d[0] || (d[0] = (w) => o.value = w),
                placeholder: f.$t("qing-shu-ru-yao-qing-ma")
              }, null, 8, [
                "modelValue",
                "placeholder"
              ]),
              Te(y, {
                class: "mt-2 w-[90%] mx-auto btn-orange btn-shadow text-white",
                loading: c.value,
                disabled: !o.value,
                onClick: l
              }, {
                default: jc(() => [
                  Bd(Tu(f.$t("dian-ji-jin-hang-zhu-ce")), 1)
                ]),
                _: 1
              }, 8, [
                "loading",
                "disabled"
              ])
            ])
          ]),
          _: 1,
          __: [
            3
          ]
        }, 8, [
          "show"
        ]);
      };
    }
  });
  tb = (t, e) => {
    const n = t.__vccOpts || t;
    for (const [r, i] of e) n[r] = i;
    return n;
  };
  rW = tb(nW, [
    [
      "__scopeId",
      "data-v-b8209841"
    ]
  ]);
  iW = {
    class: "w-[80%] text-center bg-white rounded-lg mx-auto pb-5"
  };
  sW = {
    class: "h-[80px] flex justify-center items-center relative overflow-hidden"
  };
  oW = {
    class: "relative"
  };
  aW = Gn({
    __name: "LoginPop",
    props: {
      name: {}
    },
    emits: [
      "login"
    ],
    setup(t, { emit: e }) {
      const n = Ze(true), r = e;
      return (i, s) => {
        const o = o6, a = U1;
        return fi(), Hi(a, {
          show: n.value,
          "onUpdate:show": s[1] || (s[1] = (c) => n.value = c),
          style: {
            background: "transparent",
            width: "80%",
            "min-width": "280px",
            "max-width": "325px"
          },
          "close-on-click-overlay": false
        }, {
          default: jc(() => [
            s[3] || (s[3] = Qr("img", {
              src: Y6,
              class: "w-[105px] mx-auto mb-[-23px] relative z-10"
            }, null, -1)),
            Qr("div", iW, [
              Qr("div", sW, [
                s[2] || (s[2] = Qr("img", {
                  class: "absolute w-full h-full",
                  src: X6
                }, null, -1)),
                Qr("span", oW, Tu(i.$t("qing-xian-deng-lu")), 1)
              ]),
              Te(o, {
                color: "white",
                class: "block m-auto h-[40px] min-w-[170px] btn-orange btn-shadow",
                loading: ar(Dm),
                onClick: s[0] || (s[0] = () => {
                  r("login");
                })
              }, {
                default: jc(() => [
                  Bd(Tu(i.$t("deng-lu")), 1)
                ]),
                _: 1
              }, 8, [
                "loading"
              ])
            ])
          ]),
          _: 1,
          __: [
            3
          ]
        }, 8, [
          "show"
        ]);
      };
    }
  });
  cW = tb(aW, [
    [
      "__scopeId",
      "data-v-ab2c3b4a"
    ]
  ]);
  lW = af({
    id: "cached-view",
    state: () => ({
      cachedViewList: []
    }),
    actions: {
      addCachedView(t) {
        var _a6;
        this.cachedViewList.includes(t.name) || ((_a6 = t == null ? void 0 : t.meta) == null ? void 0 : _a6.noCache) || this.cachedViewList.push(t.name);
      },
      delCachedView(t) {
        const e = this.cachedViewList.indexOf(t.name);
        e > -1 && this.cachedViewList.splice(e, 1);
      },
      delAllCachedViews() {
        this.cachedViewList = [];
      }
    }
  });
  function r9() {
    return lW(H1);
  }
  const uW = {
    class: "app-wrapper text-base"
  }, fW = Gn({
    __name: "App",
    setup(t) {
      const { parents: e } = n9(), { accountStore: n, reloadStore: r } = ks(), { listenWallet: i, connectWallet: s, login: o } = _y(), a = it(() => r9().cachedViewList), c = Ze(true), l = async () => {
        (n == null ? void 0 : n.account) && (c.value = await e());
      };
      return xn(() => n == null ? void 0 : n.sign, (u) => {
        u && l();
      }, {
        immediate: false,
        deep: true
      }), Si(() => {
        const u = setInterval(() => {
          yy() && (clearInterval(u), s(), i());
        }, 500);
      }), (u, f) => {
        const d = cS("router-view"), m = cW, y = rW;
        return fi(), HS("div", uW, [
          ar(r).isRouterAlive ? (fi(), Hi(d, {
            key: 0
          }, {
            default: jc(({ Component: x }) => [
              (fi(), Hi(tS, {
                include: a.value
              }, [
                (fi(), Hi(lS(x)))
              ], 1032, [
                "include"
              ]))
            ]),
            _: 1
          })) : op("", true),
          ar(n).isLogin ? op("", true) : (fi(), Hi(m, {
            key: 1,
            onLogin: ar(o)
          }, null, 8, [
            "onLogin"
          ])),
          c.value ? op("", true) : (fi(), Hi(y, {
            key: 2,
            show: !c.value
          }, null, 8, [
            "show"
          ]))
        ]);
      };
    }
  }), dW = tb(fW, [
    [
      "__scopeId",
      "data-v-f9d86dbd"
    ]
  ]), hW = "modulepreload", pW = function(t) {
    return "/loan/" + t;
  }, bv = {}, fr = function(e, n, r) {
    let i = Promise.resolve();
    if (n && n.length > 0) {
      document.getElementsByTagName("link");
      const o = document.querySelector("meta[property=csp-nonce]"), a = (o == null ? void 0 : o.nonce) || (o == null ? void 0 : o.getAttribute("nonce"));
      i = Promise.allSettled(n.map((c) => {
        if (c = pW(c), c in bv) return;
        bv[c] = true;
        const l = c.endsWith(".css"), u = l ? '[rel="stylesheet"]' : "";
        if (document.querySelector(`link[href="${c}"]${u}`)) return;
        const f = document.createElement("link");
        if (f.rel = l ? "stylesheet" : hW, l || (f.as = "script"), f.crossOrigin = "", f.href = c, a && f.setAttribute("nonce", a), document.head.appendChild(f), l) return new Promise((d, m) => {
          f.addEventListener("load", d), f.addEventListener("error", () => m(new Error(`Unable to preload CSS for ${c}`)));
        });
      }));
    }
    function s(o) {
      const a = new Event("vite:preloadError", {
        cancelable: true
      });
      if (a.payload = o, window.dispatchEvent(a), !a.defaultPrevented) throw o;
    }
    return i.then((o) => {
      for (const a of o || []) a.status === "rejected" && s(a.reason);
      return e().catch(s);
    });
  }, gW = [
    {
      path: "/",
      name: "root",
      redirect: {
        name: "ecologyLoan"
      },
      children: [
        {
          path: "lp-pledge",
          name: "LpPledge",
          component: () => fr(() => import("./index-JfpGQrRU.js").then(async (m) => {
            await m.__tla;
            return m;
          }), __vite__mapDeps([0,1,2,3,4,5,6,7,8,9])),
          meta: {
            title: "lp\u8D28\u62BC"
          }
        }
      ]
    },
    {
      path: "/ecology-loan",
      name: "ecologyLoan",
      meta: {
        title: "\u5E02\u573A",
        tabBarShow: true
      },
      component: () => fr(() => import("./index-BjalBOO6.js").then(async (m) => {
        await m.__tla;
        return m;
      }), __vite__mapDeps([10,1,2,3,4,11,12,13,14,15,5,16,17,18,7,8,19,20,21,22])),
      children: [
        {
          path: "detail",
          name: "ecologyLoanDetail",
          component: () => fr(() => import("./Detail-yNnxICEm.js").then(async (m) => {
            await m.__tla;
            return m;
          }), __vite__mapDeps([23,7,8,20,24,14,6,5,13,25])),
          meta: {
            title: "\u6807\u7684\u8BE6\u60C5"
          }
        }
      ]
    },
    {
      path: "/investment-record",
      name: "InvestmentRecord",
      component: () => fr(() => import("./InvestmentRecord-Dogme5S8.js").then(async (m) => {
        await m.__tla;
        return m;
      }), __vite__mapDeps([26,27,13,14,24,1,2,3,4,7,8,19,12,20,28,29])),
      meta: {
        title: "\u6295\u8D44\u8BB0\u5F55"
      }
    },
    {
      path: "/ecology-loan-my",
      name: "ecologyLoanMy",
      meta: {
        title: "\u6211\u7684\u501F\u6B3E",
        tabBarShow: true
      },
      component: () => fr(() => import("./myPost-QSK2-HAv.js").then(async (m) => {
        await m.__tla;
        return m;
      }), __vite__mapDeps([30,1,2,3,4,11,12,13,14,15,5,16,17,18,7,8,19,20,31]))
    },
    {
      path: "/my",
      name: "My",
      component: () => fr(() => import("./Index-9zVh3Eif.js").then(async (m) => {
        await m.__tla;
        return m;
      }), __vite__mapDeps([32,7,8,20,28,4])),
      meta: {
        title: "\u6211\u7684"
      }
    },
    {
      path: "/releaseLoan",
      name: "ReleaseLoan",
      component: () => fr(() => import("./ReleaseLoan-O0z1Iw4B.js").then(async (m) => {
        await m.__tla;
        return m;
      }), __vite__mapDeps([33,6,5,34,35,7,8,13,14,36,37,27,24,15,21,20,2,38])),
      meta: {
        title: "\u6211\u8981\u501F\u6B3E"
      }
    },
    {
      path: "/ecology-loan-matchmaking",
      name: "HistoryMatchmaking",
      component: () => fr(() => import("./HistoryMatchmaking-DfmkIpX1.js").then(async (m) => {
        await m.__tla;
        return m;
      }), __vite__mapDeps([39,1,2,3,4,11,12,13,14,15,5,16,17,18,7,8,19,20,40])),
      meta: {
        title: "\u5386\u53F2\u64AE\u5408"
      }
    },
    {
      path: "/loan-repayment",
      name: "LoanRepayment",
      component: () => fr(() => import("./index-BVoPSHCi.js").then(async (m) => {
        await m.__tla;
        return m;
      }), __vite__mapDeps([41,27,13,14,24,36,37,19,7,8,42,12,6,5,20,2,43])),
      meta: {
        title: "\u6211\u8981\u8FD8\u6B3E"
      }
    },
    {
      path: "/loan-earlyRepayment",
      name: "LoanEarlyRepayment",
      component: () => fr(() => import("./earlyRepayment-fpOFMOlh.js").then(async (m) => {
        await m.__tla;
        return m;
      }), __vite__mapDeps([44,27,13,14,24,7,8,42,12,20,2])),
      meta: {
        title: "\u63D0\u524D\u8FD8\u6B3E"
      },
      children: [
        {
          path: "detail",
          name: "LoanEarlyRepaymentDetail",
          component: () => fr(() => import("./earlyDetail-clVF-J7k.js").then(async (m) => {
            await m.__tla;
            return m;
          }), __vite__mapDeps([45,6,5,7,8,34,35,24,14,20,2])),
          meta: {
            title: "\u63D0\u524D\u8FD8\u6B3E\u8BE6\u60C5"
          }
        }
      ]
    },
    {
      path: "/loan-record",
      name: "LoanRecord",
      component: () => fr(() => import("./LoanRecord-BdUs1nus.js").then(async (m) => {
        await m.__tla;
        return m;
      }), __vite__mapDeps([46,27,13,14,24,17,18,12,19,7,8,20,2,47])),
      meta: {
        title: "\u501F\u6B3E/\u8FD8\u6B3E\u8BB0\u5F55"
      }
    },
    {
      path: "/loan-calendar",
      name: "LoanCalendar",
      component: () => fr(() => import("./index-CKXk_4P5.js").then(async (m) => {
        await m.__tla;
        return m;
      }), __vite__mapDeps([48,27,13,14,24,17,18,19,7,8,20,2,49])),
      meta: {
        title: "\u56DE\u6B3E\u65E5\u5386"
      }
    },
    {
      path: "/loan-news",
      name: "LoanNews",
      component: () => fr(() => import("./index-B16lP2ce.js").then(async (m) => {
        await m.__tla;
        return m;
      }), __vite__mapDeps([50,17,18,7,8,28,20,51,4])),
      meta: {
        title: "\u6D88\u606F\u5217\u8868"
      }
    }
  ];
  var i9 = {
    exports: {}
  };
  (function(t, e) {
    (function(n, r) {
      t.exports = r();
    })(Cr, function() {
      var n = {};
      n.version = "0.2.0";
      var r = n.settings = {
        minimum: 0.08,
        easing: "ease",
        positionUsing: "",
        speed: 200,
        trickle: true,
        trickleRate: 0.02,
        trickleSpeed: 800,
        showSpinner: true,
        barSelector: '[role="bar"]',
        spinnerSelector: '[role="spinner"]',
        parent: "body",
        template: '<div class="bar" role="bar"><div class="peg"></div></div><div class="spinner" role="spinner"><div class="spinner-icon"></div></div>'
      };
      n.configure = function(y) {
        var x, w;
        for (x in y) w = y[x], w !== void 0 && y.hasOwnProperty(x) && (r[x] = w);
        return this;
      }, n.status = null, n.set = function(y) {
        var x = n.isStarted();
        y = i(y, r.minimum, 1), n.status = y === 1 ? null : y;
        var w = n.render(!x), R = w.querySelector(r.barSelector), O = r.speed, B = r.easing;
        return w.offsetWidth, a(function(M) {
          r.positionUsing === "" && (r.positionUsing = n.getPositioningCSS()), c(R, o(y, O, B)), y === 1 ? (c(w, {
            transition: "none",
            opacity: 1
          }), w.offsetWidth, setTimeout(function() {
            c(w, {
              transition: "all " + O + "ms linear",
              opacity: 0
            }), setTimeout(function() {
              n.remove(), M();
            }, O);
          }, O)) : setTimeout(M, O);
        }), this;
      }, n.isStarted = function() {
        return typeof n.status == "number";
      }, n.start = function() {
        n.status || n.set(0);
        var y = function() {
          setTimeout(function() {
            n.status && (n.trickle(), y());
          }, r.trickleSpeed);
        };
        return r.trickle && y(), this;
      }, n.done = function(y) {
        return !y && !n.status ? this : n.inc(0.3 + 0.5 * Math.random()).set(1);
      }, n.inc = function(y) {
        var x = n.status;
        return x ? (typeof y != "number" && (y = (1 - x) * i(Math.random() * x, 0.1, 0.95)), x = i(x + y, 0, 0.994), n.set(x)) : n.start();
      }, n.trickle = function() {
        return n.inc(Math.random() * r.trickleRate);
      }, function() {
        var y = 0, x = 0;
        n.promise = function(w) {
          return !w || w.state() === "resolved" ? this : (x === 0 && n.start(), y++, x++, w.always(function() {
            x--, x === 0 ? (y = 0, n.done()) : n.set((y - x) / y);
          }), this);
        };
      }(), n.render = function(y) {
        if (n.isRendered()) return document.getElementById("nprogress");
        u(document.documentElement, "nprogress-busy");
        var x = document.createElement("div");
        x.id = "nprogress", x.innerHTML = r.template;
        var w = x.querySelector(r.barSelector), R = y ? "-100" : s(n.status || 0), O = document.querySelector(r.parent), B;
        return c(w, {
          transition: "all 0 linear",
          transform: "translate3d(" + R + "%,0,0)"
        }), r.showSpinner || (B = x.querySelector(r.spinnerSelector), B && m(B)), O != document.body && u(O, "nprogress-custom-parent"), O.appendChild(x), x;
      }, n.remove = function() {
        f(document.documentElement, "nprogress-busy"), f(document.querySelector(r.parent), "nprogress-custom-parent");
        var y = document.getElementById("nprogress");
        y && m(y);
      }, n.isRendered = function() {
        return !!document.getElementById("nprogress");
      }, n.getPositioningCSS = function() {
        var y = document.body.style, x = "WebkitTransform" in y ? "Webkit" : "MozTransform" in y ? "Moz" : "msTransform" in y ? "ms" : "OTransform" in y ? "O" : "";
        return x + "Perspective" in y ? "translate3d" : x + "Transform" in y ? "translate" : "margin";
      };
      function i(y, x, w) {
        return y < x ? x : y > w ? w : y;
      }
      function s(y) {
        return (-1 + y) * 100;
      }
      function o(y, x, w) {
        var R;
        return r.positionUsing === "translate3d" ? R = {
          transform: "translate3d(" + s(y) + "%,0,0)"
        } : r.positionUsing === "translate" ? R = {
          transform: "translate(" + s(y) + "%,0)"
        } : R = {
          "margin-left": s(y) + "%"
        }, R.transition = "all " + x + "ms " + w, R;
      }
      var a = /* @__PURE__ */ function() {
        var y = [];
        function x() {
          var w = y.shift();
          w && w(x);
        }
        return function(w) {
          y.push(w), y.length == 1 && x();
        };
      }(), c = /* @__PURE__ */ function() {
        var y = [
          "Webkit",
          "O",
          "Moz",
          "ms"
        ], x = {};
        function w(M) {
          return M.replace(/^-ms-/, "ms-").replace(/-([\da-z])/gi, function(D, H) {
            return H.toUpperCase();
          });
        }
        function R(M) {
          var D = document.body.style;
          if (M in D) return M;
          for (var H = y.length, q = M.charAt(0).toUpperCase() + M.slice(1), S; H--; ) if (S = y[H] + q, S in D) return S;
          return M;
        }
        function O(M) {
          return M = w(M), x[M] || (x[M] = R(M));
        }
        function B(M, D, H) {
          D = O(D), M.style[D] = H;
        }
        return function(M, D) {
          var H = arguments, q, S;
          if (H.length == 2) for (q in D) S = D[q], S !== void 0 && D.hasOwnProperty(q) && B(M, q, S);
          else B(M, H[1], H[2]);
        };
      }();
      function l(y, x) {
        var w = typeof y == "string" ? y : d(y);
        return w.indexOf(" " + x + " ") >= 0;
      }
      function u(y, x) {
        var w = d(y), R = w + x;
        l(w, x) || (y.className = R.substring(1));
      }
      function f(y, x) {
        var w = d(y), R;
        l(y, x) && (R = w.replace(" " + x + " ", " "), y.className = R.substring(1, R.length - 1));
      }
      function d(y) {
        return (" " + (y.className || "") + " ").replace(/\s+/gi, " ");
      }
      function m(y) {
        y && y.parentNode && y.parentNode.removeChild(y);
      }
      return n;
    });
  })(i9);
  var mW = i9.exports;
  const nb = Js(mW);
  nb.configure({
    easing: "ease",
    speed: 500,
    showSpinner: false,
    trickleSpeed: 200,
    minimum: 0.3,
    parent: "body"
  });
  const yW = "FlashMall", bW = {
    name: yW
  }, xv = bW.name;
  function xW(t) {
    window.document.title = t ? `${t} | ${xv}` : `${xv}`;
  }
  rb = MN({
    history: lN(),
    routes: gW
  });
  rb.beforeEach((t, e, n) => {
    nb.start(), r9().addCachedView(t), xW(t.meta.title), n();
  });
  rb.afterEach(() => {
    nb.done();
  });
  H1.use(xP);
  const kh = H3(dW);
  kh.use(H1);
  kh.use(uf);
  kh.use(rb);
  kh.mount("#app");
})();
export {
  ix as $,
  XW as A,
  o6 as B,
  op as C,
  jW as D,
  y1 as E,
  jn as F,
  JW as G,
  qW as H,
  m1 as I,
  Co as J,
  lP as K,
  s6 as L,
  ZW as M,
  oI as N,
  To as O,
  pn as P,
  cs as Q,
  MW as R,
  Tr as S,
  Qs as T,
  NW as U,
  Xr as V,
  EC as W,
  xC as X,
  Ms as Y,
  bo as Z,
  tb as _,
  __tla,
  $i as a,
  c6 as a$,
  HW as a0,
  yn as a1,
  wC as a2,
  FI as a3,
  BW as a4,
  Fn as a5,
  D1 as a6,
  OW as a7,
  Fd as a8,
  RW as a9,
  GW as aA,
  CW as aB,
  UW as aC,
  TW as aD,
  QW as aE,
  wW as aF,
  Yt as aG,
  Kq as aH,
  _y as aI,
  qq as aJ,
  ah as aK,
  L3 as aL,
  NC as aM,
  Nd as aN,
  EW as aO,
  WW as aP,
  jq as aQ,
  Sq as aR,
  t5 as aS,
  vq as aT,
  C1 as aU,
  KW as aV,
  Jq as aW,
  YK as aX,
  qn as aY,
  I1 as aZ,
  a6 as a_,
  BC as aa,
  ZC as ab,
  PW as ac,
  n3 as ad,
  FC as ae,
  LW as af,
  Zv as ag,
  U3 as ah,
  U1 as ai,
  HI as aj,
  SW as ak,
  yl as al,
  YI as am,
  Kc as an,
  rb as ao,
  Wq as ap,
  Eq as aq,
  Hc as ar,
  TI as as,
  zi as at,
  kW as au,
  Bc as av,
  VC as aw,
  IW as ax,
  vW as ay,
  DW as az,
  Bd as b,
  Kb as b0,
  _W as b1,
  W1 as b2,
  F1 as b3,
  _d as b4,
  q3 as b5,
  FW as b6,
  OC as b7,
  d3 as b8,
  HG as b9,
  HS as c,
  Gn as d,
  Te as e,
  ar as f,
  Qr as g,
  ts as h,
  fi as i,
  n9 as j,
  $W as k,
  xn as l,
  Hi as m,
  AW as n,
  Si as o,
  cS as p,
  it as q,
  Ze as r,
  xo as s,
  Tu as t,
  ks as u,
  YW as v,
  jc as w,
  zW as x,
  FN as y,
  k1 as z
};
